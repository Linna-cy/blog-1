[{"content":"网络概述 计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享。现代计算机网络已具有统一的网络体系结构。\n计算机网络提供的主要功能有：\n 数据通信 资源共享 负载均衡 高可共享性  计算机网络分类 按通信距离分类：\n  网络分类  分布距离  计算机分布范围  传输速率     局域网 MAN    10m左右 房间 4Mbps ~ 1Gbps    100m左右 楼寓   1000m左右 校园     城域网 WAN   10km 城市 50Kbps ~ 100 Mbps    广域网 LAN   100km以上 国家或全球 9.6Kbps ~ 45Mbps   其它分类方式与其分类如：\n  分类方式   分类内容    信息交换方式   电路交换网 分组交换网 综合交换网  网络拓扑结构   星型网 树型网 环型网 总线网  通信介质   双绞线网 同轴电缆网 光纤网 卫星网  传输带宽   基带网 宽带网  使用范围   公用网 专用网  速率   高速网 中速网 低速网  通信传播方式   广播式 点到点式  ISO/OSI 网络体系结构 ISO/OSI的参考模型共有7层：\n计算机网络按照数据通信和数据处理的功能可分为两层：\n  内层通信子网（通信子网）：由计算机和高速通信线路组成独立的数据系统，承担全网的通信工作（解决数据传输和通信控制问题）。\n  外层资源子网（资源子网）：包括计算机、终端、通信子网接口设备、外部设备、软件资源等，它负责全网的数据处理和提供网络资源及网络服务。\n  这两个网络层符合国际标准化组织所制定的开放式系统互连参考模型（OSI）的思想：\n 通信子网对应于OSI中的低三层：  物理层 数据链路层 网络层   资源子网对应于OSI中的高三层：  会话层 表示层 应用层    服务端要向用户端传送数据（信息流向）：\n  服务端将数据送入应用层，然后数据逐层向物理层传递。\n在传递过程中，每一层对数据做相应处理（附加控制信息、数据变换、报文分段、报文分组、变换为帧等）。\n最后，经由物理层将数据发送至用户端。\n  用户端接受信息，按照与服务端相反顺序的动作，从物理层开始层层剥去控制信息。\n最后把原数据展示给用户。\n   只有物理层是实通信（有物理连接），其余各层均为虚通信（无连线）。\n 网络的拓扑结构 网络拓扑结构是指网络中通信线路和结点的几何排序，用于表示整个网络的结构外貌，反映各结点之间的结构关系。\n常用的网络拓扑结构有：\n  总线型结构：\n  星型结构：\n  环型结构：\n  树型结构：\n  分布式结构：\n   网络互连设备 构建一个实际的网络需要网络的传输介质、网络互连设备作为支持。\n网络设备 按照ISO/OSI的分层将互连设备分类：\n  物理层设备：\n 中继器（Repeater） 集线器（Hub）：一种多端口的中继器。集线器不能自动寻址，但可以检测发送冲突。    数据链路层设备：\n  网桥（Bridge）\n  交换机（Switch）：一种多端口的网桥。\n交换技术：\n 端口交换 帧交换 信元交换      网络层设备：路由器（Router）\n  应用层设备：网关（Gateway）\n  网络传输介质 传输介质是信号传输的媒体，常用的介质分为：\n 有线介质：  双绞线（Twisted-Pair） 同轴电缆（Coaxial） 光纤（Fiber Optic）   无线介质：  微波 红外线和激光 卫星通信    网络组件 在一个局域网中，其基本组成部件为：\n 服务器（Server） 客户端（Client） 网络设备 通信介质 网络软件   网络协议与标准 计算机网络中的两个实体，想要成功通信，必须具有相同的语言，在计算机网络中称为协议（规程）。\n网络协议指的是网络中的计算机与计算机进行通信时，为了能够实现数据的正常发送与接收必须要遵循的一些事先约定好的规则（标准或约定），在这些规程中明确规定了通信时的数据格式、数据传送时序以及相应的控制信息和应答信号等内容。\n网络标准   电信标准：由国际电信联盟（International Telecommunication Union，ITU）发布的标准，有ITU-T的V系列、X系列等。\n  国际标准：由国际标准化组织（ISO）负责制定。\n其他标准化组织：\n ANSI：美国国家标准研究所，ISO的美国代表。 NIST：美国国家标准和技术研究所，美国商业部的标准化机构。 IEEE：电气和电子工程师协会（Institute of Electrical and Electronics Engineers）。 ElA：电子工业协会（Electronic Industries Association）。    Internet标准：特点是自发而非政府干预的，管理松散。\n 有民间性质的协会ISOC（Internet Society）进行必要的协调与管理。 有网络信息中心（NIC）来管理IP地址，保证注册地址的唯一性。 ISOC设有nternet总体管理机构结构（IAB）。    局域网协议 IEEE 802系列标准己被ISO采纳为国际标准。\n局域网的基本组成主要有：\n 网络服务器 网络工作站 网络适配器 传输介质  决定局域网特性的主要技术有3个方面：\n 用于传输数据的传输介质； 用于连接各种设备的拓扑结构； 用于共享资源的介质访问控制方法。  LAN 模型 在IEEE 802局域网（LAN）标准中只定义了两层：\n  物理层\n  数据链路层：\n根据LAN的特点把数据链路层分成：\n  逻辑链路控制（Logical Link Control，LLC）子层：\n实现网络层中的寻址、排序、流控和差错控制等功能\n  介质访问控制（Medium Access Control，MAC）子层\n    以太网 以太网技术采用的“存取方法”是带冲突检测的载波监听多路访问协议（Carrier-Sense Multiple Access with Collision Detection，CSMA/CD）技术。\n以太网主要包括3中类型：\n IEEE 802.3中定义的标准局域网，速度为10Mbps，传输介质为细同轴电缆； IEEE 802.3u中定义的快速以太网，速度为100Mbps，传输介质为双绞线； IEEE 802.3z中定义的千兆以太网，速度为1000Mbps，传输介质为光纤或双绞线。  令牌环网 IEEE 802.5的介质访问使用的是令牌环控制技术。\nFDDI FDDI（Fiber Distributed Data Interface,光纤分布式数据接口）类似令牌环网的协议：\n 用光纤作为传输介质； 采用一种新的编码技术，称为4B/5B编码。  无线局域网 无线局域网（WLAN）使用的是带冲突避免的载波侦听多路访问方法（CSMA/CA）。\n广域网协议 用于广域网的主要协议有：\n 点对点协议（PPP） 数字用户线（xDSL） 数字专线 帧中继 异步传输模式 X.25 协议  TCP/IP 协议族 TCP/IP作为Internet的核心协议，被广泛应用于局域网和广域网中，成为事实上的国际标准。\nTCP/IP基本特性的5个表现方面：\n  逻辑编制：\n每台连入Internet的计算机都会被分配一个逻辑地址，即IP地址。\nIP地址包括：\n 网络ID号：用来标识网络； 子网ID号：用来标识网络上的一个子网； 主机ID号：用来标识子网上的一台计算机。    路由选择：定义路由器如何选择网络路径的协议，即IP数据包的路由选择。\n  域名解析：\n域名：一种易记的字母式地址结构，也称为DNS（域名服务）名。\n将域名映射为IP地址的操作即为域名解析。\n 域名较稳定，而IP地址较易发生变化。\n   错误检测：TPC/IP具有分组交换确保数据信息在网络上可靠传递的特性。\n  流量控制：检测网络系统信息中的信息流量，防止出现网络拥塞，也属于分组交换确保数据信息在网络上可靠传递。\n  TCP/IP 分层模型 TCP/IP分层模型由4个层次构成：\n 应用层 传输层 网际层 网络接口层  传输层协议 TCP 和 UDP TCP和UDP都是应用于传输层的网络协议：\n  TCP（Transmission Control Protocol，传输控制协议）：\n在IP提供的不可靠数据服务的基础上为应用程序提供了可靠的、面向连接的、全双工的数据传输服务。\n采用三次握手来确认建立和关闭连接是否成功。\nTCP的功能或服务有：\n 可靠传输 连接管理 差错校验和重传 流量控制：采用可变大小的滑动窗口协议 拥塞控制 端口寻址    UDP（User Datagram Protocol，用户数据报协议）：\n是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信。\nUDP上的应用有VoIP等。\n  UDP的首部8B，TCP的首部20B，UDP相比TCP来说，开销较小。\nTCP和UDP均提供了端口寻址功能。\n电子邮件协议 SMTP 和 POP3 SMTP和POP3都使用TCP端口传输和接收邮件。\nSMTP：邮件发送协议；常用端口号：25。\nSMTP只能传输SACII码文本和文字附件，可以使用MIME邮件扩充协议，添加其他类型的附件。\nPOP3：邮件接收协议；常用端口号：110。\nPOP3基于C/S模式（Client/Server模式，客户端/服务器模式）。\nARP 和 RARP 协议   ARP（Address Resolution Protocol，地址解析协议）：将IP地址转换为MAC地址（物理地址）。\nIP到MAC地址的转换过程：\n 查询ARP高速缓存中是否有该IP地址 如果该IP地址在ARP高速缓存中，便使用与它对应的MAC地址，将数据报发送给所需的物理网卡 如果ARP高速缓存中没有该IP地址，ARP便在局域网上以广播方式发送一个ARP请求包 如果局域网上IP地址与某台计算机中的IP地址相一致，那么该计算机便生成一个ARP应答信息，信息中包含对应的MAC地址    RARP（反地址解析协议）：将MAC地址转换为IP地址，主要用于无盘工作站。\n  动态主机配置协议 DHCP DHCP协议的功能和作用是：\n 集中的管理、分配IP地址； 使网络环境中的主机动态地获得IP地址、Gateway地址、DNS服务器地址等信息； 提升地址的使用率。  DHCP客户端可以从DHCP服务器获得以下内容：\n 本机IP地址 DNS服务器地址 DHCP服务器地址 默认网关的地址  无效地址：\n  Windows无效地址：169.254.X.X\n169.254.X.X是Windows系统在DHCP信息租用失败时自动给客户机分配的IP地址。\n  Linux无效地址：0.0.0.0\n  ICMP ICMP（Internet Control Message Protocol，Internet控制信息协议）是一种用于发送差错报文的协议。IP传送的数据报可能丢失、重复、延迟或乱序，而ICMP就是这样一种避免差错并在发生差错时报告的机制。\nICMP定义了5种差错报文：\n 源抑制 超时 目的不可达 重定向 要求分段  还定义了4种信息报文：\n 回应请求 回应应答 地址屏蔽码请求 地址屏蔽码应答  IP在需要一个差错报文时要使用ICMP，而ICMP也是利用IP来传送报文。\nICMP可以用于测试因特网，如ping工具就是利用ICMP报文进行目标是否可达测试。\n Internet 地址 Internet地址格式主要有两种书写形式：\n 域名 IP地址  域名 域名（Domain Name）：通常是用户所用主机的名字或地址。\n域名格式由若干部分组成，每个部分又称子域名（用.分开，最少由两个字母或数字组成）。\n通常，一个完整、通用的层次型主机域名由以下4个部分组成：\n主机名.本地名.组名.最高层域名 也可以理解为：\n主机名.域名.域名后缀.域名分类 如果一个主机所在的网络级别较高，它可能拥有的域名仅包含3部分：\n本地名.组名.最高层域名 URL URL即统一资源定位器（统一资源定位符），它的形式如下：\n协议名://主机名.域名.域名后缀.域名分类/目录/网页文件 IP 地址 IP地址：Internet中的主机地址实际上是用IP地址来唯一标识的。\nIP地址有两种：\n IPv4 IPv6   通常IP地址是指IPv4。\n IPv4 每个IPv4地址都由4个小于256的数字组成（每个数字8位，共32位），数字之间用.分开，可分为5类：\n在IPv4中，全0代表的是网络，全1代表的是广播。\n由于IPv4能表示的地址个数为：\n$$ 2^{32} \\approx 40亿 $$\n子网掩码 网络软件和路由器使用子网掩码（Subnet Mask）来识别报文是仅存放在网络内部还是被路由转发到其他地方。\n子网掩码是用来指明特定的IP地址中的网络号和主机号部分。子网掩码的格式与IP地址相同：\n 所有对应网络号的部分用1填上； 所有对应主机号的部分用0填上。  IPv6 IPv6具有长达128位的地址空间，可以彻底解决IPv4地址不足的问题。\nIPv6理论上能表示的地址个数：\n$$ 2^{128} = 3.4 \\times 10^{38} $$\n 在想象得到的将来，IPv6的地址空间是不可能用完的。\n DNS 域名解析 Internet中的域名地址和IP地址是等价的，它们之间是通过域名服务（DNS域名解析）来完成映射变换的。\nDNS是一种分布式地址信息数据库系统，服务器中包含整个数据库的某部分信息，并供客户查询。DNS允许局部控制整个数据库的某些部分，但数据库的每一部分都可通过全网查询得到。\n域名系统采用的是客户端/服务器模式，整个系统由以下两部分组成：\n解析器和域名服务器组成。\n  解析器（客户端）：\n负责：\n 查询域名服务器 解释从服务器返回来的应答 将信息返回给请求方    域名服务器（服务器）：通常保存着一部分域名空间的全部信息，这部分域名空间称为区（Zone）。\n一个域名服务器可以管理一个或多个区。\n域名服务器可以分为：\n 主服务器 Caching Only服务器 转发服务器（Forwarding Server）  主域名服务器在接收到域名请求后，查询顺序如下：\n 本地缓存：缓存在该服务器中的域名信息。如果先前有多个用户对该域名进行访问，域名服务器会根据需要对该域名的信息进行缓存，以便加快后续用户访问的速度。 本地hosts文件：存储在服务器中的一种记录域名与其对应IP的文件。在PC中也有这样的文件存在。 本地数据库：存储域名信息的数据库。 转发域名服务器：如果用户访问的域名在以上内容中都不存在时，域名服务器会根据访问的域名，到对应的其他域名服务器中查询。    用户A查找用户B时，域名系统工作过程如：\n 解析器向本地域名服务器发出请求查阅用户B的域名。 本地域名服务器向最高层域名服务器发出查询地址的请求。 最高层域名服务器返回给本地域名服务器一个IP地址。 本地域名服务器向组域名服务器发出查询地址的请求。 组域名服务器返回给本地域名服务器一个IP地址。 本地服务器向刚返回的域名服务器发出查询域名地址请求。 P地址返回给本地域名服务器。 本地域名服务器将该地址返回给解析器。  因此，在访问主机的时候只需要知道域名，通过DNS服务器将域名变换为IP地址。\nDNS所用的是UDP端口，端口号为53。\n在浏览器中访问网站时，通常是使用服务方的域名进行访问。在计算机上使用域名访问内容，本地计算机并不会直接去DNS服务器查询，而是会先在本地查询该域名。计算机使用域名访问时，域名查询的顺序是：\n 本地hosts文件：存储在计算机电脑中的一个文件，例如localhost就是在本地hosts文件中与本地IP127.0.0.1对应。 本地DNS缓存：先前访问的域名与其对应的IP等信息会被计算机缓存在本地中，如果本地中有该域名的缓存，那便无须访问DNS服务器。 本地DNS服务器。 根域名服务器。  当在Wb浏览器的地址栏中输入某URL并按下回车，则处理过程如下：\n 对URL进行DNS域名解析，得到对应的IP地址； 根据这个IP，找到对应的服务器，发起TCP连接，进行三次握手： 建立TCP连接后发起HTTP请求； 服务器响应HTTP请求，浏览器得到HTML代码； 通信完成，断开TCP连接； 浏览器解析HTML代码，并请求HTML代码中的资源（如s、css图片等）； 浏览器将页面呈现给用户。   无线通信技术 流行的无线通信技术有WiFi、蓝牙等。\n其中，蓝牙覆盖范围最小、通信距离最短。\n ipconfig 命令 ipconfig是Windows中，调试计算机网络常用的命令（软件），类似于Linux中的ifconfig。\nipconfig命令的用法如下：\n   参数 说明 示例     无参数 显示所有网络适配器的IP地址、子网掩码和缺省网关值 ipconfig   /all 显示所有网络适配器的完整TCP/IP配置信息，包括DHCP服务是否已启动 ipconfig /all   /displaydns 显示本地DNS内容 ipconfig /displaydns   /flushdns 清除本地DNS缓存内容 ipconfig /flushdns   /registerdns DNS客户端手工向服务器进行注册 ipconfig /registerdns   /release DHCP客户端手工释放IP地址 ipconfig /release   /renew DHCP客户端手工向服务器刷新请求（重新申请IP地址） ipconfig /renew     网络信息安全 网络存在的威胁主要表现在以下5方面：\n 非授权访问 信息泄露或丢失 破坏数据完整性 拒绝服务攻击 利用网络传播病毒  网络安全控制技术主要有：\n 防火墙技术 加密技术 用户识别技术 访问控制技术 网络反病毒技术 网络安全漏洞扫描技术 入侵检测技术  防火墙技术 防火墙（Firewall）是建立在内外网络边界上的过滤封锁机制，它认为：\n 内部网络是安全和可信赖的； 外部网络是不安全和不可信赖的。  防火墙是网络安全体系的基础和核心控制设施，同时也承担着繁重的通信任务。\n防火墙的作用：防止不希望的、未经授权地进出被保护的内部网络。\n防火墙对通过受控干线的任何通信行为进行安全处理，如：\n 控制 审计 报警 反应  防火墙技术经历了三个发展阶段：\n 包过滤防火墙 应用代理网关防火墙 状态检测技术防火墙  包过滤防火墙 包过滤防火墙一般有一个包检查块（通常称为包过滤器），数据包过滤可以根据数据包头中的各项信息来控制以下内容之间的相互访问：\n 站点与站点 站点与网络 网络与网络  包过滤防火墙无法控制传输数据的内容，因为内容是应用层数据，而包过滤器处在网络层和数据链路层（即TCP和P层）之间。\n通过检查模块，防火墙能够拦截和检查所有出站和进站的数据，其过程如下：\n 打开包 取出包头 根据包头的信息确定该包是否符合包过滤规则 对过滤进行记录 对于不符合规则的包，进行报警并丢弃该包  过滤型防火墙的优点：\n 对用户完全透明，速度较快（通常直接转发报文）； 对每条传入和传出网络的包实行低水平控制； 每个IP包的字段都被检查，例如：  源地址， 目的IP地址， 协议， 端口；   可以识别和丢弃带欺骗性源IP地址的包； 包过滤防火墙是两个网络之间访问的唯一来源； 包过滤通常被包含在路由器数据包中，所以不需要额外的系统来处理这个特征。  过滤型防火墙的缺点：\n 不能防范黑客攻击，因为网管不可能区分出可信网络与不可信网络的界限； 不支持应用层协议，因为它不识别数据包中的应用层协议，访问控制粒度太粗糙； 不能处理新的安全威胁。  应用代理网关防火墙 应用代理网关防火墙彻底隔断内网与外网的直接通信：内网用户对外网的访问变成防火墙对外网的访问，然后再由防火墙转发给内网用户。所有通信都必须经应用层代理软件转发，访问者任何时候都不能与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。\n应用代理网关的优点：\n 可以检查应用层、传输层和网络层的协议特征； 对数据包的检测能力比较强。  应用代理网关的缺点：\n 难以配置； 处理速度非常慢。  状态检测技术防火墙 状态检测技术防火墙结合了代理防火墙的安全性和包过滤防火墙的高速度等优点，在不损失安全性的基础上，提高了代理防火墙的性能。\n入侵检测与防御 入侵检测系统（Intrusion Detection System，DS）作为防火墙之后的第二道安全屏障，通过从计算机系统或网络中的若干关键点收集网络的安全日志、用户的行为、网络数据包和审计记录等信息并对其进行分析，从中检查是否有违反安全策略的行为和遭到入侵攻击的迹象。入侵检测系统根据检测结果，自动做出响应。\n入侵检测系统有效的弥补了防火墙系统对网络上的入侵行为无法识别和检测的不足。\n入侵防御系统（IPS）是在入侵检测系统的基础上发展起来的，入侵防御系统不仅能够检测到网络中的攻击行为，同时主动的对攻击行为能够发出响应，对攻击进行防御。两者相较，主要存在以下区别：\n 在网络中的部署位置的不同； 入侵响应能力的不同。  网络攻击 网络攻击是攻击者针对特定目标实施的有特定目的的活动，攻击目标对于攻击者是个黑盒子。\n常见的网络攻击手段有：\n  拒绝服务攻击（Dos攻击）：目的是使计算机或网络无法提供正常的服务。\n拒绝服务攻击是不断向计算机发起请求来实现的。\n  重放攻击：攻击者发送一个目的主机已经接受过的报文来达到攻击目的。\n攻击者利用网络监听或者其他方式盗取认证凭据，之后再重新发送给认证服务器。\n重放攻击主要用于身份认证过程，目的是破坏认证的正确性。\n  口令入侵攻击：使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动。\n  特洛伊木马：被伪装成程序或游戏，当用户下载了带有木马的软件或附件时，这个程序就会向黑客发起连接请求，建立连接后黑客就实施攻击活动。\n  端口欺骗攻击：采用端口扫描找到系统漏洞从而实施攻击。\n  网络监听：攻击者可以接收某一网段在同一条物理通道上传输的所有信息，使用网络监听可以轻松截取包括账号和口令在内的信息资料。\n  IP欺骗攻击：产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份。\n  SQL注入攻击：是黑客对数据库进行攻击的常用手段之一。\nSQL注入产生的原因：\n 没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。 攻击者可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据， 获取数据库的权限，就可获取用户账号和口令信息，以及对某些数据修改等。    入侵检测技术：\n 专家系统 模型检测 简单匹配  病毒 计算机病毒（Computer Virus）是指编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。\n计算机病毒的特征包括：\n 传播性 隐蔽性 感染性 潜伏性 触发性 破坏性  常见的病毒类型有：\n  Worm（蠕虫病毒）：\n 欢乐时光， 熊猫烧香， 红色代码， 爱虫病毒， 震网。    Trojan（特洛伊木马）：通过内部发起连接与外部主机建立联系，由外部主机控制并盗取用户信息。\n计算机感染特洛伊木马后的典型线型是有未知程序试图建立网络连接。\n常见的木马如冰河。\n  Backdoor（后门病毒）。\n  Macro（宏病毒）：\n宏病毒感染的对象主要是文本文档、电子表格等。\n  网络安全   SSL（Secure Socket Layer，安全套接层）：传输层安全协议，用于实现Web安全通信。\nSSL常用端口号为443。\n  TLS（Transport Layer Security，传输层安全协议：建立在SSL3.0协议规范之上，是SSL3.0的后续版本。\n  SSH（Secure Shell）：终端设备与远程站点之间建立安全连接的协议，是建立在应用层和传输层基础上的安全协议。\nSSH是专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。\nSSH最初是UNIX上的程序，后来又迅速扩展到其他操作平台（如Linux、Windows）。\n  HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）：是以安全为目标的HTTP通道，即使用SSL加密算法的HTTP。\n  MME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）：是一个互联网标准，扩展了电子邮件标准。\n  PGP（Pretty Good Privacy，优良保密协议）：是一个基于RSA公匙加密体系的邮件加密软件。\n可以用它对邮件保密以防止非授权者阅读，还能对邮件加上数字签名从而使收信人可以确认邮件的发送方。\n  ","date":"2023-05-12T06:01:08Z","permalink":"https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"计算机网络（软件设计师）"},{"content":"概述 软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。\n软件工程学：\n 软件开发技术  软件开发方法学 软件工具 软件工程环境   软件工程管理  软件工程管理学 软件经济学    软件工程涉及软件开发、维护、管理等多方面的原理、方法、工具与环境。\n计算机软件 计算机软件是指：\n  计算机系统中的程序：计算任务的处理对象和处理规则的描述。\n  计算任务：任何以计算机为处理工具的任务。\n  处理对象：\n 数据：如数字、文字、图形、图像、声音等，它们只是表示，而无含义。 信息：数据及有关的含义。    处理规则：一般指处理的动作和步骤。\n    程序文档：文档是为了便于了解程序所需的阐述性资料。\n  按照软件的应用领域，可以将计算机软件分为十大类：\n 系统软件 应用软件 工程/科学软件 嵌入式软件 产品线软件 Web应用 人工智能软件 开放计算 网络资源 开源软件  软件生存周期  可行性分析与项目开发计划 需求分析 概要设计 详细设计 编码 测试 维护   软件过程模型 软件开发中所遵循的路线图（一系列可预测的步骤）称为“软件过程”。过程是活动的集合，活动是任务的集合。\n软件过程有3层含义：\n 个体含义 整体含义 工程含义  能力成熟度模型 软件过程能力成熟度模型（Capability Maturity Model of Software，CMM）是对软件组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力经过这些阶段逐步提高。\n能力成熟度模型使软件组织能够较容易地确定其当前过程的成熟度并识别其软件过程执行中的薄弱环节，确定对软件质量和过程改进最为关键的几个问题，从而形成对其过程的改进策略。\nCMM将软件过程改进分为以下5个成熟度级别：\n  初始级（Initial）：\n软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤。\n  可重复级（Repeatable）：\n建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性；建立了有必要的过程准则来重复以前在同类项目中的成功。\n  已定义级（Defined）：\n管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。\n  己管理级（Managed）：\n制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制。\n  优化级（Optimized）：\n加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。\n  能力成熟度模型集成 能力成熟度模型集成（CMMI）是若干过程模型的综合和改进，是支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率\nCⅫ提供了两种表示方法：\n  阶段式模型：\n结构类以于CMM，它关注组织的成熟度。\nCMMI-SE/SW/IPPD 1.1版中有5个成熟度等级：\n 初始的：过程不可预测且缺乏控制。 己管理的：过程为项目服务。 已定义的：过程为组织服务 定量管理的：过程已度量和控制。 优化的：集中于过程改进。    连续式模型：\n关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级（Capability Level，CL）。\n能力等级包括：\n 共性目标 共性实践  能力等级可以独立地应用于任何单独的过程域，任何一个能力等级都必须满足比它等级低的能力等级的所有准则。\nCMMI中包括6个过程域能力等级（0~5）：\n $CL_0$（未完成的）：过程域未执行或未得到$CL_1$中定义的所有目标。   $CL_1$（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。 关注于过程域的特定目标的完成。   $CL_2$（已管理的）：其共性目标集中于已管理的过程的制度化。 关注于针对单个过程实例的能力。   $CL_3$（已定义级的）：其共性目标集中于已定义的过程的制度化。 关注于过程的组织级标准化和部署。   $CL_4$（定量管理的）：其共性目标集中于可定量管理的过程的制度化。   $CL_5$（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。 其共性目标集中于优化的过程的制度化，表明过程得到很好地执行且持续得到改进。     瀑布模型 瀑布模型（Waterfall Model）是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型（它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落），包括：\n 需求分析： 设计 编码 测试 运行与维护（运维）  瀑布模型假设：一个待开发的系统需求是完整的、简明的、一致的，而且可以先于设计和实现完成之前产生。\n瀑布模型的一个变体是V模型。V模型描述了质量保证活动和沟通、建模相关活动以及早期构建相关的活动之间的关系：\n  设计、开发：随着软件团队工作沿着V模型左侧步骤向下推进，基本问题需求逐步细化，形成问题及解决方案的技术描述。\n  测试：一旦编码结束，团队沿着V模型右侧的步骤向上推进。\n其实际上是执行了一系列测试（质量保证活动），这些测试验证了团队沿着V模型左侧步骤向下推进过程中所生成的每个模型。\n  V模型提供了一种将验证确认活动（软件测试）应用于早期软件工程工作中的方法。\n瀑布模型：\n  优点：\n 容易理解，管理成本低； 强调开发的阶段性早期计划及需求调查和产品测试。    缺点：\n 客户必须能够完整、正确和清晰地表达他们的需要； 在开始的两个或3个阶段中，很难评估真正的进度状态； 当接近项目结束时，出现了大量的集成和测试工作； 直到项目结束之前，都不能演示系统的能力； 需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。    所以，瀑布模式适合开发需求明确的，需求大致固定且不会随意变更的系统。\n增量模型 增量模型（Incremental Model）融合了瀑布模型的基本成分和原型实现的迭代特征。\n增量模型假设可以将需求分段为一系列增量产品，每一增量可以分别开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”：\n 从分析到测试为一个增量的过程（线性序列）。 第1个增量往往是核心的产品。 客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。 增量模型强调每一个增量均发布一个可操作的产品。  增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。此外，它还有以下优点：\n 第一个可交付版本所需要的成本和时间很少； 开发由增量表示的小系统所承担的风险不大； 由于很快发布了第一个版本，因此可以减少用户需求的变更； 运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。  缺点：\n 如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定； 如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发、重新发布； 管理发生的成本、进度和配置的复杂性可能会超出组织的能力。  所以，增量模型适合需要快速构造可运行的产品的项目。\n演化模型 演化模型（Evolutionary Model）演化模型是迭代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于对软件需求缺乏准确认识的情况。\n典型的演化模型有原型模型和螺旋模型等。\n原型模型 并非所有的需求都能够预先定义。大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。原因有：\n 客户往往不能准确地表达对未来系统的全面要求，导致形成的需求规格说明不完整、不准确，甚至是有歧义。 在整个开发过程中，用户可能会产生新的要求，导致需求的变更。  瀑布模型难以适应这种需求的不确定性和变化，于是出现了快速原型（Rapid Prototype）这种新的开发方法。\n原型模型（Prototype Model）比较适合于用户需求不清、需求经常变化的情况；不适合大规模系统的开发。\n原型的目的是能快速、低成本地构建原型系统。\n能够采用原型方法是因为开发工具的快速发展，使得能够迅速地开发出一个让用户看得见、摸得着的系统框架。这样，对于计算机不是很熟悉的用户就可以根据这个框架提出自己的需求。\n开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型:\n 交流：目的是定义软件的总体目标，标识需求，然后 快速计划：快速制订原型开发的计划，确定原型的目标和范围。 采用快速设计方式进行建模。 构建原型。 部署交付和反馈：被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见可在下一轮中对原型进行改进。 下一轮迭代：在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发。  根据使用原型的目的不同，原型可以分为：\n 探索型原型：目的是要弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性。 实验型原型：目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。 演化型原型：目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。  螺旋模型 对于复杂的大型软件，开发一个原型往往达不到要求。\n螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。\n螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合：\n每个螺旋周期分为如下4个工作步骤：\n  制订计划：\n 确定软件的目标 选定实施方案 明确项目开发的限制条件    风险分析：\n 分析所选的方案 识别风险 消除风险    实施工程：\n 实施软件开发 验证阶段性产品    用户评估：\n 评价开发工作，提出修正建议 建立下一个周期的开发计划    螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型特别适用于庞大、复杂并且具有高风险的系统。并且，螺旋模型支持用户需求的动态变化，有助于提高软件的适应能力，降低了软件开发的风险。\n喷泉模型 喷泉模型（Water Fountain Model）：\n 以用户需求为动力； 以对象作为驱动； 适合于面向对象。  喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。其开发过程如下：\n喷泉模型使开发过程具有以下性质：\n  迭代性：意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统。\n  无间隙性：指在开发活动（如分析、设计、编码）之间不存在明显的边界。\n喷泉不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动，而是允许各开发活动交叉、迭代地进行。\n喷泉模型的各个阶段没有明显的界线，开发人员可以同步进行。\n  优点：可以提高软件项目的开发效率，节省开发时间。\n缺点：\n 由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，不利于项目的管理。 喷泉模型要求严格管理文档，使得审核的难度加大。  统一过程模型 统一过程（UP）模型开发过程的特征：\n  用例和风险驱动。\n  以架构为中心。\n  迭代并且增量：\n迭代：将整个软件开发项目划分为许多个小的“袖珍项目”。\n每个“袖珍项目”都包含正常软件项目的所有元素：\n 计划 分析和设计 构造 集成和测试 内部和外部发布    统一过程模型由UML（统一建模语言，Unified Modeling Language）方法和工具支持。\n统一过程定义了4个技术阶段及其制品：\n  起始阶段（Inception Phase）：\n专注于：项目的初创活动。\n产生的主要工作产品有：\n 构想文档（Vision Document） 初始用例模型 初始项目术语表 初始业务用例 初始风险评估 项目计划（阶段及迭代）业务模型 一个或多个原型（需要时）    精化阶段（Elaboration Phase）：\n精华阶段在理解了最初的领域范围之后进行：\n 需求分析 架构演进  产生的主要工作产品有：\n  用例模型\n  补充需求：包括非功能需求\n  分析模型\n  软件体系结构描述\n  可执行的软件体系结构原型\n  初步的设计模型\n  修订的风险列表\n  项目计划：\n包括：\n 迭代计划 调整的工作流 里程碑 技术工作产品    初始用户手册\n    构建阶段（Construction Phase）：\n关注系统的构建，产生实现模型，\n产生的主要工作产品有：\n 设计模型 软件构件 集成的软件增量 测试计划及步骤 测试用例 支持文档：  用户手册 安装手册 对于并发增量的描述      移交阶段（Transition Phase）：\n关注于软件提交方面的工作，产生软件增量。\n产生的主要工作产品有：\n 提交的软件增量 $\\beta$测试报告 综合用户反馈    敏捷开发 敏捷开发（Agile Development）的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”使客户满意。通过在软件开发过程中加入灵活性，敏捷方法使用户能够在开发周期的后期增加或改变需求。\n敏捷过程的典型方法有很多，每一种方法基于一套原则，这些原则实现了敏捷方法所宣称的理念（敏捷宣言）。\n敏捷开发有以下几种方法：\n 极限编程（XP） 水晶法（Crystal） 并列争求法（Scrum） 自适应软件开发（ASD） 敏捷统一过程（AUP）  极限编程 极限编程（XP）软件开发方式有以下性质：\n 轻量级（敏捷） 高效 低风险 柔性 可预测的 科学的  XP由价值观、原则、实践和行为4个部分组成，他们之间彼此相互依赖、关联，并通过行为贯穿于整个生存周期：\n 4大价值观：  沟通 简单性 反馈 勇气   5个原则：  快速反馈 简单性假设 逐步修改 提倡更改 优质工作   12个最佳实践：  计划游戏：快速制定计划、随着细节的不断变化而完善 小型发布：系统的设计要能够尽可能早地交付 隐喻：找到合适的比喻传达信息 简单设计：只处理当前的需求，使设计保持简单 测试先行：先写测试代码，然后再编写程序 重构：重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求 结队编程 集体代码所有制 持续集成：可以按日甚至按小时为客户提供可运行的版本 每周工作40个小时 现场客户 编码标准    敏捷统一过程 敏捷统一过程（Agile Unified Process，AUP）采用以下原理来构建软件系统：\n “在大型上连续” “在小型上迭代”。  采用经典的UP阶段性活动（初始、精化、构建和转换），提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。\n在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。每个AUP迭代执行以下活动：\n 建模：建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进。 实现：将模型翻译成源代码。 测试：像XP一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求。 部署：对软件增量的交付以及获取最终用户的反馈。 配置及项目管理：着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。 环境管理：协调标准、工具以及适用于开发团队的支持技术等过程基础设施。   需求分析 软件需求 需求分析主要的目的是弄清楚系统需要“做什么”，并将其阐述出来。\n软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。通常，这些需求包括：\n  功能需求：考虑系统要做什么，在何时做，在何时以及如何修改或升级。\n  性能需求：考虑软件开发的技术性指标。\n例如：\n 存储容量限制； 执行速度； 响应时间； 吞吐量。    用户或人的因素：考虑用户的类型。\n例如：\n 各种用户对使用计算机的熟练程度，需要接受的训练； 用户理解、使用系统的难度； 用户错误操作系统的可能性。    环境需求：考虑未来软件应用的环境，包括硬件和软件。\n 对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等； 对软件的需求包括：操作系统、网络、数据库等。    界面需求：\n考虑以下方面：\n 来自其他系统的输入； 到其他系统的输出； 对数据格式的特殊规定； 对数据存储介质的规定。    文档需求：考虑需要哪些文档，文档针对哪些读者。\n  数据需求：\n考虑以下方面：\n 输入、输出数据的格式； 接收、发送数据的频率； 数据的准确性和精度； 数据流量； 数据需保持的时间。    资源使用需求：\n考虑以下方面：\n 软件运行时所需要的数据、其他软件、内存空间等资源； 软件开发、维护时，所需的人力、支撑软件、开发设备。    安全保密要求：\n考虑以下方面：\n 是否需要对访问系统或系统信息加以控制； 隔离用户数据的方法； 用户程序如何与其他程序和操作系统隔离 系统备份要求。    可靠性要求：\n考虑以下方面：\n 系统的可靠性要求； 系统是否必须检测和隔离错误； 出错后，重启系统允许的时间。    软件成本消耗与开发进度需求：\n考虑以下方面：\n 开发是否有规定的时间表； 软/硬件投资有无限制。    其他非功能性要求：\n如采用某种开发模式，需要确定：\n 质量控制标准； 里程碑和评审； 验收标准； 各种质量要求的优先级； 可维护性方面的要求。    软件需求的出处：\n 可以来自于用户（实际的和潜在的）、用户的规约、应用领域的专家、相关的技术标准和法规； 可以来自于原有的系统、原有系统的用户、新系统的潜在用户； 可以来自于竞争对手的产品。  需求工程 需求工程可以细分为6个阶段：\n 需求获取 需求分析与协商 系统建模 需求规约 需求验证 需求管理   系统设计 进入设计阶段，需要把软件系统“做什么”的逻辑模型转换成“怎么做”的物理模型。即着手实现软件系统需求。\n系统设计的主要目的就是为系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，最终勾画出新系统的详细设计方案。\n系统设计的主要内容包括：\n 新系统总体结构设计 代码设计 输出、输入设计 处理过程设计 数据存储设计 用户界面设计 安全控制设计  常用的设计方法有以下两种：\n 面向数据流的结构化设计方法（SD）。 面向对象的分析方法（OOD）。  系统设计的基本任务大体上可以分为两个步骤：\n 概要设计 详细设计  概要设计   设计软件系统总体结构（总体结构设计）：\n其基本任务是：\n 采用某种设计方法，将一个复杂的系统按功能划分成模块； 确定每个模块的功能； 确定模块之间的调用关系； 确定模块之间的接口，即模块之间传递的信息； 评价模块结构的质量。  软件系统总体结构的设计是概要设计关键的一步，直接影响到下一个阶段详细设计与编码的工作。\n软件系统的质量及一些整体特性都在软件系统总体结构的设计中决定。\n  数据结构及数据库设计：\n  数据结构设计：逐步细化的方法也适用于数据结构的设计。\n在需求分析阶段，己经通过数据字典对数据的组成、操作约束和数据之间的关系等方面进行了描述，确定了数据的结构特性。在概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。在概要设计阶段，宜使用抽象的数据类型。\n  数据库设计：\n数据库的设计是指数据存储文件的设计，主要进行以下几方面设计：\n  概念设计：在数据分析的基础上，采用自底向上的方法从用户角度进行视图设计，一般用E-R模型来表述数据模型。\nE-R模型既是设计数据库的基础，也是设计数据结构的基础。\n  逻辑设计：E-R模型是独立于数据库管理系统（DBMS）的，要结合具体的DBMS特征来建立数据库的逻辑结构。\n  物理设计：对于不同的DBMS，物理环境不同，提供的存储结构与存取方法各不相同。\n物理设计就是设计数据模式的一些物理细节，如数据项存储要求、存取方法和索引的建立等。\n      编写概要设计文档：\n文档主要有：\n 概要设计说明书 数据库设计说明书 用户手册 修订测试计划    评审：\n对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方法的可行性，关键的处理及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审。\n  详细设计   算法设计：对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来。\n  数据结构设计：对模块内的数据结构进行设计。\n  数据库设计：对数据库进行物理设计，即确定数据库的物理结构。\n  其他设计：\n根据软件系统的类型，还可能要进行以下设计：\n 代码设计：为了提高数据的输入、分类、存储和检索等操作，节约内存空间，对数据库中某些数据项的值要进行代码设计。 输入/输出格式设计。 用户界面设计。    编写详细设计说明书。\n  评审：对处理过程的算法和数据库的物理结构都要评审。\n  系统设计的结果是一系列的系统设计文件，这些文件是物理实现一个信息系统（包括硬件设备和编制软件程序）的重要基础。\n 系统测试 系统测试是为了发现错误而执行程序的过程。\n 成功的测试：发现了至今尚未发现的错误的测试。 测试的目的：希望能以最少的人力和时间发现潜在的各种错误和缺陷。  信息系统测试应包括：\n 软件测试 硬件测试 网络测试  系统测试是保证系统质量和可靠性的关键步骤，是对系统开发过程的最后复查。\n根据测试的概念和目的，在进行信息系统测试时应遵循以下基本原则：\n  应尽早并不断地进行测试。测试应贯穿在开发的各个阶段，应尽早纠正错误，消除隐患。\n  测试工作应该避免由原开发软件的人或小组承担。\n 开发人员往往不愿否认自己的工作，总认为自己开发的软件没有错误； 开发人员的错误很难由本人测试出来，很容易根据自己编程的思路来制定测试思路，具有局限性。    在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。将实际输出结果与预期结果相比较就能发现测试对象是否正确。\n  在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。\n  在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。\n  严格按照测试计划来进行，避免测试的随意性。\n测试计划应包括：\n 测试内容 进度安排 人员安排 测试环境 测试工具 测试资料    妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便。\n  测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便。\n  系统测试阶段的测试目标来自于需求分析阶段。\n测试过程：\n 制定测试计划 编制测试大纲 根据测试大纲设计和生成测试用例 实施测试 生成测试报告  单元测试 单元测试也称为模块测试，在模块编写完成且无编译错误后就可以进行。单元测试侧重于模块中的内部处理逻辑和数据结构。如果选用机器测试，一般用白盒测试法。这类测试可以对多个模块同时进行。\n单元测试主要检查模块的以下5个特征：\n  模块接口：模块的接口保证了测试模块的数据流可以正确地流入、流出。\n在测试中应检查以下要点：\n 测试模块的输入参数和形式参数在个数、属性、单位上是否一致。 调用其他模块时，所给出的实际参数和被调用模块的形式参数在个数、属性、单位上是否一致。 调用标准函数时，所用的参数在属性、数目和顺序上是否正确。 全局变量在各模块中的定义和用法是否一致。 输入是否仅改变了形式参数。 开/关的语句是否正确。 规定的I/O格式是否与输入/输出语句一致。 在使用文件之前是否已经打开文件或使用文件之后是否己经关闭文件。    局部数据结构\n  重要的执行路径\n  出错处理\n  边界条件\n  模块间存在调用与被调关系，对每个模块进行测试时，需要开发两种模块：\n 驱动模块：接收测试例子的数据，将这些数据送到测试模块，输出结果。 桩模块（存根模块）：代替测试模块中所调用的子模块，其内部可进行少量的数据处理。目的是为了检验入口、输出调用和返回的信息。  提高模块的内聚度可以简化单元测试。\n集成测试 集成测试就是把模块按系统设计说明书的要求组合起来进行测试。即使所有的模块都通过了测试，在集成之后，仍然可能出现问题：\n 穿过模块的数据丢失； 一个模块的功能对其他模块造成有害的影响； 各个模块集成起来没有达到预期的功能； 全局数据结构出现问题； 单个模块的误差可以接受，但模块组合后，可能会出现误差累积，最后累积到不能接受的程度。  集成测试是进行一些旨在发现与接口相关的错误的测试，其目标是利用已通过单元测试的构件建立设计中描述的程序结构。\n通常，集成测试有两种方法：\n  非增量集成：分别测试各个模块，再把这些模块组合起来进行整体测试。\n 优点：可以对模块进行并行测试，能充分利用人力，并加快工程进度。 缺点：容易混乱，出现错误不容易查找和定位。    增量集成：以小增量的方式逐步进行构造和测试。\n增量式测试的范围一步步扩大，错误容易定位，更易于对接口进行彻底测试，并且可以运用系统化的测试方法。\n  增量集成策略有：\n  自项向下集成测试：一种构造软件体系结构的增量方法。\n模块的集成顺序为从主控模块（主程序）开始，沿着控制层次逐步向下，以深度优先或广度优先的方式将从属于（或间接从属于）主控模块的模块集成到结构中。\n深度优先集成是首先集成位于程序结构中主控路径上的所有构件，也可以根据特定应用系统的特征进行选择。\n例如上图中，选择最左边的路径：\n 首先，集成构建$M_1$、$M_2$和$M_5$； 其次，集成$M_8$或$M_6$（若$M_2$的正常运行是必须的）； 然后，集成中间和右边控制路径上的构建。  广度优先集成首先沿着水平方向，将属于同一层的构建集成起来。\n例如上图中：\n 首先，将构建$M_2$、$M_3$和$M_4$集成起来； 其次是$M_5$、$M_6$、$M_7$，依次类推。  集成过程可以通过下列5个步骤完成：\n 主控模块用作测试驱动模块，用这些从属于主控模块的所有模块代替桩模块。 依靠所选择的集成方法（即深度优先或广度优先），每次用实际模块替换一个从属桩模块。 在集成每个模块后都进行测试。 在完成每个测试集之后，用实际模块替换另一个桩模块。 可以执行回归测试，以确保没有引入新的错误。  回到第2步继续执行此过程，直到完成了整个程序结构的构造。\n 自顶向下集成不需要驱动模块。\n   自底向上集成测试：自底向上集成测试就是从原子模块（程序结构的最底层构件）开始进行构造和测试。\n由于构件是自底向上集成的，在处理时所需要的从属于给定层次的模块总是存在的，因此，没有必要使用桩模块。自底向上集成策略可以利用以下步骤来实现：\n 连接低层构件以构成完成特定子功能的簇。 编写驱动模块（测试的控制程序）以协调测试用例的输入和输出。 测试簇。 去掉驱动程序，沿着程序结构向上逐步连接簇。   簇：一系列相关低层构建的集合。\n自底向上集成不需要桩模块。\n 例如：\n 连接相应的构建形成簇1、簇2和簇3； 编写驱动模块（图中虚线上方连接的框，即$D_1$、$D_2$和$D_3$） 利用驱动模块对每个簇进行测试。 簇1和簇2中的构建从属于模块$M_a$，去掉驱动模块$D_1$和$D_2$，将这两个簇直接与$M_a$相连；簇3去掉驱动模块$D_3$，然后与$M_b$相连。 最后将$M_a$和$M_b$与构建$M_c$连接在一起。    回归测试：重新执行己测试过的某些子集，以确保变更没有传播不期望的副作用。\n每当加入一个新模块作为集成测试的一部分时，软件发生变更，建立了新的数据流路径，可能出现新的/O,以及调用新的控制逻辑。这些变更可能会使原来可以正常工作的功能产生问题。\n回归测试有助于保证变更不引入无意识行为或额外的错误。回归测试的方法有：\n 手工执行，重新执行所有测试用例的子集 利用捕捉/回放工具自动执行  回归测试要执行的测试子集包含以下3种测试用例：\n 能够测试软件所有功能的具有代表性的测试样本。 额外测试，侧重于可能会受变更影响的软件功能。 侧重于已发生变更的软件构件测试。  随着集成测试的进行，回归测试的数量可能变得相当庞大，因此，应将回归测试用例设计成只包括每个主要程序功能的一个或多个错误类的测试。\n  冒烟测试：一种常用的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估。\n冒烟测试方法包括下列活动：\n  将已经转换为代码的软件构件集成到构建中。\n一个构建包括所有的：\n 数据文件 库 可复用的模块 实现一个或多个产品功能所需的工程化构件    设计一系列测试以暴露影响构建正确地完成它的功能的错误，其目的是为了发现极有可能造成项目延迟的业务阻塞错误。\n  每天将该构建与其他构建及整个软件产品（以其当前形势）集成起来进行冒烟测试。\n这种集成方法可以自顶向下，也可以自底向上。\n    测试方法 测试方法分为：\n  静态测试：\n指被测试程序不在机器上运行，而是采用以下手段对程序进行检测：\n  人工检测：不依靠计算机而是依靠人工审查程序或评审软件。\n人工检测包括：\n 代码检查 静态结构分析 代码质量度量    计算机辅助静态分析\n    动态测试：指通过运行程序发现错误。\n在对软件产品进行动态测试时可以采用以下两种测试方法：\n 黑盒测试法 白盒测试法  测试用例由以下组成：\n 测试输入数据 预期输出结果：与测试输入数据对应的预期输出结果  在设计测试用例时，应当包括：\n 合理的输入条件 不合理的输入条件    黑盒测试 黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。\n进行黑盒测试主要是为了发现以下几类错误：\n 是否有错误的功能或遗漏的功能？ 界面是否有误？输入是否正确接收？输出是否正确？ 是否有数据结构或外部数据库访问错误？ 性能是否能多接受？ 是否有初始化或终止性错误？  常用的黑盒测试技术有：\n  等价类划分：将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例。\n每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以用少量代表性的测试用例取得较好的测试效果。\n等价类划分有两种不同的情况：\n 有效等价类 无效等价类  在设计测试用例时，要同时考虑这两种等价类。\n定义等价类的原则如下。\n 在输入条件规定了取值范围或值的个数的情况下，可以定义1个有效等价类和2个无效等价类。 在输入条件规定了输入值的集合或规定了“必须如何”的条件的情况下，可以定义1个有效等价类和一个无效等价类。 在输入条件是一个布尔量的情况下，可以定义一个有效等价类和一个无效等价类。 在规定了输入数据的一组值（假定$n$个），并且程序要对每一个输入值分别处理的情况下，可以定义$n$个有效等价类和1个无效等价类。 在规定了输入数据必须遵守的规则的情况下，可以定义一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。 在确知己划分的等价类中，各元素在程序处理中的方式不同的情况下，则应将该等价类进一步划分为更小的等价类。    边界值分析：输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。\n边界值划分选择等价类边界的测试用例，既注重于输入条件边界，又适用于输出域测试用例。\n对边界值设计测试用例应遵循的原则如下：\n 如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。 如果输入条件规定了值的个数，则用最大个数、最小个数、比最小个数少1、比最大个数多1的数据作为测试数据。 根据规格说明的每个输出条件使用上述两条原则。 如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例。 如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构边界上的值作为测试用例。 分析规格说明，找出其他可能的边界条件。    错误推测\n  因果图\n  白盒测试 白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。\n白盒测试常用的技术有：\n  逻辑覆盖：考察用测试数据运行被测程序时，对程序逻辑的覆盖程度。\n主要的逻辑覆盖标准以下6种：\n  语句覆盖：指选择足够的测试数据，使被测试程序中的每条语句至少执行一次。\n语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。\n  判定覆盖（分支覆盖）：指设计足够的测试用例，使得被测程序中的每个判定表达式至少获得一次“真”/“假”值。\n判定覆盖的判定表达式是指判定表达式整体。\n判定覆盖要比语句覆盖更强一些。\n  条件覆盖：指构造一组测试用例，使得每一判定语句中每个逻辑条件的各种可能的值至少满足一次。\n条件覆盖的判定语句是指判定表达式下的判定语句（如果有），即用AND、OR等逻辑运算符连接起来的语句（不包含逻辑运算符的语句）。\n  判定/条件覆盖：指设计足够的测试用例，使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次。\n判定/条件覆盖同时满足：\n 判定覆盖 条件覆盖    条件组合覆盖：指设计足够的测试用例，使得每个判定中条件的各种可能值的组合都至少出现一次。\n满足条件组合覆盖的测试用例一定满足：\n 判定覆盖 条件覆盖 判定/条件覆盖    路径覆盖：路径覆盖是指覆盖被测试程序中所有可能的路径。\n    循环覆盖\n  基本路径测试\n   运行和维护 软件维护是软件生命周期中的最后一个阶段，处于系统投入生产性运行以后的时期中，因此不属于系统开发过程。软件维护是在软件已经交付使用之后为了改正错误或满足新的需求而修改软件的过程，即软件在交付使用后对软件所做的一切改动。\n系统可维护性 系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度。提高可维护性是开发软件系统所有步骤的关键目的。系统的可维护性可以衡量系统是否能被很好地维护。\n系统可维护性的评价指标：\n  可理解性：指别人能理解系统的结构、界面、功能和内部过程的难易程度。\n模块化、详细设计文档、结构化设计和良好的高级程序设计语言等都有助于提高可理解性。\n  可测试性：诊断和测试的容易程度取决于易理解的程度。\n好的文档资料有利于诊断和测试；程序的结构、高性能的测试工具以及周密计划的测试工序也是至关重要的。\n在进行系统维护时，应该充分利用在系统测试阶段保存下来的测试用例。\n  可修改性：诊断和测试的容易程度与系统设计所制定的设计原则有直接关系。\n模块的耦合、内聚、作用范围与控制范围的关系等都对可修改性有影响。\n  软件文档是软件可维护性的决定因素。文档是软件产品的一部分，并且编写高质量的文档可以提高软件开发的质量。\n软件系统的文档分为：\n 用户文档：主要描述系统功能和使用方法，并不关心这些功能是怎样实现的； 系统文档：描述系统设计、实现和测试等各方面的内容。  可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护的特点。在软件工程的每一个阶段都应考虑并提高软件的可维护性，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审（如将来要改进的部分和可能会修改的部分）。\n维护应该针对整个软件配置，不应该只修改源程序代码。\n软件维护 软件维护主要是指根据需求变化或硬件环境的变化对应用程序进行部分或全部修改。修改时应充分利用源程序，修改后要填写程序修改登记表，并在程序变更通知书上写明新旧程序的不同之处。\n软件维护的内容一般有以下几个方面：\n  正确性维护：指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。\n所发现的错误有：\n 不太重要、不影响系统正常运行的错误，其维护工作可随时进行； 非常重要的错误，甚至会影响整个系统的正常运行，其维护工作必须制定计划，进行修改，并且要进行复查和控制。    适应性维护：使应用软件适应信息技术变化和管理需求变化而进行的修改。\n  完善性维护：为扩充功能和改善性能而进行的修改。\n 主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。 还包括对处理效率和编写程序的改进，关系到系统开发质量的重要方面。  这方面的维护还要注意将相关的文档资料加入到前面相应的文档中。\n  预防性维护：为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰。\n例如将专用报表功能改成通用报表生成功能，以适应将来报表格式的变化。\n   项目管理 沟通路径 沟通图是指项目中人员或部门之间的沟通用一条无向边连接起来，所构成图即为沟通图。沟通图中的路径称为沟通路径。\n软件项目中沟通路径$m$的计算公式：\n  沟通图中无主程序员时：\n$$ m = \\sum_{i=1}^{n} i-1 = \\cfrac{(n-1)n}{2} $$\n  沟通图中有主程序员时：\n$$ m = n - 1 $$\n  软件项目估算 软件项目估算涉及人、技术、环境等多种因素，很难在项目完成前准确地估算出开发软件所需的成本、持续时间和工作量。所以需要一些方法和技术来支持项目的估算，常用的估算方法有下列3种：\n  基于已经完成的类似项目进行估算（常用）。\n  基于分解技术进行估算。\n  基于经验估算模型的估算。\n典型的经验估算模型有：\n IBM估算模型 CoCoMo模型 Putnam模型    上述方法可以组合使用，以提高估算的精度。\nCOCOMO 估算模型 COCOMO模型是一种精确的、易于使用的成本估算模型。COCOMO模型按其详细程度分为：\n  基本COCOMO模型：是一个静态单变量模型，用于对整个软件系统进行估算。\n公式如下：\n$$ E = a(L)^b \\\\ D=cE^d $$\n $E$：工作量，单位是人月； $D$：开发时间，单位是月； $L$：项目的源代码行估计值，不包括程序中的注释及文档，其单位是千行代码； $a$、$b$、$c$、$d$：常数。  基本COCOMO模型可通过估算代码行的值$L$，然后计算开发工作量$E$和开发时间$D$的估算值。\n  中级COCOMO模型：是一个静态多变量模型，它将软件系统模型分为系统和部件两个层次，系统由部件构成，它把软件开发所需的人力（成本）看作是程序大小和一系列“成本驱动属性”的函数。\n中级COCOMO模型以基本COCOMO模型为基础，并考虑了15种影响软件工作量的因素，通过工作量调节因子（EAF）修正对工作量的估算，从而使估算更合理。其公式如下：\n$$ E = a(L)^b \\cdot EAF $$\n $L$：软件产品的目标代码行数，单位是千行代码数； $EAF$：工作量调节因子； $a$、$b$：常数。    详细COCOMO模型：将软件系统模型分为系统、子系统和模块3个层次，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响。\n  COCOMOII模型 和其前身COCOMO一样，COCOMOII也是一种层次结构的估算模型，被分为3个阶段性模型，分别对应三种不同的规模估算选择：\n  应用组装模型：在软件工程的前期阶段使用，这时用户界面的原型开发、对软件和系统交互的考虑、性能的评估以及技术成熟度的评价是最重要的。\n规模估算选择：对象点。\n  早期设计阶段模型：在需求己经稳定并且基本的软件体系结构己经建立时使用。\n规模估算选择：功能点。功能点可转换为代码行。\n  体系结构阶段模型：在软件的构造过程中使用。\n规模估算选择：代码行。\n  进度管理 进度安排：\n为监控软件项目的进度计划和工作的实际进展情况，表示各项任务之间进度的相互依赖关系，需要采用图示的方法。在图中明确标明如下内容：\n 各个任务的计划开始时间和计划完成时间。 各个任务的完成标志。 各个任务与参与工作的人数，各个任务与工作量之间的衔接情况。 完成各个任务所需的物理资源和数据资源。  进度安排的常用图形描述方法有：\n Gantt图（甘特图）； 项目计划评审技术（Program Evaluation\u0026amp;Review Technique，PERT）图。  Gantt图 Gantt图：一种简单的水平条形图，它以日历为基准描述项目任务。\n  垂直轴：表示多个不同的任务，每个任务按照左侧任务名称垂直排列。\n  水平轴：表示日历时间线（如时、天、周、月和年等）。\n每个水平条表示一个任务：\n 每一水平条的起点：表示该任务的开始时间； 每一水平条的终点：表示该任务的结束时间； 每一水平条的长度：表示完成该任务的持续时间。  当日历中同一时段存在多个水平条时，表示任务之间的并发。\n  如图：\n  Gantt图优点：\n能清晰地描述：\n 每个任务的开始时间； 每个任务的结束时间； 任务的进展情况； 各个任务之间的并行性。    Gantt图缺点：\n 不能清晰地反映各任务之间的依赖关系； 难以确定整个项目的关键所在； 不能反映计划中有潜力的部分。    PERT图 PERT图是一个有向图：\n  弧：表示任务。\n任务包含以下成分：\n  完成该任务所需的时间。\n  松弛时间（Slack Time）：表示在不影响整个工期的前提下完成该任务有多少机动余地。\n即松弛时间指当前任务的工期可以推迟的时间。\n  空任务：用虚线箭头表示，表示任务间的关系所添加。完成空任务的所需时间为0。\n  结点：表示事件。\n事件是流入结点的任务的结束，或流出结点的任务的开始。事件表示某个时间点，本身不消耗时间和资源。\n事件包含以下成分：\n 事件号。 出现该事件的最早时刻：表示在此时刻之前从该事件出发的任务不可能开始。 出现该事件的最迟时刻：表示从该事件出发的任务最迟在此时刻开始，否则整个工程就不能如期完成。  只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始。\n特殊的事件：\n 开始事件：没有任何任务流向该事件； 结束事件：没有任务任务从该事件流出。  一个项目是从开始事件开始到结束事件结束。\n  设：\n $T(e)$：完成任务$e$的所需时间； $T_s(e)$：完成任务$e$的松弛时间； $T_e(v)$：事件$v$的最早时刻； $T_l(v)$：事件$v$的最迟时刻。  PERT图各成分取值（不一定需要满足下面的关系，但是可以用下面的式子推出）：\n  事件$V_{in}$的最早时刻$T_e(V_{in})$：\n  只有一个任务流入时，设该任务的流出事件为$V_{out}$，则该任务为$\u0026lt;V_{out}, V_{in}\u0026gt;$：\n$$ T_e(V_{in}) = T_e(V_{out}) + T(\u0026lt;V_{out}, V_{in}\u0026gt;) $$\n即，该流入任务的流出事件的最早时刻 + 完成该流入任务的所需时间。\n  多个任务流入时，设与每个任务相对应的流出事件为$V_{out}[ \\ i \\ ]$，则这些任务为$\u0026lt;V_{out}[ \\ i \\ ], V_{in}\u0026gt;$：\n$$ T_e(V_{in}) = Max(T_e(V_{out}[ \\ i \\ ]) + T(\u0026lt;V_{out}[ \\ i \\ ], V_{in}\u0026gt;)) $$\n即，流入该事件的每个任务计算出的最早时刻的最大值。\n  开始事件$V_{start}$：\n$$ T_e(V_{start}) = 0 $$\n    事件$V_{out}$的最迟时刻$T_l(V_{out})$：\n  只有一个任务流出时，设该任务的流入事件为$V_{in}$，则该任务为$\u0026lt;V_{out}, V_{in}\u0026gt;$：\n$$ T_l(V_{out}) = T_l(V_{in}) - (T(\u0026lt;V_{out}, V_{in}\u0026gt;) + T_s(\u0026lt;V_{out}, V_{in}\u0026gt;)) $$\n即，该流出任务的流入事件的最迟时刻 -（该流出任务的所需时间 + 松弛时间）\n如果松弛时间未知：\n$$ T_l(V_{out}) = T_l(V_{in}) - T(\u0026lt;V_{out}, V_{in}\u0026gt;) $$\n  多个任务流出时，设与每个任务相对应的流入事件为$V_{out}[ \\ i \\ ]$，则这些任务为$\u0026lt;V_{out}[ \\ i \\ ], V_{in}\u0026gt;$：\n$$ Min(V_{out}[ \\ i \\ ]) = T_l(V_{in}) - (T(\u0026lt;V_{out}[ \\ i \\ ], V_{in}\u0026gt;) + T_s(\u0026lt;V_{out}[ \\ i \\ ], V_{in}\u0026gt;)) $$\n即，流出该事件的每个任务计算出的最晚时刻的最大值。\n如果松弛时间未知：\n$$ Min(V_{out}[ \\ i \\ ]) = T_l(V_{in}) - T(\u0026lt;V_{out}[ \\ i \\ ], V_{in}\u0026gt;) $$\n  结束事件$V_{end}$：\n$$ T_l(V_{end}) = T_e(V_{end}) $$\n即结束事件的最早时刻与最迟时刻相等。\n    设某任务的流入事件为$V_{in}$，流出事件为$V_{out}$，则该任务$\u0026lt;V_{out}, V_{in}\u0026gt;$的松弛时间$T_s(\u0026lt;V_{out}, V_{in}\u0026gt;)$，。\n$$ T_s(\u0026lt;V_{out}, V_{in}\u0026gt;) = T_l(V_{in}) - T(\u0026lt;V_{out}, V_{in}\u0026gt;) - T_e(V_{out}) $$\n即，该任务的流入事件的最迟时刻 - 该任务的所需时间 - 该任务的流出事件的最早时刻\n  PERT图的路径：从开始事件到结束事件的一条通路。\nPERT图的关键路径：指所有的任务的松弛时间都为0的路径。\n关键路径的特点：\n 所有任务的松弛时间都为0。 每个事件的最早时刻和最迟时刻都是相等的。 所有任务持续时间的和，是PERT图所有路径中最大的，并且与结束事件的最早时刻（或最晚时刻）相等。  PERT图的优点：\n 给出了每个任务的开始时间、结束时间和完成该任务所需的时间； 给出了任务之间的关系。即任务之间的执行顺序。  项目活动图 项目活动图是一种有向图（与PERT图十分类似）：\n  弧：表示活动。弧的权值表示活动的持续时间。\n  顶点：表示项目里程碑。\n特殊的里程碑：\n 开始里程碑：没有任何活动指向该里程碑； 结束里程碑：没有任何活动从该里程碑指出。    项目活动图的关键路径：按照PERT图的方法求出松弛时间为0的、从开始里程碑到结束里程碑的路径。\n关键路径的长度：为结束里程碑的最早时刻（或最晚时刻）。它可以用来表示项目完成的最少时间。\n软件配置管理 在软件开发过程中变更是不可避免的，而变更时由于没有进行变更控制，可能加剧了项目中的混乱。为了协调软件开发使得混乱减到最小，使用配置管理技术，使变更所产生的错误达到最小并最有效地提高生产率。\n软件配置管理（Software Configure Management，SCM）用于整个软件工程过程，它是一组管理整个软件生存周期中各阶段变更的活动。\n软件配置管理的主要目标包括：\n 标识变更 控制变更 版本控制 确保变更正确地实现 报告有关变更  主要内容有两种版本：\n   版本管理 配置支持 变更支持 过程支持 团队支持 变化报告 审计支持     软件配置标识 变更管理 版本控制 系统建立 配置审核 配置状态报告    变更控制 变更控制是一项最重要的软件配置任务。为了有效地实现变更控制，需借助于配置数据库和基线的概念。\n基线：是软件生存周期中各开发阶段的一个特定点，它的作用是使各开发阶段的工作划分更加明确，使本来连续的工作在这些点上断开，以便于检查与肯定阶段成果。\n基线可以作为一个检查点。在开发过程中，当采用的基线发生错误时可以知道所处的位置，返回到最近和最恰当的基线上。\n配置数据库可分为以下3类：\n  开发库：专供开发人员使用，其中的信息可能做频繁修改，对其控制相当宽松。\n  受控库：在生存期某一阶段工作结束时发布的阶段产品，这些是与软件开发工作相关的计算机可读信息和人工可读信息。\n软件配置管理正是对受控库中的各个软件项进行管理，受控库也称为软件配置库。\n  产品库：在开发的软件产品完成系统测试后，作为最终产品存入产品库，等待交付用户或现场安装。\n  风险管理 一般认为软件风险包含两个特性：\n 不确定性：指风险可能发生也可能不发生； 损失：指如果风险发生，就会产生恶性后果。  在进行风险分析时，重要的是量化每个风险的：\n 不确定程度 损失程度  项目风险威到项目计划。项目风险是指以下各方面的潜在问题以及它们对软件项目的影响：\n 预算 进度 人员：聘用职员及组织 资源 利益相关者 需求  以下方面也属于项目风险因素：\n 项目复杂度 项目规模 项目结构不确定性  技术风险威胁到要开发软件的质量及交付时间。技术风险是指以下方面的潜在问题：\n 设计 实现 接口 验证 维护  以下方面也属于技术风险因素：\n 规格说明的歧义性 技术的不确定性 技术陈旧 “前沿”技术  商业风险威肋到要开发软件的生存能力，且常常会危害到项目或产品。5个主要的商业风险如下：\n 市场风险：开发了一个没有人真正需要的优良产品或系统。 策略风险：开发的产品不再符合公司的整体商业策略。 销售风险：开发了一个销售部门不知道如何去销售的产品。 管理风险：由于重点的转移或人员的变动而失去了高级管理层的支持。 预算风险：没有得到预算或人员的保证。  Charette提出的风险分类方式：\n  己知风险：\n通过仔细评估以下内容可以发现的风险：\n 项目计划 开发项目的商业和技术环境 其他可靠的信息来源，如：  不现实的交付时间 没有文档化需求或文档化软件范围 恶劣的开发环境      可预测风险：\n能够从过去项目的经验中推断出来的风险，如：\n 人员变动 与客户缺乏沟通 由于正在进行维护而使开发人员精力分散    不可预测风险：可能会真的出现，但很难事先识别。\n  风险识别 风险识别试图系统化地指出对项目计划（估算、进度、资源分配等）的威胁。识别出已知风险和可预测风险后，项目管理者首先要做的是：\n 在可能时回避这些风险； 在必要时控制这些风险。  识别风险的一种方法是建立风险条目检查表，主要用来识别下列几种类型中的一些已知风险和可预测风险：\n 产品规模：与要开发或要修改的软件的总体规模相关的风险。 商业影响：与管理者或市场所施加的约束相关的风险。 客户特性：与客户的素质以及开发者和客户定期沟通的能力相关的风险。 过程定义：与软件过程定义的程度以及该过程被开发组织遵守的程度相关的风险。 开发环境：与用来开发产品的工具的可得性及质量相关的风险。 开发技术：与待开发软件的复杂性及系统所包含技术的“新奇性”相关的风险。 人员才干及经验：与软件工程师的总体技术水平及项目经验相关的风险。  与上述每个主题相关的问题可以针对每一个软件项目来回答。根据这些问题的答案，项目管理者就可以估计风险产生的影响。\n另一种风险条目检查表格式：仅仅列出与每一种类型有关的特性，最终给出一组风险因素和驱动因子以及它们发生的概率。\n风险因素包括：\n 性能：性能风险是指产品能够满足需求且符合其使用目的的不确定程度。 成本：成本风险是指能够维持项目预算的不确定程度。 支持：支特风险是指开发出的软件易于纠错、修改及升级的不确定程度。 进度：进度风险是指能够维持项目进度且按时交付产品的不确定程度。  风险预测 风险顶测又称风险估计，它试图从两个方面评估一个风险：\n 风险发生的可能性或概率； 发生风险所产生的后果。  通常，项日计划人员与管理人员、技术人员一起进行以下4步风险预测活动：\n 建立一个尺度或标准，以反映风险发生的可能性。 描述风险产生的后果。 估算风险对项目和产品的影响。 标注风险预测的整体精确度，以免产生误解。  一种简单的风险预测技术是建立风险表：\n  第1列：列出所有的风险（由风险识别活动得到)；\n  第2~4列：列出每个风险的：\n 种类 发生的概率 所产生的影响  风险所产生的影响可用一个数字来表示：\n “1”：表示灾难性的； “2”：表示严重的； “3”表示轻微的； “4”表示可忽略的。    评估风险影响\n发生风险时，有3个因素可能会影响风险所产生的后果：\n  风险的本质：指当风险发生时可能带来的问题。\n  风险的范围：\n包括：\n 风险的严重性 风险的整体分布情况：项目中有多少部分受到影响或有多少客户受到损害。    风险的时间：\n 何时能够感受到风险的影响； 风险的影响会持续多长时间。    整体的风险显露度（Risk Exposure，RE）可由下面的关系确定：\n$$ RE = P \\times C $$\n $P$：风险发生的概率； $C$:风险发生时带来的项目成本。  风险评估 在进行风险评估时，建立了如下形式的三元组：\n$$ (r_i, l_i, x_i) $$\n $r_i$：表示风险； $l_i$：表示风险发生的概率； $x_i$：表示风险产生的影响。  一种对风险评估很有用的技术就是定义风险参照水准。对于大多数软件项目来说，有3种典型的风险参照水准\n 成本：成本是否超支 进度：进程是否延期 性能：性能是否下降  在风险评估过程中，需要执行以下4个步骤：\n 定义项目的风险参考水平值。 建立每一组$(r_i, l_i, x_i)$与每一个参考水平值之间的关系。 预测一组临界点以定义项目终止区域，该区域由一条曲线或不确定区域所界定。 预测什么样的风险组合会影响参考水平值。  风险监控 风险控制的目的是辅助项目组建立处理风险的策略。一个有效的策略必须考虑以下3个问题：\n  风险避免：\n应对风险的最好办法是主动地避免风险，即在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生。\n  风险监控：\n项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。\n  RMMM计划：\n风险管理策略可以包含在软件项目计划中，或者风险管理步骤也可以组织成一个独立的风险缓解、监控和管理计划（RMMM计划）。\nRMMM计划将所有风险分析工作文档化，并由项目管理者作为整个项目计划中的一部分来使用。\n建立了RM计划，而且项目己经启动之后，风险缓解及监测步骤也就开始了：\n  风险缓解：一种问题规避活动。\n  风险监测：一种项目跟踪活动。\n这种监测活动有3个主要目的：\n 评估所预测的风险是否真的发生了； 保证正确地实施了各风险的缓解步骤； 收集能够用于今后风险缝隙的信息。    风险监测的另一个任务就是试图找到“起源”（在整个项目中是哪些风险引起了哪些问题）。\n   软件质量 软件质量特性的度量 可靠性、可用性和可维护性是软件的质量属性，软件工程中，用$0 \\sim 1$之间的数来度量。\n  可靠性：指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。\n可以用$\\cfrac{MTTF}{1+MTTF}$来度量。\nMTTF为平均无故障时间。\n  可用性：指在给定的时间点上，一个系统能够按照规格说明正确运作的概率。\n可以用$\\cfrac{MTBF}{1+MTBF}$来度量。\nMTBF为平均失效间隔时间。\n  可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。\n可以用$\\cfrac{1}{1+MTTR}$来度量。\nMTTR为平均修复时间。\n  软件质量模型 讨论软件质量首先要了解软件的质量特性，目前己经有多种软件质量模型来描述软件质量特性，如：\n ISO/IEC 9126 软件质量模型 Me Call 软件质量模型。  ISO/IEC 9126 软件质量模型 ISO/IEC 9126软件质量模型由3个层次组成：\n 第一层：质量特性 第二层：质量子特性 第三层：度量指标  该模型的质量特性和质量子特性：\n  质量特性 质量子特性 含义   功能性（Functionality）   适合性（Suitability）  与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性。    准确性（Accurateness）  与能够得到正确或相符的结果或效果有关的软件属性。    互用性（Interoperability）  与其他指定系统进行交互操作的能力相关的软件属性。    依从性（Compliance）  使软件服从有关的标准、约定、法规及类似规定的软件属性。    安全性（Security）  与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性。    可靠性（Reliability）   成熟性（Maturity）  与由软件故障引起失效的频度有关的软件属性。    容错性（Fault tolerance）  与在软件错误或违反指定接口的情况下维持指定的性能水平的能力有关的软件属性。    易恢复性（Recoverability）  与在故障发生后，重新建立其性能水平并恢复直接受影响数据的能力，以及为达到此目的所需的时间和努力有关的软件属性。    易使用性（Usability）   易理解性（Understandability）  与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。    易学性（Learnability）  与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。    易操作性（Operability）  与用户为进行操作和操作控制所付出的努力有关的软件属性。    效率（Efficiency）   时间特性（Time behavior）  与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性。    资源特性（Resource behavior）  与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。    可维护性（Maintainability）   易分析性（Analyzability）  与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。    易改变性（Changeability）  与进行修改、排错或适应环境变换所需努力有关的软件属性。    稳定性（Stability）  与修改造成未预料效果的风险有关的软件属性。    易测试性（Testability）  为确认经修改软件所需努力有关的软件属性。    可移植性（Portability）   适应性（Adaptability）  与软件转移到不同环境时的处理或手段有关的软件属性。    易安装性（Installability）  与在指定环境下安装软件所需努力有关的软件属性。    一致性（Conformance）  使软件服从与可移植性有关的标准或约定的软件属性。    易替换性（Replaceability）  与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。    适合性准确性互用性依从性安全性 **可靠性** |成熟性容错性易恢复性 **易使用性**|易理解性易学性易操作性 **效率** |时间特性资源特性 **可维护性**|易分析性易改变性稳定性易测试性 **可移植性**|适应性易安装性一致性易替换性 -- Mc Call 软件质量模型 Mc Call软件质量模型从以下3个方面确定了11个质量特性：\n 软件产品的运行 软件产品的修正 软件产品的转移  Mc Call也给出了一个三层模型框架：\n 第一层：质量特性 第二层：评价准则 第三层：度量指标  软件质量保证 软件质量保证是指为保证软件系统或软件产品充分满足用户要求的质量而进行的有计划、有组织的活动，其目的是生产高质量的软件。\n软件质量保证包括了与以下7个主要活动相关的各种任务：\n 应用技术方法 进行正式的技术评审 测试软件 标准的实施 控制变更 度量（Metrics） 记录保存和报告  软件评审 通常，把“质量”理解为“用户满意程度”。为了使得用户满意，有以下两个必要条件：\n  设计质量：设计的规格说明书符合用户的要求。\n设计质量的评审对象：\n 软件需求规格说明 数据需求规格说明 软件概要设计说明    程序质量：程序按照设计规格说明所规定的情况正确执行。\n程序质量的评审通常是从开发者的角度进行，与开发技术直接相关。程序质量的评审对象：\n 软件结构：  功能结构：  数据结构 功能结构 数据结构和功能结构之间的对应关系   功能的通用性 模块的层次 模块结构：  控制流结构 数据流结构 模块结构与功能结构之间的对应关系   处理过程的结构   与运行环境的接口：  与硬件的接口 与用户的接口   变更带来的影响    软件的规格说明分为：\n  外部规格说明：从用户角度来看的规格，包括硬件/软件系统设计、功能设计；\n设计质量是由外部规格说明决定的\n  内部规格说明：为了实现外部规格的更详细的规格，即软件模块结构与模块处理过程的设计。\n内部规格说明是从开发者角度来看的规格说明。\n程序是由内部规格说明决定的。\n  软件容错技术 提高软件质量和可靠性的技术大致可分为两类：\n 避开错误：在开发的过程中不让差错潜入软件的技术； 容错技术：对某些无法避开的差错，使其影响减至最小的技术。  实现容错的主要手段是冗余。冗余是指对于实现系统规定功能是多余的那部分资源，包括：\n 硬件 软件 信息 时间  由于加入了这些资源，有可能使系统的可靠性得到较大的提高。通常，冗余技术分为4类：\n  结构冗余：结构冗余是通常采用的冗余技术，按其工作方法可以分为：\n  静态冗余：\n常用的有：\n 三模冗余（Triple Module Redundancy，TR） 多模冗余  静态冗余通过表决和比较来屏蔽系统中出现的错误。\n  动态冗余：动态冗余的主要方式是多重模块待机储备。\n当系统测试到某工作模块出现错误时，就用一个备用模块来顶替它并重新运行。这里包括以下过程：\n 检测 切换 恢复  动态冗余有以下两种方式：\n  热备份系统：每当一个出错模块被其他备用模块顶替后，冗余系统相当于进行了一次重构。\n在热备份系统中，备用模块在待机过程中的失效率为0。\n  冷备份系统：各备用模块在其待机时可与主模块一同工作，也可不工作。\n    混合冗余：兼有静态元余和动态冗余的长处。\n    信息冗余\n  时间冗余\n  冗余附加技术\n   McCabe 软件复杂性度量法 McCabe度量法又称环路度量法，是通过定义环路复杂度，建立程序复杂性的度量，它是一种基于程序控制流的复杂性度量方法，它反映了程序（或模块）的控制结构的复杂性。\nMaCabe度量法认为程序的复杂性在很大程度上取决于控制的复杂性。单一的顺序程序结构最为简单，循环和选择构成的环路越多，程序就越复杂。\nMaCabe度量法以图论为工具，先画出程序图，然后用该图的环路数作为程序复杂性的度量值。\n程序图是退化的程序流程图。把程序流程图中的每个处理符号都退化成一个结点，原来连接不同处理符号的流线变成连接不同点的有向弧，这样得到的有向图称为程序图。\n程序图仅描述程序内部的控制流程，完全不表现对数据的具体操作以及分支和循环的具体条件。\n根据图论，在一个强连通的有向图$G$中，计算环的个数$V(G)$的公式为：\n$$ V(G) = m - n + 2p $$\n $V(G)$：$G$中的环路个数； $m$：$G$中的弧的个数； $n$：$G$中的结点数； $p$：$G$中的强连通分量个数。  在一个程序中，从程序图的入口点总能到达图中的任何一个结点，因此，程序总是连通的，但不是强连通的。\n为了使程序图成为强连通图，从图的入口点到出口点加一条用虚线表示的有向边（如上图所示），使图成为强连通图（但虚线弧并不算入实际的弧数）。这样就可以使用上式计算环路复杂性了，也因此程序图的$p$通常为1。\n即，计算有向图$G$的环路复杂性的公式为：\n$$ V(G) = m - n + 2 $$\n例如上图中，结点数$n=6$，弧数$m=9$，则：\n$$ V(G) = 9 - 6 + 2 = 5 $$\n即上图McCabe环路复杂的度量值为5。\n $V(G) = 10$是一个实际模块的上限。当$V(G) \u0026gt; 10$时，很难充分测试这个模块。\n在白盒测试中，计算环路复杂度可以简单地使用判定条件的数量 + 1。\n  软件工具 软件开发工具 对应于软件开发过程的各种活动，软件开发工具通常有：\n 需求分析工具 设计工具 编码与排错工具 测试工具  软件维护工具 辅助软件维护过程中活动的软件称为软件维护工具，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：\n 版本控制工具 文档分析工具 开发信息库工具 逆向工程工具 再工程工具  ","date":"2023-05-08T10:02:34Z","permalink":"https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"软件工程（软件设计师）"},{"content":"概述 结构化方法是一种面向数据流的开 发方法，它由以下构成：\n 结构化分析：根据分解与抽象的原则，按照系统中数据处理的流程，用数据流图来建立系统的功能模型，从而完成需求分析工作。 结构化设计：根据模块独立性准则、软件结构优 化准则将数据流图转换为软件的体系结构，用软件结构图来建立系统的物理模型，实现系统的 概要设计。 结构化程序设计：使用3种基本控制结构构造程序，任何程序都可以由顺序、选择和重复3种基本控制结构构造。  结构化方法总的指导思想是自顶向下、逐层分解，它的基本原则是功能的分解与抽象。它是软件工程中最早出现的开发方法，特别适合于数据处理领域的问题，但是不适合解决大规模的、特别复杂的项目，且难以适应需求的变化。\n 系统设计 抽象 抽象是一种设计技术，重点说明一个实体的本质方面，而忽略或者掩盖不太重要或非本质的方面。\n抽象是一种重要的工具，用来将复杂的现象简化到可以分析、实验或者可以理解的程度。\n软件工程中从软件定义到软件开发要经历多个阶段，在这个过程中每前进一步都可看作是对软件解法的抽象层次的一次细化。\n抽象的最底层就是实现该软件的源程序代码。在进行模块化设计时也可以有多个抽象层次，最高抽象层次的模块用概括的方式叙述问题的解法，较低抽象层次的模块是较高抽象层次模块对问题解法描述的细化。\n模块化   模块：是在程序中是数据说明、可执行语句等程序对象的集合，或者是单独命名和编址的元素，例如高级语言中的过程、函数和子程序等。\n在软件的体系结构中，模块是可组合、分解和更换的单元。\n  模块化：是指将一个待开发的软件分解成若干个小的简单部分一模块，每个模块可独立地开发、测试，最后组装成完整的程序。\n这是一种复杂问题“分而治之”的原则。\n模块化的目的是使程序的结构清晰，容易阅读、理解、测试和修改。\n  模块独立：是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系简单。\n衡量模块独立程度的标准有（模块独立性的两个定性标准）：\n 耦合性； 内聚性。  在将软件系统划分模块时，应尽量做到高内聚、低耦合，提高模块的独立性。\n  耦合 耦合是模块之间的相对独立性（互相连接的紧密程度）的度量。\n模块之间的耦合取决于：\n 各个模块之间接口的复杂程度； 调用模块的方式； 通过接口的信息类型。  一般模块之间可能的耦合方式有7种类型：\n  无直接耦合：指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何信息。\n无直接耦合的模块间：\n 耦合性最弱； 模块独立性最高。    数据耦合：指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递。\n  标记耦合：指两个模块之间传递的是数据结构。\n  控制耦合：指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择地执行模块内的某一功能。\n  外部耦合：模块间通过软件之外的环境联结（如I/O将模块耦合到特定的设备、格式、通信协议上）时称为外部耦合。\n  公共耦合：指通过一个公共数据环境相互作用的那些模块间的耦合。\n  内容耦合：当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时，这种模块之间的耦合称为内容耦合。\n     耦合类型 说明     无直接耦合 没有直接关系，不传递任何信息   数据耦合 调用关系，传递简单数据值   标记耦合 传递数据结构   控制耦合 调用关系，被调模块传递给主调模块控制变量   外部耦合 通过软件之外的环境联结   公共耦合 通过公共数据环境相互作用   内容耦合 直接使用另一个模块的内部数据\n或通过非正常入口转入另一个模块内部     解耦：降低模块之间的耦合性的过程。\n 内聚 内聚是对一个模块内部各个元素彼此结合的紧密程度的度量。一个内聚程度高的模块（在理想情况下）应当只做一件事。\n一般模块的内聚性分为7种类型：\n  偶然内聚（巧合内聚）：指一个模块内的各处理元素之间没有任何联系。\n偶然内聚具有最低的内聚性。\n具有偶然内聚的模块具有以下特点（缺点）：\n 不易修改、理解和维护； 会影响到模块间的耦合关系。    逻辑内聚：指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。\n  时间内聚：把需要同时执行的动作组合在一起形成的模块。\n  过程内聚：指一个模块完成多个任务，这些任务必须按指定的过程执行。\n  通信内聚：指模块内的所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或者产生相同的输出数据。\n  顺序内聚：指一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入。\n  功能内聚：指模块内的所有元素共同作用完成一个功能，缺一不可。\n这是最强的内聚。\n     内聚类型 说明     偶然内聚\n（巧合内聚） 各处理之间没有任何联系   逻辑内聚 执行若干个逻辑上相似的功能，\n通过参数确定该模块完成哪一个功能   时间内聚 把需要同时执行的动作组合在一起   过程内聚 完成多个任务，这些任务必须按指定的过程执行   通信内聚 所有处理都在同一个数据结构上操作，\n或者各处理使用相同的输入数据或者产生相同的输出数据   顺序内聚 各处理都与同一功能密切相关且必须顺序执行，\n前一功能元素的输出就是下一功能元素的输入   功能内聚 所有元素共同作用完成一个功能，缺一不可    系统结构设计原则 为保证总体结构设计顺利完成，应遵循以下几条原则：\n  分解——协调原则：\n系统整体，具有其整体的目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。\n  自顶向下的原则：\n从上往下，逐层分解；先确定上层模块的功能，再确定下层模块的功能。\n  信息隐蔽、抽象的原则：\n上层模块只规定下层模块做什么和所属模块间的协调关系，但不规定怎么做，以保证各模块的相对独立性和内部结构的合理性，使得模块与模块之间层次分明，易于理解、实施和维护。\n  一致性原则：\n要保证整个软件设计过程中具有：\n 统一的规范、 统一的标准、 统一的文件模式 ……    明确性原则：\n每个模块必须：\n 功能明确、接口明确； 消除多重功能和无用接口。    高内聚、低耦合：\n模块之间的耦合尽可能小，模块的内聚度尽可能高。\n  模块的扇入系数和扇出系数要合理：\n 扇出系数：模块直接调用其他模块的个数。 扇入系数：模块被其他模块调用时，直接调用它的模块个数。  经验表明，一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7，否则会引起出错概率的增大。但菜单调用型模块的扇入与扇出系数可以大一些，公用模块的扇入系数可以大一些。\n  模块的规模适当：\n 过大的模块常常使系统分解得不充分； 过小的模块有可能降低模块的独立性，造成系统接口的复杂性。    模块的作用范围应该在其控制范围之内。\n  避免或减少使用病态连接：病态连接是指从中部进入或访问一个模块。\n  系统文档 信息系统的文档是系统建设过程的“痕迹”，是系统维护人员的指南，是开发人员与用户交流的工具。\n对文档在系统开发人员、项目管理人员、系统维护人员、系统评价人员以及用户之间的多种作用总结如下：\n  用户与系统分析人员在系统规划和系统分析阶段通过文档进行沟通。\n这里的文档主要包括：\n 可行性研究报告、 总体规划报告、 系统开发合同、 系统方案说明书。    系统开发人员与项目管理人员通过文档在项目期内进行沟通。\n这里的文档是指项目管理文件，主要有：\n  系统开发计划，\n包括：\n 工作任务分解表、 PERT图、 甘特图、 预算分配表；    系统开发月报；\n  系统开发总结报告。\n  有了这些文档可以：\n 不同阶段开发人员工作的顺利交接； 降低因为人员流动带来的风险。    系统测试人员与系统开发人员通过文档进行沟通。\n系统测试人员可以根据以下文档对系统开发人员所开发的系统进行测试：\n 系统方案说明书、 系统开发合同、 系统设计说明书、 测试计划。  系统测试人员再将评估结果撰写成系统测试报告。\n  系统开发人员与用户在系统运行期间进行沟通。\n用户通过系统开发人员撰写的文档运行系统。这里的文档主要是：\n 用户手册、 操作指南。    系统开发人员与系统维护人员通过文档进行沟通。\n这里的文档主要有：\n  系统设计说明书；\n  系统开发总结报告。\n开发总结报告还可分为以下3个文档：\n 研制报告； 技术报告； 技术手册：记录了系统开发过程中的各种主要技术细节。      用户与维修人员在运行维护期间进行沟通。\n用户在使用信息系统的过程中，将运行过程中的问题进行记载，形成：\n 系统运行报告、 维护修改建议。  系统维护人员根据以下文档对系统进行维护和升级：\n 维护修改建议； 系统开发人员留下的技术手册等文档。       人员 阶段 文档     用户\n系统分析人员 系统规划\n系统分析 沟通文档，主要是规划报告、合同、方案：\n可行性研究报告总体规划报告系统开发合同系统方案说明书   系统开发人员\n项目管理人员 项目期内 沟通文档（项目管理文件），主要是计划、报告类文档：\n系统开发计划工作任务分解表PERT图甘特图预算分配表系统开发月报系统开发总结报告   系统测试人员\n系统开发人员 测试 系统测试人员根据以下文档对系统进行测试：\n系统方案说明书系统开发合同系统设计说明书测试计划系统测试人员再将评估结果撰写成系统测试报告   系统开发人员\n用户 系统运行期间 用户通过系统开发人员撰写的文档运行系统：\n用户手册操作指南   系统开发人员\n系统维护人员 维护 沟通文档：系统设计说明书系统开发总结报告研制报告研制报告技术手册   用户\n维修人员 运维 用户将运行过程中的问题进行记载：系统运行报告维护修改建议系统维护人员根据以下文档对系统进行维护和升级：维护修改建议系统开发人员留下的技术手册等文档     结构化分析方法 数据流图 数据流图也称数据流程图（Data Flow Diagram，DFD），是一种便于用户理解、分析系统数据流程的图形工具。它摆脱了系统的物理内容，精确地在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。\n数据流图中的基本图形元素包括：\n  数据流（Data Flow）：由一组固定成分的数据组成，表示数据的流向。\n在DFD种，数据流的流向由以下几种：\n 从加工流向另一个加工； 从加工流向数据存储（写）； 从数据存储流向加工（读）； 从外部实体流向加工（输入）； 从加工流向外部实体（输出）。  即数据流的起点或终点必须至少有一个是加工。\n除了与数据存储有关的数据流（流向数据存储或从数据存储流出），DFD中的每个数据流都必须用一个定义明确的名字表示。\n  加工（Process）：加工描述了输入数据流到输出数据流之间的变换，也就是输入数据流经过什么处理后变成了输出数据流。\n每个加工都有一个名字和编号。\n一个加工可以有多个输入数据流和多个输出数据流，但至少有一个输入数据流和一个输出数据流。\n数据流图中常见的3种错误如下所示：\n  黑洞：加工只有输入，没有输出。\n如下图加工1。\n  白洞：加工只有输出但没有输入。\n如下图加工2。\n  灰洞：加工中输入数据不足以产生输出数据。\n有几种可能的原因：\n 一个错误的命名过程； 错误命名的输入或输出； 不完全的事实。  如下图加工3。\n    数据存储（Data Store）：存储和提供数据。\n每个数据存储都有一个定义明确的名字标识。\n数据存储可以：\n 存储加工的输出数据：数据流流入数据存储，表示数据的写入操作； 提供加工的输入数据：数据流从数据存储流出，表示数据的读操作。 双向箭头的数据流指向数据存储，表示对数据的修改。  DFD中的数据存储在具体实现时可以用以下方式实现：\n 文件系统实现； 数据库系统实现。  数据存储的存储介质可以是：\n 磁盘、 磁带、 其他存储介质。    外部实体（External Agent，外部主体）：指存在于软件系统之外的人员、组织、物体或外部系统，它指出系统所需数据的发源地（源）和系统所产生的数据的归宿地（宿）。\n例如：\n 人员：学生、老师、员工、主观、医生、客户…… 组织：供应商、采购部门…… 物体：传感器、控制器、单车、车辆…… 外部系统：支付系统、车辆交易系统、库存管理系统、道闸控制系统……  在许多系统中，某个源和某个宿可以是同一个人员、组织、物体或外部系统，此时，在DFD中可以用同一个符号表示：\n 当数据流从该符号流出时，表示它是源； 当数据流流向该符号时，表示它是宿； 当两者皆有时，表示它既是源又是宿。  外部实体表示存在于系统之外的对象，用来帮助用户理解系统数据的来源和去向。\n  其中，软件系统内部的数据处理模型：使用数据流、加工和数据存储构建。\n数据流图描述了系统的分解，但没有对图中各成分进行说明。\n   基本元素 图形表示     数据流    加工    数据存储    外部实体     数据流图必须确保：\n 数据流的起点或终点必须至少有一个是加工。 加工至少有一个输入数据流和一个输出数据流。  分层数据流图：\n  顶层图：描述系统的输入和输出。\n即描述系统从哪些外部实体接受数据流，以及系统发送数据流到哪些外部实体。\n 顶层图只有一个加工，即待开发的软件系统。 顶层图中的数据流就是系统的输入/输出信息。 顶层图中通常没有数据存储。    0层图：分解顶层图的加工。\n  再分解：将DFD中某些比较复杂的加工再次分解成一张DFD子图。\n  数据字典 数据字典（DD）是为数据流图中的以下成分做出说明：\n 数据流； 文件； 加工：对加工的描述称为“小说明”或“加工逻辑说明”； 组成数据流或文件的数据项。  数据字典有以下4类条目：\n  数据流条目：对DFD中数据流的定义，通常列出该数据流的各组成数据项。\n   符号 含义 举例及说明     $=$ 被定义为    $+$ 与 $x = a + b$：$x$由$a$和$b$组成   $[a|b]$ 或 $x = [a   $\\{a\\}$ 重复 $x = \\{a\\}$：$x$由任意个$a$组成   $m\\{a\\}n$\n或\n$\\big\\{ a \\big\\}^{n}_{m}$ 重复 $x=m\\{a\\}n$ 或 $x=\\big\\{a\\big\\}^{n}_{m}$：$x$中出现$m \\sim n$次$a$\n$n$：重复次数的上限$m$：重复次数的下限   $(a)$ 可选 $x = (a)$：$a$在$x$中出现$0$或$1$次   $\u0026ldquo;a\u0026rdquo;$ 基本数据元素 $x = \u0026ldquo;a\u0026rdquo;$：$x$是取值为字符$a$的数据元素   $m..n$ 连接符 $x = m..n$：$x$可取$m \\sim n$中的任意一个值      数据项条目：组成数据流和数据存储的最小元素，是不可再分解的数据单位。\n  数据存储条目：对DFD中数据存储的定义。\n  基本加工条目：用来说明DFD中（下层）基本加工的处理逻辑。\n  源点、终点不在系统之内，故一般不在字典中说明。\n 用户界面设计 用户界面（UI）设计在人与计算机之间搭建了一个有效的交流媒介。\n黄金原则 黄金原则一共有3条：\n 用户操纵控制 减少用户的记忆负担 保持界面一致  ","date":"2023-05-07T00:00:00Z","permalink":"https://blog.linner.asia/p/%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"结构化开发（软件设计师）"},{"content":"数据库体系结构 数据描述有两种形式：\n 逻辑描述：指程序员或用户用以操作的数据形式，是抽象的概念化数据。 物理描述：指数据在存储设备上的存储方式，物理数据是实际存放在存储设备上的数据。  三级模式结构 实际上有许多不同的数据库产品，但它们的体系结构基本上都具有相同的特征，采用“三级模式和两级映像”：\n三级结构有3类数据模型：\n 外模型：用户使用的数据视图，是一种局部的逻辑数据视图，表示用户所理解的实体、实体属性和实体关系。 概念模型：全局的逻辑数据视图，是数据库管理员所看到的实体、实体属性和实体之间的联系。 内模型：数据的物理存储模型。  三个物理模型分别对应数据库系统的3层结构：\n  外模式（子模式、用户模式）：数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。\n外模式用DBMS的外模式描述语言（外模式DDL)来定义。\n  概念模式（模式）：所有用户的公共数据视图，与具体的应用程序和应用程序开发工具无关。\n概念模式用DBMS的模式描述语言（模式DDL)来定义。\n  内模式（物理模式、存储模式）：是数据在数据库内部的表示方式。\n内模式由DBMS的内模式描述语言（内模式DDL)来描述，由设备介质语言来定义。\n定义所有的内部记录类型、索引和文件的组织方式。\n  两级模式映象 数据库系统在三级模式之间提供了两级映像：\n 模式——内模式映像存在于概念级和内部级之间，实现概念模式和内模式间的相互转换。 外模式——模式映像：存在于外部级和概念级之间，实现了外模式和概念模式之间的相互转换。  数据的独立性（指数据与程序独立）是由DBMS的二级映像功能来保证的。数据的独立性包括：\n  物理独立性：指当数据库的内模式发生改变时，数据的逻辑结构不变。\n物理独立性可以保证，当数据的物理结构改变时，应用程序不用改变。\n但是，为了保证应用程序能够正确执行，需要修改概念模式和内模式之间的映像。\n  逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。\n数据的逻辑结构发生变化后，用户程序也可以不修改。\n但是，为了保证应用程序能够正确执行，需要修改外模式和概念模式之间的映像。\n   数据模型 在数据库技术中，表示实体类型及实体类型间联系的模型称为数据模型。\n数据模型有以下类型：\n 概念数据模型：从信息世界中抽象的数据模型； 结构数据模型：从计算机世界中抽象出的DBMS支持的数据模型。  概念数据模型 概念数据模型用于信息世界建模，一般采用实体-联系方法（E-R方法）。概念数据模型的常用术语有：\n  实体：客观存在并可以相互区别的事物称为实体。\n如一个单位、一个职工、一个部门或一个项目等。\n  属性：描述实体的特性称为属性，一个实体可以由若干个属性来刻画。\n属性的具体取值称为属性值，用以表示一个具体实体。\n  码：唯一标识实体的属性集称为码。\n  域：属性的取值范围称为该属性的域。\n  实体型：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。\n例如，学生（学号，姓名，性别，班号）就是一个实体型。\n  实体集：同型实体的集合称为实体集。\n例如，全体学生就是一个实体集。\n  联系：实体（型）之间的对应关系称为联系。联系分为两种：\n 实体内部各属性之间的联系； 实体之间的联系。  两个实体型之间的联系有3种类型：\n 一对一联系(1:1)； 一对多联系(1:n)； 多对多联系(m:n)。    实体-联系方法表示的概念数据模型称为E-R图。E-R图是抽象和描述现实世界的有力工具：\n 实体型：用矩形表示，矩形框内写明实体名； 属性：用椭圆形表示，并用无向边将其与相应的实体连接起来； 联系：用菱形表示，菱形框内写明联系名，并用无向边将其分别与有关实体连接起来，同时在无向边旁标上联系的类型。  结构数据模型 结构数据模型是直接面向数据库的逻辑结构。这类模型涉及到计算机系统和数据库管理系统，所以称为结构数据模型。任何一个DBMS都以某个结构数据模型为基础，或者说支持某个结构数据模型。\n常用术语：\n  数据项：又称字段，是数据库中可以命名的最小逻辑数据单位。可以是一个数或个字符串，用它描述属性的数据。\n  记录：是数据项的有序集，即一个记录是由若干个数据项或字段组成，用它描述实体。\n一般来说，数据只有被组成记录的形式才有实际意义。\n  文件：文件是一个具有符号名的一组同类记录的集合。文件包含记录的结构和记录的值。\n  结构数据模型主要包括：层次、网状、关系和面向对象模型。\n关系模型是一种用二维表格结构快表示实体以及实体之间联系的数据模型。每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述。因此可以说，关系模型是由关系模式组成的集合。\n 目前大多数数据库管理系统都是关系型的。\n  关系模型 术语 有关关系模型的术语：\n  关系：一个关系就是一张二维表，每个关系有一个关系名\n  元组：表中的一行即为一个元组，对应存储文件中的一个记录值。\n  属性：表中的列称为属性，每一列有一个属性名。\n属性值相当于记录中的数据项或者字段值。\n  域：属性的取值范围。\n  关系模式：对关系的描述称为关系模式，由关系名和其属性集合构成，关系模式的格式为：关系名（属性名1，属性名2，…，属性名n）\n  候选码（候选健）：属性或属性组合其值能够唯一地标识一个元组。\n  主码（主键）：在一个关系中可能有多个候选码，从中选择一个作为主码。\n  主属性：所有候选键都称为主属性，其他的属性都称为非码属性。\n  外码（或外键）：如果一个关系中的属性或属性组并非该关系（二维表）的码，但它们是另外一个关系（二维表）的码，则称其为该关系的外码。\n  全码：关系模式的所有属性组是这个关系模式的候选码，称为全码。\n  超码（超键）：一个包含码的属性集称为超码。\n例如学号是码，则（学号，姓名）就是一个超码。\n  完整性约束 完整性规则保证用户对数据库做修改时不会破坏数据的一致性。\n  实体完整性（Entity Integrity，引用完整性）：规定基本关系R的主属性A不能取空值。\n即主属性不能为空。\n  参照完整性（Referential Integrity）：若F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值可以取：\n 空值（F的每个属性值均为空值）； S中某个元组的主码值。  即实体之间的关联可以变现为：关系R用外码F与关系S关联，外码F的值可以为空也可以为关系S中某个元组（记录）的主码值。\n  用户定义完整性（User Defined Integrity）：针对某一具体的关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求，由应用的环境决定。\n例如，银行的用户账户规定必须大于等于100000、小于999999。\n  关系代数运算符 关系操作的特点是操作对象和操作结果都是集合，而非关系数据模型的数据操作方式则为一次一个记录的方式。\n关系数据语言分为三类：\n 关系代数语言； 关系演算语言； 具有关系代数和关系演算双重特点的语言。  关系演算语言包含：\n 元组关系演算语言； 域关系演算语言。  关系代数运算符有4类：\n基本关系代数运算是对两个具有相同的关系模式的关系进行运算。关系$R$与$S$具有相同的关系模式，即$R$与$S$的元数相同（结构相同）。\n基本关系代数运算包含：\n  并（Union）：关系$R$与$S$的并是由属于$R$或属于$S$的元组构成的集合，记作$R \\cup S$，其形式定义如下：\n$$ R \\cup S = \\{ t | (t \\in R) \\vee (t \\in S) \\} $$\n 式中$t$为元组变量。\n   差（Difference）：关系$R$与$S$的差是由属于$R$但不属于$S$的元组构成的集合，记作$R-S$，其形式定义如下：\n$$ R-S = \\{ t| (t \\in R) \\wedge (t \\not\\in S) \\} $$\n  交（Intersection）：关系$R$与$S$的交是由属于$R$同时又属于$S$的元组构成的集合，记作$R \\cap S$,其形式定义如下：\n$$ R \\cap S = \\{ t| (t \\in R) \\wedge (t \\in S) \\} $$\n $R \\cap S = R-(R-S)$，或者$R \\cap S = S-(S-R)$。\n   扩展的关系代数运算可以从基本的关系运算中导出，包括：\n  广义笛卡儿积（Extended Cartesian Product）：两个元组分别为$n$目和$m$目的关系$R$和$S$的广义笛卡儿积是一个$(n+m)$列的元组的集合。\n元组的前$n$列是关系$R$的一个元组，后$m$列是关系$S$的一个元组，记作$R \\times S$，其形式定义如下：\n$$ R \\times S = \\{ t| (t \\ = \\ \u0026lt;t^n, t^m\u0026gt;) \\wedge (t^n \\in R) \\wedge (t^m \\in S) \\} $$\n如果$R$和$S$中有相同的属性名，可在属性名前加关系名作为限定，以示区别。若$R$有$K_1$,个元组，$S$有$K_2$个元组，则$R$和$S$的广义笛卡儿积有$K_1 \\times K2$个元组。\n $\u0026lt;t^n, t^m\u0026gt;$是一个元组$t^n$和$t^m$拼接成的一个元组。\n   投影（Projection）：投影运算是从关系的垂直方向进行运算，在关系$R$中选出若干属性列$A$组成新的关系，记作$\\pi_A (R)$，其形式定义如下：\n$$ \\pi_A (R) = \\{ t[A]|t \\in R \\} $$\n  选择（Selection）：选择运算是从关系的水平方向进行运算，是从关系$R$中选择满足给定条件的诸元组，记作$\\sigma_F (R)$其形式定义如下：\n$$ \\sigma_A (R) = \\{ t| (t \\in R) \\wedge F(t) = True \\} $$\n其中，$F(t)$中的运算对象可以是：\n 属性名（或列的序号）； 常数； 运算符； 算术比较符（$\u0026lt;, \\le, \u0026gt;, \\ge, \\neq$）； 逻辑运算符（$\\wedge, \\vee, \\neg$）。    连接（Join）：连接运算是从两个关系$R$和$S$的笛卡儿积中选取满足条件的元组。\n 可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。\n   $\\theta$连接：从$R$与$S$的笛卡儿积中选取属性间满足一定条件的元组。记作：\n$$ R \\mathop{\\Join}\\limits_{X \\theta Y} S = \\{ t| (t=\u0026lt;t^n,t^m\u0026gt;) \\wedge (t^n \\in R) \\wedge (t^m \\in S) \\wedge (t^n[X] \\ \\theta \\ t^m[Y]) \\} $$\n其中：\n $X \\theta Y$：连接的条件； $\\theta$：比较运算符； $X$和$Y$分别为$R$和$S$上度数相等且可比的属性组； $t^n\\left[ X \\right]$表示$R$中$t^n$元组的对应于属性$X$的一个分量； $t^m[Y]$表示$S$中$t^m$元组的对应于属性$Y$的一个分量。  $\\theta$连接也可以表示为：\n$$ R \\mathop{\\Join}\\limits_{i \\theta j} S = \\{ t| (t=\u0026lt;t^n,t^m\u0026gt;) \\wedge (t^n \\in R) \\wedge (t^m \\in S) \\wedge (t^n[i] \\ \\theta \\ t^m[j]) \\} $$\n其中，\n  $i=1,2,3,\\cdots,n$；\n  $j=1,2,3,\\cdots,m$；\n  $i \\theta j$：\n从两个关系$R$和$S$中选取$R$的第$i$列和$S$的第$j$列之间满足$\\theta$运算的元组进行连接。\n  $\\theta$连接可以由基本的关系运算笛卡儿积和选取运算导出。因此，$\\theta$连接可表示为：\n$$ R \\mathop{\\Join}\\limits_{X \\theta Y} S = \\sigma_{X \\theta Y}(R \\times S) $$\n或：\n$$ R \\mathop{\\Join}\\limits_{i \\theta j} S = \\sigma_{i \\theta j}(R \\times S) $$\n  等值连接：当$\\theta$为“=”时，称之为等值连接，记为$R \\mathop{\\Join}\\limits_{i = j} S$，其形式定义如下：\n$$ R \\mathop{\\Join}\\limits_{i = j} S = \\{ t| (t=\u0026lt;t^n,t^m\u0026gt;) \\wedge (t^n \\in R) \\wedge (t^m \\in S) \\wedge (t^n[i] = t^m[j]) \\} $$\n  $F$连接：从关系$R$和$S$的笛卡尔积中选取属性值满足某一公式$F$的元组，记为$\\mathop{\\Join}\\limits_{F}$。\n$F$是形为$F_1 \\wedge F_2 \\wedge \\cdots \\wedge F_n$的公式，每个$F_p$是形为$i \\theta j$的式子。\n  自然连接：自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果集中将重复属性列去掉。\n若：\n  $t^n \\in R$，$t^m \\in S$；\n  $R$和$S$具有相同的属性组$B$，且$B=(B_1,B_2,,B_k)$；\n  假定$R$关系的属性：\n$$ A_1,A_2,\\cdots,A_{n-k},B_1,B_2,\\cdots,B_k $$\n  $S$关系的属性：\n$$ B_1,B2,\\cdots,B_k,B_{k+1},B_{k+2},\\cdots,B_m $$\n  自然连接可以记为$R \\Join S$,其形式定义如下：\n$$ R \\Join S = \\{ t| (t = \u0026lt;t^n, t^m\u0026gt;) \\wedge (t^n \\in R) \\wedge (t^m \\in S) \\wedge (R.B_1 = S.B_1) \\wedge (R.B_2 = S.B_2) \\wedge \\cdots \\wedge (R.B_k = S.B_k) \\} $$\n 一般连接是从关系的水平方向运算，而自然连接不仅要从关系的水平方向运算，而且要从关系的垂直方向运算（去掉重复属性）。\n     外连接（Outer Jion）：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。\n外连接运算有3种：\n  左外连接（Left Outer Jion，⟕）：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值$null$充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。\n  右外连接（Right Outer Jion，⟖）：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值$null$填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。\n  全外连接（Full Outer Jion，⟗）。完成左外连接和右外连接的操作。即填充左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，将产生的新元组加入自然连接的结果中。\n    除（Division）：给定关系$R(X,Y)$和$S(Y,Z)$，$X、Y、Z$为属性组。$R \\div S$应当满足元组在$X$上的分量值$x$的象集$Y_x$包含关系$S$在属性组$Y$上投影的集合。其形式定义如下：\n$$ R \\div S = \\{ t^n[X] | (t^n \\in R) \\wedge (\\pi_y (S) \\subseteq Y_x) \\} $$\n其中，$Y_x$为$x$在$R$中的象集，$x=t^n[X]$，且$R \\div S$的结果集的属性组为$X$。\n 除运算是同时从关系的水平方向和垂直方向进行运算。\n    SQL 语句 SQL（Structured Query Language，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进行各种操作。\n 标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSISQL。\n查看更多 SQL语句 相关内容。\n 分类   DDL（Data Definition Language，数据定义语言）：用来定义数据库对象：数据库，表，列等。\n关键字：CREATE、DROP、ALTER 等。\n  DML（Data Manipulation Language，数据操作语言）：用来对数据库中表的数据进行增删改。\n关键字：INSERT、DELETE、UPDATE 等。\n  DQL（Data Query Language，数据查询语言）：用来查询数据库中表的记录。\n关键字：SELECT等。\n  DCL（Data Control Language，数据控制语言）：用来定义数据库的访问权限和安全级别，及创建用户。\n  数据定义语言（DDL） CREATE——创建：\n  建立数据库：\nCREATE DATABASE 数据库名;   建立基本表：\nCREATE TABLE tab_name ( 列名 数据类型 [列级完整性约束条件], ... 表级完整性约束条件, ... ); 完整性约束有3种子句：\n PRIMARY KEY：主键约束； CHECK：检查约束； FOREIGN KEY：外键约束； NOT NULL：非空约束； UNIQUE：唯一约束； DEFAULT：默认约束。  定义列时使用的基本数据类型如下：\n NTEGER：整数（也可写成INT）。 FLOAT(n)：浮点数，精度至少为n位数字。 NUMERIC(p,d)：定点数，由p位数字（不包括符号、小数点）组成，小数点后面有d位数字（也可写成DECIMAL(p,d)或DEC(p,d)）。 CHAR(n)：长度为n的定长字符串。 DATETIME：日期时间型。    ALTER TABLE——修改表结构：\n  增加新列：\nALTER TABLE 表名 ADD 列名 类型   修改列的定义：\nALTER TABLE 表名 ALTER COLUMN 列名 新类型   删除列：\nALTER TABLE 表名 DROP COLUMN 列名   DROP TABLE——删除基本表：\nDROP TABLE 表名 数据操纵语言（DML） INSERT INTO——插入：\n  直接插入元组值：\nINSERT INTO 表名（列名序列）VALUES (元组值) 或者：\nINSERT INTO 表名 (列名 序列) (TABLE (元组值), (元组值), ...)   插入一个查询的结果值：\nINSERT INTO 表名 (列名序列) SELECT 查询语句   DELETE FROM——删除：\nDELETE FROM 表名 [WHERE 条件表达式] UPDATE——修改：\nUPDATE 表名 SET 列名=值表达式[, 列名=值表达式...] [WHERE条件表达式] 数据查询语言（DQL） SELECT——查询：\nSELECT 目标表的列名或列表达式序列 FROM 关系名表序列 [WHERE 行条件表达式] [GROUP BY 列名序列 [HAVING 组条件表达式]] [ORDER BY 列名[ASC|DESC]...] WHERE 条件查询 SELECT 目标表的列名或列表达式序列 FROM 关系名表序列 WHERE 行条件表达式 运算符：\n   运算符 说明 运算符 说明     = 等于 \u0026gt; 大于   \u0026lt;\u0026gt; 或 != 不等于 \u0026gt;= 大于等于   \u0026lt; 小于 !\u0026gt; 不大于   \u0026lt;= 小于等于 BETWEEN 范围在指定的两个值之间   !\u0026lt; 不小于 IS NULL 为 NULL 的值   IS NOT NULL 不为 NULL 的值 AND 逻辑与   OR 逻辑或 NOT逻辑非    IN 匹配包含在集合中的值 NOT IN 指定不包含在集合中的值   LIKE 字符模糊配对      LIKE字符模糊配对包含以下通配符：\nSELECT 目标表的列名或列表达式序列 FROM 关系名表序列 WHRER 列名 LIKE \u0026#39;_ABC%\u0026#39;;  %：表示任何字符出现任意次数。 _：表示匹配单个任意字符。  ORDER BY 排序数据 ORDER BY可以指定多个列来排序，排序规则有：\n   关键字 规则说明     ASC 升序排序   DESC 降序排序    SELECT 目标表的列名或列表达式序列 FROM 关系名表序列 [...] [ORDER BY 列名 [ASC|DESC] ...]  ORDER BY子句必须是SELECT命令中的最后一个子句。\n GROUP BY 分组数据 SELECT 目标表的列名或列表达式序列 FROM 关系名表序列 [GROUP BY 列名序列 [HAVING 组条件表达式]]  HAVING是GROUP BY的分组条件控制语句。 HAVING的操作符和WHERE相同。 被WHERE过滤掉的记录并不会出现在分组中。  聚合函数 聚合函数实现数据统计等功能。\n函数名|功能 AVG|计算一个数值型表达式的平均值 COUNT|计算指定表达式中选择的项数，COUNT(*)统计查询输出的行数 MIN|计算指定表达式中的最小值 MAX|计算指定表达式中的最大值 SUM|计算指定表达式中的数值总和 STDEV|计算指定表达式中所有数据的标准差 STDEVP|计算总体标准差\nSELECT 目标表的列名或列表达式序列 FROM 关系名表序列 WHERE 使用了聚合函数的条件判断 [ ... ] 或：\nSELECT 聚合函数 FROM 关系名表序列  聚合函数可以使用算数运算符。\n聚合函数常与GROUP BY子句一起使用。\n 连接    连接符号 说明     INNER JOIN 内连接（默认）。\n内连接又包括等值连接、非等值连接和自连接。   OUTER JOIN 外连接。\n又包括：\nLEFT OUTER JOIN（左外连接）；\nRIGHT OUTER JOIN（右外连接）；\nFULL OUTER JOIN（全外连接）    子查询 子查询是指将SELECT作为其它语句的子句使用。例如在WHERE、FROM中使用SELECT。\n数据控制语言（DCL） 数据控制控制的是用户对数据的存储访问权力，是由DBA决定的。但是，某个用户对某类数据具有何种权利，是个政策问题而不是技术问题。\n授权语句格式（GRANT）：\nGRANT \u0026lt;权限\u0026gt;[, \u0026lt;权限\u0026gt;] ... [ON \u0026lt;对象类型\u0026gt; \u0026lt;对象名\u0026gt;] TO\u0026lt;用户\u0026gt;[, \u0026lt;用户\u0026gt;]... [WITH GRANT OPTION]; 不同类型的操作对象有不同的操作权限，常见的操作权限如下：\n   对象 对象类型 操作权限     属性列 TABLE SELECT、\nINSERT、\nUPDATE、\nDELETE、\nALL PRIVILEGES   视图 TABLE SELECT、\nINSERT、\nUPDATE、\nDELETE、\nALL PRIVILEGES   基本表 TABLE SELECT、\nINSERT、\nUPDATE、\nDELETE、\nALTER、\nINDEX、\nALL PRIVILEGES   数据库 DATABASE CREATETAB     建立表的权限，可由DBA授予普通用户； WITH GRANT OPTION：表示获得了这些权限的用户还可以将权限赋给其他用户。  收回权限语句格式（REVOKE）：\nREVOKE \u0026lt;权限\u0026gt;[, \u0026lt;权限\u0026gt;]... [ON \u0026lt;对象类型\u0026gt; \u0026lt;对象名\u0026gt;] FROM \u0026lt;用户\u0026gt;[, \u0026lt;用户\u0026gt;]; 视图 视图是从一个或者多个基本表或视图中导出的虚拟表。\n创建视图：\nCREATE VIEW 视图名 (列表名) AS SELECT 查询子句 [WITH CHECK OPTION];  子查询可以是任意复杂的SELECT语句，但通常不允许含有ORDER BY子句和DISTINCT短语。 WITH CHECK OPTION：表示对UPDATE、INSERT、DELETE操作时保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。 组成视图的属性列名或者全部省略或者全部指定。如果省略属性列名，则隐含该视图由SELECT子查询目标列的主属性组成。 对视图进行的增改操作实际上是对基本表进行操作。  删除视图：\nDROP VIEW 视图名; 索引 数据库中的索引是某个表中一列或者若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。\n索引分为：\n 聚集索引：指索引表中索引项的顺序与表中记录的物理顺序一致的索引； 非聚集索引。   对数据库表创建和删除索引，修改的是数据库的内模式。\n  关系数据库的规范化 关系模式 一个关系模式应当是一个五元组（含关系名）：$R\u0026lt;U,D,dom,F\u0026gt;$。\n其中：\n $R$：关系名，是符号化的元祖语义； $U$：一组属性名； $D$：属性组$U$中的属性来自域$D$； $dom$：属性到域的映射； $F$：属性组$U$上的一组数据依赖（函数依赖）。  $D$和$dom$对模式设计关系不大，通常将关系模式看作是一个三元组：$R\u0026lt;U,F\u0026gt;$。\n当且仅当$U$上的一个关系$r$满足$F$时，称$r$为关系模式$R\u0026lt;U,F\u0026gt;$的一个关系。\n函数依赖 数据依赖是通过一个关系中属性间值的相等与否体现出来的数据间的相互关系。\n  函数依赖：设$R(U)$是属性集U上的关系模式，$X$、$Y$是$U$的子集。若对$R(U)$的任何一个可能的关系$r$，$r$中不可能存在两个元组在$X$上的属性值相等，而在$Y$上的属性值不等（即，在关系$r$中，元组在$X$上的属性值相等，那么在$Y$上的属性值也相等），则称X函数决定Y或Y函数依赖于X，记作$X \\rightarrow Y$。\n如，学生表中，$学号 \\rightarrow 姓名$。\n属性之间有3种关系，但并不是每一种都存在函数依赖。如果$X$和$Y$之间的对应关系是：\n $1-1$：存在函数依赖$X \\rightarrow Y$和$Y \\rightarrow Y$； $n:1$：存在函数依赖$X \\rightarrow Y$； $n:m$：不存在函数依赖。    非平凡的函数依赖：$X \\rightarrow Y$，但$Y \\not\\subseteq X$，则称$X \\rightarrow Y$是非平凡的函数依赖。\n例如，$姓名 \\not\\subseteq 学号$，则$学号 \\rightarrow 姓名$是一个非平凡的函数依赖。\n  平凡的函数依赖：如果$X \\rightarrow Y$，但$Y \\subseteq X$，则称$X \\rightarrow Y$是平凡的函数依赖。\n例如，$学号 \\subset (学号,课程号)$，则$(学号,课程号) \\rightarrow 学号$是一个平凡的函数依赖。\n  完全函数依赖：在R(U)中，如果$X \\rightarrow Y$，并且对于X的任何一个真子集$X'$都有**$X'$不能决定$Y$**，则称$Y$对$X$完全函数依赖，记作$X \\stackrel{f}{\\longrightarrow} Y$。\n即需要由$X$的所有属性才能决定$Y$的，才能称为完全函数依赖。\n如，$(学号,课程号) \\rightarrow 成绩$。\n如果$X$仅包含一个属性，那么此时必为完全函数依赖。\n  部分函数依赖：如果$X \\rightarrow Y$，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作$X \\stackrel{P}{\\longrightarrow} Y$。部分函数依赖也称为局部函数依赖。\n如，（学号，班级代号） $\\rightarrow$ 姓名，因为学号 $\\rightarrow$ 姓名，所以（学号，班级代号） $\\stackrel{P}{\\longrightarrow}$ 姓名。\n  传递依赖：在$R(U,F)$中（F是U上的一组函数依赖），如果$X \\rightarrow Y,\\ Y \\not\\subseteq X,\\ Y \\rightarrow Z$，则称Z对X传递依赖（$X \\rightarrow Z$）。\n即$X \\stackrel{f}{\\longrightarrow} Y$，且$Y \\rightarrow Z$，则$X \\rightarrow Z$。\n  码：设$K$为$R(U,F)$中属性的组合，若$K \\rightarrow U$，且对于$K$的任何一个真子集$K'$都有$K'$不能决定$U$，则$K$为$R$的候选码。\n即$K \\stackrel{f}{\\rightarrow} U$，那么K是R的候选码。\n若有多个候选码，则选一个作为主码（主键，主关键字）。候选码通常也称为候选关键字（候选键，键）。\n  主属性和非主属性：包含在任何一个候选码中的属性称为主属性，否则称为非主属性。\n  外码：若$R(U)$中的属性或属性组$X$非$R$的码，但$X$是另一个关系的码，则称$X$为外码。\n  函数依赖的公理系统（Armstrong公理系统）：\n设关系模式$R(U,F)$，其中$U$为属性集，$F是$U$上的一组函数依赖，那么有以下推理规则：\n  自反律（A1）：若$Y \\subseteq X \\subseteq U$，则$X \\rightarrow Y$为$F$所蕴涵（蕴含）。\n如，（学号，姓名） $\\rightarrow$ 姓名是函数依赖所蕴涵的。\n  增广律（A2）：若$X \\rightarrow Y$为F所蕴涵，且$Z \\subseteq U$,则$XZ \\rightarrow YZ$为$F$所蕴涵。\n如，学号 $\\rightarrow$ 姓名，班级 $\\subseteq$ 学生表，那么（学号，班级） $\\rightarrow$ （姓名，班级）是函数依赖所蕴涵的。\n  传递律（A3）：若$X \\rightarrow Y,\\ Y \\rightarrow Z$为$F$所蕴涵，则$X \\rightarrow Z$为$F$所蕴涵。\n  根据上述3条推理规则又可推出下述3条推理规则：\n 合并规则：若$X \\rightarrow Y,\\ X \\rightarrow Z$，则$X \\rightarrow YZ$为F所蕴涵。 伪传递律：若$X \\rightarrow Y,\\ WY \\rightarrow Z$，则$XW \\rightarrow Z$为F所蕴涵。 分解规则：若$X \\rightarrow Y,\\ Z \\subseteq Y$，则$X \\rightarrow Z$为F所蕴涵。   合并规则和分解规则是两个互逆的规则。即$X \\rightarrow Y,\\ X \\rightarrow Z$，可得$X \\rightarrow YZ$；那么$X \\rightarrow YZ$，也可得$X \\rightarrow Y,\\ X \\rightarrow Z$（因为$Y,Z \\sub YZ$）。\n 总结：\n   名称 条件 结论     函数依赖 元组在$X$上的属性值相等，那么在$Y$上的属性值也相等 $X$函数决定$Y$或$Y$函数依赖于$X$，记作$X \\rightarrow Y$   非平凡的函数依赖 $X \\rightarrow Y$，$Y \\not\\subseteq X$ $X \\rightarrow Y$是非平凡的函数依赖   平凡的函数依赖 $X \\rightarrow Y$，$Y \\subseteq X$ $X \\rightarrow Y$是平凡的函数依赖   完全函数依赖 $X \\rightarrow Y$，$X' \\subset X$，$X' \\not\\rightarrow Y$ $Y$对$X$完全函数依赖，记作$X \\stackrel{f}{\\longrightarrow} Y$   部分函数依赖（局部函数依赖） $X \\rightarrow Y$，$X \\stackrel{f}{\\not\\longrightarrow} Y$ $Y$对$X$部分函数依赖，记作$X \\stackrel{P}{\\longrightarrow} Y$   传递依赖 $X \\rightarrow Y$，$Y \\not\\subseteq X$，$Y \\rightarrow Z$ $Z$对$X$传递依赖       名称 定义     码（候选码，候选关键字） 若$K \\stackrel{f}{\\rightarrow} U$，则$K$为$R$的候选码   主属性 包含在任何一个候选码中的属性   非主属性 不包含在任何一个候选码中的属性   外码 $X$非$R$的码，但$X$是另一个关系的码，则称$X$为外码    Armstrong公理系统：\n   定律 条件 F蕴含     自反律 $Y \\subseteq X \\subseteq U$ $X \\rightarrow Y$   增广律 $X \\rightarrow Y$，$Z \\subseteq U$ $XZ \\rightarrow XZ$   传递律 $X \\rightarrow Y,\\ Y \\rightarrow Z$ $X \\rightarrow Z$       规则 条件 F蕴含     合并规则 $X \\rightarrow Y,\\ X \\rightarrow Z$ $X \\rightarrow YZ$   伪传递律 $X \\rightarrow Y,\\ WY \\rightarrow Z$ $XW \\rightarrow Z$   分解规则 $X \\rightarrow Y,\\ Z \\subseteq Y$ $X \\rightarrow Z$    闭包计算 设关系模式$R\u0026lt;U,F\u0026gt;$，其中$U$为属性集，$F$是$U$上的一组函数依赖。称所有用Armstrong公理从F推出的函数依赖$X \\rightarrow A_i$中，$A_i(X,A_i \\subseteq U)$的属性集合为$X$的属性闭包，记为$X^{+}_{F}$或$X^{+}$。\n定理：\n设关系模式$R\u0026lt;U,F\u0026gt;$，其中$F$为函数依赖集，$X,Y \\subseteq U$，则从$F$推出$X \\rightarrow Y$的充要条件是$Y \\subseteq X^{+}$。\n 属性的闭包计算用于求主键。\n 例如，给定关系$R(U,F)$，其中$U={A,B,C,D,E,H}$，$F={A \\rightarrow B, B \\rightarrow DH, A \\rightarrow H, C \\rightarrow E }$。\n先根据$F$选取仅在$\\rightarrow$左边出现的属性集（例如，$A$、$C$和$AC$）。根据选取的属性集进行闭包运算（先对$A$进行运算）：\n$$ (A)^{+} \\rightarrow (A \\ BH)^{+} \\rightarrow (AB \\ D \\ H)^{+} \\rightarrow (ABDH) $$\n此时，$(ABDH)^{+}$无论再怎么推，结果都是$(ABDH)$，说明对$A$的闭包计算已经结束了，结果就是$(ABDH)$。\n而$(ABDH) \\neq U$，说明$A$并不是关系$R$的主键。\n而对于$C$的函数依赖仅有$C \\rightarrow E$，所以此时应该对$(AC)$进行闭包运算：\n$$ (AC)^{+} \\rightarrow (ABDH \\ CE)^{+} \\rightarrow (ABCDEH) $$\n此时对$(AC)$的闭包计算结果$(ABCDEH) = U$，说明$(AC)$是关系$R$的主键。\n关系模式的分解 对存在数据冗余、插入异常、删除异常问题的关系模式，应采取将一个关系模式分解为多个关系模式的方法进行处理（原来存储在一个二维表内的数据就要分散到多个二维表中）。要求是分解后的二维表不能丢失分解前二维表的信息。\n为使分解后的模式保持原模式所满足的特性，其基本要求是模式分解具有：\n 无损连接性； 保持函数依赖性。  无损连接 无损连接性指的是对关系模式分解时，原关系模式下，任一合法的关系实例，在分解之后应能通过自然连接运算恢复起来。\n设$\\rho = \\{ R_1\u0026lt;U_1,F_1\u0026gt;,\\ R_2\u0026lt;U_2,F_2\u0026gt;,\\ \\cdots,\\ R_k\u0026lt;U_k,F_k\u0026gt; \\}$是关系模式$R\u0026lt;U,F\u0026gt;$的一个分解，如果对于$R$的任一满足$F$的关系$r$都有：\n$$ r = \\pi_{R1}(r) \\Join \\pi_{R2}(r) \\Join \\cdots \\Join \\pi_{Rk}(r) $$\n则称这个分解$\\rho$是满足依赖集$F$的无损连接。\n   $\\pi()$运算是投影运算。\n例如$\\pi_{R1}(r)$，表示关系$r$在$R_1$上的投影。    $\\Join$运算是自然连接运算。\n  个人理解：\n无损连接性就是指，关系模式拆分后（分成若干个小的关系模式，即$\\rho$），$\\rho$中的关系模式从总体上看，保持着与$R$一致的连接。$\\rho$中的关系模式通过自然连接保持着原本的关系模式。重要的是$rho$中的关系模式可以通过自然连接恢复到原关系模式。\n 验证无损连接的充要条件：\n如果$R$的分解为$\\rho = \\{R_1,R_2\\}$，$F$为$R$所满足的函数依赖集合，则分解$\\rho$具有无损连接性的充分必要条件为：\n$$ R_1 \\cap R_2 \\rightarrow (R_1 - R_2) \\\\ 或 \\\\ R_1 \\cap R_2 \\rightarrow (R_2 - R_1) $$\n无损连接的判定算法：\n  构造一个$k$行$n$列的表：\n 每一列对应一个属性$A_j$； 每一行对应分解$rho$中的一个关系模式$R_i\u0026lt;U_i, F_i\u0026gt;$。  若属性$A_j$属于$U_i$，则在第$i$行第$j$列上放符号$a_j$，否则放符号$b_{ij}$。\n  逐个检查$F$中的每一个函数依赖$FD_i$，并修改表中的元素：\n取$F$中一个函数依赖$X_i \\rightarrow A_j$（$X_i$要属于$rho$中的任一关系），考虑这些行中第$j$列元素：\n 若其中有$a_j$，则全部改为$a_j$； 否则全部改为$b_{mj}$，$m$为这些行的行号最小值。  若某一行变成了$(a_1, a_2, \\cdots, a_n)$，则分解$rho$具有无损连接性，算法终止。\n  比较扫描前后，表有无变化。\n 如有变化，则返回第2步； 否则算法终止，分解$rho$是有损连接。    例如，关系模式$R\u0026lt;U,F\u0026gt;$，其中，$U = \\{ A, B, C \\}$，$F = \\{ A \\rightarrow B, C \\rightarrow B \\}$。\n判断$\\rho = \\{ AC, BC \\}$是否具有无损连接性：\n  构造初始表：\n   $R_i$ $A$ $B$ $C$     AC $a_1$ $b_{12}$ $a_3   BC $b_{21}$ $a_2$ $a_3$      考察$A \\rightarrow B$，将$AC$行的$B$列改为$a_2$：\n   $R_i$ $A$ $B$ $C$     AC $a_1$ $a_2$ $a_3   BC $b_{21}$ $a_2$ $a_3$      从上表中看出$AC$行为${a_1, a_2, a_3}$，所以判断该关系模式具有无损连接性。\n  保持函数依赖 设有关系模式$R$，$F$是$R$的函数依赖集，$Z$是$R$的一个属性集合，则称$Z$所涉及到的$F^+$中所有函数依赖为$F$在$Z$上的投影，即为$\\pi_Z(F)$，有：\n$$ \\pi_Z(F) = \\{ x \\rightarrow y | (x \\rightarrow y) \\in F^+ 且 xy \\subseteq z \\} $$\n设关系模式$R$的一个分解$\\rho = \\{ R_1\u0026lt;U_1,F_1\u0026gt;,\\ R_2\u0026lt;U_2,F_2\u0026gt;,\\ \\cdots,\\ R_k\u0026lt;U_k,F_k\u0026gt; \\}$，$F$是$R$的依赖集，如果$F$等价于$\\pi_{R1}(F) \\cup \\pi_{R2}(F) \\cup \\cdots \\cup \\pi_{Rk}(F)$，则称分解$\\rho$具有依赖保持性。\n 该定义中的\u0026quot;等价\u0026quot;并不代表相等，而是$F$中所包含的函数依赖在分解的函数依赖中也被包含，或者在分解的函数依赖中能被推出。\n  一个无损连接分解不一定具有依赖保持性； 一个依赖保持性分解不一定具有无损连接性。  范式 关系数据库中的关系必须满足一定的规范化要求，对于不同的规范化程度可用范式来衡量。\n范式是符合某一种级别的关系模式的集合，是衡量关系模式规范化程度的标准，达到范式的关系才是规范化的。\n一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化。\n主要有6种范式，高一级范式是在低一级范式的基础上进一步满足一些要求，按要求从低到高分为：\n  第一范式（1NF）：若关系模式R的每一个分量是不可再分的数据项，则关系模式R属于第一范式。\n如，关系模式$R\u0026lt;U,F\u0026gt;$：\n$$ U = \\{ 学号,姓名,学院,院长,课程号,课程名,成绩 \\} \\\\ F = \\{ 学号 \\rightarrow 姓名,学号 \\rightarrow 学院,学院 \\rightarrow 院长,课程号 \\rightarrow 课程名,(学号,课程号) \\rightarrow 成绩 \\} $$\n1NF可能存在的问题：\n  数据冗余：数据的冗余度大，R中可能出现多个元组在多个属性集中值相同；\n  修改异常：引起修改操作的不一致性，修改一条记录可能需要修改其他多条记录才能保持数据一致性（由数据冗余引起）；\n  插入异常：主码不能取空值或部分空值，会出现插入异常；\n  删除异常：本该删除但又客观存在的元组，会出现删除异常。\n即，删除掉的数据可能包含着其他本不该被删除的属性。\n  问题的原因是1NF中可能存在部分函数依赖。\n  第二范式（2NF）：若关系模式$R \\in 1NF$，且每一个非主属性完全依赖于码，则关系模式$R \\in 2NF$。\n即当1NF消除了对主键的部分函数依赖后就能满足2NF。\n例如，$学号 \\rightarrow 学院$，即$(学号,课程号) \\stackrel{P}{\\rightarrow} 学院$（部分依赖于码），所以$R \\not\\in 2NF$。\n模式的分解需要保持函数依赖。根据$F$，将$R$分解为：\n  $R_1\u0026lt;U_1,F_1\u0026gt;$：\n$$ U_1 = \\{ 学号,姓名,学院,院长 \\} \\\\ F_1 = \\{ 学号 \\rightarrow 姓名,学号 \\rightarrow 学院,学院 \\rightarrow 院长 \\} $$\n  $R_2\u0026lt;U_2,F_2\u0026gt;$：\n$$ U_2 = \\{ 课程号,课程名 \\} \\\\ F_2 = \\{ 课程号 \\rightarrow 课程名 \\} $$\n  $R_3\u0026lt;U_3,F_3\u0026gt;$：\n$$ U_3 = \\{ 学号,课程号,成绩 \\} \\\\ F_3 = \\{ (学号,课程号) \\rightarrow 成绩 \\}\n  则，$R1 \\in 2NF$，$R2 \\in 2NF$，$R3 \\in 2NF$。\n 2NF可能依然会存在数据冗余、修改异常、插入异常删除异常等问题。\n   第三范式（3NF）：若关系模式$R(R \\in 2NF)$中任何一个非主属性都不传递函数依赖于码。\n若关系模式$R\u0026lt;U,F\u0026gt;$（$U$为关系集，$F$为函数依赖集）中不存在这样的码$X$，使得：\n $X \\rightarrow Y(Y \\not\\rightarrow X)$， $Y \\rightarrow Z$，  则关系模式$R \\in 3NF$，其中：\n $Y$为属性组， $Z(Z \\not\\subseteq Y)$为非主属性。  即当2NF消除了非主属性对主键的传递函数依赖，则称为3NF。\n如，$R_1$中有$学号 \\rightarrow 学院$，$学院 \\rightarrow 院长$（非主属性\u0026quot;院长\u0026quot;传递依赖于主键\u0026quot;学号\u0026quot;）。可将$R_1$分解为：\n  $R_{11}\u0026lt;U_{11},F_{11}\u0026gt;$：\n$$ U_{11} = \\{ 学号,姓名,学院 \\} \\\\ F_{11} = \\{ 学号 \\rightarrow 姓名, 学号 \\rightarrow 学院 \\} $$\n  $R_{12}\u0026lt;U_{12},F_{12}\u0026gt;$：\n$$ U_{12} = \\{ 学院,院长 \\} \\\\ F_{12} = \\{ 学院 \\rightarrow 院长 \\} $$\n    BC范式（BCNF）：关系模式$R\u0026lt;U,F\u0026gt;$属于BCNF（$R$首先得满足3NF），当且仅当其$F$中每个依赖的决定因素必定包含R的某个候选码。\n由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：\n  满足3NF。\n  所有非主属性对每一个码都是完全函数依赖。\n$$ 码 \\stackrel{f}{\\longrightarrow} 非主属性 $$\n  所有的主属性对每一个不包含它的码，也是完全函数依赖。\n  没有任何属性完全函数依赖于非码的任何一组属性。\n  一个满足BCNF的关系模式R己消除了插入和删除异常。\n  第四范式（4NF）：\n多值依赖：\n给定的关系模式$R(U,F)$：\n $X,Y,Z \\subseteq U$， $Z=U-X-Y$（$Z$是$X \\cup Y$的差集）。  当且仅当对$R$的任一关系$r$，给定的一对$(x,z)$值，有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关。则关系模式$R$中的多值依赖$X \\rightarrow\\rightarrow Y$成立。\n平凡的多值依赖：\n $X \\rightarrow\\rightarrow Y$成立， $Z = \\Phi$，  则$X \\rightarrow\\rightarrow Y$为平凡的多值依赖。\n例如，课程$\\rightarrow\\rightarrow$任课老师，课程$\\rightarrow\\rightarrow$参考书。\n4NF定义：\n设有一关系模式$R(U,F)$是1NF，如果对于$R$的每个非平凡多值依赖$X \\rightarrow\\rightarrow Y(Y \\not\\subseteq X)$，$X$都包含了$R$的一个候选码，则称$R$是第四范式，记为4NF。\n例如，课程$\\rightarrow\\rightarrow$任课老师，课程$\\rightarrow\\rightarrow$参考书都是非平凡多值依赖，而课程不是码，所以不属于4NF。\n  第五范式（5NF）。\n  范式之间的关系：\n$$ 5NF \\sub 4NF \\sub BCNF \\sub 3NF \\sub 2NF \\sub 1NF $$\n3NF和BCNE它们是进行规范化的主要目标。\n1NF到4NF之间的转换关系：\n   范式 转换关系     1NF 每一个分量是不可再分的数据项   2NF 1NF消除了部分函数依赖后满足2NF   3NF 2NF消除了非主属性对码的传递函数依赖后满足3NF   BCNF 3NF消除了主属性对码的部分和传递函数依赖后满足BCNF   4NF BCNF消除非平凡且非函数依赖的多值依赖后满足4NF    几种范式及其分解的性质：\n   性质 3NF BCNF 4NF     消除函数依赖带来冗余 否 是 是   消除多值函数依赖带来冗余 否 否 是   保持函数依赖 是 否 否   保持多值函数依赖 否 否 否     数据库设计 新奥尔良（New Orleans）法式目前公认的数据库设计方法，它将数据库设计分为以下几个阶段：\n 用户需求分析 概念结构设计 逻辑结构设计 物理结构设计  这几个阶段之后是与数据库建立和运行有关的阶段：\n 数据库实施 数据库运行和维护  需求分析 需求分析是项目确定后，对数据库应用系统所要设计的内容（数据）和功能（行为）的整理和描述，是以用户的角度来认识系统。\n需求分析是后面几个阶段，逻辑结构设计、物理结构设计以及应用程序设计的依据。\n需求分析将收集到的零碎的、局部的数据分析整理后，建立需求说明文档、数据字典和数据流程图。\n需求分析还包含：\n  数据流分析：是对事务处理所需的原始数据的收集，及经过处理后所得数据及其流向。\n使用数据流图（DFD）表示。DFD能指出数据的流向和需要进行的事物处理（不涉及如何处理）。\n  数据字典：是关于数据库中数据的描述，即元数据（不是数据本身）。\n数据字典包括5个部分：\n 数据项； 数据结构； 数据流； 数据存储； 加工。    系统需求说明书是需求分析阶段的成果，主要包括数据流图、数据字典、各种说明性表格、统计输出表和系统功能结构图等。\n需求分析阶段的工作：\n概念结构设计 概念设计阶段的目标是产生整体数据库概念结构，即概念模型，它是与DBMS无关的。\n概念结构设计的方法：\n 自顶向下 自底向上 逐步扩张 混合策略（自顶向下和自底向上相结合）  概念结构是对现实世界的一种抽象，从数据库设计角度看，主要是数据抽象，一般有如下3种数据抽象：\n 分类 聚集 概括  局部视图设计就是对某个局部应用设计其分一R图，也称局部E-R图。其基本步骤如下：\n 确定局部结构范围； 定义实体； 联系定义； 属性分配。  概念模型的建立采用E-R模型。\nE-R 模型 E-R模型用E-R图（ERD）表示，E-R图有以下几个成分：\n  实体：用矩形表示。\n  联系：用棱形表示，并用无向边分别与有关实体连接起来，同时在无向边标注联系的类型（$1:1$，$1:n$ 或 $m:n$）。\n  属性：用椭圆形表示，并用无向边将其与相应的实体连接起来\nE-R模型中的属性有以下分类：\n  简单属性和复合属性：\n 简单属性是原子的、不可再分的； 复合属性可以细分为更小的部分。    单值属性和多值属性：\n 单值属性是一个属性对应一个值； 多值属性是一个属性对应一组值。    NULL属性：实体在某个属性上没有值或属性值未知时，使用NULL值表示。\n  派生属性：派生属性可以从其他属性得来（通过运算等方式求出）。\n    扩充的E-R模型（用来表达更多具有特殊语义的成分）有以下成分：\n  弱实体：使用双线矩形框表示。将需要依赖其他实体存在的实体。\n实体间的所有（Ownership，拥有）关系代表一个实体对另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提。\n例如职工与家属的联系，家属总是属于某职工的（在关系模式中需要依赖职工而存在），所以家属是弱实体。\n  特殊化：将一个实体集按照某些特性区分为几个子实体。这种从普遍到特殊的过程即为特殊化。\n  E-R图中的主要构件（包含扩充的E-R模型成分）：\n建立概念结构模型 建立概念结构模型的步骤如下：\n  选择局部应用：\n需求分析阶段得到的大量数据分散杂乱，许多数据会应用于不同的处理，数据与数据之间关联关系也较为复杂。要最终确定实体、属性和联系，必须根据数据流图这一线索理清数据。\n数据流图是对业务处理过程从高层到底层的一级抽象：\n 高层抽象流图一般反映系统的概貌，对数据的引用较为笼统； 底层又可能过于细致，不能体现数据的关联关系。  因此要选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能。从这一层入手，就能很好地设计分E-R图。\n  逐一设计分E-R图。\n  E-R图合并：\n根据局部应用设计好各局部E-R图之后，就可以对各分E-R图进行合并。\n合并的目的在于，在合并过程中解决分E-R图中相互存在的冲突。\n  分E-R图之间的冲突主要有：\n 属性冲突：同一属性在不同的分E-R图上的属性类型、取值范围和数据单位等可能会不一致。 命名冲突：相同意义的属性在不同的分E-R图上可能会有不同的命名。 结构冲突：同一实体在不同的分E-R图中可能会有不同的属性；同一对象在某一分E-R图中被抽象为实体，而在另一分E-R图中又可能被抽象为属性，反之亦然。  逻辑结构设计 逻辑结构设计就是在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型和关系模型。\n通常是把概念模型转换成为某个具体的数据库管理系统所支持的结构数据模型（与DBMS有关）。即，将概念结构设计所得的E-R模型转换成关系模式。\n逻辑结构设计的工作步骤：\nE-R 模型转换关系模式   实体向关系模式的转换：\n将E-R图中的实体逐一转换成为一个关系模式：\n 实体名：对应关系模式的名称； 实体的属性：转换成关系模式的属性； 实体标识符：关系的码（键）。    联系向关系模式的转换：\n  一对一联系的转换：\n有两种方式：\n  方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性包括该联系所关联的两个实体的码及联系的属性，关系的码取自任一方实体的码。\n那么一个一对一联系需要转换成三个关系模式。\n  方式2（一般使用该方式）：将联系归并到关联的两个实体的任一方，给待归并的一方实体属性集中增加另一方实体的码和该联系的属性即可，归并后的实体码保持不变。\n一个一对一联系仅需转换成两个关系模式。\n  例如：\n  方式1：\n厂长（姓名，性别，年龄）\n工厂（厂号，厂名，地点）\n管理（（厂长）姓名，厂号，任期）\n 粗体代表该关系模式的码。管理的码可以为姓名或厂号。\n   方式2：\n厂长（姓名，性别，年龄）\n工厂（厂号，厂名，地点，（厂长）姓名，任期）\n    一对多联系的转换：\n两种方式：\n 方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个实体的码及联系的属性，关系的码是多方实体的码； 方式2（一般使用该方式）：将联系归并到关联的两个实体的多方，给待归并的多方实体属性集中增加一方实体的码和该联系的属性即可，归并后的多方实体码保持不变。  例如：\n  方式1:\n仓库（仓库号，地点，面积）\n商品（货号，商品名，价格）\n仓储（货号，仓库号，数量）\n  方式2：\n仓库（仓库号，地点，面积）\n商品（货号，商品名，价格，仓库号，数量）\n    多对多联系的转换：\n多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组。\n例如：\n转换成：\n学生（学号，姓名，性别，年龄）\n课程（课程号，课程名，学时）\n选修（（学号，课程号），成绩）\n    关系模式的规范化 转换后的关系模式可能存在数据冗余、更新异常等问题，所以需要进一步的规范化处理。\n  根据语义确定各关系模式的数据依赖（函数依赖）。\n  根据数据依赖确定关系模式的范式。判定关系模式是否达到了3NF或4NF。\n  如果关系模式不符合要求，要根据关系模式的分解算法对其进行分解，达到3NF、BCNF或4NF。\n  关系模式的评价及修正。\n根据规范化理论对关系模式分解之后，就可以在理论上消除冗余和更新异常。但根据处理要求，可能还需要增加部分冗余以满足处理要求，这就需要做部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。\n   事务管理 事务是一个操作序列，这些操作“要么都做，要么都不做”。\n事务和程序是两个不同的概念，一般一个程序可包含多个事务。\n在SQL语言中，事务定义的语句有以下三条。\n  BEGIN TRANSACTION：事务开始。\n  COMMIT：事务提交。\n该操作表示事务成功地结束，它将通知事务管理器该事务的所有更新操作现在可以被提交或永久地保留。\n  ROLLBACK：事务回滚。\n该操作表示事务非成功地结束，它将通知事务管理器出故障了，数据库可能处于不一致状态，该事务的所有更新操作必须回滚或撤销。\n  事务的ACID性质：\n  原子性（Atomicity）：事务是原子的，要么都做，要么都不做。\n  一致性（Consistency）：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态。\n因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。\n  隔离性（Isolation）：事务相互隔离。\n当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的\n  持久性（Durability）：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。\n   数据库故障 在数据库的运行过程中，难免会出现计算机系统的软、硬件故障，这些故障会影响数据库中数据的正确性，甚至破坏数据库，使数据库中的全部或部分数据丢失。因此，数据库的关键技术在于建立冗余数据，即备份数据。如何在系统出现故障后能够及时地使数据库恢复到故障前的正确状态，就是数据库恢复技术。\n故障类型：\n 事务内部故障：有的可以通过事务程序本身发现；有的是非预期的，不能由事务程序处理。 系统故障（软故障）：是指造成系统停止运行的任何事件，使得系统要重新启动，例如CPU故障、操作系统故障和突然停电等。 介质故障（硬故障）：如磁盘损坏、磁头碰撞和瞬时强磁干扰。此类故障发生的几率小，但破坏性最大。 计算机病毒：计算机病毒是一种人为的故障和破坏，是在计算机程序中插入的破坏，计算机功能或者数据可以繁殖和传播的一组计算机指令或程序代码。  备份方法 恢复的基本原理是“建立数据冗余”（重复存储）。建立冗余数据的方法是进行数据转储和登记日志文件，分为：\n  静态转储和动态转储：\n  静态转储：在转储期间不允许对数据库进行任何存取、修改操作；\n  动态转储：在转储期间允许对数据库进行存取、修改操作。\n动态转储和用户事务可并发执行。\n    海量转储和增量转储：\n 海量转储：指每次转储全部数据； 增量转储：指每次只转储上次转储后更新过的数据。    日志文件：\n在事务处理的过程中，DBMS把以下操作写入日志文件：\n 事务开始、事务结束； 对数据库的插入、删除和修改。  一旦发生故障，DBMS的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。因此，DBMS利用日志文件来进行事务故障恢复和系统故障恢复，并可协助后备副本进行介质故障恢复。\n  恢复 事务恢复有以下3个步骤：\n 反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。 对事务的更新操作执行逆操作。 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样的处理，直到事务的开始标志。   并发控制 所谓并发操作，是指在多用户共享的系统中许多用户可能同时对同一数据进行操作。并发操作带来的问题是数据的不一致性，主要有三类：\n 丢失更新 不可重复读 读脏数据  其主要原因是事务的并发操作破坏了事务的隔离性。DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据。\n封锁 并发控制的主要技术是封锁。基本封锁的类型有：\n  排它锁（X锁或写锁）：若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他事务都不能再对A加任何类型的锁，直到T释放A上的锁。\n  共享锁（S锁或读锁）：若事务T对数据对象A加上S锁，则只允许T读取A，但不能修改A，其他事务只能再对A加S锁，直到T释放A上的S锁。\n这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A进行任何修改。\n   分布式数据库 分布式数据库系统是指数据存放在计算机网络的不同场地的计算机中，每一场地都有自治处理能力并能完成局部应用；而每一场地也参与（至少一种）全局应用程序的执行，全局应用程序可通过网络通信访问系统中多个场地的数据。其定义强调分布性和逻辑整体性两点。\n分布式数据库中有以下基本概念：\n 分片透明：指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的。 复制透明：指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。 位置透明：指用户无须知道数据存放的物理位置。 逻辑透明：指用户或应用程序无需知道局部场地使用的是哪种数据模型。  具有以下性质：\n 共享性：数据存储在不同的结点数据共享。 自治性：指每结点对本地数据都能独立管理。 可用性：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。 分布性：指数据在不同场地上的存储。   存储过程 存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。\n存储过程是数据库所提供的一种数据库对象，通过存储过程定义一段代码，提供给应用程序调用来执行。从安全性的角度考虑，更新数据时，通过提供存储过程正第三方调用，将需要更新的数据传入存储过程，而在存储过程内部用代码分别对需要的多个表进行更新，从而避免了向第三方提供系统的表结构，保证了系统的数据安全。\n","date":"2023-04-22T00:00:00Z","permalink":"https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"数据库（软件设计师）"},{"content":"面向对象基本概念 面向对象（Object-Oriented，00） = 对象（Object）+ 分类（Classification）+ 继承（Inheritance）+ 通过消息的通信（Communication with Messages）\n对象 在面向对象的系统中，对象是基本的运行时的实体，它包括：\n 属性：数据； 行为：作用于数据的操作。  一个对象把属性和行为封装为一个整体。\n 封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。\n对象可以看作是一个程序模块。\n 一个对象通常由以下成分组成：\n 对象名； 属性； 方法。  消息 对象之间进行通信的一种构造叫件消息。\n类 类可以分为三种：\n  实体类：实体类的对象表示现实世界中真实的实体；\n  接口类：接口类的对象为用户提供一种与系统合作交互的方式，分 为人和系统两大类（边界类）；\n 人的接口可以是显示屏、窗口、Wb窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。 系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。    控制类：控制类的对象用来控制活动流，充当协调者。\n  继承 继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。\n一个父类可以有多个子类。所以继承又分为：\n  单重继承：只从一个父类得到继承；\n  多重继承：一个子类有两个或更多个父类。\n多重继承中可能导致子类存在二义性的成员。\n  多态 多态（Polymorphism）：不同的对象收到同一消息可以产生完全不同的结果。\n同一消息就可以调用不同的方法。多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应。\n多态有不同的形式：\n 通用的多态：  参数多态：应用比较广泛，被称为最纯的多态； 包含多态：在许多语言中都存在，最常见的例子就是子类型化。即一个类型是另一个类型的子类型。   特定的多态：  过载（Overloading）多态：同一个名字在不同的上下文中所代表的含义不同； 强制多态。    绑定 绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。\n绑定分为：\n  静态绑定：在编译时进行的；\n  动态绑定：在运行时进行的。\n一个给定的过程调用和代码的结合直到调用发生时才进行。\n动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类对象可以出现的地方，子类对象也可以出现。\n在运行过程中，当一个对象发送消息请求服务时，要根据匿收对象的其体情况将请求的操作与实现的方法进行连接，即动态绑定。\n   面向对象分析 同其他分析方法一样，面向对象分析（Object-Oriented Analysis，OOA）的目的是为了获得对应用问题的理解。\n面向对象分析包含5个活动：\n 认定对象； 组织对象； 描述对象间的相互作用； 确定对象的操作 定义对象的内部信息。  认定对象 在应用领域中，按自然存在的实体确立对象。\n在定义域中，首先将自然存在的“名词”作为一个对象，这通常是研究问题、定义域实体的良好开始。\n组织对象 分析对象间的关系，将相关对象抽象成类，其目的是为了简化关联对象，利用类的继承性建立具有继承性层次的类结构。\n抽象类时可从以下方面考虑：\n 对象间的操作； 一个对象是另一个对象的一部分，如房子是由门和窗构成的。   面向对象设计 程序设计范型（Programming Paradigm）是人们在程序设计时所采用的基本方式模型，决定了程序设计时采用的思维方式、使用的工具，同时又有一定的应用范畴。\n程序设计范型的发展经历了：\n 过程程序设计； 模块化程序设计； 函数程序设计； 逻辑程序设计； 面向对象程序设计范型。  面向对象程序设计（Object-Oriented Programming，OOP）的实质是选用一种面向对象程序设计语言（Object-Oriented Programming Language，OOPL）：\n 采用对象、类及其相关概念所进行的程序设计； 关键在于加入了类和继承性，从而进一步提高了抽象程度。  特定的OOP概念一般是通过OOPL中特定的语言机制来体现的。\nOOP现在已经扩展到系统分析和软件设计的范畴，出现了面向对象分析和面向对象设计的概念。\n设计原则 面向对象方法中的五大原则：\n  责任原则（Single Responsibility Principle，SRP）：当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。\n  开放封闭原则（Open \u0026amp; Close Principle，OCP）：软件实体（类、模块、函数等）应 该可以扩展的，即开放的；但是不可修改的，即封闭的。\n  里氏替换原则（Liskov Substitution Principle，LSP）：子类型必须能够替换掉他们的基 类型。\n即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。\n当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。\n  依赖倒置原则（Dependence Inversion Principle，DP）：抽象不应该依赖于细节，细 节应该依赖于抽象。即，高层模块不应该依赖于低层模块，二者都应该依赖于抽象。\n  接口分离原则（Interface Segregation Principle，ISP）：不应该强迫客户依赖于它们不 用的方法。接口属于客户，不属于它所在的类层次结构。\n即：依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。\n这样做的好处就在于可以最大限度地应对可能的变化。\n  Robert C. Martin提出的面向对象设计原则还包括以下几个：\n 重用发布等价原则（Release Reuse Equivalency Principle，REP）：重用的粒度就是发布的粒度。 共同封闭原则（Common Closure Principle，CCP）：包中的所有类对于同一类性质的变化应该是共同到闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。 共同重用原则（Common Reuse Principle，CRP）：一个包中的所有类应该是共同重用 的。如果重用了包中的一个类那么就要重用包中的所有类。 无环依赖原则（Acyclic Dependencies Principle，ADP）：在包的依赖关系图中不允许存 在环，即包之间的结构必须是一个直接的五环图形。 稳定依赖原则（Stable Dependencies Principle,SDP）：朝着稳定的方向进行依赖。 稳定抽象原则（Stable Abstractions Principle，SAP）：包的抽象程度应该和其稳定程 度一致。   UML 面向对象分析强调的是对一个系统中对象的特征和行为的定义。目前，国际上已经出现了多种面向对象的方法，例如：\n Peter Coad和Edward Yourdon的OOA和OOD方法（又称Coad/Yourdon方法或Coad方法）； Booch的OOD方法（又称Booch方法）； OMT（Object Modeling Technique，面向对象建模技术）方法； UML（Unified Modeling Language，统一建模语言）。  UML是面向对象软件的标准化建模语言。由于其简单、统一，又能够表达软件设计中的动态和静态信息，目前己经成为可视化建模语言事实上的工业标准。\n事物 UML中有4种事物：\n  结构事物（Structural Thing）：是UML模型中的名词。它们通常是模型的静态部分，描述概念或物理元素。\n结构事物包括：\n 类（Class）； 接口（Interface）； 协作（Collaboration）； 用例（Use Case）； 主动类（Active Class）； 构件（Component）； 制品（Artifact）； 结点（Node）。    行为事物（Behavior Thing）：是UML模型的动态部分。它们是模型中的动词，描述了跨越时间和空间的行为。\n行为事物包括：\n 交互（Interaction）； 状态机（State Machine）； 活动（Activity）。    分组事物（Grouping Thing）：分组事物是UML模型的组织部分，是一些由模型分解成的“盒子”。\n在所有的分组事物中，最主要的分组事物是包（Package）。包是把元素组织成组的机制，这种机制具有多种用途。结构事物、行为事物甚至其他分组事物都可以放进包内。\n包与构件（仅在运行时存在）不同，它纯粹是概念上的（即它仅在开发时存在）。\n  注释事物（Annotational Thing）：注释事物是UML模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素。\n注解（Note）是一种主要的注释事物。注解是一个依附于一个元素或者一组元素之上，对它进行约束或解释的简单符号。\n  关系 UML中有4种关系，这4种关系是UML模型中可以包含的基本关系事物：\n  依赖（Dependency）：是两个事物间的语义关系，其中一个事物（独立事物）发 生变化会影响另一个事物（依赖事物）的语义。\n在图形上，把一个依赖画成一条可能有方向的虚线，如图：\n依赖的变体有：\n 精化； 跟踪； 包含； 延伸。    关联（Association）：是一种结构关系，它描述了一组链，链是对象之间的连接。\n聚集（Aggregation）是一种特殊类型的关联，它描述了整体和部分间的结构关系。\n关联和聚集的图形化表示如图：\n 在关联上可以标注重复度（Multiplicity）和角色（Role）。\n实心菱形表示组合，空心菱形表示聚合；菱形右边表示整体，左边表示部分。\n   泛化（Generalization）：是一种特殊/一般关系，特殊元素（子元素）的对象可替代一般元素（父元素）的对象。用这种方法，子元素共享了父元素的结构和行为。\n在图形上，把一个泛化关系画成一条带有空心箭头的实线，它指向父元素：\n  实现（Realization）：是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。\n在两种情况下会使用实现关系：\n 在接口和实现它们的类或构件之间： 在用例和实现它们的协作之间。  在图形上，把一个实现关系画成一条带有空心箭头的虚线，如图：\n   UML中的图 UML2.0提供了13种图，分别是：\n 类图 对象图 用例图 状态图 活动图 构件图 组合结构图 部署图 包图 交互图：  序列图 通信图 交互概览图 计时图    UML中关联的多重度：\n进行面向对象设计时，类图中可以展现类之间的关联关系，还可以在类图中图示关联中的数量关系，即多重度。表示数量关系时，用多重度说明数量或数量范围，表示有多少个实例（对象）能被连接起来，即一个类的实例能够与另一个类的多少个实例相关联。\n类图 类图（Class Diagram）展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中所建立的最常见的图就是类图。\n类图中通常包括下述内容：\n 类； 接口； 协作； 依赖、泛化和关联关系。  类图中也可以包含：\n 注解和约束； 包或子系统。  类图用于对系统的静态设计视图建模，通常以下述3种方式之一使用类图：\n  对系统的词汇建模：\n涉及做出这样的决定：\n 哪些抽象是考虑中的系统的一部分， 哪些抽象处于系统边界之外。  用类图详细描述这些抽象和它们的职责。\n  对简单的协作建模：协作是一些共同工作的类、接口和其他元素的群体，该群体提供的一些合作行为强于所有这些元素的行为之和。\n  对逻辑数据库模式建模：将模式看作为数据库的概念设计的蓝图。在很多领域中，要在关系数据库或面向对象数据库中存储永久信息，可以用类图对这些数据库的模式建模。\n  对象图 对象图（Object Diagram）展现了某一时刻一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的静态快照。\n对象图一般包括对象和链，如图：\n和类图一样，对象图给出系统的静态设计视图或静态进程视图，但它们是从真实的或原型实例的角度建立的。\n用例图 用例图（Use Case Diagram）展现了一组用例、参与者（Actor）以及它们之间的关系。\n用例图通常包括以下内容：\n  用例：是从用户角度描述系统的行为，它将系统的一个功能描述成一系列的事件，这些事件最终对操作者产生有价值的观测结果。\n用例是一个类，它代表一类功能而不是使用该功能的某一具体实例。\n  参与者：是与系统交互的外部实体，可能是使用者，也可能是与系统交互的外部系统、基础设备等。\n  关系：\n 用例之间的扩展关系（\u0026lt;\u0026lt;extend\u0026gt;\u0026gt;）和包含关系（\u0026lt;\u0026lt;include\u0026gt;\u0026gt;）， 参与者和用例之间的关联关系， 用例与用例以及参与者与参与者之间的泛化关系。    交互图 交互图用于对系统的动态方面进行建模。一张交互图表现的是一个交互，由一组对象和它们之间的关系组成，包含它们之间可能传递的消息。\n每种交互图针对不同的目的，能适用于不同的情况。交互图表现为：\n 序列图：强调消息时间顺序的交互图； 通信图：强调接收和发送消息的对象的结构组织的交互图； 交互概览图：强调控制流的交互图； 计时图。  在多数情况下，交互图包括对以下内容的具体的或原型化的实例以及它们之间传递的消息进行建模：\n 类； 接口； 构件； 结点。  所有这些都位于一个表达行为的脚本的语境中。\n交互图一般包含：\n 对象； 链： 消息。  序列图 序列图（Sequence Diagram，又称顺序图）是场景（Scenario）的图形化表示，描述了以时间顺序组织的对象之间的交互活动\n形成序列图时，首先把参加交互的对象放在图的上方，沿水平方向排列。通常把发起交互的对象放在左边，下级对象依次放在右边。然后，把这些对象发送和接收的消息沿垂直方向按时间顺序从上到下放置。\n序列图有两个不同于通信图的特性：\n 序列图有对象生命线； 序列图有控制焦点。  通信图 通信图（Communication Diagram，又称协作图）强调收发消息的对象的结构组织。通信图强调参加交互的对象的组织。\n产生一张通信图，首先要将参加交互的对象作为图的顶点，然后把连接这些对象的链表示为图的弧，最后用对象发送和接收的消息来修饰这些链。这就提供了在协作对象的结构组织的语境中观察控制流的一个清晰的可视化轨迹。\n通信图有两个不同于序列图的特性：\n 通信图有路径； 通信图有序号。  状态图 状态图（State Diagram）展现了一个状态机。状态图关注系统的动态视图，对于接口、类和协作的行为建模尤为重要，强调对象行为的事件顺序。\n状态图由以下组成：\n  状态：指对象的生命周期中某个条件或者状态，是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。\n子状态：嵌套在另外一个状态中的状态。\n 简单状态。 组合状态：含有子状态的状态。    转换（事件和动作）：是两个状态之间的一种关系，表示对象将在源状态中执行一定的动作，并在某个特定事件发生而且某个特定的警界（监护）条件满足时进入目标状态。\n 转换动作：是一个可执行的原子操作，是不可中断的，其执行时间是可忽略不计的。    事件：是在某个特定时刻发生的事情，它是对引起系统做动作或（和）从一个状态转换到另个状态的外界事件的抽象。\n  活动。\n  可以用状态图对系统的动态方面建模。这些动态方面可以包括出现在系统体系结构的任何视图中的任何一种对象的按事件排序的行为，这些对象包括：\n 类（各主动类）； 接口； 构件； 结点。  当对系统、类或用例的动态方面建模时，通常是对反应型对象建模。\n活动图 活动图（Activity Diagram）是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。活动图专注于系统的动态视图，它对于系统的功能建模特别重要，并强调对象间的控制流程。\n活动图一般包括：\n 活动状态； 动作状态； 转换； 对象。  活动图可以表示：\n 分支； 合并； 分岔； 汇合。  当对一个系统的动态方面建模时，通常有两种使用活动图的方式：\n 对工作流建模； 对操作建模。  构建图 构件图（Component Diagram，又称组件图）展现了一组构件之间的组织和依赖。构件图专注于系统的静态实现视图。它与类图相关，通常把构件映射为一个或多个类、接口或协作。\n部署图 部署图（Deployment Diagram）是用来对面向对象系统的物理方面建模的方法，展现了运行时处理结点以及其中构件（制品）的配置。部署图对系统的静态部署视图进行建模，它与构件图相关。\n \u0026lt;\u0026lt;artifact\u0026gt;\u0026gt;表示制品。\n部署图展现了系统的软件和硬件之间的关系在实施阶段使用。\n 总结  静态建模：  类图 对象图 用例图   动态建模：  序列图（顺序图，时序图） 通信图（协作图） 状态图 活动图   物理建模：  构件图（组件图) 部署图   交互图：  序列图（顺序图，时序图） 通信图（协作图）     设计模式 每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。使用设计模式能减少一些重复劳动。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便地复用成功的设计和体系结构。\n设计模式分类：\n    创建型 结构型 行为型     类 Factory Method（工厂方法模式） Adapter（适配器模式） Interpreter（解释器模式）\nTemplate Method（模板方法模式）   对象 Abstract Factory（抽象工厂模式）\nBuilder（生成器模式）\nPrototype（原型模式）\nSingleton（单例模式） Adapter（适配器模式）\nBridge（桥接模式）\nComposite（组合模式）\nDecorator（装饰器模式）\nFacade（外观模式）\nFlyweight（享元模式）\nProxy（代理模式） Chain of Responsibility（责任链模式）\nCommand（命令模式）\nIterator（迭代器模式）\nMediator（中介者模式）\nMemento（备忘录模式）\nObserver（观察者模式）\nState（状态模式）\nStrategy（策略模式）\nVisitor（访问者模式）    创建型设计模式 创建型模式顾名思义就是针对对象的创建过程所做的设计模式。\n创建型模式抽象了实例化过程。\n 类创建型模式：使用继承改变被实例化的类； 对象创建型模式：将实例化委托给另一个对象。  工厂模式 工厂方法（Factory Method）模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。\n 即接口不创建具体的对象，交由子类来决定实例化哪个类。\n 工厂模式结构：\n  Product：定义工厂方法所创建的对象的接口。\n  ConcreteProduct：实现Product接口。\n  Creator：声明工厂方法，该方法返回一个Product类型的对象。\nCreator也可以定义一个工厂方法的默认实现，它返回一个默认的ConcreteProduct对象，可以调用工厂方法以创建一个Product对象。\n  ConcreteCreator：重定义工厂方法以返回一个ConcreteProduct实例。\n  Factory Method模式适用于：\n 当一个类不知道它所必须创建的对象的类的时候。 当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。   关键词：子类指定创建对象。\n 工厂模式：\n 特点：用户类和工厂类分开。 优点：用户需要什么对象，只需向工厂请求即可。用户无需修改就可使用对象。 缺点：对象修改时，工厂类也需要做相应的修改。  抽象工厂模式 抽象工厂（Abstract Factory）提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。\n 即提供对象的接口，用户无需考虑实现类。\n 抽象工厂模式的结构：\n AbstractFactory：声明一个创建抽象产品对象的操作接口。 ConcreteFactory：实现创建具体产品对象的操作。 AbstractProduct：为一类产品对象声明一个接口。 ConcreteProduct：定义一个将被相应的具体工厂创建的产品对象，实现AbstractProduct接口。 Client：仅使用由AbstractFactory和AbstractProduct类声明的接口。  Abstract Factory模式适用于：\n 一个系统要独立于它的产品的创建、组合和表示时。 一个系统要由多个产品系列中的一个来配置时。 当要强调一系列相关的产品对象的设计以便进行联合使用时。 当提供一个产品类库，只想显示它们的接口而不是实现时。   题目选项描述：\n  提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类。\n  当一个系统应该独立于它的产品创建、构成和表示时。\n  当要强调一系列相关的产品对象的设计以便进行联合使用时。\n  一个系统要由多个产品系列中的一个来配置时。\n  为图形用户界面（GUI）组件定义不同平台的并行类层次结构。\n不同平台的GUI组件，使用同样的接口，根据平台使用不同的实现。    关键词：系列。\n 抽象工厂模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做。它仅负责给存储具体工厂类必须实现的接口。\n生成器（建造者）模式 生成器（Builder，建造者）模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n生成器模式结构：\n  Product：表示被构造的复杂对象。\n  Builder：为创建一个Product对象的各个部件指定抽象接口。\n  ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。\nConcreteBuilder创建Product对象产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。\n  Director：构造一个使用Builder接口的对象。\n  Builder模式适用于：\n 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。   题目选项描述\n 当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。 适用于抽象复杂对象的构建步骤和基于构建过程的具体实现构建复杂对象的不同表示。  关键词：复杂对象、不同表示。\n 原型模式 原型（Prototype）模式用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。\n原型模式结构：\n Prototype：声明一个复制自身的接口。 ConcretePrototype：实现一个复制自身的操作。 Client：让一个原型复制自身从而创建一个新的对象。  Prototype模式适用于：\n 当一个系统应该独立于它的产品创建、构成和表示时。 当要实例化的类是在运行时刻指定时，例如，通过动态装载。 为了避免创建一个与产品类层次平行的工厂类层次时。 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。  原型模式：\n 特点：通过给出一个原型对象来指明所要创建的对象的类型，然后复制这个原型对象的方法创建出更多同类型的对象。 优点：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。 缺点：每一个类都必须配备一个克隆方法。  单例（单态）模式 单例（Singleton，单态）模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n 就好像Spring中的Bean，每个Bean有且仅有一个实例，通过@Autowired自动装配（来访问）。\n 单例模式结构：\n Singleton：指定一个Instance操作，允许客户访问它的唯一实例。 Instance：是一个类操作；可能负责创建它自己的唯一实例。  Singleton模式适用于：\n 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时。   关键词：唯一实例、一个实例。\n 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。\n结构型设计模式 结构型设计模式涉及如何组合类或对象以获得更大的结构。\n  结构型类模式：采用继承机制来组合接口或实现。\n一个简单的例子是采用多重继承方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。\n这一模式尤其有助于多个独立开发的类库协同工作。\n  结构型对象模式：描述了如何对一些对象进行组合，从而实现新功能的一些方法（不是对接口和实现进行组合）。\n因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。\n  适配器（变压器）模式 适配器（Adapter，变压器）模式将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n类适配器使用多重继承对一个接口与另一个接口进行匹配：\nAdapter模式适用于：\n 想使用一个已经存在的类，而它的接口不符合要求。 想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter）想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。   题目选项描述：\n 将一个对象加以包装以给客户提供其希望的另外一个接口。 想使用一个已经存在的类，而其接口不符合要求。 使所有接口不兼容类可以一起工作。 将一个类的接口转换成客户希望的另一个接口。  关键词：另一个接口、接口不符合要求、接口兼容、接口转换。\n 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。\n桥接模式 桥接（Bridge）模式将抽象部分与其实现部分分离，使它们都可以独立地变化。\n桥接模式结构：\n  Abstraction：定义抽象类的接口，维护一个指向Implementor类型对象的指针。\n  RefinedAbstraction：扩充由Abstraction定义的接口。\n  Implementor：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。\n一般来说，Implementor接口仅提供基本操作，而Abstraction：定义了基于这些基本操作的较高层次的操作。\n  ConcreteImplementor：实现Implementor接口并定义它的具体实现。\n  Bridge模式适用于：\n  不希望在抽象和它的实现部分之间有一个固定的绑定关系。\n例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。\n  类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。\n这是Bridge模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。\n  对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。\n  （C++）想对客户完全隐藏抽象的实现部分。\n  有许多类要生成的类层次结构。\n  想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。\n   题目选项描述：\n 类的抽象和其实现之间不希望有一个固定的绑定关系。 不希望在抽象和它的实现部分之间有一个固定的绑定关系。  关键词：固定的绑定关系。\n 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联。也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。\n组合（合成）模式 组合（Composite，合成）模式将对象组合成树型结构以表示“部分——整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。\n组合模式的结构：\n  Component：为组合中的对象声明接口。\n 在适当情况下实现所有类共有接口的默认行为； 声明一个接口用于访问和管理Component的子组件； （可选）在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它。    Leaf：在组合中表示叶结点对象，叶结点没有子结点；在组合中定义图元对象的行为。\n  Composite：\n 定义有子组件的那些组件的行为； 存储子组件； 在Component接口中实现与子组件有关的操作。    Client：通过Component接口操纵组合组件的对象。\n  Composite模式适用于：\n 想表示对象的部分——整体层次结构。 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。   题目选项描述：\n表示对象的部分——整体层次结构。\n 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。\n装饰器模式 装饰器（Decorator）模式动态地给一个对象添加一些额外的职责。装饰器提供了用子类扩展功能的灵活替代。就增加功能而言，Decorator模式比派生子类更加灵活。\n装饰器模式结构：\n Component：定义一个对象接口，可以给这些对象动态地添加职责。 ConcreteComponent：定义一个对象，可以给这个对象添加一些职责。 Decorator：维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。 ConcreteDecorator：向组件添加职责。  Decorator模式适用于：\n 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 处理那些可以撤销的职责。 当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。   题目选项描述：\n 将一个对象加以包装以提供一些额外的行为。 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 动态地给一个对象添加一些额外的职责。  关键词：提供、添加、额外行为、指责。\n 外观（门面）模式 外观（Facade，门面）模式为子系统中的一组接口提供一个一致的门面（界面），Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n外观模式的结构：\n  Facade：知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象。\n  Subsystem classes：\n 实现子系统的功能； 处理有Facade对象指派的任务； 没有Facade的任何相关信息，即没有指向Facade的指针。    Facade模式适用于：\n  Facade可以提供一个简单的默认视图，供大多数用户使用。\n要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。\nFacade提供的简单默认视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。\n  客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。\n  当需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过Facade进行通信，从而简化了它们之间的依赖关系。\n   题目选项描述：\n 将一系列对象加以包装以简化其接口。 需要为一个复杂子系统提供一个简单接口。  关键词：简化接口、复杂子系统。\n 外观模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。\n外观模式提供一个高层次的接口，使得子系统更易于使用：\n 每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。 整个系统可以有多个门面类。  享元模式 享元（Flyweight）模式运用共享技术有效地支持大量细粒度的对象。\n享元模式的结构：\n  Flyweight：描述一个接口，通过这个接口Flyweight可以接受并作用于外部状态。\n  ConcreteFlyweight：实现Flyweight接口，并为内部状态（如果有）增加存储空间。\nConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的，即它必须独立于ConcreteFlyweight对象的场景。\n  并非所有的Flyweight子类都需要被共享。\nFlyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子结点。\n  FlyweightFactory：创建并管理Flyweight对象；确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者在不存在时创建一个实例。\n  Client：维持一个对Flyweight的引用；计算或存储一个或多个Flyweight的外部状态。\n  Flyweight模式适用于：\n 一个应用程序使用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。  享元模式能做到共享的关键是区分状态：\n 内蕴状态：存储在享元内部，不会随环境的改变而有所不同。 外蕴状态：随环境的改变而改变的。  外蕴状态不能影响内蕴状态，它们是相互独立的。\n享元模式：将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。\n代理模式 代理（Proxy）模式为其他对象提供一种代理以控制对这个对象的访问。\n代理模式的结构：\n  Proxy：保存一个引用使得代理可以访问实体；提供一个与Subject的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它。\n其他功能依赖于代理的类型：\n Remote Proxy：负责对请求及其参数进行编码，并向不同地址空间中的实体发送己编码的请求； Virtual Proxy：可以缓存实体的附加信息，以便延迟对它的访问； Protection Proxy：检查调用者是否具有实现一个请求所必需的访问权限。    Subject：定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。\n  RealSubject：定义Proxy所代表的实体。\n  Proxy模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见情况有:\n  远程代理（Remote Proxy）：为一个对象在不同地址空间提供局部代表。\n  虚代理(Virtual Proxy）：根据需要创建开销很大的对象。\n  保护代理（Protection Proxy）：控制对原始对象的访问，用于对象应该有不同的访问权限的时候。\n  智能引用（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作。\n典型用途包括：\n 对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放； 当第一次引用一个持久对象时，将它装入内存； 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。    某些情况下，用户不想或者不能够直接引用一个对象，代理对象可以在用户和目标对象直接起到中介的作用。\n客户端分辨不出代理主题对象与真实主题对象。代理模式可以不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。\n行为型设计模式 行为模式涉及算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。\n  行为类模式：使用继承机制在类间分派行为。\n  行为对象模式：使用对象复合。\n一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务。\n  责任链模式 责任链（Chain of Responsibility）模式使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n责任链模式的结构：\n  Handler：\n 定义一个处理请求的接口； （可选）实现后继链。    ConcreteHandler：\n 处理它所负责的请求； 可访问它的后继者； 如果可处理该请求，就处理它，否则将该请求转发给后继者。    Client：向链上的具体处理者（ConcreteHandler）对象提交请求。\n  Chain of Responsibility模式适用于以下条件：\n 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。   题目选项描述：\n 有多个对象可以处理一个请求，在运行时刻自动确定由哪个对象处理。 一个客户需要使用一组相关对象。 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。  关键字：多个对象、一个请求、一组相关对象。\n 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。\n处理者有两个选择：承担责任或者把责任推给下家。\n一个请求可以最终不被任何接收端对象所接受。\n命令模式 命令（Command）模式将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。\n命令模式的结构：\n  Command：声明执行操作的接口。\n  ConcreteCommand：将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现Execute。\n  Client：创建一个具体命令对象并设定它的接收者。\n  Invoker：要求该命令执行这个请求。\n  Receiver：知道如何实施与执行一个请求相关的操作。\n任何类都可能作为一个接收者。\n  Command模式适用于：\n  抽象出待执行的动作以参数化某对象。\nCommand模式是过程语言中的回调（Callback）机制的一个面向对象的替代品。\n  在不同的时刻指定、排列和执行请求。\n一个Command对象可以有一个与初始请求无关的生存期。\n如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程，并在那实现该请求。\n  支持取消操作。\nCommand的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。\nCommand接口必须添加一个Unexecute操作，该操作取消上一次Execute 调用的效果。\n执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消和“重做”。\n  支持修改日志。\n这样当系统崩溃时，这些修改可以被重做一遍。\n在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。\n从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。\n  用构建在原语操作上的高层操作构造一个系统。\n这样一种结构在支持事务（Transaction）的信息系统中很常见。\nCommand模式提供了对事务进行建模的方法。Command有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。\n   题目选项描述：\n 抽象出执行的动作以参数化某对象。 将请求封装为对象从而可以使用不同的请求对客户进行参数化。 在不同的时刻指定、排列和执行请求。   命令模式：把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方：\n 不必知道接收请求的一方的接口； 不必知道请求是怎么被接收 不必知道请求的操作是否执行，何时被执行以及是怎么被执行的。  解释器模式 解释器（Interpreter）模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n解释器模式结构：\n  AbstractExpression：声明一个程序的解释操作，这个接口为抽象语法树中所有的结点所共享。\n  TerminalExpression：实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例。\n  NonterminalExpression：对文法中的每一条规则都需要一个NonterminalExpression类。\n 为每个符号都维护一个AbstractExpression类型的实例变量； 为文法中的非终结符实现解释（Interpret）操作。    Context：包含解释器之外的一些全局信息。\n  Client：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树，该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成；调用解释操作。\n  Interpreter模式适用于当有一个语言需要解释执行，且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好:\n  该文法简单。\n对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。\n即Interpreter模式需要构建抽象语法树，如果文法太复杂，需要构建复杂的语法树，不便于管理。\n  效率不是一个关键问题。\n最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。\n   题目选项描述：\n有一个语言需要解释执行，并且可将句子表示为一个抽象语法树。\n 解释器模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。\n迭代器模式 迭代器（Iterator）模式提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。\n多个对象聚在一起形成的总体称之为聚合（聚集），聚合对象是能够包容一组对象的容器对象。\n迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。\n迭代器模式的结构：\n Iterator（迭代器）：定义访问和遍历元素的接口。 ConcreteIterator（具体迭代器）：实现迭代器接口；对该聚合遍历时跟踪当前位置。 Aggregate（聚合）：定义创建相应迭代器对象的接口。 ConcreteAggregate（具体聚合）：实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。  Iterator模式适用于：\n 访问一个聚合对象的内容而无须暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口。   题目选项描述：\n访问一个聚合对象的内容而无须暴露它的内部表示。\n 中介者（调停者）模式 中介者模式（Mediator，调停者）用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n中介者模式的结构：\n Mediator（中介者）：定义一个接口用于各同事（Colleague）对象通信。 ConcreteMediator（具体中介者）：通过协调各同事对象实现协作行为；了解并维护它的各个同事。 Colleague（同事类）：知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信。  Mediator模式适用于：\n 一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。 想定制一个分布在多个类中的行为，而又不想生成太多的子类。   题目选项描述：\n 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。 一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。 减少多个对象或类之间的通信复杂性。   中介者模式：包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。\n当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。中介者模式将多对多的相互作用转化为一对多的相互作用。\n中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。\n备忘录模式 备忘录（Memento）模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。\nMemento模式的结构：\n Memento（备忘录）：存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录。 Originator（原发器）：创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态。 Caretaker（管理者）负责保存好备忘录；不能对备忘录的内容进行操作或检查。  Memento模式适用于：\n 必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。   题目选项描述：\n 将对象的状态恢复到先前的状态。 在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存。 必须保存一个对象在某一个时刻的（部分）状态。  关键词：状态。\n 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。\n观察者模式 观察者（Observer）模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n即，观察者模式让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。\n观察者模式的结构：\n Subject（目标）：提供注册和删除观察者对象的接口；知道它的观察者，可以有任意多个观察者观察同一个目标。 Observer（观察者）：为那些在目标发生改变时需获得通知的对象定义一个更新接口。 ConcreteSubject（具体目标）：将有关状态存入各ConcreteObserver对象；当它的状态发生改变时，向它的各个观察者发出通知。 ConcreteObserver（具体观察者）：维护一个指向ConcreteSubject对象的引用；存储有关状态，这些状态应与目标的状态保持一致；实现Observer的更新接口，以使自身状态与目标的状态保持一致。  Observer模式适用于：\n 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。 当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。  状态模式 状态（State）模式允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。\n状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。\n状态模式的结构：\n Context（上下文）：定义客户感兴趣的接口；维护一个ConcreteState子类的实例，这个实例定义当前状态。 State（状态）：定义一个接口以封装与Context的一个特定状态相关的行为。 ConcreteState（具体状态子类）：每个子类实现与Context的一个状态相关的行为。  State模式适用于：\n  一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。\n  一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。\n这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。\nState模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。\n   题目选项描述：\n 一个对象的行为决定于其状态且必须在运行时刻根据状态改变行为。 一个对象在其内部状态改变时改变其行为。   策略模式 策略（Strategy）模式定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。\n即，策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。\n  Strategy（策略）：定义所有支持的算法的公共接口。\nContext使用这个接口来调用某ConcreteStrategy定义的算法。\n  ConcreteStrategy（具体策略）：以Strategy接口实现某具体算法。\n  Context（上下文）：用一个ConcreteStrategy对象来配置；维护一个对Strategy对象的引用；可定义一个接口来让Strategy访问它的数据。\n  Strategy模式适用于：\n 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。 需要使用一个算法的不同变体例如,定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使厨策略模式。 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。   题目选项描述：\n 需要使用一个算法地不同变体。 许多相关的类仅仅是行为有异。 在设计某购物中心的收银软件系统时，要求能够支持在不同时期推出打折、返利、满减等不同促销活动。   策略模式使得算法可以在不影响到客户端的情况下发生变化。\n策略模把行为和环境分开：环境类负责维持和查询行为类，各种算法在具体的策略类中提供。\n由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。\n模板方法模式 模板方法模式（Template Method）定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n模板方法模式的结构：\n  AbstractClass（抽象类）：\n 定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤； 实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。    ConcreteClass（具体类）：实现原语操作以完成算法中与特定子类相关的步骤。\n  Template Method模式适用于：\n  一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。\n  各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。\n  控制子类扩展。\n模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展），这就只允许在这些点进行扩展。\n  模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。\n访问者模式 访问者（Visitor）模式表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下，定义作用于这些元素的新操作。\n即，访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。\n访问者模式的结构：\n  ConcreteVisitor（具体访问者）：实现每个有Visitor声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。\nConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。\n  Element（元素）：定义以一个访问者为参数的Accept操作。\n  ConcreteElement（具体元素）：实现以一个访问者为参数的Accept操作。\n  ObjectStructure（对象结构）：能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合。\n  Visitor模式适用于：\n  一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。\n  需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作“污染”这些对象的类。\nVisitor使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。\n  定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。\n改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。\n   题目选项描述：\n需要对一个对象结构中的对象进行很多不同的并且不相关的操作。\n 访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。\n设计模式总结 创建型设计模式（抽象了对象的实例化过程）：\n   名称 关键字 说明     工厂方法 动态生产对象 定义创建对象的接口，由子类实例化对象。   抽象工厂模式 生成系列对象 提供创建一系列对象的接口，无需指定具体的类。   生成器模式 构造复杂对象 将复杂类的构建与表示分离。\n同样的构建可以创建不同的表示。   原型模式 克隆对象 用原型实例指定创建对象的类型，通过复制原型来创建对象。   单例模式 一个实例 保证一个类仅有一个实例，并提供一个全局访问点。    结构型模式（组合类或对象获得新的结构）：\n   名称 关键字 说明     适配器模式 接口转换 将类的接口转换成兼容其他类的接口。   桥接模式 抽象与实现分离 将类的抽象与实现分离，使它们可以独立变化。   组合模式 组合对象 将对象组合成树型结构以表示“部分——整体”的层次结构。\n使得用户对单个对象和组合对象的使用具有一致性。   装饰模式 动态附加职责 动态地给一个对象添加一些额外的职责，比用子类来扩展功能更灵活。   外观模式 对外统一接口 为子系统定义和提供一个统一的对外高层接口（外观）。\n简化了该子系统的使用。   享元模式 共享大量细粒度对象 提供支持大量细粒度对象共享的有效方法。   代理模式 中介代理 为其他对象提供一种代理以控制对这个对象的访问。    行为型模式：\n   名称 关键字 说明     责任链模式 职责传递 将处理请求的多个对象连成一条链，请求在链中传递，直到有对象处理。\n给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。   命令模式 请求封装为对象 将一个请求封装为一个对象，可用不同请求对客户进行参数化。\n将请求排队或记录日志，支持撤销操作。   解释器模式 语句解释 给定一种语言，定义其文法和解释器，解释器根据文法解释语言中的句子。   迭代器模式 顺序访问数据集 提供一个顺序访问聚合对象中元素的方法，不需要暴露对象的内部表示。   中介者模式 不直接引用 用中介对象封装一系列的对象交互。\n使各对象不需显式地相互调用，达到低耦合。\n可以独立改变对象间的交互。   备忘录模式 保存状态 不破坏封装的前提下，捕获对象的内部状态，并在该对象之外保存。\n可以在以后恢复保存的状态。   观察者模式 联动 定义对象间的一种一对多依赖关系。\n一个对象状态改变，所有依赖于它的对象都得到通知并被自动更新。   状态模式 状态封装成类 把对象的行为封装在不同的状态对象中。\n允许一个对象在其内部状态改变时改变它的行为。   策略模式 多方案切换 定义并封装一系列算法，使它们可以在不影响客户端的情况下相互替换。   模板方法模式 框架 定义一个操作中的算法骨架，让其子类来实现算法中的剩余逻辑。\n可以不改变算法结构而重新定义其某些特定步骤。   访问者模式 数据与操作分离 封装作用与某对象结构中元素的操作。\n可以在不改变元素类的前提下，定义或修改作用于这些元素的操作。    ","date":"2023-04-18T00:00:00Z","permalink":"https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"面向对象（软件设计师）"},{"content":"著作权 著作权（也称为版权）：是指作者对其创作的作品享有的人身权和财产权。\n人身权包括：\n 发表权 署名权 修改权 保护作品完整权  财产权包括：\n 作品的使用权 获得报酬   著作权中，发表权有时限，时限是作者终身及其死亡后50年。署名权、修改权、保护作品完整权等不受时间限制，受到永久保护。\n  知识产权的特点 知识产权的特点包括：\n 无形性 双重性 确认性 独占性 地域性 时间性  地域性 各国主管机关依照本国法律授予的知识产权，只能在不国领域内受法律保护。著作权虽然自动产生，但它受地域限制。\n时间性 知识产权具有法定的保护期限。\n例如，我国发明专利的保护期为20年，自专利申请日起计算。\n  我国公民的作品发表权的保护期为作者终生及其死亡后50年。\n  我国商标权的保护期限自核准注册之日起10年内有效。\n但可以根据其所有人的需要无限地延长权利期限：\n 在期限届满前6个月内申请续展注册， 每次续展注册的有效期为10年， 续展注册的次数不限。  商业秘密受法律保护的期限是不确定的。\n   计算机软件著作权 计算机软件著作权有两个对象：\n  主体：指享有著作权的人，包括：\n 公民 法人 其他组织    客体：指著作权法保护的计算机软件著作权的范围（受保护的对象）。\n著作权法保护的计算机软件是指：\n  计算机程序，包括：\n 源程序， 目标程序；    计算机程序有关文档，文档一般以以下形式出现：\n 程序设计说明书， 流程图， 用户手册。      计算机软件著作权受到以下两个法律的保护：\n 《中华人民共和国著作权法》，简称著作权法； 《计算机软件保护条例》。  时限：计算机软件著作权的权利自软件开发完成之日起产生。\n保护条件 《计算机软件保护条例》规定，依法受到保护的计算机软件作品必须符合下列条件：\n  独立创作。\n不可抄袭。使用他人软件作品的逻辑步骤的组合方式，对他人构成侵权。\n  可被感知。\n受保护的软件必须固定在某种有形物体上，例如固定在存储器、磁盘和磁带等设备上，也可以是其他的有形物，如纸张等。\n  逻辑合理。\n软件作品必须具备合理的逻辑思想，并以正确的逻辑步骤表现出来。\n  权利   计算机软件的著作人身权\n 发表权 开发者身份权（也称为署名权）    计算机软件的著作财产权\n 使用权 复制权 修改权 发行权 翻译权 注释权 信息网络传播权 出租权 使用许可权 获得报酬权 转让权    软件合法持有人的权利\n软件的合法复制品所有人享有下述权利：\n 根据使用的需要把软件装入计算机等能存储信息的装置内。 根据需要进行必要的复制。 为了防止复制品损坏而制作备份复制品（不能给他人使用）。 为了把该软件用于实际的计算机应用环境或者改进其功能性能而进行必要的修改。    保护期 计算机软件著作权的权利自软件开发完成之日起产生，保护期为50年。保护期满，除开发者身份权以外，其他权利终止。\n一旦计算机软件著作权超出保护期，软件就进入公有领域。计算机软件著作权人的单位终止和计算机软件著作权人的公民死亡均无合法继承人时，除开发者身份权以外，该软件的其他权利进入公有领域。软件进入公有领域后成为社会公共财富，公众可无偿使用。\n职务作品 职务软件作品是指公民在单位任职期间为热行本单位工作任务所开发的计算机软件作品。\n根据《计算机软件保护条例》可以判断软件作品的归属。\n构成职务软件作品的条件：\n 公民在单位任职期间所开发的软件如果是执行本职工作的结果，即针对本职工作中明确指定的开发目标所开发的，则该软件的著作权属于该单位。 当公民作为某单位的雇员时，如其开发的软件属于执行本职工作的结果，该软件著作权应当归单位享有。 如果该雇员主要使用了单位的设备，著作权不能属于该雇员个人享有。   如果软件作品属于职务软件作品，那开发者只有署名权。\n 构成非职务软件（个人）作品的条件：\n  所开发的软件作品不是执行其本职工作的结果。\n若雇员开发创作的软件不是执行本职工作的结果，则构成非职务计算机软件著作权的条件之一。\n  开发的软件作品与开发者在单位中从事的工作内容无直接联系。\n雇员所开发的软件作品与其本职工作没有直接的关系，则构成非职务计算机软件著作权的第二个条件。\n  开发的软件作品未使用单位的物质技术条件。\n开发软件作品所必须的设备、数据、资金和其他软件开发环境，不属于雇员所在的单位所有。没有使用受雇单位的任何物质技术条件构成非职务软件著作权的第三个条件。\n  委托开发 委托开发的软件作品属于著作权法规定的委托软件作品。委托开发软件作品著作权关系的建立，一般由委托方与受委托方订立合同而成立。\n委托开发软件作品关系中：\n 委托方：主要责任是提供资金、设备等物质条件，并不直接参与开发软件作品的创作开发活动。 受托方：主要责任是根据委托合同规定的目标开发出符合条件的软件。  接受他人委托开发的软件，其著作权的归属由委托者与受委托者签订书面合同约定：无书面合同或者合同未作明确约定的，其著作权由受托人享 有。\n委托开发的软件著作权的归属按以下标准确定：\n 软件著作权的归属应当根据委托开发软件的合同来确定。 若没有签订书面协议，或者在协议中未对软件著作权归属作出明确的约定，则软件著作权属于受委托者，即属于实际完成软件的开发者。  侵权行为 计算机软件著作权侵权行为：\n  未经软件著作权人的同意而发表或者登记其软件作品。\n侵犯著作权人的发表权。\n  将他人开发的软件当作自己的作品发表或者登记。\n侵犯开发者身份权和署名权。\n  未经合作者的同意将与他人合作开发的软件当作自己独立完成的作品发表或者登记。\n合作开发的软件，软件作品的发表权也应由全体开发者共同行使。\n  在他人开发的软件上署名或者更改他人开发的软件上的署名。\n侵犯了软件著作人的开发者身份权及署名权。\n  未经软件著作权人或者其合法受让者的许可，修改、翻译其软件作品。\n侵犯了著作权人或其合法受让者的使用权中的修改权、翻译权。\n如果征得软件作品著作人的同意，修改和改善新增加的部分，创作者应享有著作权。\n  未经软件著作权人或其合法受让者的许可，复制或部分复制其软件作品。\n侵犯了著作权人或其合法受让者的使用权中的复制权。\n  未经软件著作权人及其合法受让者同意，向公众发行、出租其软件的复制品。\n此种行为侵犯了著作权人或其合法受让者的发行权与出租权。\n  未经软件著作权人或其合法受让者同意，向任何第三方办理软件权利许可或转让事宜。\n侵犯了软件著作权人或其合法受让者的使用许可权和转让权。\n  未经软件著作权人及其合法受让者同意，通过信息网络传播著作权人的软件。\n侵犯了软件著作权人或其合法受让者的信息网络传播权。\n   商业秘密权 商业秘密的定义：“指不为公众所知悉的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息”。\n商业秘密的基本内容：\n 经营秘密：未公开的经营信息，是指与生产经营销售活动有关的经营方法、 管理方法、产销策略、货源情报、客户名单、标底和标书内容等专有知识。 技术秘密：未公开的技术信息，是指与产品生产和制造有关的技术诀窍、生产方案、工艺流程、设计图纸、化学配方和技术情报等专有知识。  商业秘密的构成条件：\n 必须具有未公开性，即不为公众所知悉； 必须具有实用性，即能为权利人带来经济效益； 必须具有保密性，即采取了保密措施。  商业秘密的丧失：一项商业秘密受到法律保护的依据是必须具备上述构成商业秘密的3个条件，当缺少上述3个条件之一时就会造成商业秘密丧失保护。\n 专利权 专利申请的原则：\n 专利申请人及其代理人在办理各种手续时都应当采用书面形式。 遵循“一份申请一项发明”原则。 多人就同样的发明创造申请专利的，专利权授给最先申请人。 相同的发明，多人同时申请，由所有申请人协商确定专利权归属。  专利的时限（均自申情日起计算）：\n  发明专利权 20年   实用新型专利权 10年   外观设计专利权 15年   商标权   商标权保护期限自核准注册之日起10年内有效。\n  商标权保护期限可以根据其所有人的需要无限地延长权利期限。\n在期限届满前6个月内申请续展注册，每次续展注册的有效期为10年，续展注册的次数不限。\n如果商标权人逾期不办理续展注册，其商标权也将终止。\n  商标权注册先申请注册先得，同一天申请先使用商标先得，都没使用过则协商。\n","date":"2023-04-15T12:29:35+08:00","permalink":"https://blog.linner.asia/p/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"知识产权（软件设计师）"},{"content":"概述 计算机系统由两部分组成：\n 硬件 软件  通常把未配置软件的计算机称为裸机。\n操作系统（Operating System）目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。\n操作系统也包括了系统软件。\n操作系统在计算机系统中的地位：\n操作系统是用户与计算机之间的接口，它在计算机系统中占据重要而特殊的地位，所有其他软件，如编辑程序、汇编程序、编译程序、数据库管理系统等系统软件，以及大量的应用软件都是建立在操作系统基础上的，并得到它的支持和取得它的服务。\n 进程管理 进程管理也称处理机管理。在多道程序批处理系统和分时系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了进程。进程是资源分配和独立运行的基本单位。\n进程有两个基本属性：\n 可拥有资源的独立单位； 可独立调度和分配的基本单位。  程序执行顺序 程序顺序执行 前驱图是一种有向无循环图，由结点和有向边组成：\n 结点：代表各程序段的操作； 有向边：表示两个程序段（结点）操作之间存在的前驱关系（$\\rightarrow$）。  前驱关系：\n程序段$P_i$和$P_j$的前趋关系表示成$P_i \\rightarrow P_j$，其中，$P_i$是$P_j$的前驱，$P_j$是$P_i$的后继，其含义是：\n$P_i$执行结束后$P_j$才能执行。例如，输入、计算和输出：\n程序顺序执行时的主要特征包括：\n 顺序性 封闭性 可再现性  程序并发执行 若在计算机系统中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。\n虽然每个作业有前趋关系的各程序段不能在CPU和输入/输出各部件（同一个部件）中并行执行，但是同一个作业内没有前趋关系的程序段或不同作业的程序段可以分别在CPU和各输入/输出部件上（不同部件中）并行执行。\n例如，某系统中有一个CPU、一台输入设备和一台输出设备，每个作业具有3个程序段输入Ii、计算Ci和输出Pi（i = 1，2，3）。其前驱图如（其中，在同一垂直方向上的作业并行执行）：\n程序并发执行时的特征：\n 失去了程序的封闭性； 程序和机器的执行程序的活动不再一一对应； 并发程序间的相互制约性。  程序并发执行带来的问题：并发程序间共享了变量，破坏了程序的封闭性和可再现性。\n并发程序的问题可以通过研究进程间的同步和互斥解决。\n进程的三态模型 在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化，因此进程一般有3种基本状态：\n 运行：当一个进程在处理机上运行时。 就绪：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行（还未得到）。 阻塞（等待或睡眠）：一个进程正在等待某一事件发生而暂时停止运行，这时即使把处理机分配给进程也无法运行。  进程间的通信 在多道程序环境的系统中存在多个可以并发执行的进程，故进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。\n同步和互斥   同步：合作进程间的直接制约问题。\n进程间的同步：是指在系统中一些需要相互合作，协同工作的进程，这样的相互联系称为进程的同步。\n例如，进程A向缓冲区送数据，进程B从缓冲区取数据加工，当进程B要取数据加工时，必须是进程A完成了向缓冲区送数据的操作，否则进程B必须停下来等待进程A的操作结束。\n  互斥：申请临界资源进程间的间接制约问题。\n进程间的互斥：是指系统中多个进程因争用临界资源而互斥执行。\n 临界资源（Critical Resource，CR）：在多道程序系统环境中，那些一次只能供一个进程使用的资源。如打印机、共享变量和表格等。\n   临界区管理的原则：\n 临界区（Critical Section，CS）：是进程中对临界资源实施操作的那段程序。\n 对互斥临界区管理的4条原则如下：\n 有空即进：当无进程处于临界区时，允许进程进入临界区，并且只能在临界区运行有限 的时间。 无空则等：当有一个进程在临界区时，其他欲进入临界区的进程必须等待，以保证进程互斥地访问临界资源。 有限等待：对于要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免陷入“饥饿”状态。 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等状态。  信号量机制 信号量机制是一种有效的进程同步与互斥工具。\n信号量机制主要有：\n 整型信号量 记录型信号量 信号量集机制  整型信号量：\n信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为如下两类：\n 公用信号量：实现进程间的互斥，初值为1或资源的数目。 私用信号量：实现进程间的同步，初值为0或某个正整数。  信号量$S$的物理意义：\n $S \\ge 0$：表示某资源的可用数，此时有可用资源； $S \u0026lt; 0$：则其绝对值表示阻塞队列中等待该资源的进程数，此时无可用资源，并且有进程被阻塞。  PV操作 PV操作：实现进程同步与互斥的常用方法。\nP操作和V操作是低级通信原语，在执行期间不可分割。其中：\n  P操作（减）：表示申请一个资源；\n定义：$S := S-1$（$S$表示信号量）。\n $S \\ge 0$：执行P操作的进程继续执行； $S \u0026lt; 0$：无可用资源，置该进程为阻塞状态，并将其插入阻塞队列。    V操作（加）：表示释放一个资源。\n定义：$S := S+1$。\n $S \u0026gt; 0$：执行V操作的进程继续执行； $S \\le 0$：表示释放前有程序被阻塞，从阻塞状态唤醒一个进程，并将其插入就绪队列，然后执行V操作的进程继续。    利用PV操作实现进程的互斥：\n 令信号量mutex的初始值为1； 进入临界区：执行P操作； 推出临界区：执行V操作。  利用PV操作实现进程的同步：\n实现进程的同步可用一个信号量与消息联系起来。\n信号量的值：\n 为0：表示希望的消息未产生； 非0：表示希望的消息已经存在。  假定信号量S表示某条消息，进程可以：\n 调用P操作：测试消息是否到达； 调用V操作：通知消息已经准备好。  例如：\n 生产者进程$P_1$：不间断地生产产品送入缓冲区； 消费者进程$P_2$：不断地从缓冲区中取产品消费。  为实现$P_1$与$P_2$间同步问题，分别设置信号量：\n $S_1$：初值为1，表示缓冲区空，可以将产品送入缓冲区； $S_2$：初值为0，表示缓冲区有产品。  同步过程如图：\n若缓冲区可存放$n$件产品，生产者不断生产，消费者不断消费。可以设置3个信号量：\n $S$：互斥信号量，初值为1； $S_1$：表示是否可以将产品放入缓冲区，初值为$n$； $S_2$：表示缓冲区是否存有产品，初值为0。  其同步过程如图：\n死锁现象 死锁是指两个以上的进程互相都要请求对方己经占有的资源，导致这些进程都无法继续运行下去的现象。\n产生死锁的原因有：\n  进程间互相竞争资源：\n多个进程所共享的资源不足以满足它们的需求时，将引起它们对资源的竞争，从而导致死锁。\n  进程推进顺序非法：\n进程在运行的过程中请求和释放资源的顺序不当，从而导致死锁。\n  产生死锁的4个必要条件：\n 互斥条件 请求保持条件 不可剥夺条件 环路条件  发生死锁时，在进程资源有向图中必构成环路（每个进程占有了下一个进程申请的一个或多个资源），如：\n  资源：用方框表示资源的集合，方框中的圆圈表示资源；\n  进程：用圆圈表示；\n  有向边：\n  请求资源：箭头由进程指向资源\n$$ \\bigcirc \\rightarrow \\Box $$\n  分配资源：箭头由资源指向进程\n$$ \\bigcirc \\leftarrow \\Box $$\n    造成死锁的情况有：\n  进程推进顺序不当：\n设有两个互斥资源$A$和$B$被两个并发执行的进程$P_1$和$P_2$共享。假如它们按照如下次序请求，则系统会发生死锁：\n $P_1.Request(A)$：请求成功，资源$A$被$P_1$占用； $P_2.Request(B)$：请求成功，资源$B$被$P_2$占用； $P_1.Request(B)$：请求失败，资源$B$已被$P_2$占用； $P_2.Request(A)$：请求失败，资源$A$已被$P_1$占用。   上述请求顺序中，1和2的顺序可以交换，3和4的顺序可以交换。\n   同类资源分配不当：\n $m$：资源数， $n$：进程数， $k$：每个进程都要求的资源数。  若满足$m \\ge n \\times (k-1) + 1$，则不会发生死锁。\n若每个进程要求的资源数不同，为$k_i$（$i = 1,2,\\cdots,n$），那么此时可能会引起死锁的原因是：\n$$ m \u0026lt; \\sum_{i=1}^{n}{k_i} $$\n  PV操作使用不当：\n如图：\n当信号量$S_1=S_2=0$时将发生死锁。\n $P_2.P(S_2)$：执行前$S_2 = 0$，执行后$S_2 = -1$，$P_2$等待； $P_1.P(S_1)$：执行前$S_1 = 0$，执行后$S_1 = -1$，$P_1$等待。  此时$P_1$和$P_2$都无法继续运行，造成死锁。\n  死锁的处理 死锁的处理策略主要有4种：\n 鸵鸟策略（不理睬策略） 预防策略 避免策略 检测与解除死锁  死锁预防：\n死锁预防是采用某种策略限制并发进程对资源的请求，破坏死锁产生的4个必要条件之一，严格防止死锁的产生，使系统在任何时刻都不满足死锁的必要条件。预防死锁的两种策略如下：\n  预先静态分配法：破坏了“不可剥夺条件”，预先分配所需资源，保证不等待资源。\n该方法的问题是降低了对资源的利用率，降低进程的并发程度；有时可能无法预先知道所需资源。\n  资源有序分配法：破坏了“环路条件”，把资源分类按顺序排列，保证不形成环路。\n该方法存在的问题是限制进程对资源的请求：由于资源的排序占用系统开销。\n  死锁避免：\n比起死锁预防，死锁避免则不那么严格地限制产生死锁的必要条件。最著名的死锁避免算法是银行家算法，死锁避免算法需要很大的系统开销。\n银行家算法 银行家算法对于进程发出的、每一个系统可以满足的资源请求命令加以检测，若分配资源后系统：\n 进入不安全状态，则不予分配； 仍处于安全状态，则实施分配。  与死锁预防策略相比，银行家算法提高了资源的利用率，但对于分配资源后系统是否安全的检测，增加了系统开销。\n  安全状态：指系统能按某种顺序如$\u0026lt;P_1, P_2, \\cdots, P_n\u0026gt;$来为每个进程分配其所需资源，直到最大需求，使每个进程都可顺序完成。\n通常称$\u0026lt;P_1, P_2, \\cdots, P_n\u0026gt;$序列为安全序列。\n  不安全状态：若系统不存在这样一个安全序列，则称系统处于不安全状态。\n  假设系统有$n$个进程（$P_i, i = 1, 2, \\cdots, n$），使用银行家算法求系统安全序列的一般步骤为：\n  根据目前可用资源数和仍需资源数求得序列当前的第$k$（$1 \\le k \\le n$）个进程应为$P_i$。\n $P_i$的仍需资源数$\\le$系统可用资源数。\n   根据$P_i$的已分配资源数 + 分配前系统可用资源数，求出系统执行完$P_i$后的可用资源数。\n 系统执行完$P_4$后，会释放$P_4$占用的资源。\n   重复执行步骤1到步骤2，直到能判断系统处于安全状态还是不安全状态。若为安全状态，则可求出安全序列。\n  假设系统种有三类互斥资源$R_1$、$R_2$和$R_3$，可用资源数分别为8、7和4。在$T_0$时刻系统种有$P_1$、$P_2$、$P_3$、$P_4$和$P_5$这5个进程，这些进程对资源的最大需求量和已分配资源数如图：\n由上图可得系统的仍需资源数（最大需求量 - 已分配资源数）为：\n   $R_1$ $R_2$ $R_3$     5 3 1   0 1 1   6 0 1   1 0 0   2 3 1    可得系统目前可用资源数（可用资源数 - 所有进程的最大需求量）：\n   $R_1$ $R_2$ $R_3$     1 1 0    求出安全序列的过程：\n  根据目前可用资源数和仍需资源数可得序列中第1个进程应为$P_4$。\n 因为$P_4$仅仅只需要再分配一个$R_1$，而系统目前恰好剩余1个$R_1$和$R_2$。\n 系统执行完$P_4$后，会释放$P_4$占用的资源，那么此时系统可用资源数为（已分配资源数 + 分配前可用资源数）：\n   $R_1$ $R_2$ $R_3$     2 3 1      与上一步类似，可求得序列中第2个进程为$P_2$或$P_5$。\n  若为$P_2$，执行完$P_2$后，系统可用资源数为：\n   $R_1$ $R_2$ $R_3$     4 4 2      若为$P_5$，执行完$P_5$后，系统可用资源数为：\n   $R_1$ $R_2$ $R_3$     3 4 2        根据上一步，有两个可能的安全序列：\n 若序列的上一个进程为$P_2$，序列的第3个进程为$P_5$。 若序列的上一个进程为$P_5$，序列的第3个进程为$P_2$。  此时，无论当前序列为$\u0026lt;P_4, P_2, P_5\u0026gt;$还是$\u0026lt;P_4, P_5, P_2\u0026gt;$，它们执行完序列的第3个进程后，系统可用资源数都为：\n $R_1$|$R_2$|$R_3$ :---:|:---:|:---: 5 |5 |3    根据上一步的系统可用资源数，上一步所得的两个序列的第4个进程都为$P_1$。\n此时，它们执行完$P_1$后，系统可用资源数为：\n   $R_1$ $R_2$ $R_3$     6 6 4      两个序列的第4个进程都为$P_3$。\n它们执行完$P_3$后，系统可用资源数为：\n   $R_1$ $R_2$ $R_3$     8 7 4    此时系统可用资源数与检测前的可用资源数相等，即所有资源都被释放，没有被任何进程占用。\n那么该系统处于安全状态，且一共有两个安全序列，分别为：\n $\u0026lt;P_4, P_2, P_5, P_4, P_3\u0026gt;$； $\u0026lt;P_4, P_5, P_2, P_4, P_3\u0026gt;$。    线程  传统进程有两个基本属性：\n 可拥有资源的独立单位； 可独立调度和分配的基本单位。   引入线程的原因是，进程的系统必须付出较大的时空开销。引入线程后，将传统进程的两个基本属性分开：\n 线程：作为调度和分配的基本单位； 进程：作为独立分配资源的单位。  线程是进程中的一个实体，是被系统独立分配和调度的基本单位。\n线程的特点：\n 线程基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈），它可与同属一个进程的其他线程共享进程所拥有的全部资源。 线程也具有就绪、运行和阻塞3种基本状态。 线程可创建另一个线程。 同一个进程中的多个线程可并发执行。  线程因其具有许多传统进程所具有的特性，故称为\u0026quot;轻型进程（Light-Weight Process）\u0026quot;；而传统进程称为\u0026quot;重型进程（Heavy-Weight Process）\u0026quot;。\n线程分为：\n 用户级线程（User-Level Threads）：不依赖于内核，该类线程的创建、撤销和切换都不利用系统调用来实现； 内核支持线程（Kernel-Supported Threads）：依赖于内核，即无论是在用户进程中的线程，还是在系统中的线程，它们的创建、撤销和切换都利用系统调用来实现。  某些系统同时实现了两种类型的线程。\n 与线程不同的是，不论是系统进程还是用户进程，在进行切换时，都要依赖于内核中的进程调度。因此，不论是什么进程都是与内核有关的，是在内核支持下进行切换的。\n  存储管理 程序局部性原理 程序在执行时将呈现出局部性规律，即在一段时间内，程序的执行仅局限于某个部分。相应地，它所访问的存储空间也局限于某个区域内。\n程序的局限性表现在以下两个方面：\n  时间局限性：\n 如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行； 如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。  产生时间局限性的典型原因是在程序中存在着大量的循环操作。\n  空间局限性：指一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。\n即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为程序是顺序执行的。\n  分页存储管理 分页原理：\n 页：将一个进程的地址空间划分成若干个大小相等的区域，称为页。 块（页框）：将主存空间划分成与页相同大小的若干个物理块，称为块或页框。  在为进程分配主存时，将进程中若干页分别装入多个不相邻接的块中。\n地址结构：\n其中，页内地址是同一页（页号）中的偏移量。\n分页的过程是由操作系统完成的，对用户是透明的，所以用户不必关心分页的过程，其优点是能有效地提高主存利用率，其缺点是不易实现共享。\n分段存储管理 在分段存储管理方式中，作业的地址空间被划分为若干个段。每个段是一组完整的逻辑信息，例如有主程序段、子程序段、数据段及堆栈段等。每个段都有自己的名字，都是从0开始编址的一段连续的地址空间，各段的长度是不等的。\n分段系统的地址结构如：\n段是信息的逻辑单位，其优点是易于实现段的共享，即允许若干个进程共享一个或多个段，而且对段的保护也十分简单。\n段页式存储管理 结合分页和分段存储管理方式，形成一种新的存储管理方式，即段页式存储管理。段页式系统有两种系统的优点。\n段页式系统的基本原理是：\n 将整个主存划分成大小相等的存储块（页框）。 将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名。 将每个段划分成若干页，以页框为单位离散分配。  段页式地址空间的结构：\n 设备管理 缓冲技术 缓冲技术可提高外设利用率，尽可能使外设处于忙状态。缓冲技术可以采用两种方式：\n 硬件缓冲：利用专门的硬件寄存器作为缓冲； 软件缓冲：通过操作系统来管理的。  单缓冲 单缓冲工作过程图：\n当第1块数据送入用户工作区后（进行数据处理），缓冲区是空闲的，可以传送第2块数据（输入）。即第1块数据的处理$C_1$与第2块数据的输入$T_2$是可以并行的，以此类推：\n若$T$为输入的时间，$M$为传输的时间，$C$为处理的时间系统对每一块数据的处理时间为：$Max(C, T) + M$：\n $T \u0026gt; C$：处理时间为$M + T$； $T \u0026lt; C$：处理时间为$M + C$。  $n$个作业的单缓冲所花费的时间为：\n$$ (Max(C, T) + M) \\times n + Min(C, T) $$\n双缓冲 双缓冲进一步加快了I/O的速度，提高了设备的利用率。其工作基本过程是在设备输入时，先将数据输入到缓冲区1，装满后便转向缓冲区2。\n双缓冲工作过程图：\n双缓冲的工作特点是，可以实现对缓冲中数据的输入$T$和提取$M$，与CPU的计算$C$，三者并行工作：\n在双缓冲时，系统处理一块数据的时间可以粗略地认为是$Max(C, T)$：\n $C \u0026lt; T$：可使块设备连续输入； $C \u0026gt; T$：可使系统不必等待设备输入。  $n$个作业的双缓冲所花费的时间为：\n$$ Max(T, M, C) \\times n + T + M + C - Max(T, M, C) $$\n即，\n$$ Max(T, M, C) \\times (n - 1) + T + M + C $$\n磁盘调度算法   先来先服务（First-Come First-Served，FCFS）：根据进程请求访问磁盘的先后次序进行调度。\n 优点：公平、简单，且每个进程的请求都能依次得到处理，不会出现某进程的请求长期得不到满足的情况。 缺点：此算法由于未对寻道进行优化，致使平均寻道时间可能较长。    最短寻道时间优先（Shortest Seek Time First，SSTF，最短移臂算法）：该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，使得每次的寻道时间最短。\n 优点：可能会出现饥饿现象。 缺点：不能保证平均寻道时间最短。    扫描算法（SCAN，电梯调度算法）：总是从磁头当前位置开始，沿磁头的移动方向去选择离当前磁头最近的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。\n在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。\n 优点：避免了饥饿现象的出现。 缺点：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，再从外向里扫描完所有要访问的磁道后才处理该进程的请求，致使该进程的请求被严重地推迟。    单向扫描算法（CSCAN，循环扫描算法）：为了减少上述SCAN缺点中存在的这种延迟，算法规定磁头只做单向移动。\n例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。\n  旋转调度算法 旋转调度要考虑的问题是，当移动臂定位后，有多个进程等待访问该柱面时，应当如何决定这些进程的访问顺序。显然，系统应该选择延迟时间最短的进程对磁盘的扇区进行访问。\n当有若干等待进程请求访问磁盘上的信息时，旋转调度应考虑如下情况：\n 进程请求访问的是同一磁道上不同编号的扇区。 进程请求访问的是不同磁道上不同编号的扇区。 进程请求访问的是不同磁道上具有相同编号的扇区。  对于情况1和2，旋转调度总是让首先到达读/写磁头位置下的扇区先进行传送操作：对于情况3，旋转调度可以任选一个读/写磁头位置下的扇区进行传送操作。\n例如：\n假设磁盘旋转速度为20ms/圈，每读一个记录后处理需要4ms。若格式化时每个磁道被分为10个扇区，有10个逻辑记录存放在同一磁道上，其排序顺序如下图所示：\n初始时读写头停在记录A处，程序顺序处理这些记录（A～J）。\n顺序处理完这些记录的总时间：\n  经过一个扇区的时间 $= 20ms /10 = 2ms$。\n  处理完A，磁盘转到读写头指向B开始处时，这个过程的时间为$2ms + 20ms = 22ms$。\n因为磁盘是一直在旋转的，而读取A扇区（2ms）后，处理A扇区花费4ms。此时磁盘可以再经过两个扇区，来到记录D的开始处。\n为了顺序处理记录，磁盘需要再旋转8个扇区回到B开始处。相当于处理完A后磁盘需要再旋转一圈以开始读取B。这样一个过程所耗费的时间即为$2ms + 20ms = 22ms$。\n  顺序处理完所有记录的总时间 $= 9 \\times (2ms + 20ms) + 2ms + 4ms = 204ms$。\n前9个记录（A～J）的一个过程所耗费的时间是一样的（$ 9 \\times (2ms + 20ms)$）。\n当处理完记录I并旋转到J开始处时，只需要读取J（2ms）并且处理完（4ms）即可。这个过程的时间应为（$2ms + 4ms$）。\n  记录优化分布方案：\n让下一个要读取的记录，刚好在上一个记录处理完成后读写头所停的扇区。\n优化后的总时间 $= 10 \\times (2ms + 4ms) = 60ms$。\n设$n$个扇区的磁盘，经过一个扇区的时间为$t$，读取一个记录后处理的时间为$c$，那么：\n  顺序处理完所有记录的总时间为：\n$$ (t + nt) (n-1) + t + c $$\n即：\n$$ t \\times n^2 + c $$\n  记录优化后的总时间：\n$$ n(t + c) $$\n   文件管理 多级索引结构 磁盘索引是指在索引表中记录磁盘的地址项，地址项直接或间接地记录了磁盘数据块的地址。\n磁盘索引有以下几种结构：\n  直接索引：索引表中的地址项直接指向磁盘数据块。\n  一级间接地址索引：索引表中的地址项指向一个磁盘索引块。这个索引块中的记录是地址项，这些地址项直接指向磁盘数据块。\n称这个磁盘索引块为一级索引块。\n  二级间接地址索引：索引表中的地址项指向一个磁盘索引块。这个索引块中的一个记录指向一个一级索引块。\n称这个记录指向一级索引块的磁盘索引块为二级索引块。\n  文件目录   文件控制块（FCB）：用于文件的描述和控制的数据结构，实现了文件的“按名存取”。\n文件控制块至少要包括文件名和存放文件的物理地址。\n文件控制块也称为文件的说明或文件目录项（简称目录项）。\n  文件目录：文件控制块的有序集合。\n即文件目录是由文件控制块组成的，专门用于文件的检索。\n  文件控制块 文件控制块中包含以下信息：\n  基本信息类：例如文件名、文件的物理地址、文件长度和文件块数等。\n  存取控制信息类：文件的存取权限。\nUNIX中，用户分成三类：\n 文件主用户 同组用户 一般用户  以上三类用户对文件的权限为：\n 读 写 执行    使用信息类：文件建立日期、最后一次修改日期、最后一次访问的日期、当前使用的 信息（如打开文件的进程数、在文件上的等待队列）等。\n  目录结构 组织好文件的目录是设计文件系统的重要环节，文件目录结构的组织方式直接影响到文件的存取速度，关系到文件的共享性和安全性。\n常见的目录结构有：\n  一级目录结构：一级目录的整个目录组织是一个线性结构，在整个系统中只需建立一张目录表，系统为每个文件分配一个目录项。\n优点：结构简单；\n缺点：查找速度慢，不允许重名和不便于实现文件共享等。\n主要用在单用户环境中。\n  二级目录结构：为了克服一级目录结构存在的缺点引入了二级目录结构。\n二级目录结构的组成为：\n 主文件目录（Master File Directory，MFD）：每个用户文件目录都占有一个目录项，其目录项中包括用户名和指向该用户目录文件的指针； 用户目录（User File Directory，UFD）：由用户所有文件的目录项组成的。  优点：提高了检索目录的速度，较好地解决了重名问题。\n缺点：该结构虽然能有效地将多个用户隔离开（这种隔离在各个用户之间完全无关时是一个优点），但当多个用户之间要相互合作去共同完成一个大任务，且一个用户又需要去访问其他用户的文件时，这种隔离便成为一个缺点，因为这种隔离使诸用户之间不便于共享文件。\n  多级目录结构：在多道程序设计系统中常采用多级目录结构。\n多级目录结构是树型目录结构。从根结点向下，每一个结点是一个目录，叶结点是文件。\n在采用多级目录结构的文件系统中，用户要访问一个文件，必须指出文件所在的路径名：\n  路径名：从某个目录开始到该文件的通路上所有各级目录名拼起来得到的。\n在各目录名之间、目录名与文件名之间需要用分隔符隔开。\n  绝对路径名（Absolute Path Name）：指从根目录开始的完整路径。\n全文件名：指绝对路径名加上该文件的文件名。\n  相对路径名：从当前所在目录开始到其他目录或文件的路径。\n    位示图 位示图（Bitmap）是一种空闲空间管理方法。通过在外存上建立一张位示图，记录文件存储器的使用情况。\n位示图用二进制的一位来表示一个物理块的使用情况：\n 0：表示空闲； 1：表示占用。  例如：\n位示图的大小由磁盘空间的大小（物理块总数）决定。\n位示图的描述能力强，适合各种物理结构。\n","date":"2023-04-12T16:28:00+08:00","permalink":"https://blog.linner.asia/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"操作系统（软件设计师）"},{"content":"复杂度 大O表示法 算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。\n 加法规则：多项相加，保留最高阶项，并将系数化为1； 乘法规则：多项相乘都保留，并将系数化为1。  递归式的时间（空间）复杂度：\n$$ 递归的次数 \\times 每次递归的时间（空间）复杂度 $$\n渐进符号 可以用渐进符号来表示渐进复杂度。\n渐进符号包括：\n  $O$：算法运行时间的渐进上界。\n给定一个函数$g(n)$，$O\\big( g(n) \\big) = \\{ f(n):\\exists 正常数c和n_0,使得\\forall n \\ge n_0, 有 0 \\le f(n) \\le cg(n) \\}$。\n即，当$n \\ge n_0$时，$f(n) \\le c \\cdot g(n)$。\n  $\\Omega$：算法运行时间的渐进下界。\n给定一个函数$g(n)$，$O\\big( g(n) \\big) = \\{ f(n):\\exists 正常数c和n_0,使得\\forall n \\ge n_0, 有 0 \\le cg(n) \\le f(n) \\}$。\n即，当$n \\ge n_0$时，$c \\cdot g(n) \\le f(n)$。\n  $\\Theta$：算法运行时间的渐进上界和渐进下界，即渐进紧致界（又叫紧缺界）。\n给定一个函数$g(n)$，$O\\big( g(n) \\big) = \\{ f(n):\\exists 正常数c_1、c_2和n_0,使得\\forall n \\ge n_0, 有 0 \\le c_1g(n) \\le f(n) \\le c_2g(n) \\}$。\n即，当$n \\ge n_0$时，$c_1g(n) \\le f(n) \\le c_2g(n)$。\n  逻辑结构分类  线性结构  线性表（一般线性表） 特殊线性表  栈 队列 字符串   线性表的推广  数组 广义表     非线性结构  树结构  二叉树 多叉树   图结构  有向图 无向图   集合结构     线性表 由 $n(n\\geq 0)$ 个数据特性相同的元素构成的有限序列称为线性表。$n=0$ 时，称为空表。非空表的特点如下：\n 存在唯一一个“第一个”元素。 存在唯一一个“最后一个”元素。 相邻元素之间存在序偶关系：  除第一个之外，结构中的每个数据元素均只有一个前驱； 除最后一个之外，结构中的每个数据元素均只有一个后继。    线性表的存储结构分为：\n 顺序存储； 链式存储  顺序存储结构 线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。在这种存储方式下，元素间的逻辑关系无须占用额外的空间来存储。\n其存储结构如图所示：\n假设线性表的每个元素占用的存储空间为$L$，$LOC(a_i)$为第$i$个元素的存储位置（$0 \\le i \\le n-1$，$n$为线性表的长度）：\n  第$i+1$个元素和第$i$个元素的存储位置满足：\n$$ LOC(a_{i+1})=LOC(a_i)+L $$\n  第$i$个元素的存储位置：\n$$ LOC(a_i)=LOC(a_0) + i \\times L $$\n如果下标从1开始：\n$$ LOC(a_i)=LOC(a_1) + (i-1) \\times L $$\n  顺序存储结构的线性表的特点：\n 优点：可以随机存取表中的元素，不需要额外的存储空间来表达元素之间的逻辑关系； 缺点：插入和删除操作不方便、效率低、比较耗时（插入和删除操作需要移动元素），顺序表的长度是固定的。  在表厂为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：\n  在第$i$个插入位置插入，需要移动$n+1-i$个元素。\n 在第1个位置插入（$a_1$）需要移动$n$个元素； 在第$n+1$个位置插入（$a_n$后面）不需要移动元素。    设在第$i$个插入位置插入的概率为$p_i$，等概率下（假如这$n+1$个插入位置插入的概率相同）插入一个新元素需要移动的元素个数的期望值$E_{insert}$为：\n$$ E_{insert} = \\sum_{i=1}^{n+1}{ \\Big( p_i \\times (n-i+1) \\Big) } = \\cfrac{1}{n+1} \\sum_{i=1}^{n+1}{(n-i+1)} = \\cfrac{n+1}{2} $$\n$$ p_i = \\cfrac{1}{n+1} $$\n即，$E_{insert} = \\cfrac{插入位置数-1}{2} = \\cfrac{n+1}{2}$\n  在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：\n  删除第$i$个元素$a_i$需要移动$n-i$个元素。\n 删除元素$a_1$需要移动$n-1$个元素； 删除元素$a_n$不需要移动元素。    设$a_i$被删除的概率为$q_i$，等概率下删除元素时需要移动的元素个数的期望值$E_{delete}$为：\n$$ E_{delete} = \\sum_{i=1}^{n}{\\Big( q_i \\times (n-i) \\Big)} = \\cfrac{1}{n} \\sum_{i=1}^{n}{(n-i)} = \\cfrac{n-1}{2} $$\n$$ q_i = \\cfrac{1}{n} $$\n即，$E_{delete} = \\cfrac{删除位置数}{2} = \\cfrac{n-1}{2}$\n  插入操作时间复杂度：\n 最好情况（在第$n+1$个位置插入）：$O(1)$； 最坏情况（在第1个位置插入）：$O(n)$； 平均复杂度：$O(n)$。  查找元素时间复杂度（根据下标查找）：$O(1)$。\n链式存储结构 线性表的链式存储是指通过指针链接起来的结点来存储数据元素。\n其存储结构如下所示：\n  数据域：用于存储数据元素的值；\n  指针域：用于存储当前元素的直接前驱或直接后继的位置信息（直接前或后驱的指针，称其为指针或链）。\n存储各数据元素的结点的地址并不要求是连续的，因此存储数据元素的同时必须存储元素之间的逻辑关系。\n  链式表的特点：\n 结点空间只有在需要的时候才申请，无须事先分配； 长度不固定。  链式表结点之间通过指针域构成一个链表，若结点中只有一个指针域，则称为线性链表。\n上图中的Head：一个指向链表第一个结点的针，称为头指针。使用它就可以顺序地访问到表中的任意一个元素。\n插入和删除操作时间复杂度（带不带头节点的复杂度都一样）：\n 最好情况（在$i=1$位置）：$O(1)$； 最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$ 平均复杂度：$O(n)$  链表操作的时间复杂度取决于指针遍历。\n 栈 栈是一种后入先出（Last In First Out，LIFO）的线性表。栈只能通过访问它的一端来实现数据存储和检索。\n栈的基本操作有：\n 入栈：将元素置入栈顶； 出栈：将元素从栈顶中取出。 读取栈顶元素  栈的出栈顺序一定和入栈顺序相反。\n顺序存储结构 栈的顺序存储结构也称为顺序栈。\n顺序栈使用一个栈顶指针标记栈顶元素的索引位置。每次出栈时都需要重置栈顶指针，将栈顶指针向下移动，标记到新的栈顶元素。\n顺序栈的空间容量有限，所以每次入栈时都需要判断栈是否为满。\n链式存储结构 栈的链式存储结构称为链栈。链栈的头指针就是栈顶指针。\n栈的应用 栈的典型应用包括表达式求值、括号匹配等，在计算机语言的实现以及将递归过程转变为非递归过程的处理中，栈有重要的作用。\n 队列 队列是一种先入先出（First In First Out，FIFO）的线性表。\n队列只允许在表的一端插入元素，在表的另一端删除元素。\n 队头（Front）：允许删除元素的一端； 队尾（Rear）：允许插入元素的一端。  队列的基本操作有：\n 入队：将元素加入到队尾； 出队：将元素加入到对头。  队列的入队顺序一定等于出队顺序。\n 使用两个栈可以来模拟一个队列（从一个栈出栈后的元素入另一个栈后再出栈）。\n 顺序存储结构 队列的顺序存储结构称为顺序队列。\n顺序队列设置两个指针：\n 队头指针：指向对头元素的下标； 队尾指针：指向队尾元素的下标。  如果顺序队列只按照数组下标大小顺序来设置指针（对头指针的值永不大于队尾指针），那么在经过一段时间的操作后，对头指针有可能指向的并不是数组的第一个元素，此时队列的长度永远都到达不了数组的长度（空间无法被充分利用，实际使用的长度和逻辑长度不符）。\n为了解决这个问题，我们可以把数组想象为一个环型的结构（将最后一个元素和第一个元素连接起来，队头指针可以比队尾指针大）。如果此时队列的状态是上图中步骤$(e)$的状态，此时再插入元素，可以将元素放在数组索引0的位置，再让队尾指针始终保持在队列最后一个元素的索引之后即可。将这种队列称为循环队列，如：\n链式存储结构 队列的链式存储也称为链队列（链队）。这里为了便于操作，可以给链队列添加一个头结点，并令头指针指向头结点。因此，队列为空的判定条件是头指针和尾指针的值相同，且 均指向头结点。\n队列的应用 队列结构常用于处理需要排队的场合，例如操作系统中处理打印任务的打印队列、离散事件的计算机模拟等。\n 串 串（字符串）是一种特殊的线性表，其数据元素为字符。\n串具有自身的特性，运算时常常把一个串作为一个整体来处理。\n串的基本概念和操作：\n  空串：长度为0的串；\n  子串：由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。子串在主串中的位置是指子串首次出现时，该子串的第一个字符在主串中的位置。空串是任意串的子串。\n  串相等：指两个串长度相等且对应序号的字符也相同。\n  串比较：两个串比较大小时以字符的ASCⅡ码值（或其他字符编码集合）作为依据。\n实质上，比较操作从两个串的第一个字符开始进行，字符的码值大者所在的串为大；若其中一个串先结束，则以串长较大者为大。\n  赋值：\n 拷贝赋值：将一个串的值赋给另一个串； 引用（地址）赋值：将一个串的引用（地址）赋给另一个串。那么这个串可以使用另一个串中的值，但是对这个串所做的操作，也会作用到另一个串。    连接串：将一个串插入到另一个串尾。\n  插入串：将一个串插入到另一个串的任意位置中。\n  顺序存储结构 串的顺序存储结构是一种定长的串（类似顺序表）。\n链式存储结构 串的链式存储结构可以方便地对串进行插入删除操作（类似链表）。\n串的模式匹配 子串的定位操作通常称为串的模式匹配。子串也称为模式串。\n有关串模式匹配算法的详细讲解可以查看：经典字符串匹配\n朴素的模式匹配算法 朴素的模式匹配算法也称为布鲁特一福斯算法（即暴力匹配算法），其基本思想是从主串的第一个字符起与模式串的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串第二个字符起与模式串的第一个字符重新比较，直到模式串中每个字符依次和主串中一个连续的字符序列相等时为止，此时称为匹配成功。如果不能在主串中找到与模式串相同的子串，则匹配失败。\n设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：\n  最好情况：$O(m)$，次数为$m$；\n  最坏情况：$O(n \\times m)$，次数为$\\cfrac{1}{2} m(n-m+2)$：\n$$ \\sum_{i=0}^{n-m}{p_i\\big( (i+1) \\times m \\big)} = \\cfrac{m}{n-m+1} \\sum_{i=0}^{n-m}{(i+1)} = \\cfrac{1}{2} m(n-m+2) $$\n  平均：$O(n+m)$，次数为$\\cfrac{1}{2} (n+m)$：\n$$ \\sum_{i=0}^{n-m}{p_i(i+m)} = \\cfrac{1}{n-m+1} \\sum_{i=0}^{n-m}{i+m} = \\cfrac{1}{2} (n+m) $$\n  KMP 算法 KMP算法又称为改进的模式匹配算法。\n 串的前缀：包含第一个字符，且不包含最后一个字符的子串； 串的后缀：包含最后一个字符，且不包含第一个字符的子串。 前缀集合：包含串的所有前缀的集合； 后缀集合：包含串的所有后缀的集合。  KMP的重点是求模式串字符的next值（失配指针$Next[\\ i\\ ]$），假设$a_{i-1}$为当前要求next值的模式串字符：\n  前缀集合：\n$$ Prefix=\\{p_0,p_0p_1,\\cdots,p_0\u0026hellip;p_{i-1}\\} $$\n  后缀集合：\n$$ Postfix=\\{p_{i-1},p_{i-2}p_{i-1},\\cdots,p_1\u0026hellip;p_{i-1}\\} $$\n  失配指针：\n$$ Next[i] = \\begin{cases} -1 \u0026amp; 当\\ i=0 时 \\\\ max \u0026amp; \\{ k|0\u0026lt;k\u0026lt;i 且 \u0026ldquo;p_0\\cdots p_{k-1}\u0026rdquo; = \u0026ldquo;p_{i-k}\\cdots p_{i-1}\u0026rdquo; \\} \\\\ 0 \u0026amp; 其他情况 \\end{cases} $$\n即：\n $Next[0] = -1$； $Next[i] = maxLen(Prefix \\cap Postfix)$  可以解释为：\n$$ Next[\\ i\\ ] = 前i个子串的最长相同前后缀的长度 $$\n特殊情况：$Next[\\ 1\\ ] = 0$，因为其前缀集合和后缀集合都为空。\n   失配表是用来指示匹配失败后指针该如何移动的。\n失配表的建立跟要匹配的串没有任何关系，仅跟模式串有关。\n  多维数组 多维数组是定长线性表在维数上的扩展，即线性表中的元素又是一个线性表。多维数组是一种“同构”的数据结构，其每个数据元素类型相同、结构一致。\n  一维数组：即线性表。\n  二维数组（仅讨论顺序存储结构）：\n二维数组的存储结构（如下图），可以分为以行为主序（下图左边）和以列为主序（下图右边）两种。\n设：\n 二维数组为$A[n,m]$，$n$为行数，$m$为列数； 数组元素$a_{i,j},\\ 0 \\le i \\le n-1,\\ 0 \\le j \\le m-1$； $LOC(a_{i,j})$为元素$a_{i,j}$的地址； $L$为单个元素的存储空间大小。  则有：\n  以行为主序优先存储：\n$$ LOC(a_{i,j}) = LOC(a_{0,0}) + (i \\times n + j) \\times L $$\n如果下标从1开始（$1 \\le i \\le n,\\ 1 \\le j \\le m$）：\n$$ LOC(a_{i,j}) = LOC(a_{1,1}) + \\big( (i-1) \\times n + (j-1) \\big) \\times L $$\n  以列为主序优先存储：\n$$ LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \\times m) \\times L $$\n如果下标从1开始（$1 \\le i \\le n,\\ 1 \\le j \\le m$）：\n$$ LOC(a_{i,j}) = LOC(a_{1,1}) + \\big( (i-1) + (j-1) \\times m \\big) \\times L $$\n     优先存储说法问题：\n以行为主序优先存储的意思应该是在内存中按行存储。以列为主序优先存储的意思应该是在内存中按列存储。\n假设一个二维数组为：\n$$ \\begin{vmatrix} a_{11} \u0026amp; a_{12} \u0026amp; a_{13} \u0026amp; a_{14} \\\\ a_{21} \u0026amp; a_{22} \u0026amp; a_{23} \u0026amp; a_{24} \\\\ a_{31} \u0026amp; a_{32} \u0026amp; a_{33} \u0026amp; a_{34} \\\\ a_{41} \u0026amp; a_{42} \u0026amp; a_{43} \u0026amp; a_{44} \\\\ a_{51} \u0026amp; a_{52} \u0026amp; a_{53} \u0026amp; a_{54} \\end{vmatrix} $$\n按照以行为主序优先存储的公式，它在内存中应该是分为了5个地址连续的数组来存储。即内存中，$[a_{11},a_{12},a_{13},a_{14}]$为一个数组，其后再接一个数组$[a_{12},a_{22},a_{23},a_{24}]$，以此类推，在内存中按照列的元素作为一个连续的一维数组单位，再按照第1行后接第2行作为整个连续的二维数组。它们在内存中的地址顺序是：\n$$ a_{11},a_{12},\u0026hellip;,a_{14},\\\\ a_{21},\u0026hellip;,a_{24},\\\\ a_{31},\u0026hellip;,a_{34},\\\\ a_{41},\u0026hellip;,a_{44},\\\\ a_{51},\u0026hellip;,a_{54} $$\n那么以列为主序优先存储的地址顺序就为：\n$$ a_{11},a_{21},\u0026hellip;,a_{51},\\\\ a_{12},\u0026hellip;,a_{52},\\\\ a_{13},\u0026hellip;,a_{53},\\\\ a_{14},\u0026hellip;,a_{54} $$\n 一般矩阵都用二维数组来表示，但是对于一些特殊矩阵，如对称矩阵、三角矩阵和对角矩阵。它们的非0元素的分布存在一定规律，所以可以将其压缩存储在一维数组中，并且它们的多个值相同的元素（按照对应特殊矩阵定义上的值相同，并非简单的值相同）只分配一个存储单位。\n对称矩阵 若矩阵$A_{n \\times n}$中的元素特点为$a_{ij}=a_{ji}\\ (1 \\le i,j \\le n)$，则称之为$n$阶对称矩阵。\n对称矩阵$A_{n \\times n}$：\n$$ \\begin{vmatrix} a_{11} \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n} \\\\ a_{21} \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{2n} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ a_{n1} \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{vmatrix} $$\n其中以对角线划分为三个区域：\n  主对角线：$a{11},a_{22},\\cdots,a_{nn}$，共有$n$个元素；\n  上三角区：对角线以上的所有元素，即：\n$$ \\begin{vmatrix} 0 \u0026amp; a_{12} \u0026amp; a_{13} \u0026amp; \\cdots \u0026amp; a_{1n} \\\\ 0 \u0026amp; 0 \u0026amp; a_{23} \u0026amp; \\cdots \u0026amp; a_{2n} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; a_{(n-1)n} \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \\end{vmatrix} $$\n  下三角区：对角线以下的所有元素，和上三角区的个数相等并且重复。\n  可以将对称矩阵中，$n^2$个元素压缩存储到$\\cfrac{n(n+1)}{2}$个元素的存储空间中。一般是存储下三角区和对角线。\n假设将$n$阶对称矩阵$A_{n \\times n}$压缩存储到一维数组$B\\left[ \\cfrac{n(n+1)}{2} \\right]$，则$B[k]\\ (1 \\le k \\le \\cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\\ (1 \\le i,j \\le n)$之间存在一一对应关系（以行为主序）：\n$$ k = \\begin{cases} \\cfrac{i(i-1)}{2} + j, \u0026amp; 当\\ i \\ge j \\\\ \\cfrac{j(j-1)}{2} + i, \u0026amp; 当\\ i \u0026lt; j \\end{cases} $$\n如果下标从0开始（第一个元素为$a_{00}$，$0 \\le k \\le \\cfrac{n(n+1)}{2} - 1$，并且$0 \\le i,j \\le n-1$）：\n$$ k = \\begin{cases} \\cfrac{i(i+1)}{2} + j + 1, \u0026amp; 当\\ i \\ge j \\\\ \\cfrac{j(j+1)}{2} + i + 1, \u0026amp; 当\\ i \u0026lt; j \\end{cases} $$\n 为什么$length(B) = \\cfrac{n(n+1)}{2}$（压缩存储的一维数组大小）：\n主对角线的元素的大小为$n$，下三角区的对角线大小分别为$n-1,n-2,\u0026hellip;,1$。即： $$ length(B) = \\sum_{i=1}^{n}{i} = \\cfrac{n(n+1)}{2} $$\n  PS：《软件设计师教程（第五版）》中一维数组的下标$k$的取值范围错了：\n很明显不是$\\left[ 1, \\cfrac{n(n+1)}{2} \\right)$，而应该是$\\left[ 1, \\cfrac{n(n+1)}{2} \\right]$。\n 三对角矩阵 对角矩阵是指矩阵中的非0元素都集中在以主对角线为中心的带状区域中，即除了主对角线上和直接在对角线上、下方若干条对角线上的元素外，其余的矩阵元素都为0。三对角矩阵是对角矩阵中的一种，包括主对角线和在主对角线上、下方的各一条对角为非0元素：\n$$ \\begin{vmatrix} a_{11} \u0026amp; a_{12} \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \\\\ a_{21} \u0026amp; a_{22} \u0026amp; a_{23} \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; a_{32} \u0026amp; a_{33} \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; a_{43} \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; a_{(n-1)(n-1)} \u0026amp; a_{(n-1)n} \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; a_{n(n-1)} \u0026amp; a_{nn} \\end{vmatrix} $$\n设有$n$阶三对角矩阵$A_{n \\times n}$，将其非0元素$a_{ij}(a_{ji})\\ (1 \\le i,j \\le n)$存储在一维数组$B[k](1 \\le k \\le 3 \\times n - 2)$中，则元素位置之间的对应关系为：\n$$ k = 3 \\times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2 $$\n如果下标从0开始（$0 \\le k \\le 3(n-1)$，并且$0 \\le i,j \\le n-1$）：\n$$ k = 3 \\times i - 1 + j - i + 1 + 1 = 2i + j + 1 $$\n稀疏矩阵 在一个矩阵中，若非0元素的个数远远少于0元素的个数，且非0元素的分布没有规律，则称之为稀疏矩阵。\n对于稀疏矩阵，存储非0元素时必须同时存储其位置（即行号和列号），用三元组$(i,j,a_{ij})$可唯一确定矩阵$A$中的一个元素。\n可以用三元组表来存储这些三元组。稀疏矩阵的三元组表的顺序存储结构称为三元组顺序表，常用的三元组表的链式存储结构是十字链表。\n 树 树结构是一种非线性结构，该结构中的一个数据元素可以有两个或两个以上的直接后继元素。\n树（Tree）是 $n(n\\ge0)$ 个结点的有限集。\n 空树：$n=0$； 非空树：$n\u0026gt;0$，  有且仅有一个根结点， 除根节点外的其余结点可分为 $m(m\u0026gt;0)$ 个互不相交的集合，即子树（SubTree）$T_1,T_2,\\cdots,T_m$。    树的定义是递归的：\n 一棵树由若干棵子树构成； 子树又由更小的子树构成。  基本概念 术语  度：结点拥有的子树数。整个树的度是树内各结点度的最大值。 叶结点：度为 0 的结点，也称终端结点。 非终端结点：度不为 0 的结点，也称分支结点。 内部结点：除根节点外的非终端结点。 子节点：结点子树的根结点。 父结点：与子结点相连的上一层的唯一一个结点。 兄弟结点：同一个父节点的子节点之间互为兄弟。 祖先结点：从根结点到该结点所经分支上的所有结点（包括其父节点，但不包括其本身）。 子孙结点：以某结点为根的子树中的所有结点。 堂兄弟结点：父节点在同一层（但不是同一个）的结点互为堂兄弟。 层次：以根结点为第一层，根的子节点为第二层 …… 树中任意结点的层次等于其父节点的层次加 1。 树的高度：树中结点的最大层次，也称树的深度。 森林：是 $m(m\\ge0)$ 棵互不相交的树的集合。树中每个结点的子树的集合即为森林。  树的类型  有序树：树中结点的各子树从左到右是有次序的，即不能互换。 无序树：树中结点的各子树相互之间可以互换，没有次序。  树的性质   设$n$个结点的树，$d_i \\ (1 \\le i \\le n)$为该树中结点的度：\n$$ n = (\\sum_{i=1}^{n}{d_i})+1 $$\n  度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \\ge 1$）。\n  高度为$h$的$m$度树至多有$\\cfrac{m^h-1}{m-1}$个结点。\n  树的逻辑结构 树可以用二元组 $Tree=(root,F)$ 表示。其中 $root$ 是根结点，$F$ 是 $m(m\\ge0)$ 棵子树的森林，即 $F=(T_1,T_2,\\cdots,T_m)$，其中 $T_i=(r_i,F_i)$ 为根 $root$ 的第 $i$ 棵子树。\n树根与其子树森林之间的关系： $$ RF = \\{ \u0026lt;root,r_i\u0026gt;|i=1,2,4,m,\\quad m\u0026gt;0 \\} $$\n 二叉树 二叉树是（$n \\ge 0$）个结点的有限集合：\n 空树：$n=0$； 由一个根结点及两棵不相交的且分别称为左、右子树的二叉树所组成（两个子数顺序不可交换）。  二叉树同样具有递归性质。\n二叉树的性质：\n  第$i$层（$i \\ge 1$）上最多有$2^{i-1}$个结点。\n因为二叉树每个结点至多有两个分支（结点）。\n  高度为$k$的二叉树最多有$2^k-1$个结点（$k \\ge 1$）。\n每层结点都取最大值后累加：\n$$ \\sum_{i=1}^{k}{2^{i-1}} = 2^k - 1 $$\n将深度为$k$且有$2^k-1$个结点的二叉树称为满二叉树。\n对满二叉树自上而下、从左至右进行编号（即层序遍历的顺序）。一个深度为$k$、有$n$个结点的二叉树，当且仅当其每一个结点都于深度为$k$的满二叉树中编号从1至$n$的结点一一对应时，称之为完全二叉树。\n 完全二叉树有一个隐藏关系：$n \u0026gt; 2^{k-1}-1$。即深度为$k$的完全二叉树，其结点数$n$必须要比深度为$k-1$的满二叉树至少多1个结点。\n  深度为$k$的满二叉树结点数$n$和其第$k$层结点数$m$的关系：\n$$ n = 2m-1 $$\n   任何一棵二叉树，若其终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。\n即：\n$$ 终端结点数（度0结点数）=度2结点数+1 $$\n  具有$n$个结点的完全二叉树的深度（高度）为：\n$$ \\lfloor \\log_2{n} \\rfloor + 1; $$\n或：\n$$ \\lceil \\log_2{(n+1)} \\rceil $$\n  二叉树形态总数（卡特兰数）：\n$$ \\cfrac{C^{n}_{2n}}{n+1} $$\n 排列组合公式：\n$$ A^n_m = m \\times (m-1) \\times \\cdots \\times (m-n+1) $$\n$m$是起点，$n$是次数。\n$$ C^n_m = \\cfrac{A^n_m}{A^n_n} $$\n 顺序存储结构 用一组地址连续的存储单元存储二叉树中的结点。\n可以按照为完全二叉树编号的顺序（即层序遍历的顺序），将二叉树映射到顺序表中：\n若编号为$i$的结点（$i \\ge 1$），则：\n $i=1$：根结点，没有双亲（父结点）； $i\u0026gt;1$：双亲为$\\left\\lfloor \\cfrac{i}{2} \\right\\rfloor$； $i \\le \\cfrac{n}{2}$：左孩子编号为$2i$； $i \\le \\cfrac{n-1}{2}$：右孩子编号为$2i+1$。  完全二叉树适合采用顺序存储结构，而一般二叉树则不适合。\n链式存储结构 可以用三叉链表或二叉链表来存储二叉树（一个结点含有3个或2个指针，其中必须有两个指针来分别存储左子树和右子树的根结点）。链表的头指针指向二叉树根结点：\n 三叉链表仅仅是多了一个指向父结点的链表。\n 设有$n$个结点的二叉树，则其空指针域数量：\n  对于二叉链表：\n 总指针域个数：$2n$； 分支数（子孙结点数，非空指针域个数）：$n-1$。  可得：\n$$ 空指针域数=2n-(n-1)=n+1 $$\n  对于三叉链表：\n 总指针域个数：$3n$； 分支数（子孙结点数）：$n-1$； 指向父结点且非空的指针域个数：$n-1$。  即，非空指针域个数为：$2(n-1)$。\n可得：\n$$ 空指针域数=3n-2(n-1)=n+2 $$\n  遍历 二叉树有以下遍历方法：\n  先序遍历：根左右\n 访问根结点； 先序遍历左子树； 先序遍历右子树。    中序遍历：左根右\n 中序遍历左子树； 访问根结点； 中序遍历右子树。    后序遍历：左右根\n 后序遍历左子树； 后序遍历右子树； 访问根结点。  后序遍历可以使用栈：\n 根结点入栈； 右子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）； 左子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）； 将栈中所有元素出栈，出栈顺序即为后序遍历的顺序。    层序遍历：根据层序从上至下，从左到右遍历\n  访问根结点（第1层）；\n  从左到右访问第2层所有结点；\n  从左到右访问第3层所有结点；\n\u0026hellip;\n  直至访问到最后一层的所有结点（从左到右）。\n层序遍历可以使用队列：\n 将根结点入队； 将对头元素出队，然后将其左右子结点（如果有的话）依序入队； 重复步骤2直至所有元素出队，出队顺序即为层序遍历顺序。     二叉树的遍历实质上是对一个非线性结构进行线性化的过程，它使得每个结点（除第一个和最后一个）在这些线性序列中有且仅有一个直接前驱和直接后继。\n 平衡二叉树 二叉树可以用于快速查找。例如比根结点小的在左子树，比根结点大的在右子树（二叉排序树）。那么每次查找，根据根结点就可以剔除一半的范围。\n但是如果二叉树左右子树的结点数量差别很大，那么每次查找并不一定能剔除一半的范围，查询效率大打折扣。\n设一个二叉树的左右子树高度之差的绝对值为$d$，那么\n 不平衡的二叉树：$d \u0026gt; 1$； 平衡的二叉树：$d \\le 1$。   完全二叉树一定是平衡二叉树，平衡二叉树不一定是完全二叉树。\n 二叉排序树 二叉排序树的定义：\n 左子树所有结点的关键字都小于根结点； 右子树所有根结点的关键字都大于根结点； 左右子树也都是二叉排序树。  二叉排序树的中序遍历（左根右）得到的是该二叉树的有序序列。\n线索二叉树 线索二叉树是在二叉树结点中保存了结点的前驱和后继的信息。\n如果使用指针来指向其前驱和后继，增加指针信息会降低存储空间的利用率。\n可以采用增加两个标志（leftTag和rightTag）来区分指针域指向的是左或右子结点还是前驱或后继：\n  leftTag leftChild data rightChild rightTag   其中：\n$$ leftTag = \\begin{cases} True \u0026amp; leftChild指向结点左孩子 \\\\ False \u0026amp; leftChild指向结点的直接前驱 \\end{cases} $$\n$$ rightTag = \\begin{cases} True \u0026amp; rightChild指向结点右孩子 \\\\ False \u0026amp; rightChild指向结点的直接后继 \\end{cases} $$\n若二叉树的二叉链表采用以上所示的结点结构，则相应的链表称为线索链表，其中指向结点前驱、后继的指针称为线索。\n对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化。\n哈夫曼树 哈夫曼树即最优二叉树，是一类带权路径长度最短的树。\n  路径：指从树中一个结点到另一个结点之间的通路；\n  路径长度：路径上的分支数目；\n  树的路径长度：指从树根到每一个叶子之间的路径长度之和；\n  结点的带权路径长度：从该结点到树根之间的路径长度与该结点权值的乘积；\n  树的带权路径长度：树中所有叶子结点的带权路径长度之和。\n设：\n 带权叶子结点数：$n$； 叶子结点的权值：$w_k$； 叶子结点到根的路径长度：$l_k$。  则树的带权路径长度为：\n$$ WPL = \\sum_{k=1}^{n}{w_kl_k} $$\n  哈夫曼树是指权值为$w_1,w_2,\\cdots,w_n$的$n$个叶子结点的二叉树中，带权路径长度最小的二叉树。\n构造最优二叉树的哈夫曼算法：\n 根据给定的$n$个权值$\\{ w_1,w_2,\\cdots,w_n \\}$，构成$n$棵二叉树集合$F=\\{T_1,T_2,\\cdots,T_n\\}$，每棵树$T_i$有且仅有一个带权为$w_i$的根结点。 在$F$中选取2棵权值最小的树作为左、右子树，构造一棵新二叉树。新二叉树的根结点权值为其左右子树根结点权值之和。 从$F$中删除这2棵树，并将新树加入到$F$中。 重复步骤2、3直到$F$中仅含一棵树为止，这棵树便是哈夫曼树。  哈夫曼算法并未规定哪棵树作为左或右子树，所以哈夫曼树并不唯一，但$WPL$值是唯一的。\n给定$n$个权值后，哈夫曼树的结点数$m$就确定了：\n$$ m = 2 \\times n - 1 $$\n所以可用一维数组存储哈夫曼树。\n哈夫曼编码 哈夫曼编码是一种不等长的编码，它用哈夫曼算法来构造出最优前缀码：\n给定字符集$D=\\{ d_1,d_2,\\cdots,d_n \\}$及字符的使用频率$W=\\{w_1,w_2,\\cdots,w_n\\}$。\n构造最优前缀码的方法为：\n 以$d_1,d_2,\\cdots,d_n$作为叶子结点，$w_1,w_2,\\cdots,w_n$作为叶子结点的权值，构造出一棵最优二叉树。 将树中每个结点的左分支标上0，右分支标上1（左0右1）。 每个叶子结点代表字符的编码就是从根到叶子的路径上组成的0、1串。  其中，字符$a$字符$b$、$c$、$d$、$e$的编码分别为00、01、100、11、101。\n压缩比   按照出现频率计算加权平均长度：\n$$ 加权平均长度 = \\sum_{i=1}^{5}{字符i的位数 \\times 字符i出现频率} $$\n即：\n$$ 1 \\times 40% + 3 \\times (10% + 20% + 16% + 14%) = 2.2 $$\n压缩后平均长度为2.2。\n  计算压缩比：\n$$ 压缩比 = \\cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度} $$\n即，\n  编码5个字符至少需要3位：$2^2 \u0026lt; 5 \u0026lt; 2^3$，所以压缩前编码长度为3；\n  压缩比：\n$$ \\cfrac{3-2.2}{3} \\approx 0.27 $$\n     哈夫曼编码方案是基于贪心策略的。\n  图 在图中，任意两个结点之间都可能有直接的关系，所以图中一个结点的前驱结点和后继结点的数目是没有限制的。\n图$G$是由集合$V$和$E$构成的二元组，记作$G=(V,E)$：\n 顶点：表示数据元素。$V$是图中顶点的非空有限集合。 边：表示数据元素之间的关系。$E$是图中边的有限集合。  图可分为两种类型：\n 有向图：有向图顶点之间的关系称为弧（或有向边），用$\u0026lt;v_i,v_j\u0026gt;$表示，$v_i$是弧尾（始点或起点），$v_j$是弧头（终点，箭头指向的顶点），即有向边是指从弧尾指向弧头的一条边。$\u0026lt;v_i,v_j\u0026gt;$和$\u0026lt;v_j,v_i\u0026gt;$分别表示的是两条边。 无向图：无向图顶点之间的关系用$(v_i,v_j)$表示。$(v_i,v_j)$和$(v_j,v_i)$表示的是同一条边。  术语 完全图 完全图：\n  无向完全图：指一个有$n$个顶点的无向图，其每一个顶点与其他$n-1$个顶点之间都有边。\n$n$个顶点的无向完全图共有$\\cfrac{n(n-1)}{2}$条边：\n$$ \\sum_{i=1}^{n}{i} = \\cfrac{n(n-1)}{2} $$\n假设$n$个顶点的无向完全图，为他们编上1到$n$的编号，按照编号顺序计算边，第1个顶点跟其他$n-1$个顶点有$n$条边；第2个顶点跟其他$n-1$个顶点也有$n$条边，除去1条跟第1个顶点相连的边，有$n-1$条不一样的边；第3个顶点出去2条跟第1和第2个顶点相连的边，有$n-2$条不一样的边……以此类推，得出上方公式。\n  有向完全图：指一个有$n$个顶点的有向图，以其每一个顶点为始点与其他$n-1$个顶点之间都有弧。\n$n$个顶点的有向完全图共有$n(n-1)$条边：\n$$ \\prod_{i=1}^{n}{n-1} = n(n-1) $$\n有向完全图的$n$个顶点都有$n-1$条以其他顶点作为终点的弧（出度为$n-1$），并且这$n$个顶点的$n-1$条弧都是不同的弧，所以可推出上方公式。\n  度 度：顶点$v$的度是指关联于该顶点的边的数目，记作$D(v)$。\n若为有向图：\n 入度：以该顶点为终点的有向边的数目，记为$ID(v)$； 出度：以该顶点为起点的有向边的数目，记为$OD(v)$。  有向图度与入度、出度的关系：\n$$ D(v) = ID(v) + OD(v) $$\n对于所有的图，顶点数$n$、边数$e$与各顶点的度之间有：\n$$ e = \\cfrac{1}{2} \\sum_{i=1}^{n}{D(v_i)} $$\n即，所有顶点的度数之和 $= 2e$。\n路径 路径：\n  无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\\cdot,v_{in},v_q$，使得$(v_p,v_{i1}),(v_{i1},v_{i2}),\\cdots,(v_{in},v_q) \\in E(G)$；\n  无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\\cdot,v_{in},v_q$，使得$\u0026lt;v_p,v_{i1}\u0026gt;,\u0026lt;v_{i1},v_{i2}\u0026gt;,\\cdots,\u0026lt;v_{in},v_q\u0026gt; \\in E(G)$。\n无向图中的路径也是有方向的。\n  子图 子图：若有两个图$G=(V,E)$和$G'=(V',E')$，如果$V' \\sube V$且$E' \\sube E$，则称$G'$为$G$的子图。\n连通图 对于无向图：\n 连通：无向图中，若从顶点$v_i$到顶点$v_j$有路径，则称顶点$v_i$和顶点$v_j$是联通的。 连通图：若无向图中任意两个顶点都是联通的，称其为连通图。 连通分量：无向图$G$的极大连通子图称为$G$的连通分量。  $n$个结点的连通图，它的边的取值范围是$[n-1,\\cfrac{n(n-1)}{2}]$。\n对于有向图：\n 强连通图：在有向图$G$中，如果对于每一对顶点，$v_i,v_j\\in V$ 且 $v_i \\neq v_j$，从顶点$v_i$到顶点$v_j$和从顶点$v_j$到顶点$v_i$都存在路径，则称图$G$为强连通图。 强连通分量：有向图中的极大连通子图称为有向图的强连通分量。   连通图是无向图中的一种，所以一般也称为无向连通图。\n强连通图是有向图的一种，一般也称为有向强连通图。\n 网 边（或弧）带权值的图称为网。\n有向树 如果一个有向图恰有一个顶点的入度为0（作为root），其余顶点的入度均为1，则是一棵有向树。\n基本存储结构 图的基本存储结构有：\n 邻接矩阵表示法：使用矩阵存储顶点关系，适合存储边比较多的图； 邻接链表表示法：使用多个单链表存储顶点关系，适合存储边比较少的图。  邻接矩阵表示法 图的邻接矩阵表示法是指用矩阵来表示图中顶点之间的关系。\n对于具有$n$个顶点的图$G=(V,E)$，其邻接矩阵是一个$n$阶方阵，且满足：\n$$ A[i][j] = \\begin{cases} 1 \u0026amp; 若(v_i,v_j)或\u0026lt;v_i,v_j\u0026gt;是E中的边 \\\\ 0 \u0026amp; 若(v_i,v_j)或\u0026lt;v_i,v_j\u0026gt;不是E中的边 \\end{cases} $$\n 即，横$i$竖$j$，横出竖入。\n 无向图的邻接矩阵是对称矩阵，有向图的邻接矩阵则不一定对称。\n 无向图：顶点$v_i$的度是邻接矩阵第$i$行（或列）中值不为0的元素个数； 有向图：第$i$行的非0元素个数是顶点$v_i$的出度$OD(v_i)$；第$i$列的非0元素个数是顶点$v_i$的入度$ID(v_j)$。  网（赋权图）的邻接矩阵定义（$W_{ij}$是边或弧上的权值）：\n$$ A[i][j] = \\begin{cases} W_{ij} \u0026amp; 若(v_i,v_j)或\u0026lt;v_i,v_j\u0026gt; \\in E \\\\ \\infin \u0026amp; 若(v_i,v_j)或\u0026lt;v_i,v_j\u0026gt; \\notin E \\end{cases} $$\n邻接矩阵适合用于存储边比较多的图。\n邻接链表表示法 邻接链表表示法指的是为图的每个顶点建立一个单链表：\n  边结点（表结点）：\n  adjvex nextarc info    adjvex：指示与顶点$v_i$邻接的顶点的序号； nextarc：指示下一条边或弧的结点； info：存储与边或弧有关的信息，如权值等。    表头结点（顶点结点）：\n  data firstarc    data：存储顶点$v_i$的名或其他有关信息； firstarc：指示链表中的第一个结点（邻接顶点）。  表头结点通常以顺序存储结构存储，以便随机访问。\n  对于有向图，邻接链表存储的是以当前结点作为起点的弧；逆邻接链表存储的是以当前结点作为终点的弧。\n邻接链表适合用于存储边比较少的图。\n遍历 图的遍历是指从某个项点出发，沿着某条搜索路径对图中的所有项点进行访问且只访问一次的过程。\n深度优先搜索 深度优先搜索（Depth First Search，DFS）类似于树的先序遍历。从图$G$中任一结点$v$出发按深度优先搜索法进行遍历的步骤：\n 设置搜索指针$p$，使$p$指向顶点$v$； 访问$p$所指顶点，并使$p$指向与其相邻接的且尚未被访问过的顶点。 若$p$所指顶点存在，则重复步骤2，否则执行步骤4。 沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。  时间复杂度（$n$为顶点数，$e$为边数）：\n 邻接矩阵：$O(n^2)$； 邻接链表：$O(n+e)$。  广度优先搜索 图的广度优先搜索（Breadth First Search，BFS）步骤为：\n 从图中的某个顶点$v$出发； 访问$v$后，依次访问$v$的各个未被访问过的邻接点； 分别从$v$的邻接点出发，依次访问它们的邻接点； 按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到； 若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。  广度优先搜索可以引入队列来保存已访问过的顶点序列。即，每当一个顶点被访问后，就将其放入队列中；当队头顶点出队时，就访问其未被访问的邻接点并令这些邻接顶点入队。每个顶点最多入队一次。\n广度和深度优先搜索遍历图的时间复杂度相同（$n$为顶点数，$e$为边数）：\n 邻接矩阵：$O(n^2)$； 邻接链表：$O(n+e)$。   广度和深度优先搜索遍历图的不同之处在于：顶点访问的次序不同。\n 生成树 连通图的生成树是该图的极小连通子图（都是$n-1$条边）。\n对于非连通图而言，每个连通分量中的顶点集和遍历时走过的边集一起构成若干棵生成树，把它们称为非连通图的生成树森林。\n  在图的生成树中任一加一条边，则必然形成回路。\n边数为$e$，$e \\ge n$则必然形成回路。\n  图的生成树不是唯一的。\n按深度和广度优先搜索进行遍历将得到不同的生成树，分别称为深度优先生成树和广度优先生成树。\n  最小生成树 连通网的生成树的边也带权，把生成树各边的权值总和称为生成树的权。权值最小的生成树称为最小生成树。\nAOV 网 一个大工程项目可以分为许多较小子工程（称为活动）。有向图中，用顶点表示活动，弧表示活动之间的优先级关系（活动进行时的制约关系），称这样的有向图为以顶点表示活动的网（Activity On Vertex network，AOV网）。\n在AOV网中：\n  从顶点$v_i$到$v_j$有一条有向路径：\n $v_i$是$v_j$的前驱， $v_j$是$v_i$的后继；    $\u0026lt;v_i,v_j\u0026gt;$：\n $v_i$是$v_j$的直接前驱， $v_j$是$v_i$的直接后继。    AOV网中不应出现有向环。检测工程是否可行，首先应检查对应AOV网是否存在回路。不存在回路的有向图称为有向无环图（DAG，Directed Acycline Graph）。\n拓扑排序 检测AOV网是否是DAG的方法是对AOV网构造其顶点的拓扑有序序列。\n拓扑排序是将AOV网中的所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点$v_i$到$v_j$有一条路径，则在该线性序列中，$v_i$必在$v_j$之前。对AOV网进行拓扑排序的方法如下：\n 在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。 从网中删除该顶点及与该顶点有关的所有弧。 重复上述两步，直到网中不存在入度为0的顶点为止。  两种结果：\n 所有顶点已输出，说明网中不存在回路。 尚有未输出的顶点，剩余顶点均有前驱顶点，表面网中存在回路。  有向无环图的拓扑序列中，顶点$v_i$在$v_j$之前，则：\n 可能存在弧$\u0026lt;v_i,v_j\u0026gt;$，一定不存在弧$\u0026lt;v_j,v_i\u0026gt;$； 可能存在$v_i$到$v_j$的路径，一定不存在$v_j$到$v_i$的路径。  上图拓扑排序的结果为：6,1,4,3,2,5（结果并不唯一）。\n 当有向图中无环时，也可以利用深度优先遍历进行逆拓扑排序。\n  查找 查找是一种常用的基本运算。查找表是指由同一类型的数据元素（或记录）构成的集合。\n查找表经常要进行的操作：\n 查询某个特定的数据元素是否在查找表中。 检索某个特定的数据元素的各种属性。  通常将只进行这两种操作的查找表称为静态查找表。\n查找表经常要进行的另外两种操作：\n 在查找表中插入一个数据元素。 从查找表中删除一个数据元素。  需要在查找表中插入或删除元素，称此类查找表为动态查找表。\n关键字是数据元素（或记录）的某个数据项的值，用它来识别（标识）这个数据元素。\n 主关键字：能唯一标识一个数据元素的关键字。 次关键字：能标识多个数据元素的关键字。  平均查找长度 查找算法基本操作是“将记录的关键字与给定值进行比较”。因此，通常以“其关键字和给定值进行过比较的记录个数的期望值”作为衡量查找算法好坏的依据。\n查找算法在查找成功时的平均查找长度关键字和给定值比较次数的期望值：\n$$ ASL = \\sum_{i=1}^{n}{P_iC_i} $$\n  $P_i$为对表中第$i$个记录进行查找的概率，\n一般认为$P_i=\\cfrac{1}{n}, 1 \\le i \\le n$，即$\\sum_{i=1}^{n}{P_i}$；\n  $C_i$为查找成功时，已经进行过比较的关键字个数。\n  查找算法 静态查找表有以下查找方法：\n 顺序查找； 折半查找； 分块查找。  动态查找表有以下查找方法：\n 二叉排序树； 平衡排序树； B-树； 哈希表。  顺序查找 顺序查找是从表的一端开始，按照顺序（从左往右或从右往左）逐一进行查找。顺序查找的方法对于顺序存储方式和链式存储方式的查找表都适用。\n顺序查找中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：\n$$ ASL_{ss} = \\cfrac{1}{n} \\sum_{i=1}^{n}{(n-i+1)} = \\cfrac{n+1}{2} $$\n二分查找 二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。步骤如下：\n以升序数列$L[0\u0026hellip;n-1]$为例，假设要查找的数为$x$：\n让$x$与数列中间位置的元素$L\\left[ \\left\\lfloor \\cfrac{n}{2} \\right\\rfloor \\right]$进行比较，如果相等则返回该元素下标，否则：\n 如果$x$比中间元素小，递归地对中间元素左边的数列（比$x$小的元素）进行二分查找； 如果$x$比中间元素大，递归地对中间元素右边的数列（比$x$大的元素）进行二分查找。  折半查找的过程可用二叉树描述。$n$个结点的二叉树深度为$\\lfloor log_2{n} \\rfloor + 1$，折半查找进行比较的关键字个数最多不超过树的深度。所以，折半查找在查找成功时和给定值进行比较的关键字个数最多为$\\lfloor log_2{n} \\rfloor + 1$。\n折半查找的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：\n$$ ASL_{bs} = \\cfrac{1}{n} \\sum_{i=1}^{n}{i \\times 2^{i-1}} = \\cfrac{n+1}{n} log_2{(n+1)} - 1 $$\n当$n$值较大时，$ASL_{bs} \\approx log_2{(n+1)} - 1$。\n哈希表 哈希表查找（又叫散列表查找）是通过散列技术，将存储位置和关键字构建一个确定的关系$H$，使得每个关键字$key$对应一个存储位置$H(key)$。其中，$H$称为哈希函数或者散列函数。\n根据设定的哈希函数$H(key)$和处理冲突的方法，将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这块连续的空间称为哈希表或散列表，这一映射过程称为哈希造表或散列表，所得的存储位置称为哈希地址或散列地址。\n对于哈希表，主要考虑两个问题：\n 如何构造哈希函数； 如何解决冲突。  冲突 对于某个哈希函数$H$和两个关键字$key_1$和$key_2$,如果$key_1 \\neq key_2$，而$H(key_1)=H(key_2)$，则称为冲突。\n具有相同哈希函数值的关键字对该哈希函数来说称为同义词。\n一般情况下，冲突只能尽可能减少而不能完全避免。\n哈希函数的构造方法 常用的哈希函数构造方法有：\n 直接定址法； 数字分析法； 平方取中法； 折叠法； 随机数法； 除留余数法……  哈希函数的构造要考虑到：\n  压缩性：节省存储空间；\n  散列性：尽量减少冲突。\n要减少冲突，就要设法使哈希函数尽可能均匀地把关键字映射到存储区的各个存储单元。在构造哈希函数时，一般都要对关键字进行计算，且尽可能使关键字的所有组成部分都能起作用。\n  除留取余数法 除留取余数法是最常用的构造散列函数方法。\n除留取余数法：\n$$ f(key)=key \\enspace mod \\enspace p\\quad (p\\le m),\\ m为散列表长 $$\n $mod$ 是取模运算。\n根据经验，若散列表表长为$m$，通常$p$为小于或等于表长（最好接近$m$）的最小质数，可以更好的减小冲突。\n 冲突处理方法 解决冲突就是为出现冲突的关键字找到另一个“空”的哈希地址。在处理冲突的过程中可能得到一个地址序列$H_i,(i=1,2,\\dots,k)$。常见的处理冲突的方法有以下几种：\n 开放地址法； 多重散列法（再哈希法）； 链地址法； 公共溢出区法……  开放地址法 开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。\n有三种寻找空散列地址的方法：\n  线性探测法（线性探测再散列）：\n$$ H_i=(H(key)+d) mod m $$\n其中：\n $d$取$0,1,2,\u0026hellip;,m-1$； $m$为散列表的长度。  $d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。\n  二次探测法（二次探测再散列）：\n$$ H_i=(H(key)+q^2) mod m $$\n其中：\n $q$取$0,1,-1,2,-2,\u0026hellip;,\\pm k$，$k \\le \\cfrac{m}{2}$ $m$为散列表的长度  二次探测法其实是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。\n  线性探测法市能使第$i$个哈希地址的同义词存入第$i+1$个哈希地址，这样本应存入第$i+1$个哈希地址的元素变成了第$i+2$个哈希地址元素的同义词，……，因此，可能出现很多元素在相邻的哈希地址上“聚集”起来的现象，大大降低了查找效率。\n 排序 排序算法有稳定排序和不稳定排序两种。假设待排序序列中，$R_i$和$R_j$关键字相同，即$k_i=k_j$，且$R_i$领先与$R_j$排序后\n 稳定排序：排序后$R_i$和$R_j$相对次序不变，$R_i$任领先于$R_j$； 不稳定排序：排序后可能出现$R_j$领先于$R_i$的情况。  根据记录存储的位置可分为：\n 内部排序：待排序记录存储在内存中进行排序的过程。 外部排序：排序记录的数量很大，内存无法容纳全部记录，在排序过程需要对外存进行访问的排序过程。  排序过程需要进行的两种基本操作：\n  比较两个关键字的大小。\n这种操作对于大多数排序方法来说是必需的。\n  将记录从一个位置移动到另一个位置。\n这种操作可以通过改变记录的存储方式来避免。\n  排序算法及其时间、空间复杂度：\n   排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 是否归位     直接插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 否   希尔排序 $O(n^{1.3})$ $O(n^2)$ $O(n)$ $O(1)$ 不稳定 否   简单选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 是   堆排序 $O(nlog_2{n})$ $O(nlog_2{n})$ $O(nlog_2{n})$ $O(1)$ 不稳定 是   冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 是   快速排序 $O(nlog_2{n})$ $O(n^2)$ $O(nlog_2{n})$ $O(log_2{n})$ 不稳定 是   归并排序 $O(nlog_2{n})$ $O(nlog_2{n})$ $O(nlog_2{n})$ $O(n)$ 稳定 否     是否归位：在排序过程中，能否确定某些元素的最终排序位置。\n 选择排序 选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去都是 $O(n²)$ 的时间复杂度。\n算法步骤：\n 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复步骤2，直到所有元素均排序完毕。   归位：在排序过程中，能确定某些元素的最终排序位置。\n #include \u0026lt;stdio.h\u0026gt; void selectionSort(int arr[], int len) { for (int i = 0 ; i \u0026lt; len - 1 ; i++) { int min = i; for (int j = i + 1; j \u0026lt; len; j++) // 走访未排序的元素  // 找到最小值  if (arr[j] \u0026lt; arr[min]) min = j; // i 不是最小数时，将 i 和最小数进行交换  if (i != min) { int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); selectionSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; } 冒泡排序 冒泡排序（Bubble Sort）是一种简单直观的排序算法。\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n算法步骤：\n假设一个序列长度为n，m（m≤n）是已排序完成的在末尾的数。\n  比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。对比结束后，最后的元素会是最大的数。\n  对接下来n-m个未排序的数重复步骤1和2，直到没有任何一对数字需要比较。\n第一趟对序列中所有n个数进行比对，第二趟对序列中n-1个未排序完成的数进行比对，以此类推。每次比对的数为n-m。\n   归位：在排序过程中，能确定某些元素的最终排序位置。\n #include \u0026lt;stdio.h\u0026gt; void bubbleSort(int arr[], int len) { for (int i = 0; i \u0026lt; len - 1; i++) for (int j = 0; j \u0026lt; len - 1 - i; j++) if (arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bubbleSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; } 直接插入排序 直接插入排序的做法是：在插入第$i$个记录（$R_i$）时，序列中的前$i-1$个记录$R_1,R_2,\\cdots,R_{i-1}$已排好序。将$R_i$与前面的有序序列做比较，找到应该插入的位置将$R_i$插入，并将插入位置后的记录依序向后移动。\n 如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。\n对于基本有序的序列用直接插入排序效率是最高的。\n不归位：在排序过程中，不能确定某些元素的最终排序位置。\n 希尔排序 希尔排序又称为“缩小增量排序”，它是对直接插入排序方法的改进。\n希尔排序的基本思想是：先将整个待排记录序列分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。\n步骤如下：\n  选择一个增量序列$t_1,t_2,\u0026hellip;,t_k$，其中$t_i \u0026lt; t_{i-1}(1 \\le i \\le k),t_k = 1$；\n一般来说，$t_1 \\le \\cfrac{n}{2}$。\n  按增量序列个数$k$，对序列进行$k$趟排序；\n  每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为$t_i$的子序列，分别对各子表进行直接插入排序。仅增量因子为$1$时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n   归位：在排序过程中，能确定某些元素的最终排序位置。\n 计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是$Θ(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。\n由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。\n 计数排序是用来排序0到100之间的数字的最好的算法。\n 算法步骤：\n 找出待排序的数组中最大和最小的元素。 统计数组中每个值为 i的元素出现的次数，存入数组 C的第 i项。 对所有的计数累加（从 C中的第一个元素开始，每一项和前一项相加）。 反向填充目标数组：将每个元素 i放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。  堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。\n堆积是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；  算法步骤\n  将待排序的数组构造出一个堆 H[0……n-1]；\n  把堆首（堆顶结点，即最大值）和堆尾（堆的最下层最右边的结点）互换；\n此时不再对原堆顶（最大值）进行操作，即原堆顶已经被“移出”，堆的长度缩小1。\n  把新的数组顶端数据调整到相应位置；\n  重复步骤 2 到 3，直到堆的尺寸为 1。\n   归位：在排序过程中，能确定某些元素的最终排序位置。\n 快速排序 快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。\n算法步骤\n 从序列中选择一个元素作为“基准”（pivot）。 将所有比基准数小的放在基准左边，所有比基准数大的放在基准右边（相同的数可以在任一边）。这个称为分区（partition）操作。 分区完成后，该基准就会归到序列中的相应位置，该位置是排序完成后的位置。 分别递归地把小于基准数的子序列（左边）和大于基准数的子序列（右边）重复执行1到3操作。   归位：在排序过程中，能确定某些元素的最终排序位置。\n 归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n 自上而下的递归； 自下而上的迭代。  算法步骤：\n 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。   不归位：在排序过程中，不能确定某些元素的最终排序位置。\n ","date":"2023-04-08T00:00:00Z","permalink":"https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"数据结构（软件设计师）"},{"content":"低级和高级语言 程序设计语言根据硬件是否能识别区分为两类：\n 低级语言：二进制机器指令、汇编语言。 高级语言：面向各类应用的程序设计语言，更加接近自然语言。需要通过编译器或解释器（翻译）来让机器执行。   编译和解释 程序设计语言按照翻译的方式可分为：\n  编译：需要通过编译器（编译程序）将源程序（源代码）编译为包含二进制指令的可执行文件（目标程序）。\n真正在机器上运行的是与源程序（逻辑）等价的目标程序。\n源程序和编译器都不再参与目标程序的运行过程。\n汇编程序也是属于编译执行。\n  解释：需要通过解释器（解释程序）将源程序（源代码）中的指令解释为二进制指令后给机器执行。\n该过程不会产生独立的目标程序。\n并且解释器和源程序都会参与到程序的运行过程（运行控制）中。\n 与编译方式相比，解释方式程序执行的速度慢，因为解释方式执行的程序，需要解释器在其中充当一个原程序与机器之前实时的翻译。\n脚本语言属于动态语言，其程序结构可以在运行中改变。\n   编译过程 编译程序的功能是把某高级语言书写的源程序翻译成与之等价的目标程序（汇编语言或机 器语言)。\n编译程序的工作过程如下图所示：\n其中，以下几个阶段对于编译过程来说是必须的：\n 词法分析 语法分析 语义分析 目标代码生成  以下两个阶段对于编译过程来说不是必须的（可省略）：\n 中间代码生成 （中间或目标）代码优化  词法分析 源程序可以简单地被看成是一个多行的字符串。词法分析阶段的任务是对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号。“单词”符号是程序设计语言的基本语法单位，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。\n词法分析程序输出的“单词”常以二元组的方式输出，即单词种别和单词自身的值。\n词法分析过程依据的是语言的词法规则，即描述“单词”结构的规则。\n词法规则 词法分析根据词法规则将构成源程序的字符串转换成单词符号序列。词法规则可用3型文法（正规文法）或正规表达式描述。\n正规表达式 正规表达式（正规式）有以下符号：\n   符号 名称 含义     * 闭包 表示其前面链接的符号或集合可以出现$[0, +\\infty]$次。   · 连接 可省略，将多个符号或集合连接起来。表示逻辑与   | 或 表示逻辑或。    Example：\n设$U$、$V$和$W$均为正规式：\n有限自动机 有限自动机是词法分析的一个工具（一种识别装置的抽象概念），它能正确地识别正规集。\n  确定的有限自动机（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的状态是唯一的。\n一个DFA是一个五元组$(S, \\Sigma, f, s_0, Z)$：\n  $S$：包含状态的有限集（每个元素称为一个状态）。\n  $\\Sigma$：有穷字母表，其每个元素称为一个输入字符。\n  $f$：$S \\times \\Sigma \\to S$ 上的单值部分映像。\n$$ f(A,a)=Q \\qquad A \\in S, a \\in \\Sigma $$\n表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。\n  $s_0$：唯一的开始状态，$s_0 \\in S$。\n  $Z$：非空的终止状态集合，$Z \\subseteq S$。\n  DFA可以用两种直观的方式表示：\n  状态转换图：简称为转换图，是一个有向图。\n  DFA中的每个状态对应转换图中的一个结点。\n  DFA中的每个转换函数对应图中的一条有向弧。\n  双圈表示的结点是终态结点。\n 终态也可以是初态。\n   若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。\n  状态转换矩阵：用一个二位数组$M$表示。\n矩阵元素$M[A,a]$：\n 行下标：表示状态。当前状态为$A$。 列下标：表示输入的字符。当前输入为$a$。 $M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。      不确定的有限自动机（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的状态是不唯一的。\nNFA也是一个五元组$(S, \\Sigma, f, s_0, Z)$。与DFA的区别是：\n  $f$是$S \\times \\Sigma \\to 2^S$ 上的映像。\n对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。\n  有向弧上的标记可以是 $\\varepsilon$（$\\varepsilon$ 表示空）。\n   DFA是NFA的特例。\n   有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。\n 有向弧中出现如 $a,b$，代表该有向弧输入的值可以为$a$或$b$。即,代表或。\n 语法分析 语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如“表达式”“语句”和“程序”等。\n如果源程序中没有语法错误，语法分析后就能正确地构造出其语法树；否则指出语法错误，并给出相应的诊断信息。\n例如对id1 := id2 + id3 * 60进行语法分析后形成的语法树：\n 词法分析和语法分析在本质上都是对源程序的结构进行分析。\n到达语法分析阶段可以发现程序中所有的语法错误。例如：\n 变量的值是否正确； 语句的形式是否正确； 语句的结构是否合法； 检查括号是否匹配； \u0026hellip;\u0026hellip;   语法分析方法有多种，根据产生语法树的方向，可分为自底向上和自顶向下两类。\n上下文无关文法 程序设计语言的绝大多数语法规则可以采用上下文无关文法进行描述。\n上下文无关文法属于乔姆斯基定义的2型文法。\n对于上下文无关文法，$G[S] = (V_N, V_T, P, S)$，其产生式的形式都是 $A \\to \\beta$，其中 $A \\in V_n$，$\\beta \\in (V_N \\cup V_T)^*$。即：\n $V_N$：非终结符号集合， $V_T$：终结符号集合， $P$：产生式集合， $S$：开始符号。  上下文无关文法的推导过程可用树型结构描述：\n由上下文无关文法的推导过程也可以看出它是自顶向下推导。\n对于上下文无关文法中的集合，有以下对应关系：\n $S \\to P$ $P \\to V_N$ $V_N \\to V_T$  语义分析 语义分析阶段分析各语法结构的含义，检查源程序是否包含静态语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能翻译成正确的目标代码。\n语义分析的一个主要工作是进行类型分析和检查。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。\n语义分析阶段的输入是上一个阶段（语法分析）所构造的语法树。\n 语义分析后语法树中可能会出现一些语义处理结点。例如inttoreal，表示将一个整型数转换为浮点数。\n  语义分析不能发现程序中所有的语义错误。语义分析只能发现静态语义错误，动态语义错误需要在生成目标程序后运行时才能发现。\n有语义错误是可以编译成功的。例如a/0，符合语法，也符合静态语义，编译器检验不出来这个是错的，只有运行才会报错，也就是动态语义，动态语义错误常见的还有死循环。\nPS：现在有些IDE会对一些常见的动态语义错误进行检查，在程序编译前提示给用户。\n 中间代码生成 中间代码生成阶段的工作是根据语义分析的输出生成中间代码。\n“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。最常用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。四元式的形式为：\n(运算符, 运算对象1, 运算对象2, 运算结果)  语义分析和中间代码生成所依据的是语言的语义规则。\n中间代码生成阶段对于编译过程来说是可省略的。但是前面的三个阶段词法分析、语法分析和语义分析还有最后的目标代码生成是不可省略的。\n 编译器前后端 对于编译过程的各个阶段，在逻辑上可以把它们划分为：\n 前端：  词法分析 语法分析 语义分析 中间代码生成   后端：  中间代码优化 目标代码生成    以中间代码为分水岭（中间代码作为前端的输出，然后再作为后端的输入来连接前后端），把编译器分成了与机器有关的部分（后端）和与机器无关的部分（前端）。如此一来，对于同一种程序设计语言的编译器，开发出一个前端之后，就可以针对不同的机器开发相应的后端，前、后端有机结合后就形成了该语言的一个编译器。当语言有改动时，只会涉及前端部分的维护。\n对于不同的程序设计语言，分别设计出相应的前端，然后将各个语言的前端与同一个后端相结合，就可以得到各个语言在某种机器上的编译器。\n使用中间代码，将编译器分为前后端的好处是，有利于编译程序的可移植性。\n 编译程序的可移植性提高了，那么相应的源程序（源代码）的可移植也会提高。\n 中缀和后缀表达式 中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。\n根据生成的语法树，按照不同的方式遍历即可生成形式不同的表达式：\n  中缀表达式：中序遍历（左-根-右）；\n  后缀表达式：后序便利（左-右-根）。\n后缀转中缀用到了栈。\n   逆波兰式其实就是后缀式。\n 代码优化 由于编译器将源程序翻译成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间上和空间上有较大的浪费。当需要生成高效的目标代码时，必须进行优化。优化过程可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行。\n由于中间代码不依赖于具体机器，此时所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关。优化所依据的原则是程序的等价变换规则。\n目标代码生成 目标代码生成阶段的任务是把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关。\n寄存器的分配：寄存器访问速度快，但数量有限，所以如何分配及使用寄存器是目标代码生成时需要着重考虑的。\n 编译过程中为变量分配的存储单元所用的地址是逻辑地址，程序运行时再将逻辑地址映射为物理地址。\n 符号表管理 符号表的作用是：\n 记录源程序中各个符号的必要信息； 辅助语义的正确性检查和代码生成。  在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。\n 符号表在前三个阶段构建：可以始于词法分析阶段，也可以放到语法分析和语义分析阶段 符号表的使用有时会延续到目标代码的运行阶段。   编译过程中翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需的信息正确地填入符号表；对可执行语句，则是将其翻译成中间代码或目标代码。\n 出错处理 编写的源程序中出现的错误分为：\n  静态错误：\n编译阶段发现的程序错误，又可分为：\n 语法错误：有关语言结构上的错误。  如单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等。\n 静态语义错误：运算符与运算对象类型不合法等错误。    动态错误（动态语义错误）：发生在程序运行时。\n常见的动态错误例如除数为0。\n  在编译时发现程序中的错误后，编译程序应采用适当的策略修复它们，使得分析过程能够继续下去，以便在一次编译过程中尽可能多地找出程序中的错误。\n 程序设计语言的基本成分 程序设计语言的基本成分包括：\n 数据 运算 控制 传输 （函数）  数据成分 数据成分包含以下内容：\n  标识符：标识符通常是由字母、数字和下划线_组成，并且不能由数字开头。\n一般有如下种类标识符：\n 关键字。 变量名。 函数名。   现在，某些高级语言已经支持中文等字符来当作变量名。\n   常量：一般有字面量（例如123、\u0026quot;abc\u0026quot;）和不可变变量（在某些语言中也称其为常量）。\n  常量也具有类型； 常量也有对应的存储单元。     变量：用来存储数据或对象。有存储类别、类型、名称（变量名）、作用域和生存周期等属性（这些也是数据的属性）。\n  全局量：在程序代码中的作用域（作用范围）为整个文件或程序的数据。\n  局部量：在程序代码中的作用域（作用范围）为定义它的函数或语句块中的数据。\n  数据类型：按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型（C和C++）及其他类型等。\n许多程序设计语言都规定，程序中的数据都必须具有类型，其作用是：\n 分配存储单元：便于为数据合理分配存储单元； 检查数据对象：便于对参与表达式计算的数据对象进行（合法性）检查； 取值范围：便于规定数据对象的取值范围及能够进行的运算     动态数据结构，其数据的结构会在程序运行过程中改变，例如链表、二叉树等。\n动态数据结构的数据空间必须采用堆存储分配策略，数据存放在堆区。\n在C/C++中，全局变量的存储空间在静态数据区分配。\n 运算成分 大多数高级程序设计语言的基本运算可以分为：\n 算术运算。 关系运算。 逻辑运算。 位运算。 \u0026hellip;  控制结构 有以下三种结构来构造程序中的控制逻辑：\n 顺序结构。 选择结构。 循环结构。   大多数高级语言都针对循环结构提供了break、continue等控制流跳转语句。\n 传输成分 程序设计语言的传输成分指明语言允许的数据传输方式，如赋值处理、数据的输入和输出等。\n函数 函数定义：\n 函数首部：  返回值类型 函数名 形参表   函数体：定义函数所实现的功能。  函数声明：在C（C++）中，函数需要先声明后引用。\n函数调用：在调用函数中使用被调函数实现的功能。函数调用的一般形式为：\n函数名(实参表) 调用函数与被调函数之间参数的传递有两种形式：\n  值调用（Call by Value）：形参是实参的一份拷贝。即实参将值传递给形参，对形参值的更改并不会作用到实参上。\n  引用调用（Call by Reference）：形参是实参的一个别名。即函数中对形参的访问和修改实际上是对其相应实参所做的访问和修改。\n引用调用下，可以实现形参和实参之间数据的双向传递。\n   在进行函数调用和返回时，由系统使用栈区来进行控制和管理。\n ","date":"2023-03-30T19:58:41+08:00","permalink":"https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"程序设计语言（软件设计师）"},{"content":"计算机的基本单位   位（比特） bit、b  最小数据单位/td   字节 byte、B 1B = 8b 最小存储单位   千字节 KB 1KB = 1024B    兆字节 MB 1MB = 1024KB   吉字节 GB 1GB = 1024MB    太字节 TB 1TB = 1024GB     计算机系统 计算机系统由硬件和软件组成。\n计算机基本硬件系统：\n 运算器 控制器 存储器 输入设备 输出设备   中央处理单元 运算器、控制器等部件被集成在一起统称中央处理单元（CPU）。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。\n中央处理单元（CPU）负责获取程序指令、对指令进行译码并加以执行。\nCPU的功能：\n  程序控制：通过执行指令来控制程序的执行顺序\n  操作控制：CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。\n  时间控制：对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。\n  数据处理：通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。\n对数据的加工处理也是CPU最根本的任务。\n  对系统内部和外部的中断（异常）做出响应，进行相应的处理。\n  CPU的组成：\n 运算器 控制器 寄存器组 内部总线  运算器 运算器组成部件：\n  算术逻辑单元（ALU）：重要组成部件。负责处理数据，实现对数据的算术运算和逻辑运算。\n  累加寄存器（AC，累加器）：是一个通用寄存器。存放操作数或者结果。\n其功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。例如，在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。 运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器。\n  数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字，将不同时间段内读/写的数据隔离开来。\nDR的主要作用为：\n 作为CPU和内存、外部设备之间数据传送的中转站； 作为CPU和内存、外围设备之间在操作速度上的缓冲； 在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。    状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态（标志通常分别由1位触发器保存）。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。\n  控制器 控制器用于控制整个CPU的工作，它决定了计算机运行过程的 自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。\n指令控制逻辑要完取指令、分析指令和执行指令的操作，其过程分为取指令、指令译码、按指令操作码执行、形成下一条指令地址等步骤。\n  指令寄存器（IR）：暂存要执行的指令，该指令从内存中获取（通过缓冲寄存器）。\n当CPU执行一条指令时：\n 把指令从内存储器取到缓冲寄存器中。 送入IR暂存。 指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。    程序计数器（PC，指令计数器）：具有寄存信息和计数两种\n 在程序开始执行前，将程序的起始地址送入PC。 该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。 执行指令时，CPU自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。  由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。\n执行转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。\n  地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。\n  指令译码器(ID)。指令包含操作码和地址码两部分，而指令译码器就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。\n   数据表示 原码 原码表示法又叫符号加绝对值表示法。最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。\n原码特点：\n 0的表示不唯一（有正负0）； 加、减运算方式不统一； 需额外对符号位进行处理，不利于硬件设计； 当 $a \u0026lt; b$ 时，实现 $a-b$ 比较困难。  反码 最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。正数的反码与原码相同，负数的反码则是除符号位以外其余各位按位取反。\n补码 计算机中的补码是模2补码\n概念：在一个模运算（Moduler Arithmetic）系统中，同余（Congruence Modulo）的数等价。\n补码的定义：有 $n$ 位时，$[X]_补=(2^n+X)\\mod{2^n}\\quad (-2^{n-1}\\leq X\u0026lt;2^{n-1})$。\n  当 $X\u0026lt;0$ 时，补码有两种求法：\n 各位取反，末位加 1。 从第 2 个 1 开始往右各位取反。    当 $X\u0026gt;0$ 时，补码与原码相同。\n  补码的减法：$Y-X=Y+[-X]_补$。\n特殊的补码：\n  $[-2^{n-1}]_补=(2^n-2^{n-1})\\mod{2^n}=(10\\ldots0)_2\\ (n-1 个0)$。\n这个数的最高位（符号位）即表示符号，又表示数值。如，-128。\n  $[-1]_补=2^n-1=(11\\ldots1)_2\\ (n个1)$。\n  $[+0]_补=[-0]_补=(00\\ldots0)\\ (n个0)$。 补码的0表示唯一。\n  移码  移码就是将每个数值加上一个偏置常数（Excess/Bias）。 通常，当编码位数为 $n$ 时，bias 取 $2^{n-1}$ 或 $2^{n-1}-1$。 移码可以方便地进行大小的比较。  移码可以看成是在其补码的基础上对符号位取反。移码的0表示唯一。\n 其实（个人认为）根据补码和移码的定义，可以将补码当作特殊的移码。其bias为$2^n$。\n 各种码制带符号数的范围 浮点数 浮点数使用两个定点数来分别表示实数的尾数（F）和阶码（E）。其一般形式为：$N=2^E \\times F$。\n 一个数的浮点表示不是唯一的。小数点位置改变，阶码也随着相应改变。 浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。  规格化浮点数：\n 尾数$M \\ge 0$，其规格化尾数形式为$M=0.\\times\\times\\times$，$\\times$可为0也可为1。即$M$限定在了$[0.5,1]$。 尾数$M \\le 0$，其规格化尾数形式为$M=1.\\times\\times\\times$，$\\times$可为0也可为1。即$M$限定在了$[-1,-0.5]$。  一般浮点数阶码用R位的移码表示，尾数用M位的补码表示。这种表示的数值范围为：\n$$ -1 \\times 2^{(2^{R-1}-1)} \\sim +(1-2^{-M+1}) \\times 2^{(2^{R-1}-1)} $$\n现在所有通用计算机都采用 IEEE 754 来表示浮点数。IEEE 754 的尾数用原码表示，阶码还是用移码表示。\n 寻址方式  立即寻址：操作数就包含在指令中。 直接寻址：操作数在内存，指令给出操作数的地址。 寄存器寻址：操作数在寄存器，指令给出操作数的寄存器名（地址）。 寄存器间接寻址：操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。 间接寻址：指令中给出操作数地址（操作数地址在内存中）的地址。 相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。 变址寻址：操作数地址等于变址寄存器的内容加偏移量。   校验码 码距，是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。码距为n的编码方案，在该编码方案中任意两个合法编码之间至少有n个二进制位不同。例如值1和2的编码分别为0000 0001和0000 0010他们最后两位不同，所以，码距为2。\n 一个编码系统的码距$\\ge 2$时，该编码系统具有检错能力； 一个编码系统的码距$\\ge 3$时，该编码系统才可能有纠错能力。  即，一个校验码要想能够检错和纠错那么它的码距至少是3。\n奇偶校验码 奇偶校验（Parity Codes）是通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）或者为偶数（偶校验）。但该编码只能检错，但不能纠错。\n 奇偶校验码码距为2。 奇校验：仅检测出代码中奇数位数（奇数个0或1发生错误），不能发现偶数位数出错。偶校验反之。 常用的奇偶校验码有3种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。  海明码 海明码（Hamming Code）是一种利用奇偶性来检错和纠错的校验方法。海明码是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：\n$$ 2^k-1 \\ge n+k $$\n 该公式的字面意思为，$k$个校验位的最大值（$k$个校验位都为1），要比海明码的位数（$n+k$）要大。 海明码的码距为3。\n 海明码的编码规则如下：\n  $k$个校验位：$P_k, P_{k-1}, \\cdots, P_1$。\n  $n$个数据位：$D_{n-1}, D_{n-2}, \\cdots, D_1, D_0$。\n  对应的海明码：$H_{n+k}, H_{n+k-1}, \\cdots, H_1$。\n $H_j = P_i, j=2^{i-1}$。 数据位依序插入到海明码中剩下的位置。    海明码中任一位都是由若干个校验位来检验：\n 校验数据位时：被校验的海明位的下标等于所有参与校验该位的校验位的下标之和。 校验位由自身校验。  Example：\n  偶校验：$G_4G_3G_2G_1={(0000)}_{2}$则表示数据无错误，否则表示接收到的数据有错误。\n若出错，$G_4G_3G_2G_1$的十进制值指出来出错位置。如$G_4G_3G_2G_1=1010$，说明$H_{10}(D_5)$出错，将其取反即可纠错。\n  奇校验：$G_4G_3G_2G_1=(1111)_2$则表示数据无错误，否则表示接收到的数据有错误。\n  循环冗余码 循环冗余校验码（Cyclic Redundancy Check，CRC）广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生个校验位来进行编码，其编码长度为k+r。CRC的代码格式为：\n若CRC码的字长为n，又可称其为（n,k）码，则：\n  左边为信息码（数据），占k位；\n  右边为校验码，占n-k位。\n校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。\n  在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。\nCRC码距为2，可以检错不能纠错。\n 计算机指令集     RISC\n精简指令集（计算机） CISC\n复杂指令集（计算机）     指令种类 少、精简 多、复杂   指令复杂度 低（简单） 高（复杂）   指令长度 固定 变化   寻址方式 少 复杂多样   实现（译码方式） 硬布线控制逻辑（组合逻辑控制器） 微程序控制技术   通用寄存器数量 多、大量 一般   流水线技术 支持 不支持     流水线技术 计算机中的流水线技术（Pipelining）是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。\n若要执行$n$条指令：\n  顺序执行总时间：\n$$ 顺序执行总时间=单条指令执行的时间\\times n $$\n  流水线执行总时间：\n$$ 流水线执行总时间=一条指令执行的时间+流水线周期 \\times (n-1) $$\n流水线（操作）周期为执行时间最长的一段操作的时间。\n  连续输入$n$条指令的吞吐率：\n$$ 吞吐率=\\cfrac {n}{总执行时间} $$\n如果是流水线的吞吐率，则总执行时间为流水线执行总时间。 流水线的吞吐率是最长流水段操作时间的倒数。即：\n$$ 最长流水段操作时间=\\cfrac {流水线执行总时间}{n} $$\n  加速比：\n$$ 加速比 = \\cfrac{顺序执行总时间}{流水线执行总时间} $$\n   存储器 按存储器所处位置可分为：\n 内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。 外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。  按存储器的构成材料分类：\n 磁存储器 半导体存储器 光存储器  按存储器工作方式：\n  读/写存储器（RAM）。\n  只读存储器：ROM、PROM、EPROM、EEPROM等。\n 固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。 可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。    按访问方式：\n  按地址访问：\n可分为：\n 随机存储器 顺序存储器 直接存储器    按内容访问：例如相联存储器。\n  虚拟存储器由主存与辅存组成。\nDRAM（动态随机存储器）构成主存 DRAM需要周期性地刷新保持信息。\nSRAM（静态随机存储器）构成Cache（缓存）。\n闪存类似U盘，掉电后信息不会丢失。以块为单位进行删除。闪存是EPROM的一种类型，可以代替ROM存储器。闪存不可以代替主存。\n缓存 高速缓存用来存放当前最活跃的程序和数据，其特点是：\n 位于CPU与主存之间；容量一般在几千字节到几兆字节之间； 速度一般比主存快5~10倍，由快速半导体存储器构成； 其内容是主存局部域的副本，对程序员来说是透明的（看不到或可以忽略）。  Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。\n缓存地址映射 CPU工作时，送出的是主存单元的地址。为从Cache存储器中读/写信息，就需要将主存地址转成Cache存储器的地址，这种地址转换即为地址映像。\n高速缓存中的地址映像方法：\n  直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。\n  全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。\n  组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。\n   发生块冲突从多到少的顺序：直接映像 \u0026gt; 组相联映像 \u0026gt; 全相联映像。 地址映像都是由硬件自动完成。\n  中断 计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回源程序，这个过程称为中断。\n中断是一种非常重要的技术，输入输出设备和主机交换数据、分时操作、实时系统、计算机网络和分布式计算机系统中都要用到这种技术。为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。\n输入输出控制方式 程序查询方式（程序直接控制方式）：\n CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。 一次只能读/写一个字。 由CPU将数放入内存。  中断驱动方式：\n I/O设备通过中断信号主动向CPU报告I/O操作已完成。 CPU和I/O可并行工作。 CPU利用率得到提升。 一次只能读/写一个字。 由CPU将数据放入内存。  DMA方式（直接存储器存储方式）：\n CPU和I/O可并行工作。 仅在传送数据块多开始和结束时才需要CPU的干预。 由外设直接将数据放入内存。 一次读写的单位为\u0026quot;块\u0026quot;而不是字。  DMA传输数据比中断驱动方式传输数据要快一点。\n 总线 总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。\n采用总线结构主要有以下优点：\n 简化系统结构，便于系统设计制造； 大大减少了连线数目，便于布线，减小体积，提高系统的可靠性； 便于接口设计，所有与总线连接的设备均采用类似的接口； 便于系统的扩充、更新与灵活配置，易于实现系统的模块化； 便于设备的软件设计； 便于故障诊断和维修，同时也降低了成本。  在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以减少信息传输线的数量。\n微机中的总线分为：\n 数据总线 地址总线 控制总线  常见总线：\n ISA总线。 EISA总线。 PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。 PCI Express 总线。 前端总线。 RS-232C。 SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。 SATA。 USB。 IEEE-1394。 IEEE-488总线。  地址总线宽度：例如，内存容量4GB，$4GB=2^{2+10+10+10}B=2^32B$。所以内存单元的地址宽度为32位，即地址总线宽度为32位。\n数据总线宽度：例如字长为32的机器，那么其数据总线的宽度要为32。\n 加密技术与认证技术 加密技术 加密技术用于防止第三方窃听。\n  对称加密：只有一把密钥。加密和解密用同一把密钥。\n 密钥分发有缺陷。 加密解密速度很快。 适合加量大量明文数据。    非对称加密：\n 加密和解密不是同一把密钥。 一共有两把密钥，分别是公钥和私钥。 用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。 不能通过一把密钥推出另一把密钥。 用接收方的公钥加密明文可以实现防止窃听的效果。 密钥分发没有缺陷。 加密解密速度很慢。    认证技术 认证技术用于防止篡改、假冒和否认。\n摘要（防止篡改）：将发送的明文进行Hash算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比如果一致，侧没有篡改，否则有篡改。\n数字签名（防止假冒和否认）：\n发送方用自己的私钥对摘要进行签名（加密）。得到数字签名放在密文后一起发送过去。\n接收方用发送方的公钥对数字签名进行验证（解密）。如果验证成功则该消息没有被假冒且不能否认，否则该消息的真实性为假冒发送。\n数字证书 数字证书是用第三方CA机构使用自己的私钥对用户的公钥签名（加密），来保证这个公钥不被篡改。然后接收方用CA的公钥验证（解密），从而得到用户的公钥。\n加密算法 对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：\n DES 3DES RC-5 IDEA AES RC4  非对称密钥（公钥、公开密钥加密）算法：\n RSA ECC DSA  其他加密算法：\n  Hash函数\n  SHA-1安全散列算法\n  MD5摘要算法：\n 输出结果为128位 摘要算法防止发送的报文被篡改    加密可以阻止被动攻击，认证可以阻止主动攻击（不可以处理被动攻击）。\n 系统可靠度 ","date":"2023-03-24T00:00:00Z","permalink":"https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"计算机系统（软件设计师）"},{"content":"项目笔记仓库：https://gitee.com/linner_cheng/reggie_note\nB站视频：黑马程序员Java项目实战《瑞吉外卖》\n","date":"2023-03-21T00:00:00Z","permalink":"https://blog.linner.asia/p/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","title":"瑞吉外卖项目实战"},{"content":"数据类型 Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：\n  字符串 —— string\n  哈希 —— hash\n适合存储对象。\n  列表 —— list\n按照插入顺序排序，可以有重复元素。可以用来做任务队列。\n  集合 —— set\n无序集合，没有重复元素（后插入的元素会覆盖已有的相同元素）。\n  有序集合 —— sorted set\n有序集合（使用分值进行排序），没有重复元素。\n   常用命令  Redis命令符不区分大小写，但是key是区分大小写的。 更多命令请参考Redis中文网。\n 字符串操作命令 SET key value  设置指定key的值。 key相同的情况下，后设的值会覆盖前面的值。  GET key  获取指key的值。  SETEX key seconds value  设置指定key的值，并将key的过期时间设为seconds秒。  SETNX key value   只有在key不存在时设置key的值。\n  如：\n\u0026gt; SETNX key1 value1 1 \u0026gt; SETNX key1 value2 0 \u0026gt; GET key1 value1   哈希操作命令 Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。\nHSET key field value  将哈希表key种的字段field的值设为value。  HGET key field  获取存储在哈希表中指定字段的值。  HDEL key field  删除存储在哈希表中的指定字段。  HKEYS key  获取哈希表中所有字段。  HVALS key  获取哈希表中所有值。  HGETALL key  获取在哈希表中指定key的所有字段和值。  列表操作命令 LPUSH key value1 [value2 ...]  将一个或多个值插入到列表头部。  LRANGE key start stop  获取列表指定范围内的元素（start到stop，索引从0开始）。  RPOP key  移除并获取列表最后一个元素。  LLEN key  获取列表长度。  BRPOP key1 [key2 ...] timeout  移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时（timeout秒）或（在指定的key中）发现可弹出元素为止。  集合操作命令 Redis set是string类型的无序集合，集合成员是唯一的。\nSADD key member1 [member2 ...]  向集合添加一个或多个成员。  SMEMBERS key  返回集合中的所有成员。  SCARD key  获取集合的成员数。  SINTER key1 [key2 ...]  返回给定所有集合的交集。  SUNION key1 [key2 ...]  返回所有给定集合的并集。  SDIFF key1 [key2 ...]  返回给定所有集合的差集（左差集，即key1集合中在其他集合没有的元素集合）。  SREM key member1 [member2 ...]  移除集合中一个或多个成员。  有序集合操作命令 Redis sorted set 是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数（score）。Redis通过分数来为集合中的成员进行从小到大排序，有序集合的成员是唯一的，但分数却可以重复。\nZADD key score1 member1 [score2 member2 ...]  向有序集合添加一个或多个成员，或者更新已存在成员的分数。  ZRANGE key start stop [WITHSCOES]  通过索引区间返回有序集合中指定区间内的成员。使用WITHSCOES可以返回成员的分数。  ZINCRBY key increment member  有序集合中对指定成员的分数加上增量increment。  ZREM key member [member ...]  移除有序集合中的一个或多个成员。  通用命令 KEYS pattren  查找所有符合给定模式（pattern）的key。  EXISTS key  检查给定key是否存在。  TYPE key  返回key所存储的值的类型。  TTL key  返回给定key的剩余生存时间（TTL，time to live），以秒为单位。  DEL key1 [key2 ...]   该命令用于在key存在时删除key。\n  如：\n\u0026gt; TTL key -1 返回-1表示永久存活。\n  切换数据库 Redis 默认是在0号数据库中执行操作。如果想要切换数据库，可以使用：\nSELECT number 如：\n127.0.0.1:6379\u0026gt; SELECT 1 OK 127.0.0.1:6379[1]\u0026gt; Redis 默认提供了16个数据库。\n要修改该配置可以在redis.conf中修改databases的数量。\ndatabash 16  Spring Data Redis 配置 application.yml：\nspring: application: name: springdataredis-demo # Redis相关配置 data: redis: host: localhost port: 6379 password: 123456 database: 0 # 操作0号数据库 jedis: # Redis连接池配置 pool: max-active: 8 # 最大连接数 max-wait: 1ms # 连接池最大阻塞等待时间 max-idle: 4 # 连接池中的最大空闲连接 min-idle: 0 # 连接池中的最小空闲连接 配置类（修改默认序列化器，防止因序列化在Redis上产生乱码，但并不妨碍读值。因为读取时会自动反序列化）：\n@Configuration public class RedisConfig extends CachingConfigurerSupport { @Bean public RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate = new RedisTemplate\u0026lt;\u0026gt;(); // 默认的Key序列化器为：JdkSerializationRedisSerializer  redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(connectionFactory); return redisTemplate; } } 测试 @SpringBootTest @RunWith(SpringRunner.class) public class SpringDataRedisTest { @Autowired private RedisTemplate redisTemplate; /** * 操作字符串类型数据 */ @Test public void testString() { // 获得String类型数据操作对象  ValueOperations valueOperations = redisTemplate.opsForValue(); valueOperations.set(\u0026#34;city\u0026#34;, \u0026#34;guangzhou\u0026#34;); String city = (String) valueOperations.get(\u0026#34;city\u0026#34;); System.out.println(city); // 设置超时  valueOperations.set(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;, 10L, TimeUnit.SECONDS); // 不存在才设置  Boolean setIfAbsent1 = valueOperations.setIfAbsent(\u0026#34;city\u0026#34;, \u0026#34;foshang\u0026#34;); System.out.println(Boolean.TRUE.equals(setIfAbsent1) ? \u0026#34;city设置成功\u0026#34; : \u0026#34;city已存在\u0026#34;); Boolean setIfAbsent2 = valueOperations.setIfAbsent(\u0026#34;city_name\u0026#34;, \u0026#34;foshang\u0026#34;, 10L, TimeUnit.SECONDS); Object cityName = valueOperations.get(\u0026#34;city_name\u0026#34;); System.out.println(setIfAbsent2 ? \u0026#34;city_name设置成功:\u0026#34; + cityName : \u0026#34;city_name已存在\u0026#34;); } /** * 操作哈希类型数据 */ @Test public void testHash() { HashOperations hashOperations = redisTemplate.opsForHash(); String id = \u0026#34;002\u0026#34;; // 存值  hashOperations.put(id, \u0026#34;name\u0026#34;, \u0026#34;xiaoming\u0026#34;); hashOperations.put(id, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); hashOperations.put(id, \u0026#34;address\u0026#34;, \u0026#34;guangzhou\u0026#34;); // 取值  String name = (String) hashOperations.get(id, \u0026#34;name\u0026#34;); String age = (String) hashOperations.get(id, \u0026#34;age\u0026#34;); String address = (String) hashOperations.get(id, \u0026#34;address\u0026#34;); System.out.println(\u0026#34;name:\u0026#34; + name + \u0026#34;,age:\u0026#34; + age + \u0026#34;,address:\u0026#34; + address); // 获取hash结构中的所有字段  Set keys = hashOperations.keys(id); for (Object key : keys) { System.out.println(key); } // 删除  //hashOperations.delete(keys, \u0026#34;address\u0026#34;, \u0026#34;age\u0026#34;);  // 获得hash结构中的所有值  List\u0026lt;String\u0026gt; values = hashOperations.values(id); for (String value : values) { System.out.println(value); } } /** * 操作列表类型数据 */ @Test public void testList() { ListOperations listOperations = redisTemplate.opsForList(); String key = \u0026#34;mylist\u0026#34;; // 存储  listOperations.leftPush(key, \u0026#34;a\u0026#34;); listOperations.leftPushAll(key, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;); // 取值  System.out.printf(\u0026#34;入队：\u0026#34;); List\u0026lt;String\u0026gt; myList = listOperations.range(key, 0, -1); for (String s : myList) { System.out.printf(s + \u0026#34; \u0026#34;); } System.out.println(); // 获得列表长度 llen  int size = listOperations.size(key).intValue(); System.out.printf(\u0026#34;出队：\u0026#34;); for (int i = 0; i \u0026lt; size; i++) { // 出队列  String element = (String) listOperations.rightPop(key); System.out.printf(element + \u0026#34; \u0026#34;); } System.out.println(); } /** * 操作集合类型数据 */ @Test public void testSet() { SetOperations setOperations = redisTemplate.opsForSet(); String key = \u0026#34;myset\u0026#34;; // 存值  setOperations.add(key, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;a\u0026#34;); // 取值  Set\u0026lt;String\u0026gt; myset = setOperations.members(key); for (String s : myset) { System.out.printf(s + \u0026#34; \u0026#34;); } System.out.println(); // 删除成员  setOperations.remove(key, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); // 取值  myset = setOperations.members(key); for (String s : myset) { System.out.printf(s + \u0026#34; \u0026#34;); } System.out.println(); } /** * 操作有序集合类型数据 */ @Test public void testZset() { ZSetOperations zSetOperations = redisTemplate.opsForZSet(); String key = \u0026#34;myZset\u0026#34;; // 存储  zSetOperations.add(key, \u0026#34;a\u0026#34;, 10.); zSetOperations.add(key, \u0026#34;b\u0026#34;, 11.); zSetOperations.add(key, \u0026#34;c\u0026#34;, 12.); zSetOperations.add(key, \u0026#34;d\u0026#34;, 13.); zSetOperations.add(key, \u0026#34;a\u0026#34;, 14.); // 取值  Set\u0026lt;String\u0026gt; range = zSetOperations.range(key, 0, -1); for (String s : range) { System.out.printf(s + \u0026#34; \u0026#34;); } System.out.println(); // 修改分数  zSetOperations.incrementScore(key, \u0026#34;b\u0026#34;, 20.); // 删除成员  zSetOperations.remove(key, \u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;); // 取值  range = zSetOperations.range(key, 0, -1); for (String s : range) { System.out.printf(s + \u0026#34; \u0026#34;); } System.out.println(); } /** * 通用操作 */ @Test public void testCommon() { // 获取Redis中所有key  Set\u0026lt;String\u0026gt; keys = redisTemplate.keys(\u0026#34;*\u0026#34;); for (String key : keys) { System.out.println(key); } // 判断m某个key是否存在  Boolean hasKey = redisTemplate.hasKey(\u0026#34;linner\u0026#34;); System.out.println(hasKey ? \u0026#34;linner存在\u0026#34; : \u0026#34;linner不存在\u0026#34;); // 删除指定key  redisTemplate.delete(\u0026#34;myZset\u0026#34;); // 获取指定key对应的value的数据类型  DataType dataType = redisTemplate.type(\u0026#34;myset\u0026#34;); System.out.println(dataType.name()); } } ","date":"2023-03-11T00:00:00Z","permalink":"https://blog.linner.asia/p/redis%E5%9F%BA%E7%A1%80/","title":"Redis基础"},{"content":"简介 MybatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具（依然可以使用MyBatis里的工具），旨在简化开发、提供效率。更多详情请访问MyBatisPlus官网（官网有两个地址，https://mp.baomidou.com/或https://mybatis.plus）。\n基于Spring使用MybatisPlus，在构建Spring工程时需要勾选MySQL和MyBatis相关技术。由于Spring并未收录MP，所以需要手动导入坐标：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 可选： --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在application.yml（配置文件）中配置数据库信息：\nspring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=Asia/Shanghai  username: root password: root  DAO接口 使用MP编写DAO接口，可以直接继承BaseMapper\u0026lt;\u0026gt;（该接口内置了许多DAO方法）：\n@Mapper public interface UserDao extends BaseMapper\u0026lt;User\u0026gt;{ } 编写引导类：\n@SpringBootApplication public class MybatisplusApplication { public static void main(String[] args) { SpringApplication.run(MybatisplusApplication.class, args); } } DAO接口要想被容器扫描到，有两种方案：\n 在DAO接口上添加@Mapper注解，并且确保DAO处在引导类所在包或其子包中。 在引导类上添加@MapperScan注解，其属性为所要扫描的DAO所在包：@MapperScan(\u0026quot;com.linner.dao\u0026quot;)（可以不写@Mapper）。  ","date":"2023-02-28T00:00:00Z","permalink":"https://blog.linner.asia/p/mybatisplus/","title":"MyBatisPlus"},{"content":"多模块开发 多模块开发有以下两种：\n 按照功能拆分。 按照模块拆分。  例如，将项目中的DAO类拆分出来作为一个独立的模块。然后使用Maven将该模块作为依赖导入项目中。\n假设现在已经将项目中的实体类拆分出来作为maven-dao模块。该模块也使用Maven构建，然后导入该项目所需依赖。经过测试后，将该项目的\u0026lt;groupId\u0026gt;、\u0026lt;artifactId\u0026gt;和\u0026lt;version\u0026gt;导入原本项目。\nmaven-dao模块的pom.xml中：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;!-- 将下面内容作为依赖导入到原项目中 --\u0026gt; \u0026lt;groupId\u0026gt;com.linner\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springmvc-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- END --\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/project\u0026gt; 将上方\u0026lt;groupId\u0026gt;、\u0026lt;artifactId\u0026gt;和\u0026lt;version\u0026gt;导入原项目：\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.linner\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springmvc-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/dependencies\u0026gt; 接着使用Maven的install命令将maven-dao模块安装到Maven本地仓库中，项目即可正常启动。\n 依赖管理 依赖传递 Maven项目中的依赖是具有传递性的。即，依赖的依赖可以作为依赖使用。将依赖关系作为树状结构看待，那么依赖的子孙依赖，也可以作为项目的依赖。\n依赖传递有直接依赖和间接依赖。\n  直接依赖：\n在pom.xml中编写的依赖就是该项目的直接依赖。即，依赖树中，子依赖（子节点）即为当前项目（根节点）的直接依赖。\n  间接依赖： 依赖树中，直接依赖下的所有依赖（孙子节点）即为当前项目的间接依赖。\n  因为依赖传递的存在，会导致使用依赖的过程中出现冲突问题。例如有两个相同的依赖，它们的版本不同，就会导致依赖冲突。\nMaven指定了一系列规则来解决依赖冲突问题。\n 特殊优先：同级下（依赖树中同个父节点的依赖为同级，即同个pom.xml下），配置了相同资源的不同版本，后配置的覆盖先配置。 路径优先：依赖树中，层级越浅，优先级越高；层级越深，优先级越低。 声明优先：资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。即，谁先声明用谁。   注意：依赖的优先级只对当前项目起作用。即，当前项目选择的依赖版本并不会影响到依赖中相同资源不同版本的依赖。 最终选择的依赖结果根据Idea中Mavem面板的依赖树视图。\n 可选依赖 可选依赖指对外隐藏当前所依赖的资源（不透明），隐藏后对应资源将不具有依赖传递。\n可选依赖的开关使用\u0026lt;optional\u0026gt;。如：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;xxx.xxxxxx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xxxxx-xxxxxx\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;x.x.x\u0026lt;/version\u0026gt; \u0026lt;!-- 默认为false，设置为true为开启可选依赖 --\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 排除依赖 排除依赖指主动断开依赖的资源，被排除的资源无需指定版本（不需要）。即，在当前项目中，排除依赖中不需要的间接依赖。\n排除依赖使用\u0026lt;exclusions\u0026gt;来指定一个排除的依赖列表。列表中使用\u0026lt;exclusion\u0026gt;来指定要排除的依赖。如：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;xxx.xxxxxx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xxxxx-xxxxxx\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;x.x.x\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;yyy.yyyyyy\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;yyyyy-yyyyyyy\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 排除依赖不需要指定版本 --\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 聚合工程 聚合即为将多个模块组织成一个整体，同时进行项目构建的过程。聚合工程通常是一个不具有业务功能的\u0026quot;空\u0026quot;工程（有且仅有一个pom文件）。使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建。当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。\nExample：\n创建一个空的Maven项目，并将其打包方式设置为pom，然后添加所要管理的项目：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.linner\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;x.x.x\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 设置管理的模块名称 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;!-- module里面的值为管理模块的相对路径 --\u0026gt; \u0026lt;module\u0026gt;../xxxx\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../yyyy\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../zzzz\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;/project\u0026gt; 当该maven-parent被compile后，所有被其管理的项目都会被执行编译操作。\n 聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。\n 继承 继承是用来解决重复配置问题。继承描述的是两个工程间的关系子工程可以继承父工程中的配置信息，常见于依赖关系的继承。继承的作用：简化配置、减少版本冲突。\n 一般继承和聚合都是使用同一个空项目来构建，但是这两个的功能是不一样的。\n 在子工程中配置当前工程继承自parent工程：\n\u0026lt;!-- 在project下配置 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.linner\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;x.x.x\u0026lt;/version\u0026gt; \u0026lt;!--设置父项目pom.xml位置路径--\u0026gt; \u0026lt;relativePath\u0026gt;../maven-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 将子项目共同使用的依赖都抽取出来，维护在父项目的pom.xml中：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.linner\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;x.x.x\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../xxxx\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../yyyy\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../zzzz\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 子项目依赖版本问题 如果把所有用到的依赖都管理在父项目的pom.xml，这样就会导致有很多项目引入了过多自己不需要的依赖，这样对于子项目来说也是种负担。\n可以在父工程中使用\u0026lt;dependencyManagement\u0026gt;来定义依赖管理：\n\u0026lt;!-- 在project下配置 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencyManagement\u0026gt;标签不真正引入jar包，而是配置可供子项目选择的jar包依赖。\n如果子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定\u0026lt;version\u0026gt;：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 子项目使用的jar包version由父项目决定。\n 属性 Maven属性的概念和变量的概念很相似。在一个地方声明，其他地方使用，当属性的声明修改后，所有使用属性的地方都会跟着修改。\n在Maven中的属性分为:\n  自定义属性。\n  内置属性。\n使用mvn help:system命令查看。\n  Setting属性。\n  Java系统属性。\n  环境变量属性。\n  自定义属性 在父工程中使用\u0026lt;properties\u0026gt;定义属性：\n 5.2.10.RELEASE 4.12 1.3.0  定义属性标签的名称可以自定义，如\u0026lt;spring.version\u0026gt;也可以修改为\u0026lt;spring-version\u0026gt;。\n接着修改依赖的version：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用${属性名}来使用属性。\n配置文件加载属性 属性也可以作用于其他配置文件中（如jdbc.properties）。\n先在父工程中定义属性，并且设置Maven过滤文件范围：\n\u0026lt;properties\u0026gt; \u0026lt;jdbc.url\u0026gt;jdbc:mysql://127.1.1.1:3306/spring_db\u0026lt;/jdbc.url\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;!-- 设置资源目录（相对路径） --\u0026gt; \u0026lt;directory\u0026gt;../xxxx/src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;!-- 设置是否能够解析${}，默认是false --\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 修改jdbc.properties（属性值的使用方式与pom.xml中相同）：\njdbc.driver=com.mysql.jdbc.Driver jdbc.url=${jdbc.url} jdbc.username=root jdbc.password=root 如果需要在多个项目中解析属性值，可以使用${project.basedir}（Maven的内置系统属性）来简化书写：\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;!-- ${project.basedir}: 表示当前项目所在目录 子项目继承了父项目，相当于所有的子项目都添加了资源目录的过滤 --\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;${project.basedir}/src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;!-- 忽略 web.xml 检查 或者在 src\\main\\webapp\\WEB-INF\\ 添加一个 web.xml 文件 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.3\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 忽略 web.xml 检查 --\u0026gt; \u0026lt;failOnMissingWebXml\u0026gt;false\u0026lt;/failOnMissingWebXml\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  使用mvn help:system命令可以查看更多的内置属性。\n  版本管理  SNAPSHOT（快照版本）：  项目开发过程中临时输出的版本，称为快照版本。 快照版本会随着开发的进展不断更新。   RELEASE（发布版本）：  项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的。 即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本。   alpha（内测版）：Bug多、不稳定、内部版本不断添加新功能。 beta（公测版）：不稳定（相对比alpha稳定些），Bug相对较多不断添加新功能。 纯数字版本。   多环境开发 Maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。\n在父工程中配置多个环境，并指定默认激活环境：\n\u0026lt;profiles\u0026gt; \u0026lt;!--开发环境--\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;jdbc.url\u0026gt;jdbc:mysql://127.1.1.1:3306/spring_db\u0026lt;/jdbc.url\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;!-- 设定是否为默认启动环境 --\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;!--生产环境--\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;pro\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;jdbc.url\u0026gt;jdbc:mysql://127.2.2.2:3306/spring_db\u0026lt;/jdbc.url\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;!--测试环境--\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;test\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;jdbc.url\u0026gt;jdbc:mysql://127.3.3.3:3306/spring_db\u0026lt;/jdbc.url\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; 动态切换配置环境可以使用Maven的-P参数来指定，参数值为环境id：\nmvn install -P test  跳过测试 在执行install指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行test。test可以确保每次打包或者安装的时候，程序的正确性。\n但是，假如测试已经通过，在没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。或者，功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。此时就需要跳过测试：\n  Idea工具可以实现跳过测试（Maven面板中带闪电图标的按钮）。\n  在父工程中的pom.xml中添加测试插件配置：\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.4\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;skipTests\u0026gt;false\u0026lt;/skipTests\u0026gt; \u0026lt;!--排除掉不参与测试的内容--\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt;**/BookServiceTest.java\u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;configuration\u0026gt;中有如下标签：\n skipTests：如果为true，跳过所有测试；为false，不跳过测试。 excludes：不参与测试的测试类，针对skipTests为false来设置的。 includes：参与测试的测试类，针对skipTests为true来设置的。    命令跳过测试：\nmvn 指令 -D skipTests   执行的项目构建指令必须包含测试生命周期，否则无效果。 命令需要在pom.xml所在目录下进行执行。     ","date":"2023-02-27T00:00:00Z","permalink":"https://blog.linner.asia/p/maven-%E9%AB%98%E7%BA%A7/","title":"Maven 高级"},{"content":"SpringBoot 简介 SpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。\nSpringBoot开发分为如下几步：\n 创建新模块，选择Spring初始化，并配置模块相关基础信息。 选择当前模块需要使用的技术集。 开发控制器类。 运行自动生成的Application类。  项目创建及配置 创建项目  注意：\n  在创建好的工程中不需要创建配置类。\n  创建好的项目会自动生成其他的一些文件（这些文件目前来说没有任何作用），可以将这些文件删除。\n可以删除的目录和文件如下：\n .mvn .gitignore HELP.md mvnw mvnw.cmd     项目依赖 在项目中的pom.xml中有如下代码：\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; 该代码指定了一个父工程，父工程中的东西在该工程中可以继承过来使用。\n并且使用Spring Initializr创建的项目会自动在pom.xml中导入所需的起步依赖（包含starter的依赖）。\n引导类 创建的每个SpringBoot项目都包含一个引导类，如：\n@SpringBootApplication public class SpringbootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringbootDemoApplication.class, args); } } 引导类是项目的入口，运行main()就可以启动项目。\n 引导类默认只会扫描当前包下同级的类和包（包下的的类）。\n如果Controller包与引导类的包同级（例如com.linner.controller与com.linner.springbootdemo），此时引导类可以正常启动，但是由于扫描不到Cotroller包，接口无法访问。有三种解决方法：\n  将Controller包移动到引导类的包下（此处为springbootdemo）。\n  将引导类移动到项目组包下（此处为com.linner）。\n  在创建工程时，修改软件包名。\nSpring Initializr默认软件包名为项目组名.项目名（此处为com.linner.springbootdemo）。此处创建的项目将其修改为项目组名（com.linner）。\n   切换 Web 服务器 如果要使用Jetty服务器，我们需要先在pom.xml中使用\u0026lt;exclusion\u0026gt;标签排除默认的Tomcat服务器，然后再导入使用Jetty服务器所需的坐标：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置文件 SpringBoot有两种配置文件格式，它们都在resources目录下：\n  properties格式：\n文件名为application.properties，格式如下：\n# 端口 server.port=81 # 访问路径 server.servlet.context-path=/   yaml格式：\n文件名为application.yml或application.yaml，格式如下：\nserver: # 端口 port: 80 servlet: # 访问路径 context-path: /  yaml格式的键值对中，键后面的冒号后（值的前面）一定要加空格。\n    SpringBoot程序的配置文件必须是application，只是后缀名不同。\n 以上三个配置文件可以同时存在，它们的优先级从高到低为：\n application.properties application.yml application.yaml  Idea可以快速地编辑配置文件：\nyaml 语法   大小写敏感。\n  属性层级关系使用多行描述，每行结尾使用冒号结束。\n  使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）。\n空格的个数并不重要，只要保证同层级的左侧对齐即可。\n  属性值前面添加空格（属性名与属性值之间使用:+空格作为分隔）。\n  # 表示注释。\n  数据前面要加空格与冒号隔开。\n  数组数据在数据书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。如：\nlist: - Java - Spring 读取配置数据 使用@Value(\u0026quot;表达式\u0026quot;)可以从配置文件中读取数据，注解中用于读取属性名引用方式是：${一级属性名.二级属性名……}。如：\n@RestController public class MyController { @Value(\u0026#34;${server.port}\u0026#34;) private Integer port; @Value(\u0026#34;${list[0]}\u0026#34;) private String java; @GetMapping(\u0026#34;/config\u0026#34;) public String gerConfig() { return \u0026#34;port=\u0026#34; + this.port + \u0026#34;\\n\u0026#34; + this.java; } } SpringBoot还可以使用 @Autowired 注解注入 Environment 对象的方式读取数据。这种方式 SpringBoot 会将配置文件中所有的数据封装到 Environment 对象中，如果需要使用哪个数据只需要通过调用 Environment 对象的 getProperty(String name) 方法获取。如：\n@RestController public class MyController { @Autowired private Environment env; @GetMapping(\u0026#34;/config\u0026#34;) public String gerConfig() { return \u0026#34;port=\u0026#34; + env.getProperty(\u0026#34;server.port\u0026#34;); } } 自定义对象 SpringBoot提供了将配置文件中的数据封装到我们自定义的实体类对象中的方式。具体操作如下：\n  在实体类上添加@Component注解。\n表示将实体类 bean 的创建交给 Spring 管理。\n  使用 @ConfigurationProperties 注解表示加载配置文件。\n在该注解中也可以使用 prefix 属性指定只加载指定键的数据。\n  在Controller中进行注入。\n  Example：\n添加依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 在配置文件中添加：\nmyconfig: name: SpringBoot port: 80 id: 666 实体类：\n@Component @ConfigurationProperties(prefix = \u0026#34;myconfig\u0026#34;) public class MyConfig { private String name; private Integer id; private Integer port; // getter and setter... } Controller：\n@RestController public class MyController { @Autowired private MyConfig myConfig; @GetMapping(\u0026#34;/myconfig\u0026#34;) public MyConfig getMyConfig() { return this.myConfig; } } 多环境配置 由于开发环境、测试环境、生产环境的配置都不相同。所以SpringBoot给开发者提供了多环境的快捷配置，需要切换环境时只需要改一个配置即可。\n  yaml格式：\n# 开发 spring: config: activate: # 配置环境名 on-profile: dev # spring.profiles 配置已弃用 server: port: 80 --- # 生产 spring: config: activate: on-profile: pro #给生产环境起的名字 server: port: 81 --- # 测试 spring: config: activate: on-profile: test #给测试环境起的名字 server: port: 82 --- # 设置启用的环境 spring: profiles: active: test  #表示使用的是开发环境的配置   properties格式：\n使用多文件方式，文件名以application-开头。如：\n  application-dev.properties：\nserver.port=80   application-pro.properties：\nserver.port=81   application-test.properties：\nserver.port=82   SpringBoot只会默认加载名为 application.properties 的配置文件，所以需要在 application.properties 配置文件中设置启用哪个配置文件。如：\nspring.profiles.active=pro   SpringBoot提供了在运行jar时设置开启指定的环境的方式。如：\njava –jar springbootdemo.jar –-spring.profiles.active=test 临时修改端口号：\njava –jar springbootdemo.jar –-server.port=88  命令行设置的端口号优先级高于配置文件。 SpringBoot官网已经对配置的优先级进行了说明：  配置文件分类 SpringBoot定义了配置文件不同的放置的位置。而放在不同位置的优先级是不同的。SpringBoot中4级配置文件放置位置：\n classpath：application.yml classpath：config/application.yml file：application.yml file：config/application.yml   级别越高优先级越高。\n 第三方资源整合 整合 Junit SpringBoot整合Junit分为三步：\n 在测试类上添加 @SpringBootTest 注解。 使用 @Autowired 注入要测试的资源。 定义测试方法进行测试。  Example：\n编写Service：\n@Service public class BookService { public void save() { System.out.println(\u0026#34;Book save ...\u0026#34;); } } 编写Test类：\n@SpringBootTest class SpringbootDemoApplicationTests { @Autowired private BookService bookService; @Test public void testSave() { bookService.save(); } }  由于引导类默认扫描当前包下的类和包，所以测试类（或者测试类的包）和引导类要在同个包下。\n否则，可以使用@SpringBootTest注解的classes属性指定引导类的字节码对象。如：@SpringBootTest(classes = SpringbootDemoApplication.class)\n 整合 MyBatis 在整合MyBatis前先建一个用于测试的数据库：\nSET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- Table structure for book_tb DROP TABLE IF EXISTS `book_tb`; CREATE TABLE `book_tb` ( `id` int NOT NULL, `name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin NOT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_bin ROW_FORMAT = Dynamic; -- Records of book_tb INSERT INTO `book_tb` VALUES (1, \u0026#39;郑嘉伦\u0026#39;); INSERT INTO `book_tb` VALUES (2, \u0026#39;钱璐\u0026#39;); INSERT INTO `book_tb` VALUES (3, \u0026#39;黄安琪\u0026#39;); INSERT INTO `book_tb` VALUES (4, \u0026#39;龙宇宁\u0026#39;); INSERT INTO `book_tb` VALUES (5, \u0026#39;姜宇宁\u0026#39;); INSERT INTO `book_tb` VALUES (6, \u0026#39;赵嘉伦\u0026#39;); SET FOREIGN_KEY_CHECKS = 1;   导入依赖：\n 在创建项目时，通过Spring Initializr导入依赖：  在pom.xml中导入坐标：  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   编写数据库配置：\nspring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/spring_db username: root password: 123456  SpringBoot版本低于2.4.3（不含），Mysql驱动版本大于8.0时，需要在url连接串中配置时区 jdbc:mysql://localhost:3306/spring_db?serverTimezone=UTC，或在MySQL数据库端配置时区解决此问题。\n   定义实体类：\npublic class Book { private Integer id; private String name; // getter、setter and toString }   定义DAO接口：\n@Mapper // SpringBoot定义DAO接口类 public interface BookDao { @Select(\u0026#34;SELECT * FROM book_tb WHERE id = #{id}\u0026#34;) public Book getById(Integer id); }   定义Test类：\n@SpringBootTest class SpringbootMybatisApplicationTests { @Autowired private BookDao bookDao; @Test public void testGetById() { Book book = bookDao.getById(1); System.out.println(book); } }   使用 Druid 数据源 SpringBoot有默认的数据源，但是也可以指定使用Druid数据源。\n  导入Druid依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   在application.yml配置文件配置：\nspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/spring_db?serverTimezone=UTC username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource   ","date":"2023-02-20T00:00:00Z","permalink":"https://blog.linner.asia/p/springboot-%E5%9F%BA%E7%A1%80/","title":"SpringBoot 基础"},{"content":"简介 SpringMVC是Spring下的一个用于Web表现层开发的技术。相比Servlet，SpringMVC更加高效快捷。\nSpringMVC流程如下：\n 浏览器发送请求到Tomcat服务器； Tomcat接收请求后，将请求交给SpringMVC中的DispatcherServlet（前端控制器）来处理。 DispatcherServlet按照对应规则将请求分发到对应的Bean。 Bean由我们自己编写来处理不同的请求。 每个Bean中可以处理一个或多个不同的请求 URL。   DispatcherServlet和Bean对象都需要交给Spring容器来进行管理。\n 综上，我们需要编写的内容为：\n  Bean对象；\n  请求URL和Bean对象对应关系的配置；\n  构建Spring容器。\n将DispatcherServlet和Bean对象交给容器管理。\n  配置Tomcat服务器。\n使Tomcat能够识别Spring容器，并将请求交给容器中的DispatcherServlet来分发请求。\n  项目的基本实现步骤如下：\n 创建Web工程（Maven结构），并在工程的pom.xml中添加SpringMVC和Servlet坐标。 创建SpringMVC控制器类（等同于Servlet功能）。 初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的Bean。 初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求。  项目结构及基础环境配置 使用SpringMVC开发的项目结构如下：\n 📁project-file-name  📁src  📁main  📁java  📁com.linner  📁config —— 配置类 📁controller —— 表现层 📁dao —— 持久层 📁domain —— 实体类 📁service —— 业务层     📁resourcs 📁webapp        这种项目结构采用了SSM架构，即：\n 表现层； 持久层； 业务层。  通过IDEA创建SpringMVC项目步骤如下：\n  创建基础的Maven-Archetype-Webapp项目。\n  补全项目结构：\n 📁src  📁main  📁java 📁resourcs 📁webapp        修改pom.xml文件：\n将多余的内容删除，然后添加SpringMVC所需的依赖。如：\n  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.linner\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springmvc-demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- SpringMVC所需依赖的坐标： --\u0026gt; \u0026lt;!-- Servlet坐标： --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;!-- Servlet需要修改作用范围，否则会与Tomcat中的servlet-api包发生冲突 --\u0026gt; \u0026lt;!-- provided代表的是该包只在编译和测试的时候用 --\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- SpringMVC坐标： --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;port\u0026gt;80\u0026lt;/port\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;uriEncoding\u0026gt;UTF-8\u0026lt;/uriEncoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt;  项目环境 使用SpringMVC构建Web项目，除了以上基础配置外，还需要导入其他配置。\nDAO相关的坐标：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  配置类 jdbc.properties（数据库配置，放在项目中resources目录下）：\njdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///spring_db?useSSL=false\u0026amp;characterEncoding=utf-8 jdbc.username=root jdbc.password=root SpringMVC项目至少需要SpringConfig和SpringMvcConfig这两个配置类。\n Spring：控制业务（Service）和功能（DataSource、SqlSessionFactoryBean、 MapperScannerConfigurer等）相关的Bean。 SpringMVC：加载表现层Bean（Controller）。  SpringConfig（启动Tomcat服务器时加载Spring配置类）：\n@Configuration @ComponentScan({\u0026#34;com.linner.service\u0026#34;}) @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) @Import({JdbcConfig.class,MyBatisConfig.class}) @EnableTransactionManagement public class SpringConfig { }  Spring需要管理的是service包和dao包。但dao包最终是交给MapperScannerConfigurer对象来进行扫描处理的。所以SpringConfig只需要扫描到service包即可。\n演示@ComponentScan的另一种用法（排除controller包中的Bean）：\n@ComponentScan(value=\u0026#34;com.linner\u0026#34;, excludeFilters=@ComponentScan.Filter( type = FilterType.ANNOTATION, classes = Controller.class // 排除@Controller定义的Bean  ) ) 上面方法本质是使用@ComponentScan的excludeFilters属性设置过滤规则。\n type：设置排除规则。  ANNOTATION：按照注解排除。 ASSIGNABLE_TYPE：按照指定的类型过滤。 ASPECTJ：按照Aspectj表达式排除（基本上不会用）。 REGEX：按照正则表达式排除。 CUSTOM：按照自定义规则排除。    classes：设置排除的具体注解类。\n SpringMvcConfig\n@Configuration @ComponentScan(\u0026#34;com.linner.controller\u0026#34;) public class SpringMvcConfig { } DAO相关配置类：\nJdbcConfig：\npublic class JdbcConfig { @Value(\u0026#34;${jdbc.driver}\u0026#34;) private String driver; @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; @Value(\u0026#34;${jdbc.username}\u0026#34;) private String username; @Value(\u0026#34;${jdbc.password}\u0026#34;) private String password; @Bean public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager ds = new DataSourceTransactionManager(); ds.setDataSource(dataSource); return ds; } } MyBatisConfig：\npublic class MyBatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); factoryBean.setTypeAliasesPackage(\u0026#34;com.linner.domain\u0026#34;); return factoryBean; } @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\u0026#34;com.linner.dao\u0026#34;); return msc; } } ServletConfig（Web项目入口配置类）：\npublic class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class\u0026lt;?\u0026gt;[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } protected Class\u0026lt;?\u0026gt;[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\u0026#34;/\u0026#34;}; } }  SpringMVC 工作流程 SpringMVC的使用过程共分两个阶段：\n  启动服务器初始化过程；\n  服务器启动，执行ServletConfig类，初始化Web容器。\n  根据getServletConfigClasses获取所需的SpringMVC配置类（这里是SpringMvcConfig）来初始化SpringMVC的容器。\n  加载SpringMvcConfig配置类。\n  执行@ComponentScan加载对应的Bean。\n扫描指定包下所有类上的注解，将所有的Controller类（如有@Controller、@RestController等注解的类）加载到容器中。\n  加载每一个Controler。\n使用@RequestMapping建立请求路径与Controler中的方法的对应关系。\n  执行getServletMappings方法，定义所有的请求都通过SpringMVC。如：\nprotected Spring[] getServletMappings() { return new Spring[]{\u0026#34;/\u0026#34;}; } /代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求。\n    单次请求过程。\n 根据请求路径发送请求。 Web容器将符合设置的请求路径的请求交给SpringMVC处理。 解析请求路径。 执行匹配对应请求路径的方法。 将有@ResponseBody方法的返回值作为响应体返回给请求方。     请求与响应 SpringMVC是Web层的框架，主要作用是接收请求、接收数据、响应结果。\n编写Controller只需要在Controller类上使用@Controller注解即可。\n接收 URL 参数  接收URL参数，GET和POST请求的编写方式一致。 如果要使用不同的方式接收请求，可以修改@RequestMapping注解：\n@RequestMapping(value = \u0026#34;/save\u0026#34;, method = RequestMethod.GET)  普通参数 @Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { // 使用 [http://localhost/user/hello?name=张三] 访问  // 返回响应体 Hello 张三!  @RequestMapping(\u0026#34;/hello\u0026#34;) @ResponseBody public String hello(String name) { return \u0026#34;Hello \u0026#34; + name + \u0026#34;!\u0026#34;; } // 使用 [http://localhost/user/login?name=张三\u0026amp;password=abc] 访问  // 返回响应体 OK，终端输出 userName=张三; password=abc  @RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public String login(@RequestParam(\u0026#34;name\u0026#34;) String userName, String password) { System.out.println(\u0026#34;userName=\u0026#34; + userName + \u0026#34;; password=\u0026#34; + password); return \u0026#34;OK\u0026#34;; } }   请求路径（@RequestMapping）：\n请求路径使用@RequestMapping注解。注解中的值为请求路径。 @RequestMapping可以作用在类和方法上。\n方法上定义的@RequestMapping是具体的请求路径。即，如果在方法上使用了@RequestMapping并且没有在类上使用@RequestMapping，那么该方法的请求路径即为方法上@RequestMapping中的值。\n类上定义的@RequestMapping是请求目录。即，如果在方法和类上均使用了@RequestMapping，那么该方法的请求路径需要加上类@RequestMapping注解中定义的目录。例如上方代码中的请求路径为/user/hello和。\n  请求参数：\n普通参数即URL地址传参。\n定义相同的地址参数名与方法形参变量名即可接收参数。\n如果想要形参名与地址参数名不同则可使用@RequestParam注解定义地址参数名（如login()）。\n如果有多个请求参数则定义多个方法参数。\n  返回值：\n返回值使用@ResponseBody注解后直接在方法中使用return返回。这里注解@ResponseBody是指将返回值作为响应体。\n  POJO类型参数 使用POJO类型接收参数，只需要让请求参数名与形参对象属性名相同即可。如果有嵌套的POJO参数，请求参数名与形参对象属性名相同，然后按照对象层次结构关系即可接收。\n定义一个POJO类：\npublic class Address { private String province; private String city; // setter、getter and toString... } public class User { private Integer id; private String name; private String password; private Address address; // setter、getter and toString... } Controller：\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { // 访问 [http://localhost/user/login?id=123\u0026amp;password=abc\u0026amp;name=张三\u0026amp;address.province=广东\u0026amp;address.city=广州]  // 返回响应体 OK，终端输出 Login: User{id=123, name=\u0026#39;张三\u0026#39;, password=\u0026#39;abc\u0026#39;, address=Address{province=\u0026#39;广东\u0026#39;, city=\u0026#39;广州\u0026#39;}}  @RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public String login(User user) { System.out.println(\u0026#34;Login: \u0026#34; + user); return \u0026#34;OK\u0026#34;; } } 数组、集合类型参数 接收数组参数只需让请求参数名与形参名相同且请求参数为多个即可（形参为数组类型）。\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { // 访问 [http://localhost/user/setHobbies?id=123\u0026amp;hobbies=唱歌,跳舞,Rap,打篮球]  // 返回响应体 OK，终端输出 User 123\u0026#39;s hobbyies: [唱歌, 跳舞, Rap, 打篮球]  @RequestMapping(\u0026#34;/setHobbies\u0026#34;) @ResponseBody public String setHobbies(Integer id, String[] hobbies) { System.out.println(\u0026#34;User \u0026#34; + id + \u0026#34;\u0026#39;s hobbies: \u0026#34; + Arrays.toString(hobbies)); return \u0026#34;OK\u0026#34;; } } 使用集合类型形参接收参数，使用方式与数组不同（会报错）。因为SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象。\n使用集合类型形参接收参数需要使用@RequestParam绑定参数关系。\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { // 访问方式与数组形式相同，响应体与终端输出也相同  @RequestMapping(\u0026#34;/setHobbies\u0026#34;) @ResponseBody public String setHobbies(Integer id, @RequestParam List\u0026lt;String\u0026gt; hobbies) { System.out.println(\u0026#34;User \u0026#34; + id + \u0026#34;\u0026#39;s hobbies: \u0026#34; + hobbies); return \u0026#34;OK\u0026#34;; } } 日期格式 使用@DateTimeFormat可以设置参数的日期格式，如：\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { // URL: http://localhost/user/setBirthday?id=123\u0026amp;birthday=2023/1/1 18:23:40  @RequestMapping(\u0026#34;/setBirthday\u0026#34;) @ResponseBody public String setBirthday(Integer id, @DateTimeFormat(pattern = \u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;) Date birthday) { System.out.println(\u0026#34;User \u0026#34; + id + \u0026#34;\u0026#39;s birthday is \u0026#34; + birthday); return \u0026#34;OK\u0026#34;; } } JSON 数据参数 使用JSON传输需要添加相应依赖。SpringMVC默认使用的是jackson来处理json的转换：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在配置类中添加@EnableWebMvc注解来开启JSON数据类型自动转换：\n@Configuration @ComponentScan(\u0026#34;com.linner.controller\u0026#34;) @EnableWebMvc // 开启JSON数据类型自动转换 public class SpringMvcConfig { } 使用JSON传输数据只需要在形参前添加@ResponseBody注解来将外部传递的JSON数据映射到形参到对象中：\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { @RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public String login(@RequestBody User user) { System.out.println(\u0026#34;Login: \u0026#34; + user); return \u0026#34;OK\u0026#34;; } @RequestMapping(\u0026#34;/setHobbies\u0026#34;) @ResponseBody public String setHobbies(Integer id, @RequestBody List\u0026lt;String\u0026gt; /* 也可以使用 String[] */ hobbies) { System.out.println(\u0026#34;User \u0026#34; + id + \u0026#34;\u0026#39;s hobbies: \u0026#34; + hobbies); return \u0026#34;OK\u0026#34;; } }   login()：\nURL：http://localhost/user/login\nJSON：\n{ \u0026#34;id\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;province\u0026#34;: \u0026#34;广东\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;广州\u0026#34; } }   setHobbies：\nURL：http://localhost/user/setHobbies2?id=123\nJSON：\n[\u0026#34;唱歌\u0026#34;, \u0026#34;跳舞\u0026#34;, \u0026#34;Rap\u0026#34;, \u0026#34;打篮球\u0026#34;]   响应 JSON 数据 响应JSON数据需要依赖于@ResponseBody（在Controller中）和@EnableWebMvc（在配置类中）注解。将返回值设置为实体类对象，设置返回值类型为实体类类型，即可实现返回对应对象的JSON数据：\n实体类：\npublic class Book { private Integer id; private String name; // constructor、setter、getter and toString ... } Controller:\n@Controller @RequestMapping(\u0026#34;/books\u0026#34;) public class BookController { @RequestMapping(\u0026#34;/search\u0026#34;) @ResponseBody public Book search(int id) { return new Book(id, \u0026#34;Hello SpringMVC\u0026#34;); } @RequestMapping(\u0026#34;/searchName\u0026#34;) @ResponseBody public List\u0026lt;Book\u0026gt; searchName(String name) { System.out.println(\u0026#34;Search the book \u0026#34; + name); List books = new ArrayList\u0026lt;Book\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) { books.add(new Book(i, name + Integer.toString(i))); } return books; } }   searchName()：\nURL：http://localhost/books/searchName?name=SpringMVC 返回JOSN：\n[ { \u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;SpringMVC0\u0026#34; }, { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;SpringMVC1\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;SpringMVC2\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;SpringMVC3\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;SpringMVC4\u0026#34; } ]   search()：\nURL：http://localhost/books/search?id=123 返回JSON：\n{ \u0026#34;id\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;SpringMVC\u0026#34; }   REST 风格 REST（Representational State Transfer，表现形式状态转换），是一种软件架构风格。REST的优点有：\n 隐藏资源的访问行为，无法通过地址得知对资源是何种操作。 简化书写。  按照REST风格访问资源时使用行为动作区分对资源进行了何种操作：\n GET：查询； POST：新增。 PUT：修改。 DELETE：删除。  如：\n  http://localhost/users——GET：\n查询全部用户信息（查询）。\n  http://localhost/users/1——GET：查询指定用户（id为1）信息（查询）。\n  http://localhost/users——POST：添加用户信息（新增/保存）。\n  http://localhost/users——PUT：修改用户信息（修改/更新）。\n  http://localhost/users/1——DELETE：删除用户信息（删除）。\n   描述模块的名称通常使用复数，表示此类资源，而非单个资源。\n Example：\n@Controller @RequestMapping(\u0026#34;/users\u0026#34;) public class UserController { /** * 添加用户 */ @RequestMapping(method = RequestMethod.POST) @ResponseBody public String save(@RequestBody User user) { return \u0026#34;OK\u0026#34;; } /** * 删除用户 */ @RequestMapping(value = \u0026#34;/{id}\u0026#34;, method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable int id) { return \u0026#34;OK\u0026#34;; } /** * 修改用户 */ @RequestMapping(method = RequestMethod.PUT) @ResponseBody public String update(@RequestBody User user) { return \u0026#34;OK\u0026#34;; } /** * 根据用户id查询 */ @RequestMapping(value = \u0026#34;/{id}\u0026#34;, method = RequestMethod.GET) @ResponseBody public String searchById(@PathVariable int id) { return \u0026#34;OK\u0026#34;; } /** * 查询所有用户 */ @RequestMapping(method = RequestMethod.GET) @ResponseBody public String searchAll() { return \u0026#34;OK\u0026#34;; } } 上方Controller中每个方法的@RequestMapping中都使用了method元素来确定请求方式。并且根据需要save()和update()都接收一个JSON数据。\ndelete()和searchById()都使用了路径参数（value = \u0026quot;\\{id}\u0026quot;）。指定路径参数后，需要在方法参数列表中添加名称相同的参数，并且用@PathVariable注解（public String delete(@PathVariable int id)）。\n路径参数可以定义多个，如：\n@RequestMapping(value = \u0026#34;/{id}/{name}\u0026#34;, method = RequestMethod.GET) @ResponseBody public String searchById(@PathVariable int id, @PathVariable String name) { return \u0026#34;OK\u0026#34;; } 如果想要路径参数名与形参名不同，需要在@PathVariable中注明对应关系，如：\n@RequestMapping(value = \u0026#34;/{id}\u0026#34;, method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable(\u0026#34;id\u0026#34;) int userId) { return \u0026#34;OK\u0026#34;; } RESTful 快速开发   使用@RestController注解：\n将@ResponseBody注解提到类上，让所有的方法都有@ResponseBody的功能。 @RestController注解正好相当于@Controller加上@ResponseBody的功能，所以可以使用@RestController替代它们。\n  使用@GetMapping、@PostMapping、@PutMapping、@DeleteMapping等替代@RequestMapping。\n例如@GetMapping就相当于RequestMapping(method = RequestMethod.GET)。\n  Example：\n@RestController @RequestMapping(\u0026#34;/books\u0026#34;) public class BookController { /** * 搜索全部书籍 */ @GetMapping public String getAll() { return \u0026#34;All Books\u0026#34;; } /** * 搜索图书 */ @GetMapping(\u0026#34;/{id}\u0026#34;) public String getById(@PathVariable int id) { return \u0026#34;Get by id \u0026#34; + id; } /** * 保存图书 */ @PostMapping public String save(@RequestBody Book book) { return \u0026#34;Save \u0026#34; + book.toString(); } /** * 修改图书 */ @PutMapping public String update(@RequestBody Book book) { return \u0026#34;Update \u0026#34; + book.toString(); } /** * 删除图书 */ @DeleteMapping(\u0026#34;/{id}\u0026#34;) public String delete(@PathVariable int id) { return \u0026#34;Delete by id\u0026#34; + id; } }  拦截器 拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行。拦截器可以在指定的发那个发调用前后执行预先设定的代码，可以阻止原始方法的执行。拦截器和过滤器在作用和执行顺序上很相似。它们的关系如下图所示：\n创建拦截器类：\n@Component // 由SpringMVC来管理 public class BookInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle...\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle...\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion...\u0026#34;); } } 配置拦截器类：\n@Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { @Autowired // 自动装配  private BookInterceptor bookInterceptor; @Override protected void addInterceptors(InterceptorRegistry registry) { // 添加（声明）拦截器并配置拦截规则  // 可以同时配置多个规则  registry.addInterceptor(bookInterceptor).addPathPatterns(\u0026#34;/books\u0026#34;, \u0026#34;/books/*\u0026#34;); } } 让SpringMVC扫描到拦截器的配置类：\n@Configuration @ComponentScan({\u0026#34;com.linner.controller\u0026#34;, \u0026#34;com.linner.config\u0026#34;}) @EnableWebMvc public class SpringMvcConfig { } 运行程序，发送books开头的请求（如http://localhost/books），终端会有如下输出：\npreHandle... getAll... postHandle... afterCompletion... 拦截器的执行顺序如下：\n 执行preHandle()。  preHandle()返回值为true：  执行请求路径相应的方法或下一个拦截器的preHandle()。 判断是否执行postHandle()：  Controller被执行（后续拦截器链中没有一个preHandle()返回值为false），执行postHandle()。 Controller没有被执行（后续拦截器链中存在一个preHandle()返回值为false），不执行postHandle()。   执行afterCompletion()。   preHandle()返回值为false。   结束。  当配置多个拦截器时，形成拦截器链。多个preHandle()按照Interceptor被声明顺序执行；多个postHandle()按照Interceptor被声明顺序逆序执行。即，拦截器链的运行顺序参照拦截器添加顺序为准。\n当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行。当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion()操作（afterCompletion()代表当前拦截器执行完成，与后续拦截器链中preHandle()的返回值和Controller是否被执行无关）。\n拦截器配置书写简化 Interceptor的配置类SpingMvcSupport可以书写在SpringMvcConfig中：\n@Configuration @ComponentScan({\u0026#34;com.linner.controller\u0026#34;}) @EnableWebMvc public class SpringMvcConfig implements WebMvcConfigurer { @Autowired private BookInterceptor bookInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(bookInterceptor).addPathPatterns(\u0026#34;/books\u0026#34;, \u0026#34;/books/*\u0026#34;); } } 静态资源 @Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/pages/**\u0026#34;).addResourceLocations(\u0026#34;/pages/\u0026#34;); } }  addResourceHandler()：定义访问资源路径。 addResourceLocations()：定义访问路径时的静态资源目录。  ","date":"2023-02-20T00:00:00Z","permalink":"https://blog.linner.asia/p/springmvc-%E5%9F%BA%E7%A1%80/","title":"SpringMVC 基础"},{"content":"反射 反射是Java中一种用于动态获取类或对象的信息以及动态调用对象方法的功能机制。在运行状态中，对于任意一个类，使用反射可以获取这个类的所有属性和方法；对于任意一个对象，使用反射能够调用它的任意属性和方法。利用反射可以无视对象的修饰符，调用类里面的内容。利用反射可以跟配置文件结合起来使用，把要创建的对象信息和方法写在配置文件中。\n使用反射包含以下步骤：\n 获取class字节码文件对象。 利用反射可以操作类或对象的信息有：  构造方法（获取、创建对象） 成员变量（获取、赋值） 成员方法（获取、运行）    获取字节码文件对象 Java中的每个类都是一个Class对象（字节码文件对象）。获取字节码文件对象共有以下三种方式：\n  通过class字节码文件获取：Class.forName(\u0026quot;类的全类名\u0026quot;)\n类的全类名=类的包名.类名。\n使用该方式，是通过.java源代码文件编译后生成的.class字节码文件获取。\nClass clazz = Class.forName(\u0026#34;com.linner.repo.Student\u0026#34;);   通过Class对象的class属性获取：类名.class\n该方式是对象已载入内存后使用的，需要使用import语句将对应的类导入（.class文件加载到内存后产生的Class对象也是唯一的）。\nClass clazz = Student.class;   通过对象获取：对象.getClass()\n通过创建对象后的getClass()方法来返回该对象的Class对象。该方法需要创建具体对象后才能使用。\nStudent student = new Student(); Class clazz = student.getClass();     以上三种方法获取到的Class对象均为同一个对象。即，使用==分别判断以上三种方法获取到的对象均为true。\n  获取了Class对象后就可以获取到该类的各种信息。\n获取构造方法 获取构造方法即为获取Constructor对象。\n   方法名 说明     Constructor\u0026lt;?\u0026gt;[] getConstructors() 获得所有的公共构造方法（public）   Constructor\u0026lt;?\u0026gt;[] getDeclaredConstructors() 获得所有的构造方法（包括private）    Constructor\u0026lt;T\u0026gt; getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes) 获取指定的公共构造方法   Constructor\u0026lt;T\u0026gt; getDeclaredConstructor(Class\u0026lt;?\u0026gt;... parameterTypes) 获取指定的构造方法（包括private）    Example：\npublic class Student { public Student() { System.out.println(\u0026#34;创建了一个Student对象\u0026#34;); } private Student(String name) { System.out.println(\u0026#34;创建了一个Student对象：\u0026#34; + name); } public Student(String name, int age) { System.out.println(\u0026#34;创建了一个Student对象：name=\u0026#34; + name + \u0026#34;, age=\u0026#34; + age); } } public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { // 获取Class对象  Class clazz = Class.forName(\u0026#34;com.linner.repo.Student\u0026#34;); // 获取所有公共构造方法对象  Constructor[] constructors1 = clazz.getConstructors(); for (Constructor constructor : constructors1) { System.out.println(constructor); } System.out.println(\u0026#34;=======================\u0026#34;); // 获取所有构造方法对象（包括private）  Constructor[] constructors2 = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors2) { System.out.println(constructor); } System.out.println(\u0026#34;=======================\u0026#34;); // 获取指定的构造方法对象  // 空参构造方法  Constructor con1 = clazz.getConstructor(); System.out.println(con1); // 包含参数的构造方法  Constructor con2 = clazz.getConstructor(String.class, int.class); System.out.println(con2); // 获取指定的构造方法对象（包括private）  Constructor con3 = clazz.getDeclaredConstructor(String.class); System.out.println(con3); } } 通过反射创建对象 使用Constructor对象的newInstance()方法可以为反射的类创建对象。\nExample：\npublic class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { // 获取Class对象  Class clazz = Class.forName(\u0026#34;com.linner.reflect.Student\u0026#34;); // 获取无参的公共构造方法  Constructor con1 = clazz.getConstructor(); // 使用无参的构造方法创建对象  Student stu1 = (Student) con1.newInstance(); System.out.println(stu1); // 获取带参数的构造方法（包括private）  Constructor con2 = clazz.getDeclaredConstructor(String.class, int.class); // 暴力反射  // 如果是private修饰的构造方法，需要临时修改构造方法的访问权限（取消检查访问权限）  con2.setAccessible(true); // 使用带参数的构造方法创建对象  Student stu2 = (Student) con2.newInstance(\u0026#34;zhangsan\u0026#34;, 23); System.out.println(stu2); } } 获取成员变量 获取成员变量即为获取Field对象。\n   方法名 说明     Field[] getFields() 返回所有公共成员变量对象（public）   Field[] getDeclaredFields() 返回所有成员变量对象（包括private）   Field getField(String name) 返回指定名称的公共成员变量对象（public）   Field getDeclaredField(String name) 返回指定名称的成员变量对象（包括private）    Example：\npublic class Student { public String name; private int age; public String gender; private String address; } public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { // 获取Class对象  Class clazz = Class.forName(\u0026#34;com.linner.reflect.Student\u0026#34;); // 获取所有公共成员变量对象  Field[] fields1 = clazz.getFields(); for (Field field : fields1) { System.out.println(field); } System.out.println(\u0026#34;====================\u0026#34;); // 获取所有成员变量（包括private）  Field[] fields2 = clazz.getDeclaredFields(); for (Field field : fields2) { System.out.println(field); } System.out.println(\u0026#34;====================\u0026#34;); // 获取指定名称的公共成员变量  Field nameField = clazz.getField(\u0026#34;name\u0026#34;); System.out.println(nameField); System.out.println(\u0026#34;====================\u0026#34;); // 获取指定名称的成员变量（包括private）  Field ageField = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(ageField); } } 利用反射获取和修改成员变量的值 可以使用以下Field对象方法对成员变量的值进行修改：\n  赋值：\nvoid set(Object obj, Object value) 参数：\n obj：要修改属性值的具体对象； value：具体要修改的值。    获取值：\nObject get(Object obj) 参数：\n obj：要修改属性值的具体对象。    Example：\npublic class Student { public String name; private int age; private String gender; private String address; public Student(String name, int age, String gender, String address) { this.name = name; this.age = age; this.gender = gender; this.address = address; } } public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Student student = new Student(\u0026#34;张三\u0026#34;, 23, \u0026#34;大三\u0026#34;, \u0026#34;广州\u0026#34;); // 获取Class对象  Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.linner.reflect.Student\u0026#34;); // 获取并修改name的值  Field nameField = clazz.getField(\u0026#34;name\u0026#34;); // 获取name的值  String name = (String) nameField.get(student); System.out.println(name); // 修改name的值  nameField.set(student, \u0026#34;李四\u0026#34;); name = (String) nameField.get(student); System.out.println(name); System.out.println(\u0026#34;===============\u0026#34;); // 获取并修改私有变量的值（暴力反射）  Field addressField = clazz.getDeclaredField(\u0026#34;address\u0026#34;); // 临时取消访问权限（获取和修改私有变量的值都需要此操作）  addressField.setAccessible(true); // 获取私有变量address的值  String address = (String) addressField.get(student); System.out.println(address); // 修改私有变量address的值  addressField.set(student, \u0026#34;北京\u0026#34;); address = (String) addressField.get(student); System.out.println(address); } } 获取成员方法 获取成员方法即为获取Method对象。\n   方法名 说明     Method[] getMethods() 返回所有公共成员方法对象（public）   Method[] getDeclaredMethods() 放回所有成员方法对象（包括private）   Method getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 返回指定名称和形参的公共成员方法对象（public）   Method getDeclaredMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes 返回指定名称和形参的成员方法对象（包括private）    Example：\npackage com.linner.reflect; public class Student { private String name; private int age; private String gender; private String address; public Student() { } public Student(String name) { this.name = name; } public Student(String name, int age) { this.name = name; this.age = age; } public Student(String name, int age, String gender, String address) { this.name = name; this.age = age; this.gender = gender; this.address = address; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#39;\u0026#34; + gender + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, address=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } private void sleep() { System.out.println(this.name + \u0026#34;正在睡觉\u0026#34;); } private void study() { System.out.println(this.name + \u0026#34;正在内卷\u0026#34;); } private void study(int time) { System.out.println(this.name + \u0026#34;已经卷了\u0026#34; + time + \u0026#34;分钟还在卷\u0026#34;); } } public class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { // 获取Class对象  Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.linner.reflect.Student\u0026#34;); // 获取所有公共成员方法  Method[] methods1 = clazz.getMethods(); for (Method method : methods1) { System.out.println(method); } System.out.println(\u0026#34;==============\u0026#34;); // 获取所有成员方法（包括private）  Method[] methods2 = clazz.getDeclaredMethods(); for (Method method : methods2) { System.out.println(method); } System.out.println(\u0026#34;==============\u0026#34;); // 获取指定的公共成员方法  // 空参的公共成员方法  Method toStringMethod = clazz.getMethod(\u0026#34;toString\u0026#34;); System.out.println(toStringMethod); // 带参数的公共成员方法  Method setNameMethod = clazz.getMethod(\u0026#34;setName\u0026#34;, String.class); System.out.println(setNameMethod); System.out.println(\u0026#34;==============\u0026#34;); // 获取指定的成员方法（包括private）  // 空参的成员方法  Method studyMethod1 = clazz.getDeclaredMethod(\u0026#34;study\u0026#34;); System.out.println(studyMethod1); // 带参数的成员方法  Method studyMethod2 = clazz.getDeclaredMethod(\u0026#34;study\u0026#34;, int.class); System.out.println(studyMethod2); } } 通过反射运行成员方法 使用Method对象的invoke()方法可以运行成员方法。\nObject invoke(Object obj, Object... args)  obj：具体调用成员方法的对象； args：调用成员方法传递的参数； 返回值：方法的返回值。  Example：\npublic class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { Student student = new Student(\u0026#34;张三\u0026#34;, 23, \u0026#34;大三\u0026#34;, \u0026#34;广州\u0026#34;); // 获取Class对象  Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.linner.reflect.Student\u0026#34;); // 调用无参的成员方法  Method toStringMethod = clazz.getMethod(\u0026#34;toString\u0026#34;); String studentToString = (String) toStringMethod.invoke(student); System.out.println(studentToString); // 调用带参的私有成员方法  Method studyMethod = clazz.getDeclaredMethod(\u0026#34;study\u0026#34;, int.class); // 临时取消访问权限  studyMethod.setAccessible(true); studyMethod.invoke(student, 180); } }  注解 Java注解是附加在代码中的一些元信息，用于编译和运行时进行解析和使用，起到说明、配置的功能。\n注解不会影响代码的实际逻辑（并不直接影响代码的语义），仅仅起到辅助性的作用（但是注解可以被看做是程序的工具或者类库。会反过来对正在运行的程序语义有所影响）。包含在java.lang.annotation包中。注解使用@interface来定义（类似于接口的定义）。为注解定义一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或throw语句，返回值类型被限定为原始数据类型、String、Class、enums、注解类型，或前面这些类型的数组，方法可以有默认值。注解可以从源文件、class文件或者在运行时通过反射机制多种方式被读取。\n注解的实现的原理很大的一部分是基于反射实现。\n一般来说，注解一般分为三种类型：\n 元注解 标准注解 自定义注解  元注解 元注解是专职负责注解其他注解，主要是标明该注解的使用范围，生效范围。元注解并不能被修改，只能被用来定义自定义注解。\n元注解包括以下四种：\n   注解 说明     @Target 定义注解的作用目标。即用来定义自定义注解具体作用在类上，方法上，还是变量上。具体值和作用对象如下：\nElementType.TYPE：接口、类、枚举、注解\nElementType.FIELD：字段、枚举的常量\nElementType.METHOD：方法\nElementType.PARAMETER：方法参数\nElementType.CONSTRUCTOR：构造函数\nElementType.LOCAL_VARIABLE：局部变量\nElementType.ANNOTATION_TYPE：注解\nElementType.PACKAGE：包   Retention 定义注解的保留策略。该注解的值如下：\nRetentionPolicy.SOURCE：定义注解仅存在于源码中，在class字节码文件中不包含；\nRetentionPolicy.CLASS：该注解默认的保留策略，定义注解会在class字节码文件中存在，但运行时无法获得；\nRetentionPolicy.RUNTIME：定义注解会在class字节码文件中存在，在运行时可以通过反射获取到。   @Document 说明该注解将被包含在javadoc中。   @Inherited 说明子类可以继承该注解。    标准注解 Java 提供了三个标准注解，定义在java.lang中（这三个注解的作用更多是一种注释）。\n  @Override：表示当前方法覆盖了父类中的对应方法（重写方法）。\n  @Deprecated：标记一个元素为已过期，避免或不推荐使用。\n支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE。\n  @SuppressWarnings：不输出对应的编译警告。\n  自定义注解 注解的定义类似于接口的定义，使用@interface来定义。定义注解类中的一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或throw语句，返回值类型被限定为原始数据类型、字符串String、Class、enums、注解类型，或前面这些类型的数组，方法可以有默认值。\n自定义注解一般分为以下三个步骤：\n  定义注解。\n如：\n@Target(ElementType.Type) // 表明该注解加载在类上 @Retention(RetentionPolicy.RUNTIME) // 表明运行时读取该注解 // 定义注解类 public @interface MyAnnotationType { // 定义注解方法（不能有参数或throw等）  String value(); } @Target(ElementType.FIELD) // 表明该注解加载在字段上（接口、类、枚举）。 @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotationField { String name(); // 使用default定义默认值  int length() default 0; }   使用注解。\n如（在其他类上）：\n@MyAnnotationType(\u0026#34;Annotation\u0026#34;) // 或（有多个元素时需要指定元素名）：@MyAnnotation1(value = \u0026#34;Annotation\u0026#34;) public class UsingAnnotations { @MyAnnotationField(name = \u0026#34;张三\u0026#34;, length = 12) public int a; @MyAnnotationField(name = \u0026#34;李四\u0026#34;) // length将使用默认值  public String b; }   读取注解。\n如（定义一个类来读取）：\npublic class AnnotationValues { public static void readValues() throws ClassNotFoundException { Class usingAnnotationsClass = Class.forName(\u0026#34;UsingAnnotation\u0026#34;); // 读取作用于类上的注解  MyAnnotationType mat = (MyAnnotationType) usingAnnotationsClass.getAnnotation(MyAnnotationType.class); System.out.println(mat.value()); // 读取作用于属性上的注解  Field a = usingAnnotationsClass.getDeclaredField(\u0026#34;a\u0026#34;); MyAnnotationField maf = (MyAnnotationField) a.getAnnotation(MyAnnotationField.class); System.out.println(maf.name()); System.out.println(maf.length()); } }   使用注解模拟 Junit public class AnnotationDemo { // @MyTest  public void test1() { System.out.println(\u0026#34;test1...\u0026#34;); } @MyTest public void test2() { System.out.println(\u0026#34;test2...\u0026#34;); } // @MyTest  public void test3() { System.out.println(\u0026#34;test3...\u0026#34;); } @MyTest public void test4() { System.out.println(\u0026#34;test4...\u0026#34;); } @MyTest public void test5() { System.out.println(\u0026#34;test5...\u0026#34;); } public static void main(String[] args) throws Exception { AnnotationDemo a = new AnnotationDemo(); // 获取Class对象  Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.linner.annotation.AnnotationDemo\u0026#34;); // 判断对象的所有方法上是否存在MyTest注解  Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { if (method.isAnnotationPresent(MyTest.class)) { method.invoke(a); } } } } ","date":"2023-02-14T00:00:00Z","permalink":"https://blog.linner.asia/p/java-%E8%BF%9B%E9%98%B6/","title":"Java 进阶"},{"content":"Spring Framewor 简介  Spring5.0已经全面支持JDK8，建议JDK使用1.8版本。\n Spring Framework是Spring家族中其他框架的底层基础。\nSpring Framewor 架构 Spring Framework的发展经历了很多版本的变更，每个版本都有相应的调整。\nSpring Framework 架构：\n  核心层\nCore Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块。\n  AOP层\n AOP：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强。 Aspects：AOP是编程思想，Aspects是对AOP思想的具体实现。    数据层\n Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术。 Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis。 Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现。    Web层\n  Test层\nSpring主要整合了Junit来完成单元测试和集成测试。\n   从Spring Framework 5没有架构图，而最新的架构图是4版本，所以可以认为Spring Framework从4版本开始架构就已经趋于稳定，没有什么变动。\n Spring 核心概念 在Spring核心概念主要包含：\n  IOC\n IOC，Inversion of Control，即控制反转。 控制反转：主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部的一种思想。   例如，业务（Service）层要使用到数据（DAO）层的类对象。此时就可以使用IOC思想，由外部程序给业务层创建数据层对象。 这样可以降低业务层和数据层之间的耦合性。 如果数据层的实现更改的话，就无需在业务层中修改实现类。\n  IOC容器  Spring提供了一个容器，称为IOC容器，用来充当IOC思想中的\u0026quot;外部\u0026quot;。 IOC容器负责对象的创建、初始化等一系列工作。   Bean  在IOC容器中，被创建或被管理的对象统称为Bean。 IOC容器中存放的就是一个个的Bean对象。      DI\n 依赖注入：在容器中建立Bean与Bean之间的依赖关系的整个过程。   例如，业务层和数据层在IOC容器中创建Bean后，并不能直接工作，因为业务层需要依赖数据层才能正确工作。所以此时就需要使用依赖注入，在业务层和数据层之间建立依赖关系。\n   IOC和DI的最终目标就是充分解耦。在Spring Framewor中的实现依靠：\n 使用IOC容器管理Bean（IOC）。 在IOC容器内将有依赖关系的Bean进行关系绑定（DI）。  最终，使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。\n 配置文件方法使用IOC/DI 使用 IOC 容器创建 Bean（bean 标签） 基础配置：\n  创建Maven项目，项目基础结构如下：\n 📁project-file-name  📁src  📁main  📁java  📁com.linner  📁dao 📁domain 📁service     📁resourcs   📁test  📁java  📁com.linner  📁service       📄pom.xml        添加Spring Framework的依赖jar包：\n\u0026lt;dependencies\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;!--springframework--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/dependencies\u0026gt;   添加业务层、数据层类：\n  User.java:\npackage com.linner.domain; public class User { Integer id; String username; String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, username=\u0026#39;\u0026#34; + username + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   DAO(仅测试，无需查询数据库):\n接口：\npackage com.linner.dao; import com.linner.domain.User; import java.util.List; public interface UserDao { List\u0026lt;User\u0026gt; findAll(); User findById(int id); void delete(int id); void save(User user); void update(User user); } 实现类：\npackage com.linner.dao.impl; import com.linner.dao.UserDao; import com.linner.domain.User; import java.util.List; public class UserDaoImpl implements UserDao { @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;UserDao findAll...\u0026#34;); return null; } @Override public User findById(int id) { System.out.println(\u0026#34;UserDao findById:\u0026#34; + id); return null; } @Override public void delete(int id) { System.out.println(\u0026#34;UserDao delete:\u0026#34; + id); } @Override public void save(User user) { System.out.println(\u0026#34;UserDao save:\u0026#34; + user); } @Override public void update(User user) { System.out.println(\u0026#34;UserDao update:\u0026#34; + user); } }   Service:\n接口：\npackage com.linner.service; import com.linner.domain.User; import java.util.List; public interface UserService { List\u0026lt;User\u0026gt; findAll(); User findById(int id); void delete(int id); void save(User user); void update(User user); } 实现类：\npackage com.linner.service.impl; import com.linner.dao.UserDao; import com.linner.dao.impl.UserDaoImpl; import com.linner.domain.User; import com.linner.service.UserService; import java.util.List; public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;UserService findAll...\u0026#34;); userDao.findAll(); return null; } @Override public User findById(int id) { System.out.println(\u0026#34;UserService findById:\u0026#34; + id); userDao.findById(id); return null; } @Override public void delete(int id) { System.out.println(\u0026#34;UserService delete:\u0026#34; + id); userDao.delete(id); } @Override public void save(User user) { System.out.println(\u0026#34;UserService save:\u0026#34; + user); userDao.save(user); } @Override public void update(User user) { System.out.println(\u0026#34;UserService update:\u0026#34; + user); userDao.update(user); } }       测试方法：\npackage com.linner.service; import com.linner.domain.User; import com.linner.service.UserService; import com.linner.service.impl.UserServiceImpl; import org.junit.Test; import java.util.List; public class UserServiceTest { private UserService userService = new UserServiceImpl(); @Test public void testFindAll() { userService.findAll(); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testFindById() { int id = 12; userService.findById(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testDelete() { int id = 12; userService.delete(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userService.save(user); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userService.update(user); System.out.println(\u0026#34;------------\u0026#34;); } }   创建Bean\n  在📁resourcs目录下创建String配置文件applicationContext.xml，并使用\u0026lt;bean\u0026gt;标签配置Bean：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--添加UserService--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt;   接着在程序中使用Spring提供的方法获取IOC容器。然后从IOC容器中获取对象并调用其方法，修改Test类进行测试：\npublic class UserServiceTest { // private UserService userService = new UserServiceImpl();  // 使用IOC无需自己创建对象（对象由IOC容器分配  private static UserService userService; // 这里使用静态代码块获取容器和Bean  static { // 获取IOC容器  ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); userService = (UserService) ctx.getBean(\u0026#34;userService\u0026#34;); } // ... } IOC核心容器创建方式有：\n  ClassPathXmlApplicationContext：类路径下的XML配置文件。\nApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); ClassPathXmlApplicationContext的参数为XML配置文件在类路径下的相对路径。\n  FileSystemXmlApplicationContext：\nApplicationContext ctx = new FileSystemXmlApplicationContext(\u0026#34;/home/linner/IdeaProjects/my-springfw-demo/src/main/resources/applicationContext.xml\u0026#34;); FileSystemXmlApplicationContext的参数为XML配置文件在文件系统下的绝对路径。\n    UserServiceTest执行成功说明配置成功。\nBean 的基础配置 \u0026lt;bean\u0026gt;标签是作为Spring配置Bean使用。其基本形式为：\n\u0026lt;bean id=\u0026#34;\u0026#34; class=\u0026#34;\u0026#34;/\u0026gt;  id：Bean标签的唯一标识。在同一个上下文中(配置文件)不能重复。 class：Bean的类型。包含包名和类名。  别名（name 属性） \u0026lt;bean\u0026gt;的name属性可以为\u0026lt;bean\u0026gt;指定别名，别名可以有多个，使用,，;，空格进行分隔。如：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; name=\u0026#34;service userEbi\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34;/\u0026gt;  说明：EBI全称Enterprise Business Interface，译为企业业务接口。\n 获取 Bean 的方式（getBean() 方法） 使用getBean()获取Bean的方式有三种：\n  按照名称获取：\n是指在getBean()方法中传递String类型的参数，参数的值为Bean的名称。\nObject getBean(String s)   按照类型获取：\n需要保证该类型在IOC容器中有且仅有一个Bean（不能包含多个同类型的Bean）。 在参数中传递该类型的class。\n\u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; aClass)   按照名称和类型获取：\n在参数中传入Bean的名称和类型。\n\u0026lt;T\u0026gt; T getBean(String s, Class\u0026lt;T\u0026gt; aClass)   作用范围（scope 属性） \u0026lt;bean\u0026gt;的scope属性可以为\u0026lt;bean\u0026gt;设置作用范围，可选值为：\n  singloton：默认，表示创建的对象为单例（在整个IOC容器中所有获取到的该对象都为同一个对象）。如：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34; scope=\u0026#34;singloton\u0026#34;/\u0026gt; 或：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34; /\u0026gt;  实际上，单例对象在容器被获取的时候就已经被创建了。\n   prototype：表示创建的对象为非单例（每次在IOC容器中获取到的对象都是不同的对象）。如：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; name=\u0026#34;service userEbi\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt;   Example：\n  将UserService设为单例：\nString配置文件applicationContext.xml中userService的\u0026lt;bean\u0026gt;（由于Spring默认创建的是单例，所以这里可以选择不添加scope=\u0026quot;singloton\u0026quot;）：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 创建新的测试类TestForUserServiceScope：\npackage com.linner.service; import com.linner.domain.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestForUserServiceScope { private static ApplicationContext ctx; static { ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); } @Test public void testFindAll() { UserService userService = (UserService) ctx.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); userService.findAll(); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testFindById() { UserService userService = (UserService) ctx.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); int id = 12; userService.findById(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testDelete() { UserService userService = (UserService) ctx.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); int id = 12; userService.delete(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testSave() { UserService userService = (UserService) ctx.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userService.save(user); System.out.println(\u0026#34;------------\u0026#34;); } public void testUpdate() { UserService userService = (UserService) ctx.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userService.update(user); System.out.println(\u0026#34;------------\u0026#34;); } } 执行UserServiceTest1后，在输出中可以发现：每个测试方法中使用getBean()获取到的UserService都是同个对象。\n  将UserService设为非单例：\n修改String配置文件applicationContext.xml：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; 再次执行UserServiceTest1，可以发现：每个测试方法中使用getBean()获取到的UserService都是不同的对象。\n  Bean 的实例化 实例化Bean分为三种方式：\n 构造方法 静态工厂 实例工厂  构造方法实例化 Bean（默认） \u0026lt;bean\u0026gt;默认是使用无参的构造方法实例化Bean。并且，Spring底层用的是反射（因为即使将构造方法设置为private依然可以使用）。\n静态工厂实例化 Bean（factory-method 属性） 静态工厂实例化Bean指的是通过工厂类来创建对象。\n一般情况下是使用如下方法静态工厂实例化对象：\n  创建com.linner.factory包，并编写UserDaoFactory：\npackage com.linner.factory; import com.linner.dao.UserDao; import com.linner.dao.impl.UserDaoImpl; public class UserDaoFactory { public static UserDao getUserDao() { return new UserDaoImpl(); } }   编写TestFroInstanceUserDao测试类：\npackage com.linner.dao; import com.linner.domain.User; import com.linner.factory.UserDaoFactory; import org.junit.Test; public class TestFroInstanceUserDao { private UserDao userDao = UserDaoFactory.getUserDao(); @Test public void testFindAll() { userDao.findAll(); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testFindById() { int id = 12; userDao.findById(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testDelete() { int id = 12; userDao.delete(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userDao.save(user); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userDao.update(user); System.out.println(\u0026#34;------------\u0026#34;); } }   在IOC容器中使用静态工厂实例化：\n  在Spring配置文件中加入UserDao的配置：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.factory.UserDaoFactory\u0026#34; factory-method=\u0026#34;getUserDao\u0026#34;/\u0026gt;  class：工厂类的类全名。这里指定的是创建UserDao的静态工厂类UserDaoFactory。 factory-method：class指定的工厂类中创建对象的方法名。这里指定的是工厂类中用来创建UserDao的方法。    修改TestFroInstanceUserDao：\nimport org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestFroInstanceUserDao { private static UserDao userDao; static { ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); userDao = (UserDao) ctx.getBean(\u0026#34;userDao\u0026#34;); } // ... }    注意：使用这种方法实例化，不能将该Bean注入到其他Bean中。\n 实例工厂实例化 Bean 使用 Bean 的 factory-bean 属性 实例化工厂实例化Bean是指，为工厂类添加一个单例的Bean（为区分则称为工厂Bean），然后在要实例化的Bean中指定使用这个工厂Bean作为实例化工厂。\n修改UserDaoFactory（不使用静态工厂）：\npublic class UserDaoFactory { public UserDao getUserDao() { return new UserDaoImpl(); } } 在Spring的配置文件中添加UserDaoFactory的\u0026lt;bean\u0026gt;，并且修改UserDao的\u0026lt;bean\u0026gt;：\n\u0026lt;bean id=\u0026#34;userDaoFactory\u0026#34; class=\u0026#34;com.linner.factory.UserDaoFactory\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; factory-bean=\u0026#34;userDaoFactory\u0026#34; factory-method=\u0026#34;getUserDao\u0026#34;/\u0026gt;  添加了一个userDaoFactory工厂Bean。 factory-bean：工厂的实例对象，即工厂Bean的id或name。 factory-method：工厂对象中具体创建对象的方法名，即factory-bean指定对象中创建该对象的方法名。  成功执行TestFroInstanceUserDao即配置成功。\n使用 FactoryBean 接口 创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法：\npackage com.linner.factory; import com.linner.dao.UserDao; import com.linner.dao.impl.UserDaoImpl; import org.springframework.beans.factory.FactoryBean; public class UserDaoFactoryBean implements FactoryBean { @Override public Object getObject() throws Exception { return new UserDaoImpl(); } @Override public Class\u0026lt;?\u0026gt; getObjectType() { return UserDao.class; } @Override public boolean isSingleton() { return true; } }  getObject()：创建实例化对象并返回。代替原始实例工厂中创建对象的方法。 getObjectType()：返回所创建类的Class对象。 isSingleton()：设置对象是否为单例。默认true，可以不重写。  修改Spring配置文件：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.factory.UserDaoFactoryBean\u0026#34;/\u0026gt; 成功执行TestFroInstanceUserDao即配置成功。\nBean 的生命周期 Bean的生命周期是指Bean对象从创建到销毁的整个过程。对Bean的生命周期进行控制，可以在Bean创建后（如加载初始化需要用到资源）还有销毁前（如释放资源）执行一些操作。\ninit-method 和 destroy-method 属性 Spring控制生命周期的第一个方法便是使用Spring配置文件中\u0026lt;bean\u0026gt;的 init-method 和 destroy-method 属性。\n在UserDaoImpl中创建初始化方法和销毁方法（方法名任意）：\npublic class UserDaoImpl implements UserDao { /** * 初始化方法 */ public void init() { System.out.println(\u0026#34;UserDao init...\u0026#34;); } /** * 销毁方法 */ public void destroy() { System.out.println(\u0026#34;UserDao destroy...\u0026#34;); } // ... } 修改Spring配置文件：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.dao.impl.UserDaoImpl\u0026#34; init-method=\u0026#34;init\u0026#34; destroy-method=\u0026#34;destroy\u0026#34;/\u0026gt;  init-method：class指定的类中的初始化方法，在创建Bean对象后执行。 destroy-method：class指定的类中的销毁方法，在销毁Bean前执行。  编写TestForLifeCycle测试类：\npackage com.linner; import com.linner.dao.UserDao; import org.junit.Test; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestForLifeCycle { @Test public void testForLifeCycle() { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserDao userDao = (UserDao) ctx.getBean(\u0026#34;userDao\u0026#34;); userDao.findAll(); ctx.close(); } } 对比之前的ctx对象，这里ctx对象使用的类型从ApplicationContext变成了ClassPathXmlApplicationContext。这是因为ApplicationContext中并没有close()方法。而想要执行Bean对象中的destroy()，就必须在程序退出前关闭IOC容器（调用ctx.close()）。\n注册钩子关闭容器 在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器。\n修改TestForLifeCycle：\npublic class TestForLifeCycle { @Test public void testForLifeCycle() { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); ctx.registerShutdownHook(); UserDao userDao = (UserDao) ctx.getBean(\u0026#34;userDao\u0026#34;); userDao.findAll(); } }  注意：ApplicationContext中也没有registerShutdownHook()。所以这里使用的是ClassPathXmlApplicationC对象。\n InitializingBean 和 DisposableBean 接口 Spring 提供了InitializingBean和DisposableBean接口以更加方便地控制Bean生命周期。使用这两个接口则无需通过Sping配置文件中的init-method和destroy-method 属性来控制生命周期。\n实现InitializingBean接口的afterPropertiesSet()方法和DisposableBean接口的destroy()方法：\nimport org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; public class UserDaoImpl implements UserDao, InitializingBean, DisposableBean { /** * InitializingBean接口的初始化方法 */ @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026#34;UserDao init by afterPropertiesSet()...\u0026#34;); } /** * DisposableBean接口的销毁方法 */ @Override public void destroy() { System.out.println(\u0026#34;UserDao destroyed by destroy()...\u0026#34;); } // ... } 在Spring配置文件中删除init-method和destroy-method属性：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.dao.impl.UserDaoImpl\u0026#34;/\u0026gt; 使用 Bean 标签的注意事项   class属性不能使用接口。因为接口不能创建对象。\n  获取Bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException。\n  Bean默认为单例，避免了对象的频繁创建与销毁，达到了对Bean对象的复用，性能高。\n  如果对象是有状态对象（即该对象有成员变量可以用来存储数据）。因为所有请求线程共用一个Bean对象，所以会存在线程安全问题。\n  如果对象是无状态对象（即该对象没有成员变量没有进行数据存储）。因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。\n  适合交给容器进行管理的Bean对象：\n 表现层对象 业务层对象 数据层对象 工具对象    不适合交给容器进行管理的Bean对象：\n封装实例的域对象。会引发线程安全问题。\n  DI 依赖注入 上面的程序，在UserServiceImpl中依然需要手动创建对象：\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); // ... } 当前业务层和数据层的耦合性还是很高。此时就需要使用依赖注入来降低耦合性。\nSpring依赖注入支持简单数据类型、引用数据类型还有集合注入，并且提供了两种注入方式：\n Setter注入 构造器注入  基础配置：\n 创建Maven项目。 添加Spring Framework和Junit的依赖jar包。 添加业务层、数据层类：  User.java: 同使用IOC容器创建Bean中的User.java。 DAO(仅测试，无需查询数据库): 同使用IOC容器创建Bean中的DAO（UserDao）。 Service: 同使用IOC容器创建Bean中的Service（UserService）。      测试方法：\npackage com.linner.service; import com.linner.domain.User; import com.linner.service.UserService; import com.linner.service.impl.UserServiceImpl; import org.junit.Test; import java.util.List; public class UserServiceTest { private static UserService userService; static { ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); userService = (UserService) ctx.getBean(\u0026#34;userService\u0026#34;); } @Test public void testFindAll() { userService.findAll(); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testFindById() { int id = 12; userService.findById(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testDelete() { int id = 12; userService.delete(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userService.save(user); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userService.update(user); System.out.println(\u0026#34;------------\u0026#34;); } }   Setter 注入（property 标签） Setter注入是指，在实现类中为需要注入的属性设置Setter方法，让Spring能够使用Setter方法自动给属性创建对象。\n注入引用数据类型 要在Bean中注入引用类型属性，注入的属性其实现类必须得是IOC容器中的Bean。\n在UserServiceImpl中，取消手动创建对象，并为userDao属性提供setter方法：\npublic class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } // ... } 修改Spring配置文件applicationContext.xml：\n\u0026lt;!--...--\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.dao.impl.UserDaoImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--...--\u0026gt; 为UserService注入UserDao要在UserService的\u0026lt;bean\u0026gt;标签中使用\u0026lt;property\u0026gt;标签。·\n\u0026lt;property\u0026gt;表示配置当前\u0026lt;bean\u0026gt;的属性，其标签属性有：\n name：\u0026lt;bean\u0026gt;所指的实现类的属性名，表示配置哪一个具体的属性。 ref：要配置的属性的Bean的id或name，表示参照哪一个\u0026lt;bean\u0026gt;（该注入的Bean必须在容器中存在）。  成功运行ServiceBeanTest说明注入成功。\n如果要注入多个属性，则在实例类中加入多个属性，为其设置Setter并在Bean中配置多个\u0026lt;property\u0026gt;即可。\n注入简单数据类型 在Bean中注入简单类型属性，简单数据类型并不用在配置文件中为简单类型添加Bean标签配置。\n为BookDao添加简单类型属性：\nimport org.springframework.beans.factory.InitializingBean; public class UserDaoImpl implements UserDao, InitializingBean { private String databaseName; private int connectionNum; public void setConnectionNum(int connectionNum) { this.connectionNum = connectionNum; } public void setDatabaseName(String databaseName) { this.databaseName = databaseName; } @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026#34;UserDao init: DatabaseName=\u0026#34; + this.databaseName + \u0026#34;, ConnectionNum=\u0026#34; + this.connectionNum); } // ... } 在Spring配置文件中为UserDao添加\u0026lt;property\u0026gt;标签：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.dao.impl.UserDaoImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;databaseName\u0026#34; value=\u0026#34;mysql\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;connectionNum\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;  name：含义不变，与引用注入类型用法中的含义相同。 value: 要配置的属性的值，必须是简单数据类型。对于参数类型，Spring在注入的时候会自动转换，但是有可能会发生转换错误的情况。  成功运行ServiceBeanTest说明注入成功。\n集合注入 修改UserDao，为其添加集合类型参数和对应Setter方法：\nimport java.util.*; public class UserDaoImpl implements UserDao, InitializingBean { private int[] array; private List\u0026lt;String\u0026gt; list; private Set\u0026lt;String\u0026gt; set; private Map\u0026lt;String,String\u0026gt; map; private Properties properties; // ...此处省略setter方法  @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026#34;UserDao init: \u0026#34; + \u0026#34;array=\u0026#34; + Arrays.toString(array) + \u0026#34;, list=\u0026#34; + list + \u0026#34;, set=\u0026#34; + set + \u0026#34;, map=\u0026#34; + map + \u0026#34;, properties=\u0026#34; + properties); } // ... } 修改Spring配置文件：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.dao.impl.UserDaoImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;3\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;a\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;b\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;c\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;set\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;a\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;a\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;b\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;c\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;map\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;a\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;b\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;c\u0026#34; value=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;properties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;a\u0026#34;\u0026gt;1\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;b\u0026#34;\u0026gt;2\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;c\u0026#34;\u0026gt;3\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   \u0026lt;property\u0026gt;：Setter注入依然使用该标签。其name属性含义不变。\n集合类型的值在其标签下定义。\n  \u0026lt;array\u0026gt;：定义数组类型的值。\n 数组元素中的值使用\u0026lt;value\u0026gt;标签定义。 \u0026lt;value\u0026gt;标签中的值要与数组的类型一致。 一般形式如下：  \u0026lt;property name=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt;   \u0026lt;list\u0026gt;：定义List类型的值。\n其用法与\u0026lt;array\u0026gt;类似。\n\u0026lt;property name=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt;   \u0026lt;set\u0026gt;：定义Set类型的值。 其用法与\u0026lt;array\u0026gt;类似。\n\u0026lt;property name=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;...\u0026lt;/value\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt;   \u0026lt;map\u0026gt;：定义Map类型的值。\n 其元素使用\u0026lt;entry\u0026gt;标签定义。并且元素的key使用key属性定义，元素的value使用value属性定义。 key和value属性的值要和Map的类型对应。  \u0026lt;property name=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;...\u0026#34; value=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;...\u0026#34; value=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;...\u0026#34; value=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt;   \u0026lt;props\u0026gt;：定义Properties的值。\n其元素使用\u0026lt;prop\u0026gt;标签定义。key使用key属性定义，value在标签中定义。\n\u0026lt;property name=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;...\u0026#34;\u0026gt;...\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;...\u0026#34;\u0026gt;...\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;...\u0026#34;\u0026gt;...\u0026lt;/prop\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt;    注意：\n List的底层也是通过数组实现的，所以\u0026lt;list\u0026gt;和\u0026lt;array\u0026gt;标签是可以混用。 集合中要添加引用类型，只需要把\u0026lt;value\u0026gt;标签改成\u0026lt;ref\u0026gt;标签。   构造器注入（constructor-arg 标签） 构造器注入是指Spring通过Bean的实例类中，带参的构造方法将其他Bean进行注入。\n注入引用数据类型 在UserServices中删除Setter方法（此处删除Setter方法是为了证明使用的是构造器注入而非Setter注入）并添加带参的构造方法：\npublic class UserServiceImpl implements UserService { private UserDao userDao; public UserServiceImpl(UserDao userDao) { this.userDao = userDao; } // ... } 修改Spring配置文件：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;constructor-arg\u0026gt;中name和ref属性的含义与\u0026lt;property\u0026gt;的含义类似。只不过name属性指的是Bean实例类型中构造方法的参数名（名称必须要一致）。\n成功运行ServiceBeanTest说明注入成功。\n如果要注入多个类型数据，则在构造方法中加入多个参数并在Bean中配置多个\u0026lt;constructor-arg\u0026gt;即可。\n注入简单数据类型 在UserDao中删除Setter方法，并为其添加带参的构造方法：\npublic class UserDaoImpl implements UserDao, InitializingBean { private String databaseName; private int connectionNum; public UserDaoImpl(String databaseName, int connectionNum) { this.databaseName = databaseName; this.connectionNum = connectionNum; } // ... } 修改Spring配置文件：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.linner.dao.impl.UserDaoImpl\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;databaseName\u0026#34; value=\u0026#34;mysql\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;connectionNum\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 成功运行ServiceBeanTest说明注入成功。\n集合注入 构造器注入集合数据类型的方式与Setter注入集合数据类型的方式类似。\n只不构造器注入要定义相应的带参方法，并且将\u0026lt;property\u0026gt;标签改为\u0026lt;constructor-arg\u0026gt;。\n自动装配（bean 标签的 autowire 属性） 自动装配只适用于引用类型依赖注入，不能对简单类型进行操作。\n自动装配的方式有：\n 按类型（常用） 按名称 按构造方法（的参数）  按类型自动装配 为UserService中的属性（如userDao）提供Setter方法。接着在Spring中为UserService删除其\u0026lt;bean\u0026gt;标签下的所有\u0026lt;proerty\u0026gt;或\u0026lt;constructor-arg\u0026gt;。然后给\u0026lt;bean\u0026gt;添加autowire=\u0026quot;byType\u0026quot;：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34; autowire=\u0026#34;byType\u0026#34;/\u0026gt;  注意：\n 类中对应属性的Setter方法不能省略。 被注入的对象必须要被Spring的IOC容器管理。 按照类型自动装配如果Spring在IOC中找到多个类型相同的Bean则会报NoUniqueBeanDefinitionException错误。   按名称自动装配 一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入。\n修改Spring配置文件（添加autowire=\u0026quot;byName\u0026quot;）：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.linner.service.impl.UserServiceImpl\u0026#34; autowire=\u0026#34;byName\u0026#34;/\u0026gt;  注意：\n 按名称自动装配是根据Setter方法的名称在IOC容器中寻找名称对应的Bean（Bean的id或name）。如setUserDao()则需要寻找名称为userDao的Bean。 如果按照名称找不到对应的Bean，则注入null（不会报错！）。 按名称自动装配中，实例类成员变量名与配置耦合，不推荐使用。   配置文件管理第三方 Bean（properties 文件加载） 数据源对象管理（DAO层） 以Druid为例：\n  pom.xml依赖：\n\u0026lt;dependencies\u0026gt; \u0026lt;!--Spring Framework--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--MySQL JDBC--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.29\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Druid--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   JDBC配置（jdbc.properties）：\njdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:33061/spring_db jdbc.username=root jdbc.password=n546,Lin0   Spring配置（applicationContext.xml）：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!--需要开启context命名空间--\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--加载jdbc配置文件--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath*:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!--Druid Bean--\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   编写App.java：\npackage com.linner; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); DruidDataSource dataSource = ctx.getBean(DruidDataSource.class); System.out.println(dataSource); } } 如果终端成功输出dataSource，说明配置成功。\n   注解开发 Spring对注解支持的版本历程:\n 2.0版开始支持注解 2.5版注解功能趋于完善 3.0版支持纯注解开发  基础配置：\n 创建Maven项目。 添加Spring Framework和Junit的依赖jar包。 添加业务层、数据层类：  User.java: 同使用IOC容器创建Bean中的User.java。 DAO(仅测试，无需查询数据库): 同Setter 注入中的DAO（UserDao）。 Service: 同Setter 注入中的Service（UserService）。    Spring 配置文件包扫描 为了能够获取到使用注解定义的Bean，需要在Spring配置文件中使用包扫描来识别出指定包下的所有Bean。\n创建Spring配置文件。在Spring配置文件中加入包扫描：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.linner\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt;  注意：\n使用\u0026lt;context:component-scan\u0026gt;包扫描，需要在\u0026lt;beans\u0026gt;标签中加入属性：\nxmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; 接着在\u0026lt;context:component-scan\u0026gt;的xsi:schemaLocation属性中加入值：\nhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd  \u0026lt;context:component-scan\u0026gt;：\n  component：组件，Spring将管理的Bean视作自己的一个组件。\n  scan：扫描。\n  base-package：该属性指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。\n 包路径越精确，如：com.linner.dao.impl，扫描的范围越小速度越快。 包路径越广泛，如：com.linner，扫描的范围越大速度越慢。   一般扫描到项目的组织名称即Maven的\u0026lt;groupId\u0026gt;下（如：com.linner）即可。 包扫描不仅能扫描当前包，还能扫描当前包下的子包。\n   创建 Bean 对象（@Component） 在UserDao中添加@Component注解：\nimport org.springframework.stereotype.Component; @Component(\u0026#34;userDao\u0026#34;) public class UserDaoImpl implements UserDao { // ... } 编写新的测试类UserDaoTest：\npackage com.linner.dao; import com.linner.domain.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserDaoTest { private static UserDao userDao; static { ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); userDao = (UserDao) ctx.getBean(\u0026#34;userDao\u0026#34;); } @Test public void testFindAll() { userDao.findAll(); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testFindById() { int id = 12; userDao.findById(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testDelete() { int id = 12; userDao.delete(id); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userDao.save(user); System.out.println(\u0026#34;------------\u0026#34;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(\u0026#34;abc\u0026#34;); user.setPassword(\u0026#34;abc123\u0026#34;); userDao.update(user); System.out.println(\u0026#34;------------\u0026#34;); } }   @Component可以传递一个String类型的值。用于制定Bean的名称。\n  @Component可以直接使用而不指定名称。即，使用按类型获取Bean。但必须保证该类型在IOC中有且仅有一个Bean。如：\n@Component(\u0026#34;userDao\u0026#34;) public class UserDaoImpl implements UserDao { // ... } UserDao userDao = ctx.getBean(UserDao.class);   @Component注解如果不起名称，会有一个默认值，就是将当前类名首字母转为小写后的值。所以也可以按照名称获取。\n  @Component还有其他三个衍生注解。\n @Controller：表现层 @Service：业务层 @Repository：数据层  它们的作用和@Component是一样的，仅作为对表现层、业务层和数据层的类进行区分。如：\nimport org.springframework.stereotype.Repository; @Repository(\u0026#34;userDao\u0026#34;) public class UserDaoImpl implements UserDao { // ... } import org.springframework.stereotype.Repository; @Repository public class UserDaoImpl implements UserDao { // ... }   纯注解开发（配置类、包扫描） Spring3.0开启了纯注解开发模式，使用Java类替代配置文件。\n删除Spring配置文件并创建配置类：\npackage com.linner.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(\u0026#34;com.linner\u0026#34;) public class SpringConfig { }   @Configuration：设定该类为Spring配置类。\n  @ComponentScan：包扫描，用来替换配置文件中的\u0026lt;context:component-scan\u0026gt;。在一个配置类中仅能使用一次。多个扫描路径使用数据格式，如：\n@ComponentScan({\u0026#34;com.linner.dao\u0026#34;, \u0026#34;com.linner.service\u0026#34;})  包扫描不仅能扫描当前包，还能扫描当前包下的子包\n   修改UserDaoTest：\nimport com.linner.config.SpringConfig; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class UserDaoTest { private static UserDao userDao; static { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); userDao = (UserDao) ctx.getBean(\u0026#34;userDao\u0026#34;); } // ... } 使用Spring配置类，获取IOC容器应该使用AnnotationConfigApplicationContext对象：\npublic AnnotationConfigApplicationContext(Class\u0026lt;?\u0026gt;... componentClasses) 作用范围（@Scope） 注解开发控制Bean的作用范围使用@Scope。它的值有两个：\n  \u0026quot;singleton\u0026quot;：默认值，将当前类设置为单例。\n  \u0026quot;prototype\u0026quot;：将当前类设置为多例。如：\nimport org.springframework.context.annotation.Scope; @Repository @Scope(\u0026#34;prototype\u0026#34;) public class UserDaoImpl implements UserDao { // ... }   生命周期控制（@PostConstruct 和 @PreDestroy） 注解控制Bean生命周期使用：\n @PostConstruct：初始化。 @PreDestroy：销毁。  给UserDao加入初始化和销毁方法（方法名任意）：\nimport javax.annotation.PostConstruct; import javax.annotation.PreDestroy; @Repository public class UserDaoImpl implements UserDao { /** * 初始化方法 */ @PostConstruct public void init() { System.out.println(this + \u0026#34;init...\u0026#34;); } /** * 销毁方法 */ @PreDestroy public void destroy() { System.out.println(this + \u0026#34;destroy...\u0026#34;); } // ... }  与使用注解开发的情况一样，要想执行destroy()需要在程序执行的时候关闭容器：\nctx.close(); 或：\nctx.registerShutdownHook(); 注意:@PostConstruct和@PreDestroy注解如果找不到，需要导入下面的jar包。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.annotation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.annotation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。\n 依赖注入 给UserService配置Bean：\nimport org.springframework.stereotype.Service; @Service public class UserServiceImpl implements UserService { // ... } 按照类型注入 注解开发按照类型注入使用@Autowired注解。\n给UserService注入UserDao：\nimport org.springframework.beans.factory.annotation.Autowired; @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; // ... }  @Autowired可以在实例类的成员变量上使用，也可以在Setter方法上使用，如：\n@Service public class UserServiceImpl implements UserService { private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) { this.userDao = userDao; } // ... } 在实例类的成员变量上使用@Autowired，即使将Setter方法注释掉依然可以注入成功。因为自动装配基于反射设计创建对象并通过暴力反射为属性进行设值（即使是私有属性也能设值）。\n使用@Autowired需要保证该类型在IOC容器中有且仅有一个同类型的Bean。 如果IOC容器中有对个同类型的Bean。那么@Autowired就会按照变量名和Bean的名称进行匹配。如：\n@Repository(\u0026#34;userDao\u0026#34;) public class UserDaoImpl implements UserDao { /*...*/ } @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; // ... } 也能注入成功。\n如果有多个同类型Bean，并且@Autowired名称匹配不上，那么会报NoUniqueBeanDefinitionException错误。\n 使用使用IOC容器创建Bean中的UserServiceTest，成功执行说明配置成功。\n按照名称注入 注解开发名称注入使用@Qualifier注解来完成。\nimport org.springframework.beans.factory.annotation.Qualifier; @Service public class UserServiceImpl implements UserService { @Autowired @Qualifier(\u0026#34;userDao\u0026#34;) private UserDao userDao; // ... } 在@Qualifier中指定Bean的名称。并且，@Qualifier必须和@Autowired一起使用才能起到按照名称注入的效果。\n 经过测试单独使用@Qualifier（不加@Autowired）的效果和按照类型注入的效果一样（可能会有其他细微的区别）。\n 注入简单数据类型 注解开发注入简单类型数据使用@Value注解。\nimport org.springframework.beans.factory.annotation.Value; @Repository public class UserDaoImpl implements UserDao { @Value(\u0026#34;mysql\u0026#34;) private String databaseName; @Value(\u0026#34;10\u0026#34;) private int connectionNum; // ... } @Value中的值使用String类型。如果要注入的是其他类型数据，需要按照其类型数据的格式编写。\n注解读取 properties 配置文件 使用@Value的意义之一在于：读取properties配置文件的信息。\n在resource目录下新建jdbc.properties：\ndatabaseName=mysql connectionNum=10 在配置类上添加@PropertySource注解：\nimport org.springframework.context.annotation.PropertySource; @Configuration @ComponentScan(\u0026#34;com.linner\u0026#34;) @PropertySource(\u0026#34;jdbc.properties\u0026#34;) public class SpringConfig { } 修改UserDao：\n@Repository public class UserDaoImpl implements UserDao { @Value(\u0026#34;${databaseName}\u0026#34;) private String databaseName; @Value(\u0026#34;${connectionNum}\u0026#34;) private int connectionNum; // ... }   读取多个配置文件，使用数组形式给@PropertySource传递字符串数组。如：\n@PropertySource({\u0026#34;jdbc.properties\u0026#34;, \u0026#34;xxx.properties\u0026#34;})   @PropertySource注解属性中不支持使用通配符*，运行会报错。\n  @PropertySource注解属性中可以加入classpath:，代表从当前项目的根路径找文件：\n@PropertySource({\u0026#34;classpath:jdbc.properties\u0026#34;})   注解管理第三方 Bean 基础配置：\n  User.java: 同使用IOC容器创建Bean中的User.java。\n  UserDao：\npackage com.linner.dao; import com.linner.domain.User; import org.apache.ibatis.annotations.*; import java.util.List; public interface UserDao { @Select(\u0026#34;SELECT * FROM user_tb\u0026#34;) List\u0026lt;User\u0026gt; findAll(); @Select((\u0026#34;SELECT * FROM user_tb WHERE id = #{id}\u0026#34;)) User findById(int id); @Delete(\u0026#34;DELETE FROM user_tb WHERE id = #{id}\u0026#34;) void delete(int id); @Insert(\u0026#34;INSERT INTO user_tb(username, password) VALUES (#{username}, #{password})\u0026#34;) void save(User user); @Update(\u0026#34;UPDATE user_tb SET username = #{username}, password = #{password} WHERE id = #{id}\u0026#34;) void update(User user); }   UserService：\nUserService接口同使用IOC容器创建Bean中的UserService.java。\nUserService实现类UserServiceImpl.java：\npackage com.linner.service.impl; import com.linner.dao.UserDao; import com.linner.domain.User; import com.linner.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Override public List\u0026lt;User\u0026gt; findAll() { return userDao.findAll(); } @Override public User findById(int id) { return userDao.findById(id); } @Override public void delete(int id) { userDao.delete(id); } @Override public void save(User user) { userDao.save(user); } @Override public void update(User user) { userDao.update(user); } }   整合 Mybatis   pom.xml依赖：\n\u0026lt;!--Spring Framework--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--MySQL JDBC--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.29\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Druid--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--MyBatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring JDBC--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--MyBatis Spring 整合包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Junit 单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   建立User表：\nDROP TABLE IF EXISTS `user_tb`; CREATE TABLE `user_tb` ( `id` int(10) PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;用户id\u0026#39;, `username` varchar(10) NOT NULL COMMENT \u0026#39;用户名\u0026#39;, `password` varchar(10) NOT NULL COMMENT \u0026#39;密码\u0026#39; ) CHARACTER SET = utf8;   JDBC配置文件jdbc.properties：\njdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false\u0026amp;useServerPrepStmts=true jdbc.username=root jdbc.password=root   JDBC配置类JdbcConfig.java：\npackage com.linner.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import javax.sql.DataSource; public class JdbcConfig { // 驱动信息：  @Value(\u0026#34;${jdbc.driver}\u0026#34;) private String driver; @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; @Value(\u0026#34;${jdbc.username}\u0026#34;) private String username; @Value(\u0026#34;${jdbc.password}\u0026#34;) private String password; /** * 获取DataSource对象 */ @Bean public DataSource dataSource() { DruidDataSource ds = new DruidDataSource(); // 设置驱动信息  ds.setDriverClassName(this.driver); ds.setUrl(this.url); ds.setUsername(this.username); ds.setPassword(this.password); return ds; } }  @Bean：用于方法上，根据返回值类型自动产生Bean，并且方法的参数会按照类型自动装配。    Mybatis配置类MybatisConfig.java：\npackage com.linner.config; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.mapper.MapperScannerConfigurer; import org.springframework.context.annotation.Bean; import javax.sql.DataSource; public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) { SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); // 设置模型类的别名扫描  ssfb.setTypeAliasesPackage(\u0026#34;com.linner.domain\u0026#34;); // 设置数据源  ssfb.setDataSource(dataSource); return ssfb; } /** * 获取MapperScannerConfigurer对象 */ @Bean public MapperScannerConfigurer mapperScannerConfigurer() { MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\u0026#34;com.linner.dao\u0026#34;); return msc; } }  SqlSessionFactoryBean：用于封装SqlSessionFactory需要的环境信息（原先的信息是在Mybatis配置文件中定义，如今可以在Java中用代码定义）。用于产生SqlSessionFactory对象。  setTypeAliasesPackage()：设置模型类的别名扫描 setDataSource()：设置DataSource。这里设置的DataSource通过方法的参数和@Bean注解实现了自动装配。并且自动装配的对像是Druid的DataSource。   MapperScannerConfigurer：用于加载Dao接口，创建代理对象保存到IOC容器中。此处设置的是dao包下的所有接口。这些接口都会被Mybatis创建成对象并且作为Bean保存在IOC容器中。即，使用ctx.getBean(UserDao.class)能获取到UserDao。    Spring配置类SpringConfig.java：\npackage com.linner.config; import org.springframework.context.annotation.*; @Configuration @ComponentScan(\u0026#34;com.linner\u0026#34;) @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) @Import({JdbcConfig.class, MybatisConfig.class}) public class SpringConfig { }  @Import：用于引入其他配置类。如果要引入多个配置类则需要使用数组形式。    测试类UserServiceTest：\npackage com.linner; import com.linner.config.SpringConfig; import com.linner.domain.User; import com.linner.service.UserService; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import java.util.List; public class UserServiceTest { private static UserService userService; static { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); userService = ctx.getBean(UserService.class); } @Test public void testFindAll() { List\u0026lt;User\u0026gt; users = userService.findAll(); for (User user : users) { System.out.println(user); } } @Test public void testFindById() { int id = 10; User user = userService.findById(id); System.out.println(user); } @Test public void testDelete() { int id = 10; userService.delete(id); } @Test public void testSave() { User user = new User(); user.setUsername(\u0026#34;张三\u0026#34;); user.setPassword(\u0026#34;abc\u0026#34;); userService.save(user); } @Test public void testUpdate() { User user = new User(); user.setId(21); user.setUsername(\u0026#34;张三\u0026#34;); user.setPassword(\u0026#34;abc\u0026#34;); userService.update(user); } }   整合 Junit   引入Spring与测试有关的整合包：\n\u0026lt;!--Spring 测试整合包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   修改测试类UserServiceTest：\nimport org.junit.runner.RunWith; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.List; // 设置类运行器 @RunWith(SpringJUnit4ClassRunner.class) // 设置Spring环境对应的配置 // 加载配置类 @ContextConfiguration(classes = {SpringConfig.class}) // 加载配置文件 //@ContextConfiguration(locations={\u0026#34;classpath:applicationContext.xml\u0026#34;}) public class UserServiceTest { // 自动装配UserService，删除static静态代码块  @Autowired private UserService userService; }   AOP AOP 介绍 一般常用的编程思想是OOP（面向对象编程，Object Oriented Programming）。\n而AOP（面向切面编程，Aspect Oriented Programming），是一种编程范式，指导开发者如何组织程序结构。\n编程思想主要的内容就是指导程序员该如何编写程序，所以AOP和OOP是两种不同的编程范式。\nAOP的作用是在不改变原始设计的基础上为其进行功能增强。类似于Filter代理模式。\nAOP术语：\n  连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等。\n在SpringAOP中，理解为方法的执行。\n例如要对项目中UserDao的功能在不进行任何修改的前提下实现增强。那么UserDao中要增强的方法即为连接点。\n  切入点（Pointcut）：匹配连接点的式子。\n在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法。\n 连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。\n   通知（Advice）：在切入点处执行的操作，也就是共性功能。\n在SpringAOP中，功能最终以方法的形式呈现。\n  通知类：定义通知的类。\n  切面（Aspect）：描述通知与切入点的对应关系。\n通知是要增强的内容，会有多个；切入点是需要被增强的方法，也会有多个。通知和切入点的关系通过切面来描述。\n  目标对象（Target）：也叫原始对象。原始功能去掉共性功能对应的类产生的对象。即，配置AOP之前原设计的对象（要增强的对象）。\n  代理（Proxy）：通过通知类把目标对象增强后产生的对象。\n目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现。\n  注解开发 AOP 基础配置：使用整合 Junit中的配置。\n  pom.xml导入坐标：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  spring-context中已经包含了spring-aop，所以不需要再单独导入spring-aop。 AspectJ是AOP思想的一个具体实现，AspectJ比起Spring的AOP实现来说，更加好用。    创建通知类UserDaoAdvice：\npackage com.linner.aop; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; @Component @Aspect public class UserDaoAdvice { @Pointcut(\u0026#34;execution(* com.linner.dao.UserDao.*(..))\u0026#34;) private void pt() {} @Before(\u0026#34;pt()\u0026#34;) public void method() { System.out.println(\u0026#34;Before...\u0026#34;); } }   @Aspect：设置当前类为AOP切面类。\n  @Pointcut：设置切入点方法。切入点定义需要一个不具有实际意义的方法（无参、无返回值、空方法体）。即UserDaoAdvice中的pt()。\n@Pointcut中的execution()用来定义切入点。\n  @Before：设置切面。即设置当前通知方法在原始切入点方法前运行。\n切入点定义作为@Before的参数。\n    在SpringConfig加入@EnableAspectJAutoProxy注解：\nimport org.springframework.context.annotation.*; @Configuration @ComponentScan(\u0026#34;com.linner\u0026#34;) @EnableAspectJAutoProxy @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) @Import({JdbcConfig.class, MybatisConfig.class}) public class SpringConfig { }   AOP 切入点表达式 切入点表达式是对要进行增强的方法的描述方式。切入点表达式的一般形式如下：\n动作关键字(访问修饰符 返回值类型 包名.类名.方法名(参数类型列表) 异常名)  由于通常都是对public方法进行定义，而public是默认的，所以可以省略。 切入点表达式定义的类可以是接口，也可以是其实现类。 AOP是在Spring中运行的，很显然切入点表达式定义的类必须存在IOC容器中。 如果匹配无参方法，直接省略参数。  Example：\nexecution(void com.linner.dao.UserDao.delete(int)) 切入点表达式通配符   *：匹配任意单个独立的任意符号。\n可以独立出现，匹配任意返回值类型、单个包名（不能用做匹配完整包名）、类名、方法名或单个参数类型（即匹配单个单词）； 也可以作为前缀或者后缀的匹配符出现。\n如：\nexecution（* com.linner.*.UserService.find*(*)) 匹配com.linner包下的任意包中的UserService类或接口中，所有以find开头的、带有一个参数的、任意返回值类型的方法。\n  ..：匹配多个连续的任意符号。\n可以独立出现，常用于简化包名与参数的书写。\nexecution（* com..UserService.findById(..)) 匹配com包下的任意包中的UserService类或接口中所有名称为findById的（参数的数量、类型任意，返回值任意）方法。\n    +：专用于匹配子类类型。\nexecution(* *..*Service+.*(..)) 这个使用率较低。*Service+，表示所有以Service结尾的接口的子类。\n  书写技巧（所有代码按照标准规范开发，否则以下技巧全部失效）：\n 描述切入点通常描述接口，而不描述实现类，如果描述到实现类，就出现耦合了。 访问控制修饰符针对接口开发均采用public描述（简化书写）。 返回值类型对于增删改方法使用精准类型加速匹配，对于查询类使用*通配快速描述。 包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配。 接口名/类名书写名称与模块相关的采用*匹配，例如UserService书写成*Service，绑定业务层接口名。 方法名书写以动词进行精准匹配，名词采用*匹配，例如getById书写成getBy*，selectAll书写成selectAll。 参数规则较为复杂，根据业务方法灵活调整。 通常不使用异常作为匹配规则。  通知类型 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置。\nAspactJ提供了5种通知类型：\n 前置通知 后置通知 环绕通知 返回后通知 抛出异常后通知  // 代码1 try { // 代码2  // 原始的业务操作  // 代码3 } catch (Exception e) { // 代码4 } // 代码5 其中：\n 前置通知：代码1和代码2 返回后通知：代码3 抛出异常后通知：代码4 后置通知:代码5 环绕通知：上述整个代码块  通知方法的方法名称没有限制，只需在方法的上端使用注解定义即可。各通知类型的注解如下：\n 前置通知：@Before 后置通知：@After 环绕通知：@Around 返回后通知：@AfterReturning 抛出异常后通知：@AfterThrowing  这些注解的使用方式都是一样的。在对应的方法上定义，并且传入切入点（函数形式）。如：@Around(\u0026quot;pt()\u0026quot;)。\n前置通知和后置通知的使用 前置通知和后置通知的使用方式一样：\n@Component @Aspect public class UserDaoAdvice { @Pointcut(\u0026#34;execution(* com.linner.dao.UserDao.*(..))\u0026#34;) private void pt() {} @Before(\u0026#34;pt()\u0026#34;) public void before() { System.out.println(\u0026#34;Before...\u0026#34;); } @After(\u0026#34;pt()\u0026#34;) public void after() { System.out.println(\u0026#34;After...\u0026#34;); } } 环绕通知的使用 import org.aspectj.lang.ProceedingJoinPoint; @Component @Aspect public class UserDaoAdvice { @Pointcut(\u0026#34;execution(* com.linner.dao.UserDao.findById(int))\u0026#34;) private void pt() {} @Around(\u0026#34;pt()\u0026#34;) public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\u0026#34;Before...\u0026#34;); Object ret = pjp.proceed(); System.out.println(\u0026#34;After....\u0026#34;); return ret; } } 环绕通知必须传入一个ProceedingJoinPoint参数。使用pjp.proceed()才可以在环绕通知中掉用原始方法。并且proceed()可以获取到原始方法的返回值。\n如果也想让代理后的方法返回跟原始方法一样的值。那么必须定义环绕方法的返回值类型，并且使用proceed()获取原始方法的返回值并返回。\n环绕通知比较灵活，可以将其定义成其他类型的通知，并且可以做到其他通知做不到的事情。例如循环调用原始方法等。\n环绕通知需要抛出异常是因为。原始方法有可能会出现异常，并且原始方法的异常并不确定。所以为了提高通用性，环绕通知默认抛出异常。\n如果环绕方法定义的是void类型，并且原始方法有返回值。如果此时在环绕通知中没有返回值，那么在掉用代理后的方法后，返回的是null。\n返回后通知的使用 @Component @Aspect public class UserDaoAdvice { @Pointcut(\u0026#34;execution(* com.linner.dao.UserDao.findById(int))\u0026#34;) private void pt() {} @AfterReturning(\u0026#34;pt()\u0026#34;) public void afterReturning() { System.out.println(\u0026#34;After Returning...\u0026#34;); } }  注意：返回后通知是需要在原始方法正常执行后才会被执行，如果原始方法执行的过程中出现了异常，那么返回后通知不会被执行。\n后置通知是不管原始方法有没有抛出异常都会被执行。\n 异常后通知 @Component @Aspect public class UserDaoAdvice { @Pointcut(\u0026#34;execution(* com.linner.service.UserService.findAll())\u0026#34;) private void pt() {} @AfterThrowing(\u0026#34;pt()\u0026#34;) public void afterThrowing() { System.out.println(\u0026#34;After Throwing...\u0026#34;); } } 在UserServiceImpl.findAll()中模拟错误即可触发。例如使用int a = 1/0;模拟错误。\n 注意：异常后通知是需要原始方法抛出异常。如果没有抛异常，异常后通知将不会被执行。\n ","date":"2022-10-16T00:00:00Z","permalink":"https://blog.linner.asia/p/spring-framework/","title":"Spring Framework"},{"content":"Ajax AJAX (Asynchronous JavaScript And XML)，其含义为异步的 JavaScript 和 XML。其中 JavaScript 表明该技术和前端相关；XML 是指以此进行数据交换。\nAJAX 作用有以下两方面：\n 与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用校验等等。  同步：浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后，浏览器页面才能继续做其他的操作。 异步：浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。    Ajax 简单使用 服务端：\npackage web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/ajaxServlet\u0026#34;) public class AjaxServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 返回给客户端响应数据  resp.getWriter().write(\u0026#34;Hello Ajax!\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 客户端：\n//1. 创建核心对象 let xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5  xhttp = new ActiveXObject(\u0026#34;Microsoft.XMLHTTP\u0026#34;); } //2. 发送请求 xhttp.open(\u0026#34;GET\u0026#34;, \u0026#34;http://localhost:8080/ajax-demo/ajaxServlet\u0026#34;); xhttp.send(); //3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026amp;\u0026amp; this.status == 200) { // 处理从服务端发送过来的响应数据  alert(this.responseText); } };  Axios Axios 是一个对原生的AJAX进行封装，简化书写的前端框架。\n使用 Axios 进行交互 Axios 的使用分为以下两步：\n  引入 Axios 的 js 文件\n\u0026lt;script src=\u0026#34;js/axios.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   使用 Axios 发送请求，并获取响应结果：\n  发送 GET 请求的基本形式：\naxios({ method: \u0026#34;get\u0026#34;, // 请求参数会传递给服务器，此处请求参数可以转义也可以不转义  url: \u0026#34;http://localhost:8080/axios-demo/demo?message=Hello%20World\u0026#34; }).then(function (resp){ // 对响应数据进行处理  alert(resp.data); })   发送 POST 请求的基本形式：\naxios({ method: \u0026#34;post\u0026#34;, url: \u0026#34;http://localhost:8080/axios-demo/demo\u0026#34;, data: \u0026#34;message=Hello World\u0026#34; }).then(function (resp){ alert(resp.data); });     其中：\n  axios() 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数：\n  method 属性：用来设置请求方式的。\n取值为 get 或者 post。\n  url 属性：用来书写请求的资源路径。\n如果是 get 请求，需要将请求参数拼接到路径的后面，格式为： url?参数名=参数值\u0026amp;参数名2=参数值2。\n  data 属性：作为请求体被发送的数据。\n即，如果是 post 请求的话，数据需要作为 data 属性的值。\n    then() 需要传递一个匿名函数。\nthen() 中传递的匿名函数称为回调函数，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。\n而该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。\n  请求方法别名 为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下：\n  get 请求：\naxios.get(url[,config])   delete 请求：\naxios.delete(url[,config])   head 请求：\naxios.head(url[,config])   options 请求：\naxios.option(url[,config])   post 请求：\naxios.post(url[,data[,config])   put 请求：\naxios.put(url[,data[,config])   patch 请求：\naxios.patch(url[,data[,config])   this 作用域问题 使用请求方法别名和箭头函数可以解决this作用域问题，防止this指向错误：\n  GET请求：\naxios.get( \u0026#34;http://localhost:8080/axios-demo/demo?message=Hello World\u0026#34; ).then(resp =\u0026gt; { // 对响应数据进行处理  alert(resp.data); })   POST请求：\naxios.post( \u0026#34;http://localhost:8080/axios-demo/demo\u0026#34;, \u0026#34;message=Hello World\u0026#34; ).then(resp =\u0026gt; { // 对响应数据进行处理  alert(resp.data); })   JSON JSON（JavaScript Object Notation）是指 JavaScript 对象表示法。\nJSON的优点：数据格式简单，所占的字节数少等。\nJSON 的格式 JSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的：\n{ \u0026#34;key_1\u0026#34;: value_1, \u0026#34;key_2\u0026#34;: value_2, \u0026#34;key_3\u0026#34;: value_3, ..., \u0026#34;key_n\u0026#34;: value_n }  JSON 格式中的键要求必须使用双引号括起来。 Value 的数据类型分为如下：  数字（整数或浮点数） 字符串（使用双引号括起来） 逻辑值（true或者false） 数组（在方括号{}中） 对象（在花括号[]中） null    在 js 中定义 json：\nvar 变量名 = `{ \u0026#34;key1\u0026#34;:value1, \u0026#34;key2\u0026#34;:value2, ... }`; 在 JS 中使用 JOSN JS 提供了一个对象 JSON ，该对象有如下两个方法：\n  parse(str)：将 JSON串转换为 js 对象。\n使用方式：\nvar jsObject = JSON.parse(jsonStr);   stringify(obj)：将 js 对象转换为 JSON 串。\n使用方式：\nvar jsonStr = JSON.stringify(jsObject)   携带JSON发送异步请求 可以使用 JSON.stringify() 将js对象转换为 JSON 串，再将该 JSON 串作为 axios 的 data 属性值进行请求参数的提交。\n但其实只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 axios 的 data 属性值。axios 会自动将 js 对象转换为 JSON 串进行提交。\n 发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST。因为 JSON 串需要放在请求体中。\n Fastjson Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。\n依赖坐标：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.62\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JOSN 和 Java对象的相互转换包含：\n  请求数据（反序列化）：\nJSON字符串转为Java对象。\n将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。\nString toJSONString(Object object)   响应数据（序列化）：\nJava对象转为JSON字符串。\n将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。\n\u0026lt;T\u0026gt; T parseObject(String jsonStr, Class\u0026lt;T\u0026gt; clazz)   Example：\n  导入坐标。\n  编写pojo类：\npackage pojo; public class User { private Integer id; private String username; private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, username=\u0026#39;\u0026#34; + username + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   编写FastJsonDemo：\npackage web.servlet; import com.alibaba.fastjson.JSON; import pojo.User; public class FastJsonDemo { public static void main(String[] args) { // 1. Java对象转JSON字符串  User user = new User(); user.setId(1); user.setUsername(\u0026#34;zhangsan\u0026#34;); user.setPassword(\u0026#34;123\u0026#34;); String jsonString = JSON.toJSONString(user); System.out.println(jsonString); // 输出：{\u0026#34;id\u0026#34;:1,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;zhangsan\u0026#34;}  // 2. 将JSON字符串转为Java对象  User u = JSON.parseObject( \u0026#34;{\\\u0026#34;id\\\u0026#34;:1,\\\u0026#34;password\\\u0026#34;:\\\u0026#34;123\\\u0026#34;,\\\u0026#34;username\\\u0026#34;:\\\u0026#34;zhangsan\\\u0026#34;}\u0026#34;, User.class); System.out.println(u); } }   ","date":"2022-09-25T00:00:00Z","permalink":"https://blog.linner.asia/p/ajax-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/","title":"Ajax 前后端交互"},{"content":"Filter 概述 Filter 表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。\n过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。设置 Filter 会在访问资源之前会先经过 Filter，将资源拦截，从而实现权限控制、统一编码处理、敏感字符处理等功能。\n过滤器Filter是在请求进入容器后，但在进入Servlet之前进行预处理。\n进行 Filter 开发分成以下三步实现：\n  定义类，实现 Filter接口，并重写其所有方法：\npackage filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; // 拦截的路径，这里 \u0026#34;/*\u0026#34; 拦截了项目中所有资源请求 @WebFilter(\u0026#34;/*\u0026#34;) public class FilterDemo implements Filter { // Filter的初始化方法  @Override public void init(FilterConfig filterConfig) throws ServletException { // ...  } // Filter的操作方法，在init后执行  @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // ...  } // 销毁Filter执行的方法  @Override public void destroy() { // ...  } }   配置Filter拦截资源的路径：\n在类上定义 @WebFilter 注解。\n此处注解的 value 属性值 /* 表示拦截所有的资源。\npackage filter; // import ...  // 拦截的路径，这里 \u0026#34;/*\u0026#34; 拦截了项目中所有资源请求 @WebFilter(\u0026#34;/*\u0026#34;) public class FilterDemo implements Filter { // ... }   在doFilter()方法中对拦截的资源进行处理，并选择是否放行：\npackage web.filter; // import ...  // 拦截的路径，这里 \u0026#34;/*\u0026#34; 拦截了项目中所有资源请求 @WebFilter(\u0026#34;/*\u0026#34;) public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // 1. 放行前，对request数据进行处理  // ...  // 放行前response中没有数据  // 2. 放行  filterChain.doFilter(servletRequest, servletResponse); // 调用该方法，会执行其它拦截器或访问路径中对应的Servlet或访问对应资源  // 如果该方法没有被调用，那么对应资源将不可被访问，且后续的其它拦截器都不会被执行  // 3. 放行后，对response数据进行处理  // ...  } // ... }   项目依赖：\n\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;port\u0026gt;80\u0026lt;/port\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  在doFilter()中，如果要使用request和response，可以将它们强转为对应的HttpServletRequest和HttpServletResponse对象来进行操作。\n  Filter 执行流程 Filter 的执行流程如下：\n  浏览器访问资源\n  资源被Filter拦截\nFilter 执行放行前逻辑\n  判断是否放行\n  放行：\n可能会执行以下操作：\n 如果有，则执行后续的Filter 如果资源没有被后续其它Filter拦截，那么访问对应资源    不放行：\n后续的其它 Filter 将不会被执行，资源也不可被访问\n    Filter 执行放行后逻辑\n   Filter 拦截路径配置 拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 @WebFilter 注解进行配置。\n拦截路径有如下四种配置方式：\n 拦截具体的资源：/index.html，只有访问index.html时才会被拦截 目录拦截：/user/*，访问/user下的所有资源，都会被拦截 后缀名拦截：*.html，访问后缀名为jsp的资源，都会被拦截 拦截所有：/*，访问项目下所有资源，都会被拦截   过滤器链 过滤器链是指在一个Web应用，可以对同个拦截路径配置多个过滤器，这多个过滤器组成了过滤器链。\n过滤器链基于函数回调，多个过滤器之间的优先级顺序以过滤器类名的自然顺序（A-Z 0-9）为规则进行排序。\n例如，有Filter1和Filter2两个拦截路径相同的Filter：\n 执行 Filter1 的放行前逻辑代码 执行 Filter1 的放行代码 执行 Filter2 的放行前逻辑代码 执行 Filter2 的放行代码 访问到资源 执行 Filter2 的放行后逻辑代码 执行 Filter1 的放行后逻辑代码  ","date":"2022-09-25T00:00:00Z","permalink":"https://blog.linner.asia/p/filter-%E8%BF%87%E6%BB%A4%E5%99%A8/","title":"Filter 过滤器"},{"content":"会话跟踪技术 会话是指一个终端用户与交互系统进行通讯的过程，例如从浏览器发出请求到服务端响应数据给前端这个过程即为一个会话。\n会话跟踪指的是一种维护浏览器状态的方法。服务器会收到多个请求，这多个请求可能来自多个浏览器。服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\n浏览器和服务器不支持数据共享的原因：\n HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求。 HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响。 请求与请求之间独立后，就无法实现多次请求之间的数据共享。  实现会话跟踪技术的方式有：\n 客户端会话跟踪技术：Cookie。 Cookie是存储在浏览器端。 服务端会话跟踪技术：Session。 Session是存储在服务器端。   Cookie Cookie是一种客户端会话技术，将数据保存到客户端，在以后的每次请求中都携带Cookie数据进行访问。\n服务器将Cookie发送给浏览器，是通过在响应头中添加Set-Cookie键值对实现的，如Set-Cookie: message=\u0026quot;Hello Wrold\u0026quot;。在多个Cookie之间使用;分割。\n浏览器在接收了服务器发送来的Cookie后，会将数据存储在浏览器的内存中。在接下来的每次请求中，浏览器都会将获取到的Cookie发送到服务器（同一次会话中或在Cookie存活时间内）。浏览器将Cookie发送到服务器，是通过在请求头中设置Cookie键值对实现的，如Cookie: message=\u0026quot;Hello Wrold\u0026quot;。同样的，在多个Cookie之间使用;分割。\n  创建Cookie对象：\nCookie cookie = new Cookie(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;)   发送Cookie到客户端（使用Response对象）：\nresponse.addCookie(cookie)   从客户端获取Cookie（使用Request对象）：\nrequest.getCookies()   创建Maven web项目。\n项目依赖：\n\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--servlet--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;/build\u0026gt; 发送 Cookie 发送Cookie使用的是HttpServletResponse对象提供的addCookie()：\nresponse.addCookie(cookie) package web.cookie; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; @WebServlet(\u0026#34;/cookieServlet\u0026#34;) public class CookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 创建Cookie对象  String value = \u0026#34;Hello World\u0026#34;; System.out.println(\u0026#34;存储数据: \u0026#34; + value); Cookie cookie = new Cookie(\u0026#34;message\u0026#34;, value); // 设置存活时间, 7天  cookie.setMaxAge(60*60*24*7); // 2. 发送Cookie, response  response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 在发送Cookie时，可以使用setMaxAge()方法设置Cookie存活的时间（单位：秒）。\n如果要在Cookie中存储中文数据，需要将中文数据使用URLEncoder.encode()按照UTF-8（与前端页面的编码保持一致）编码。\npackage web.cookie; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; @WebServlet(\u0026#34;/cookieServlet\u0026#34;) public class CookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 创建Cookie对象  // 存储中文  String value = \u0026#34;你好\u0026#34;; // URL编码  value = URLEncoder.encode(value, StandardCharsets.UTF_8); // System.out.println(\u0026#34;存储数据: \u0026#34; + value);  Cookie cookie = new Cookie(\u0026#34;message\u0026#34;, value); // 设置存活时间, 7天  cookie.setMaxAge(60*60*24*7); // 2. 发送Cookie, response  response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 获取 Cookie 从客户端获取Cookie使用的是HttpServletRequest对象提供的getCookies()：\nrequest.getCookies() 它返回一个Cookie数组（Cookie[]）。\npackage web.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.nio.charset.StandardCharsets; @WebServlet(\u0026#34;/cookieServlet\u0026#34;) public class CookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取Cookie数组  Cookie[] cookies = request.getCookies(); // 2. 遍历数组  for (Cookie cookie : cookies) { // 3. 获取数据  String name = cookie.getName(); if (\u0026#34;message\u0026#34;.equals(name)) { String value = cookie.getValue(); // URL解码  value = URLDecoder.decode(value, StandardCharsets.UTF_8); System.out.println(name + \u0026#34;:\u0026#34; + value); break; } } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } Cookie对象提供的getName()和getValue()可以分别获取Cookie的名称和值。\n 获取Cookie后应该使用URLDecoder.decode进行解码，这样确保Cookie里出现中文数据时不会乱码。\n Cookie 常用方法    方法 说明     Cookie[] getCookies() HttpServletRequest提供的获取客户端Cookie的方法   void addCookie(Cookie cookie) HttpServletResponse提供的，将Cookie发送到客户端的方法   Cookie(String name, String value) Cookie类的构造函数，用于创建Cookie，需要指定名称name和值value   void setMaxAge(int expiry) 设置Cookie过期的时间（单位：秒）。值为-1（默认情况下）或其它负数，Cookie只会在当前Session会话中持续有效。值为0表示删除对应Cookie   int getMaxAge() 返回Cookie的最大生存周期（单位：秒）。默认情况下（不设置过期时间），-1 表示 Cookie 将持续到浏览器关闭。   String getName() 返回Cookie的名称（名称在创建后不能改变）   void setValue(String newValue) 设置与Cookie关联的值   String getValue() 获取与Cookie关联的值     Session Session是一种服务端会话跟踪技术，其数据保存在服务端。Session因为是存储在服务端所以比起Cookie，Session要更加安全。但与之相对的，Session不适合长期保存数据。\nSession是基于Cookie实现的。Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个。在第一次获取Session对象时，Session对象会有一个唯一的标识，如id:123。Tomcat服务器发现业务处理中使用了Session对象，就会把Session的唯一标识id:123当做一个Cookie，添加Set-Cookie:JESSIONID=123到响应头中，并响应给浏览器。所以，浏览器通过Cookie告诉服务器Session的id，服务器也通过Cookie获取相应的Session，从而实现一次会话多次请求之间的数据共享。\nJavaEE中提供了HttpSession接口，来实现一次会话的多次请求之间数据共享功能：\n  获取Session对象（使用Request对象）：\nHttpSession session = request.getSession();   Session对象提供的功能:\n  存储数据到 session 域中：\nvoid setAttribute(String name, Object o)   根据 key，获取值：\nObject getAttribute(String name)   根据 key，删除该键值对：\nvoid removeAttribute(String name)     存储数据 package web.session; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; @WebServlet(\u0026#34;/sessionServlet\u0026#34;) public class SessionServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 存储数据到Session中  // 1. 获取Session对象  HttpSession session = request.getSession(); // 2. 存储数据  session.setAttribute(\u0026#34;message\u0026#34;, \u0026#34;Hello World!\u0026#34;); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } }  由于Session中的数据是存储在服务器，所以在Session中存储和读取中文数据不需要进行编码和解码。\n 获取数据 package web.session; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; @WebServlet(\u0026#34;/sessionServlet\u0026#34;) public class SessionServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 从Session中获取数据  // 1. 获取Session对象  HttpSession session = request.getSession(); // 2. 获取数据  Object message = session.getAttribute(\u0026#34;message\u0026#34;); System.out.println(message); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } Session 的钝化与活化 正常来说，Session是存储在内存中的，只要服务器关闭，那么所有会话的Session都会失效。但是Tomcat在正常关闭的情况下，Session并不会失效，这是因为Session的钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中。钝化的数据路径为：项目目录\\target\\tomcat\\work\\Tomcat\\localhost\\项目名称\\SESSIONS.ser。\n再次启动服务器后，从文件中加载数据到Session中，这就是Session的活化。而数据加载到Session中后，路径中的SESSIONS.ser文件会被删除掉。\nSession 的销毁 默认情况下，无操作，30分钟后自动销毁Session。对于这个失效时间，是可以通过在项目的web.xml中配置进行修改：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\u0026#34; version=\u0026#34;3.1\u0026#34;\u0026gt; \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;100\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; \u0026lt;/web-app\u0026gt; 如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的。通过在Tomcat的web.xml中搜索\u0026lt;session-timeout\u0026gt;即可找到对应设置。\n也可以通过调用HTTPSession的invalidate()方法进行手动销毁。\nSession 常用方法    方法 说明     HttpSession getSession() HttpServletRequest提供的方法，用于获取当前会话的HttpSession对象   Object getAttribute(String name) 返回在该 session 会话中具有指定名称（name）的对象；如果没有指定名称的对象，则返回 null   void setAttribute(String name, Object value) 使用指定的名称绑定一个对象到该 session 会话   void removeAttribute(String name) 将从该 session 会话移除指定名称的对象   Enumeration getAttributeNames() 返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称   String getId() 返回一个包含分配给该 session 会话的唯一标识符的字符串   void invalidate() 销毁当前Session对象。该方法指示该 session 会话无效，并解除绑定到它上面的任何对象     Cookie 和 Session Cookie 和 Session 的区别：\n 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端。 安全性：Cookie不安全，Session安全。 数据大小：Cookie最大3KB，Session无大小限制。 存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟。 服务器性能：Cookie不占服务器资源，Session占用服务器资源。  ","date":"2022-09-23T00:00:00Z","permalink":"https://blog.linner.asia/p/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF-cookie-%E5%92%8C-session/","title":"会话跟踪技术 —— Cookie 和 Session"},{"content":"安装中文支持：\napt-get install language-pack-zh-hans -y 查看系统语言包：\nlocale -a 修改.zshrc，加入：\nexport LC_ALL=zh_CN.UTF-8 export LANG=zh_CN.UTF-8 修改/etc/default/locale：\nLANG=\u0026#34;zh_CN.UTF-8\u0026#34; ","date":"2022-09-13T00:00:00Z","permalink":"https://blog.linner.asia/p/ubuntu-zsh-%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/","title":"Ubuntu zsh 中文支持"},{"content":"HttpServlet 简介 HttpServlet是对HTTP协议封装的Servlet实现类。\nServlet的体系结构：\n在开发中，关注更多的是Servlet.service()方法。而每实现一个Servlet就必须实现Servlet接口，重写接口中的5个方法。\n但其实可以通过继承HttpServlet来编写Servlet，简化Servlet的开发流程。并且，如果是开发B/S架构的Web项目，针对的都是HTTP协议。\n使用HttpServlet的格式如下：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.*; import java.io.IOException; @WebServlet(\u0026#34;/demo\u0026#34;) public class ServletDemo extends HttpServlet { // 需要复写以下两个方法:  @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;Get...\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;Post...\u0026#34;); } }   启动Tomcat，使用浏览器访问http://localhost:8080/web-demo/demo可以在控制台看到doGet()方法被执行。\n  在项目的webapp目录下新建index.html，写入：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;TestPost\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/web-demo/demo\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34;/\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 启动Tomcat，访问http://localhost:8080/web-demo/，在表单输入内容后提交。即可在控制台看到doPost()被执行。\n  使用Servlet实现HttpServlet 既然HttpServlet继承自Servlet，那么也可以通过编写Servlet类来实现HttpServlet：\npackage com.linner.web; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; public class MyHttpServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { // 根据请求方式的不同,分别进行处理  HttpServletRequest request = (HttpServletRequest) servletRequest; // 1. 获取请求方式  String method = request.getMethod(); // 2. 判断  if (\u0026#34;GET\u0026#34;.equals(method)) { // GET 方式的处理逻辑  doGet(servletRequest, servletResponse); } else if (\u0026#34;POST\u0026#34;.equals(method)) { // POST 方式的处理逻辑  doPost(servletRequest, servletResponse); } } protected void doPost(ServletRequest servletRequest, ServletResponse servletResponse) { } protected void doGet(ServletRequest servletRequest, ServletResponse servletResponse) { } @Override public String getServletInfo() { return null; } @Override public void destroy() { } }  翻阅HttpServlet.service()方法源码，可以发现HttpServlet不仅仅可以对GET和POST进行处理，还能处理其它五种请求：doHead()、doPut()、doDelete()、doOptions()和doTrace()。\n  HttpServletRequest 和 HttpServletResponse Request 和 Response 概述 Request是请求对象，Response是响应对象。在Servlet中也存在这样的两个对象：\npublic class ServletDemo implements Servlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { // ...  } // ......  } Request作用：获取请求数据\n  浏览器会发送HTTP请求到后台服务器（如，Tomcat）\n  HTTP的请求中会包含很多请求数据\n如，HTTP协议请求：\n 请求行 请求头 请求体    后台服务器会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中\n所存入的对象即为Request对象，所以我们可以从Request对象中获取请求的相关参数\n  获取到数据后就可以继续后续的业务\n如，获取用户名和密码就可以实现登录操作的相关业务\n  Response作用：设置响应数据\n 业务处理完后，后台就需要给前端返回业务处理的结果（即，响应数据） 把响应数据封装到Response对象中 后台服务器会解析Response对象，按照格式（响应行+响应头+响应体）拼接结果 浏览器最终解析结果，把内容展示在浏览器给用户浏览  而HttpServlet使用的 Request 和 Response 对象与Servlet有所不同。HttpServlet使用的是 HttpServletRequest 和 HttpServletResponse。\nExample：\n@WebServlet(\u0026#34;/demo\u0026#34;) public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 使用request对象 获取请求数据  String name = request.getParameter(\u0026#34;name\u0026#34;); // Parameter在地址中以 ? 开始：url?name=zhangsan  // 使用response对象 设置响应数据  response.setHeader(\u0026#34;content-type\u0026#34;,\u0026#34;text/html;charset=utf-8\u0026#34;); response.getWriter().write(\u0026#34;\u0026lt;h1\u0026gt;\u0026#34;+name+\u0026#34;,欢迎您！\u0026lt;/h1\u0026gt;\u0026#34;); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } Request 和 Response 继承体系 HttpServletRequest和ServletRequest之间是继承关系，HttpServletResponse和ServletResponse是继承关系。\nRequest之间的继承关系如下：\nResponse之间的继承关系如下：\n HttpServletRequest HTTP常用的请求方式为：\n GET POST  HTTP请求数据总共分为三部分内容：\n 请求行 请求头 请求体  在请求数据中，还包含着请求参数：\n 对于GET：请求参数包含在请求头中。 对于POST：请求参数一般包含在请求体中。  获取请求行数据 如打开以下链接：\nhttp://localhost:8080/HttpServlet/httpservlet.html?username=linner 其请求行大致内容如下：\nGET /HttpServlet/httpservlet.html?username=linner HTTP/1.1 包含以下三部分内容：\n  请求方式：GET\n  请求资源路径：/HttpServlet/httpservlet.html?username=linner\n请求资源路径包含：\n 虚拟目录（项目访问路径）：/HttpServlet URI（统一资源标识符）：/HttpServlet/httpservlet.html 请求参数：username=linner    HTTP协议及版本：HTTP/1.1\n  这三部分内容，HttpServletRequest对象都提供了对应的API方法来获取：\n  获取请求方式：\nString getMethod() 返回：GET\n  获取虚拟目录（项目访问路径）:\nString getContextPath() 返回：/HttpServlet\n  获取URL（统一资源定位符）:\nStringBuffer getRequestURL() 返回：http://localhost:8080/HttpServlet/httpservlet.htm\n  获取URI（统一资源标识符）:\nString getRequestURI() 返回：/HttpServlet/httpservlet.html\n  获取请求参数（GET方式）:\nString getQueryString() 返回：username=linner（多个参数也一并返回）\n  Example：\npackage com.linner.web; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) public class TestHttpServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;---------------------------------------\u0026#34;); System.out.println(\u0026#34;请求行：\u0026#34;); System.out.println(\u0026#34;请求方式：\u0026#34; + request.getMethod()); System.out.println(\u0026#34;虚拟目录：\u0026#34; + request.getContextPath()); System.out.println(\u0026#34;URL：\u0026#34; + request.getRequestURL()); System.out.println(\u0026#34;URI：\u0026#34; + request.getRequestURI()); System.out.println(\u0026#34;请求参数：\u0026#34; + request.getQueryString()); System.out.println(\u0026#34;---------------------------------------\u0026#34;); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 获取请求头数据 请求头数据由多个 key: value 组成，如客户端浏览器的版本信息：\nUser-Agent: Mozila/5.0 Chrome/105.0.0.0 Edg/105.0.1343.42 HttpServletRequest 获取请求头的方法为：\nString getHeader(String name)  name：是请求头中的key。 返回值：返回name对应key的value。  使用getHeader()获取客户端浏览器的版本信息：\npackage com.linner.web.request; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo7 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String agent = request.getHeader(\u0026#34;user-agent\u0026#34;); // name 不区分大小写  System.out.println(agent); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 输出：\nMozila/5.0 Chrome/105.0.0.0 Edg/105.0.1343.42 获取请求体数据 浏览器发送的GET请求，是没有请求体的。只有在发送POST请求时才带有请求体。\n请求体中的数据格式如：\nusername=linner\u0026amp;password=123456 与资源路径中，请求参数的格式一样。\nHttpServletRequest提供了两种方式来获取请求体中的数据：\n  获取字节输入流：\n当前端发送的是字节数据，如传递的是文件数据时使用。\nServletInputStream getInputStream()   获取字符输入流：\n当前端发送的是纯文本数据时使用。\nBufferedReader getReader()    如果要在客户端浏览器发送POST请求，需要编写一个\u0026lt;form\u0026gt;表单。\n Example：\n  在项目的webapp目录下添加index.html：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- action: 表单提交的请求地址 method: 请求方式，指定为post --\u0026gt; \u0026lt;form action=\u0026#34;/request-demo/test\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   在doPost方法中获取数据：\n 由于index.html提交的是纯文本数据，所以要使用getReader()方法获取。\n package com.linner.web.request; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo8 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取字符输入流  BufferedReader br = request.getReader(); // 2. 读取数据  String line = br.readLine(); System.out.println(line); } }  BufferedReader流是通过HttpServletRequest对象来获取的，当请求完成后HttpServletRequest对象就会被销毁，HttpServletRequest对象被销毁后，BufferedReader流就会自动关闭，所以就不需要手动关闭流了。 getReader()获取请求参数后，还需要使用readLine()读取参数数据。\n   通过浏览器访问：http://localhost:8080/request-demo/。在表单中输入内容，然后提交，就可以在控制台看到前端所发送的请求数据：\nusername=linner\u0026amp;password=123456   获取请求参数 使用getQueryString()方法和getReader()分别获取GET和POST的请求参数：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String result = req.getQueryString(); System.out.println(result); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BufferedReader br = req.getReader(); String result = br.readLine(); System.out.println(result); } } 上述代码存在的问题：\n  doGet()和doPost中出现了重复代码。\n在实际业务中，可能会出现很多相同的业务代码。\n  doGet()和doPost都必须存在。\n  GET请求和POST请求获取请求参数的方式不一样。\n    在doPost()中调用doGet()，然后在doGet()判断请求的方式，并分别做处理：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 获取请求方式  String method = req.getMethod(); // 2. 获取请求参数  String params = \u0026#34;\u0026#34;; if(\u0026#34;GET\u0026#34;.equals(method)){ params = req.getQueryString(); }else if(\u0026#34;POST\u0026#34;.equals(method)){ BufferedReader reader = req.getReader(); params = reader.readLine(); } // 3. 处理请求  System.out.println(params); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } }   HttpServletRequest已经对获取请求参数的方式进行了封装：\n  获取所有参数Map集合\nMap\u0026lt;String, String[]\u0026gt; getParameterMap()   根据名称获取参数值（返回值为数组，返回多个参数）\nString[] getParameterValues(String name)   根据名称获取参数值（单个值）\nString getParameter(String name)   同样是在doPost()中调用doGet()，然后在doGet()处理参数，但是在获取参数时不用对请求方式进行判断。\nExample：\n  webapp/index.html：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; test:get \u0026lt;form action=\u0026#34;/request-demo/test\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; get-1 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt; get-2 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; test:post \u0026lt;form action=\u0026#34;/request-demo/test\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; post-1 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt; post-2 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   使用getParameterValues()和getParameter()获取请求参数：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test1\u0026#34;) public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;---------------\u0026#34;); // 验证请求的方式：  String method = req.getMethod(); System.out.println(method); // 获取多个 value：  System.out.print(\u0026#34;hobby: \u0026#34;); String[] hobbies = request.getParameterValues(\u0026#34;hobby\u0026#34;); for (String hobby : hobbies) { System.out.print(hobby + \u0026#34;, \u0026#34;); } System.out.println(\u0026#34;\\b\\b \u0026#34;); // 获取单个 value：  String username = request.getParameter(\u0026#34;username\u0026#34;); String password = request.getParameter(\u0026#34;password\u0026#34;); System.out.println(\u0026#34;username: \u0026#34; + username); System.out.println(\u0026#34;password: \u0026#34; + password); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } }   使用getParameterMap()一次性获取所有参数：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Map; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;-------------------------------------------\u0026#34;); // 验证请求的方式：  String method = request.getMethod(); System.out.println(method); // 获取所有参数的Map集合  Map\u0026lt;String, String[]\u0026gt; map = request.getParameterMap(); for (String key : map.keySet()) { System.out.print(key + \u0026#34;:\u0026#34;); // 获取key对应的所有values  String[] values = map.get(key); for (String value : values) { System.out.print(value + \u0026#34;, \u0026#34;); } System.out.println(\u0026#34;\\b\\b \u0026#34;); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } }     请求转发 请求转发（forward）是一种在服务器内部的资源跳转方式。如：\n 服务器内资源A获取请求。 资源A（处理一部分数据后）将请求转发给资源B去处理。 资源B处理完成后将将结果响应给浏览器。  请求从资源A到资源B的过程即为请求转发。\n请求转发的特点：\n 浏览器地址栏路径不变。 只能转发到当前服务器的内部资源。 一次请求，可以在转发的资源间使用request共享数据。  使用request.getRequestDispatcher(\u0026quot;/path\u0026quot;).forward(request, response)进行请求转发：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/demo1\u0026#34;) public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;demo1...\u0026#34;); // 存储数据  request.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;Hello\u0026#34;); // 请求转发（资源转发到demo2）  request.getRequestDispatcher(\u0026#34;/demo2\u0026#34;).forward(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/demo2\u0026#34;) public class RequestDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;demo2...\u0026#34;); // 获取数据  Object msg = request.getAttribute(\u0026#34;msg\u0026#34;); System.out.println(msg); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 通过http://localhost:8080/request-demo/demo1访问。\n 由于请求转发是在服务器内部的资源转发，所以getRequestDispatcher()中的路径不需要包含虚拟目录。\n 请求转发使用HttpServletRequest（Request）对象进行资源的传递。这个用来存储资源的空间被称为Request域。\nHttpServletRequest对象提供了对于Request中的域属性操作的方法有：\n  在 Request 域属性空间中放入数据：\nvoid setAttribute(String name, Object object) 其生命周期与 Request 的生命周期相同。\n  从 Request 的域属性空间中获取指定名称的数据：\nObject getAttribute(String name)   从 Request 的域属性空间中删除指定名称的数据：\nvoid removeAttribute(String name)   创建请求转发器：\nRequestDispatcher getRequestDispatcher(String path) 请求转发器中有一个方法，用于完成将请求对象转发给下一个资源：\nvoid forward(HttpServletRequest request, HttpServletResponse response)   Tomcat7 请求参数中文乱码问题  Tomcat8.0 之后，已经将默认编码设置为UTF-8。\n POST请求参数是通过流的方式获取数据：\n Tomcat在获取流的时候采用的编码是ISO-8859-1。 页面设置的编码格式一般为UTF-8。 ISO-8859-1编码是不支持中文的，所以会出现乱码。  解决方案：通过HttpServletRequest提供的setCharacterEncoding()，在Tomcat在获取流数据之前的编码设置为UTF-8。\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.net.URLDecoder; import java.nio.charset.StandardCharsets; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo4Copy extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 设置字符输入流的编码  request.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); // 2. 获取请求参数  BufferedReader br = request.getReader(); String line = br.readLine(); // getReader()获取的是编码后的URL，如果要显示中文，需要对URL按照UTF-8进行解码  String decode = URLDecoder.decode(line, StandardCharsets.UTF_8); System.out.println(\u0026#34;解决乱码后: \u0026#34; + decode); } } GET请求参数包含在URL中：\n getQueryString()获取的并不是字符输入流，所以setCharacterEncoding()并不适用。\n   浏览器在发送HTTP的过程中会根据页面\u0026lt;meta\u0026gt;标签指定的charset的方式（一般为UTF-8）对URL进行编码。 URL编码：\n 将字符串按照编码方式转为二进制。 每个字节（8位）转为2个16进制数（一个16进制数代表4位）并在前边加上%。    Tomcat在接收编码后的URL后，会默认按照ISO-8859-1进行URL解码。\n可以使用以下两个函数可以模拟URL编码、解码的过程：\n  编码：\njava.net.URLEncoder.encode(string, charset)   解码：\njava.net.URLDecoder.decode(string, charset)     解决方案：\n 把字符数据（URL编码）按照ISO-8859-1编码转换成字节。 字节按照浏览器对应的URL编码（UTF-8）转换成对应的字符。  这样在转换的过程中保持编码一致，就可以解决中文乱码问题：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.nio.charset.StandardCharsets; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo4Copy extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String qs = request.getQueryString(); // 把字符数据（URL编码）按照ISO-8859-1编码转换成字节  byte[] bytes = qs.getBytes(StandardCharsets.ISO_8859_1); // 按照UTF-8编码转换成对应的字符  String s = new String(bytes, StandardCharsets.UTF_8); // 转换后的字符是URL编码后的字符，需要再次解码  qs = URLDecoder.decode(s, StandardCharsets.UTF_8); System.out.println(\u0026#34;解决乱码后: \u0026#34; + qs); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 通用方式解决乱码问题：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.nio.charset.StandardCharsets; @WebServlet(\u0026#34;/test\u0026#34;) public class RequestDemo4Copy extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取username  String username = request.getParameter(\u0026#34;username\u0026#34;); // 2. 解决乱码  username = new String(username.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); System.out.println(\u0026#34;解决乱码后: \u0026#34; + username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } }  HttpServletResponse HTTP响应数据总共分为三部分内容，分别是：\n  响应行\n如，HTTP/1.1 200 OK，从左到右分别为：\n  HTTP协议及版本\n  响应状态码 设置响应状态码，HttpServletResponse对象提供了以下方法设置：\nvoid setStatus(int sc)   状态码描述\n    响应头\n由多个 key: value 组成。HttpServletResponse对象提供了以下方法设置键值对：\nvoid setHeader(String name, String value)   响应体\n  获取字符输出流：\nPrintWriter getWriter()   获取字节输出流：\nServletOutputStream getOutputStream()     Respones重定向 Response重定向（redirect）是一种资源跳转方式。如：\n 浏览器发送请求给服务器，服务器中对应的资源A接收到请求。 资源A现在无法处理该请求，就会给浏览器响应一个302的状态码和location（一个访问资源B的路径）。 浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B。  重定向的特点:\n  浏览器地址栏路径发送变化（由资源A的路径变化为资源B的路径）。\n进行重定向访问时，由浏览器发送两次请求，所以地址发生了变化。\n  可以重定向到任意位置的资源（服务器内部、外部均可）。\n资源由浏览器来访问，所以可以重定向到任意位置资源。\n  不能在多个资源使用Request重定向共享数据。\n重定向是由浏览器来发送新的请求，每次请求中的Request对象都是不同的。\n  重定向需要两个步骤：\n  设置302状态码：\nresponse.setStatus(302)   设置响应头中，location的值：\nresponse.setHeader(\u0026#34;location\u0026#34;, \u0026#34;/path_b\u0026#34;)   Example：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/demo1\u0026#34;) public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;demo1...\u0026#34;); // 重定向  // 1. 设置相应状态码  resp.setStatus(302); // 2. 设置相应头 Location (不区分大小写)  resp.setHeader(\u0026#34;Location\u0026#34;, \u0026#34;/request-demo/demo2\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/demo2\u0026#34;) public class ResponseDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;demo2...\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } }  由于重定向是将重定向后的资源路径告知浏览器，所以location需要添加虚拟目录（如/response-demo/demo2）。 如果是重定向到服务器外部资源，location的值为外部资源的URL。\n HttpServletResponse提供了sendRedirect()方法来简化重定向流程。修改ResponseDemo1：\npackage com.linner.web.response; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/resp1\u0026#34;) public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;resp1...\u0026#34;); // 简化方式完成重定向  // 动态获取虚拟目录  String contextPath = req.getContextPath(); resp.sendRedirect(contextPath + \u0026#34;/resp2\u0026#34;); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 响应字符数据 将字符数据写回到浏览器，需要：\n  通过HttpServletResponse对象获取字符输出流：\nPrintWriter writer = response.getWriter()   通过字符输出流写数据：\nwriter.write(\u0026#34;你好\u0026#34;)   Example：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(\u0026#34;/demo\u0026#34;) public class ResponseDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 设置content-type（响应的数据格式）和字符集（编码）  resp.setContentType(\u0026#34;text/html;charset=utf-8\u0026#34;); // content-type也可以使用setHeader()手动设置  // resp.setHeader(\u0026#34;content-type\u0026#34;, \u0026#34;text/html\u0026#34;);  // 获取字符输出流  PrintWriter writer = resp.getWriter(); writer.write(\u0026#34;你好\u0026#34;); writer.write(\u0026#34;\u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt;\u0026#34;); //  } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } }  write()不仅能写入文本数据，还能写入HTML数据。 PrintWriter 对象会在 HttpServletRequest 被销毁时一并销毁，无需手动关闭。\n 响应字节数据 将字节数据写回到浏览器，需要：\n  通过HttpServletResponse对象获取字节输出流：\nServletOutputStream os = response.getOutputStream()   通过字节输出流写数据：\nos.write(buff)   Example：\npackage com.linner.web; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.FileInputStream; import java.io.IOException; import java.io.PrintWriter; @WebServlet(\u0026#34;/demo\u0026#34;) public class ResponseDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 读取文件  FileInputStream fis = new FileInputStream(\u0026#34;src/main/webapp/imgs/bg.jpg\u0026#34;); // 2. 获取response字节输出流  ServletOutputStream os = resp.getOutputStream(); // 3. 完成流的copy  byte[] buff = new byte[1024]; int len = 0; while ((len = fis.read(buff)) != -1) { os.write(buff, 0, len); } fis.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 其中，流的copy可以使用IOUtils工具类的copy()来简化操作：\n  导入配置：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   修改ResponseDemo：\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 读取文件  FileInputStream fis = new FileInputStream(\u0026#34;src/main/webapp/imgs/reg_bg_min.jpg\u0026#34;);0 // 2. 获取response字节输出流  ServletOutputStream os = resp.getOutputStream(); // 3. 完成流的copy  IOUtils.copy(fis, os); fis.close(); }    总结 HttpServletRequest 常用方法    方法名 作用     String getMethod() 获取请求方式   String getContextPath() 获取虚拟目录（项目访问路径）   StringBuffer getRequestURL() 获取URL（统一资源定位符）   String getRequestURI() 获取URI（统一资源标识符）   String getQueryString() 获取请求参数（GET方式）   String getHeader(String name) 获取name指定key对应的请求头的value   ServletInputStream getInputStream() 获取请求体字节输入流（POST方式获取请求参数）   BufferedReader getReader() 获取请求体字符输入流\ngetReader()获取请求参数后，还需要使用readLine()读取参数数据\n即，\nBufferedReader br = request.getReader();\nString line = br.readLine();   Map\u0026lt;String, String[]\u0026gt; getParameterMap() 获取所有请求参数Map集合   String[] getParameterValues(String name) 根据名称获取请求参数值\n返回值为数组\n返回多个参数   String getParameter(String name) 根据名称获取请求参数值\n返回单个参数值   void setAttribute(String name, Object object) 在 Request 域属性空间中放入数据   Object getAttribute(String name) 从 Request 的域属性空间中获取指定名称的数据   void removeAttribute(String name) 从 Request 的域属性空间中删除指定名称的数据   RequestDispatcher getRequestDispatcher(String path) 创建请求转发器\n请求转发器中有一个方法，用于完成将请求对象转发给下一个资源：\nvoid forward(HttpServletRequest request, HttpServletResponse response)   void setCharacterEncoding(String charset) 设置请求体字符输入流的编码    HttpServletResponse 常用方法    方法名 作用     void setStatus(int sc) 设置响应状态码   void setHeader(String name, String value) 设置响应头键值对   PrintWriter getWriter() 获取响应体字符输出流获取字符输出流后还需要使用write()方法来写入字符数据：\nPrintWriter writer = response.getWriter();\nwriter.write(\u0026quot;Hello World!\u0026quot;);   ServletOutputStream getOutputStream() 获取响应体字节输出流\n获取字节输出流前需要先使用FileInputStream对象来读取文件\n然后使用IOUtils工具类的copy()来copy流\n获取字节输出流后还需要使用write()方法来写入字符数据\n响应字节数据   void sendRedirect(String path) Respones重定向    ","date":"2022-09-12T00:00:00Z","permalink":"https://blog.linner.asia/p/httpservlet-%E4%B8%8E-tomcat/","title":"HttpServlet 与 Tomcat"},{"content":"Servlet 简介 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n Servlet 基本使用   创建Maven Web项目后，导入Servlet依赖坐标和Tomcat插件：\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- Servlet依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- Tomcat插件 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  使用\u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;的原因： provided指的是在编译和测试过程中有效，最后生成的war包时不会加入。 因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错。\n   创建Servlet类，实现Servlet接口，并重写接口中所有方法：\npackage com.linner.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; @WebServlet(\u0026#34;/demo\u0026#34;) public class ServletDemo implements Servlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\u0026#34;Hello Servlet!\u0026#34;); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } }  使用@WebServlet注解配置该Servlet的访问路径：@WebServlet(\u0026quot;/demo\u0026quot;)    启动Tomcat，根据自己项目和Tomcat的配置访问，如：http://localhost:8080/web-demo/demo\n访问成功后可以看到在控制台输出service()方法中的内容。\n   Servlet 执行流程 运行Tomcat时并没有显式创建Servlet对象，也没有显式调用其中的方法。可控制台依然输出了ServletDemo.service()中的内容。\n访问该Tomcat项目时，浏览器发出http://localhost:8080/web-demo/demo请求，从请求中可以解析出三部分内容：\n 根据localhost:8080可以找到要访问的Tomcat Web服务器 根据web-demo可以找到部署在Tomcat服务器上的web-demo项目 根据demo可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配  找到ServletDemo这个类后，Tomcat Web服务器就会为ServletDemo这个类创建一个对象，然后调用对象中的service()方法。\n而Tomcat则是根据@WebServlet注解或web.xml配置文件等信息来创建对应的Servlet对象。\n Servlet 生命周期 生命周期是指对象的生命周期指一个对象从被创建到被销毁的整个过程。\nServlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段：\n  加载和实例化：默认情况下，Servlet会在第一次访问时被容器创建\n  初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作\ninit()方法仅会被调用一次\n  请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理\n  服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放\n在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收\n  可以把Servlet的创建放到服务器启动的时候来创建（修改@WebServlet注解）：\n@WebServlet(urlPatterns = \u0026#34;/demo1\u0026#34;, loadOnStartup = 1) loadOnstartup的取值有两类情况：\n 负整数：第一次访问时创建Servlet对象 非负整数：服务器启动时创建Servlet对象，数字越小优先级越高（0的优先级最高）  Example：\npackage com.linner.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; @WebServlet(urlPatterns = \u0026#34;/demo\u0026#34;, loadOnStartup = 1) public class ServletDemo implements Servlet { /** * 初始化方法 * - 在Servlet被第一次访问或者服务器启动时被调用一次 */ public void init(ServletConfig config) throws ServletException { System.out.println(\u0026#34;init...\u0026#34;); } /** * 提供服务 * - 每一次Servlet被访问时被调用 * - 可被调用多次 */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println(\u0026#34;Hello Servlet!\u0026#34;); } /** * 销毁方法 * - 调用时机：内存释放或者服务器关闭的时候被调用一次 */ public void destroy() { System.out.println(\u0026#34;destroy...\u0026#34;); } public ServletConfig getServletConfig() { return null; } public String getServletInfo() { return null; } }  注意：若要在关闭Tomcat时调用destroy()，需要在正常关闭Tomcat的情况下，destroy()才能被执行。\n  Servlet 方法 剩下两个Servlet方法的作用是：\n  获取Servlet信息：\npublic String getServletInfo() { return \u0026#34;\u0026#34;; }   获取ServletConfig对象：\npublic String getServletInfo() { return \u0026#34;\u0026#34;; } ServletConfig对象，Tomcat Web服务器在创建Servlet对象的时候会通过init()方法将其作为参数传入：\nvoid init(ServletConfig config) throws ServletException 在getServletInfo()中仅需将服务器传过来的ServletConfig进行返回即可：\nprivate ServletConfig servletConfig; public void init(ServletConfig config) throws ServletException { // 获取服务器传入的ServletConfig  this.servletConfig = config; System.out.println(\u0026#34;init...\u0026#34;); } public ServletConfig getServletConfig() { // 将服务器传入的ServletConfig返回  return servletConfig; }    urlPattern 配置 urlPatterns 多路径访问 一个Servlet，可以配置多个访问路径（urlPattern）：\n@WebServlet(urlPatterns = {\u0026#34;/path1\u0026#34;, \u0026#34;/path2\u0026#34;, ....}) 精确匹配   配置路径：\n@WebServlet(\u0026#34;/path/servlet\u0026#34;)   访问路径：http://localhost:8080/web-demo/path/servlet\n  目录匹配   配置路径：\n@WebServlet(\u0026#34;/path/*\u0026#34;)   访问路径：\n http://localhost:8080/web-demo/path/abc http://localhost:8080/web-demo/path/def http://localhost:8080/web-demo/path/ http://localhost:8080/web-demo/path/anypath \u0026hellip;     精确匹配优先级要高于目录匹配\n 扩展名匹配   配置路径：\n@WebServlet(\u0026#34;*.html\u0026#34;)   访问路径：\n http://localhost:8080/web-demo/index.html http://localhost:8080/web-demo/login.html http://localhost:8080/web-demo/any_name.html \u0026hellip;     注意：\n 如果路径配置的不是扩展名，那么在路径的前面就必须要加/否则会报错 如果路径配置的是*.html，那么在*.html的前面不能加/，否则会报错   任意匹配   配置路径：\n@WebServlet(\u0026#34;/\u0026#34;) 或\n@WebServlet(\u0026#34;/*\u0026#34;)   访问路径：\n任何以 http://localhost:8080/web-demo/ 开头的路径\n   /和/*的区别：\n 当项目中的Servlet配置了@WebServlet(\u0026quot;/\u0026quot;)，会覆盖掉Tomcat中的DefaultServlet，当其他的urlPattern都匹配不上时都会走这个Servlet。 当项目中配置了@WebServlet(\u0026quot;/\u0026quot;)，意味着匹配任意访问路径。 DefaultServlet是用来处理静态资源，如果使用@WebServlet(\u0026quot;/\u0026quot;)将其覆盖掉。当请求静态资源的时候则是使用了自定义的Servlet类，最终会导致静态资源不能被访问。    XML配置Servlet（不推荐） Servlet从3.0版本后才开始支持注解配置，而3.0版本前只支持XML配置文件的配置方法。\n  编写Servlet类：\npackage com.linner.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; public class ServletDemo implements Servlet { // ... }   在web.xml中配置该Servlet：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!-- Servlet 全类名 --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;!-- Servlet的名称，名字任意 --\u0026gt; \u0026lt;servlet-name\u0026gt;demo\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- Servlet的类全名 --\u0026gt; \u0026lt;servlet-class\u0026gt;com.linner.web.ServletDemo\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!-- Servlet 访问路径 --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!-- Servlet的名称，要和上面的名称一致 --\u0026gt; \u0026lt;servlet-name\u0026gt;demo\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- Servlet的访问路径 --\u0026gt; \u0026lt;url-pattern\u0026gt;/demo\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;    ServletRequest 和 ServletResponse 在 Servlet.service() 中有这样两个参数，它们的类型是 ServletRequest 和 ServletResponse。这两个参数就是Servlet的 Request 和 Response 对象。\nRequest是请求对象，作用是将客户端的请求数据从客户端发送到服务端；Response是响应对象，作用是将服务端的响应数据从服务端发送到客户端。\n","date":"2022-09-12T00:00:00Z","permalink":"https://blog.linner.asia/p/servlet-%E4%B8%8E-tomcat/","title":"Servlet 与 Tomcat"},{"content":"Tomcat基本使用 Tomcat安装 访问Tomcat官网下载。Tomcat是绿色版，直接解压即可。\n启动Tomcat 以Windows系统为例，运行Tomcat目录下 bin\\startup.bat 启动脚本即可完成启动。\n启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。\nWindows系统下启动的过程中，如果控制台有中文乱码，需要修改conf/logging.prooperties。\n将\njava.util.logging.ConsoleHandler.encoding = UTF-8 修改为\njava.util.logging.ConsoleHandler.encoding = GBK 关闭Tomcat 关闭Tomcat不应该直接关闭运行窗口来强制关闭。应该运行bin\\shutdown.bat或ctrl+c来正常关闭。\n修改端口 Tomcat默认的端口是8080，通过修改 conf/server.xml 来修改端口号：\n\u0026lt;Connector port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; redirectPort=\u0026#34;8443\u0026#34;\u0026gt; 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。\n一般JavaWeb项目会被打包称war包，然后将war包放到webapps目录下，Tomcat会自动解压缩。\n Maven 创建 Web 项目 使用Maven工具能更加简单快捷的创建Web项目。\nMaven Web 项目结构  📁project_name \u0026mdash; 项目主目录  📁src \u0026mdash; 源代码和测试代码文件目录  📁main \u0026mdash; 源代码文件目录  📁java \u0026mdash; 源代码Java文件目录 📁resourcs \u0026mdash; 源代码配置文件目录 ❗📁webapp 或 web \u0026mdash; Web项目核心目录 存放web配置文件和web项目代码 (html, css, javascript等)  ❗📁WEB-INF \u0026mdash; Web项目核心目录  📄web.xml \u0026mdash; Web项目配置文件   其它目录或文件，如 index.html、html、css、js等     📁test \u0026mdash; 测试代码文件目录  📁java \u0026mdash; 测试代码Java文件目录 📁resource \u0026mdash; 测试代码配置   📄pom.xml \u0026mdash; 项目核心配置文件      开发完成部署的 Maven Web 项目结构：\n 📁project_name \u0026mdash; 项目访问路径（虚拟目录）  ❗📁WEB-INF \u0026mdash; Web项目核心目录  📁classes \u0026mdash; Java字节码文件 编译后的Java字节码文件和resources的资源文件，会被放到该目录下 包括pom.xml中依赖坐标对应的jar包 📁lib \u0026mdash; 项目所需jar包 📄web.xml \u0026mdash; Web项目配置文件 其它目录或文件，如 index.html、html、css、js等      创建 Maven Web 项目 创建方式有两种：使用骨架和不使用骨架\n使用骨架大致步骤如下：\n 创建Maven项目 选择使用Web项目骨架   输入Maven项目坐标创建项目\n  确认Maven相关的配置信息后，完成项目创建\n  删除pom.xml中多余内容   补齐Maven Web项目缺失的目录结构\n最终目录结构如下：\n 📁project_name  📁src  📁main  📁java 📁resourcs 📁webapp  📁WEB-INF  📄web.xml       📄pom.xml        不使用骨架大致步骤如下：\n 创建Maven项目 选择不使用Web项目骨架  按照正常的方式创建，不勾选Create from archetype\n 输入Maven项目坐标创建项目\n  在pom.xml设置打包方式为war\n\u0026lt;project\u0026gt; \u0026lt;!-- ...... --\u0026gt; \u0026lt;groupId\u0026gt;......\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;.......\u0026lt;/artifactId\u0026gt; \u0026lt;vesion\u0026gt;.......\u0026lt;/vesion\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;!-- ...... --\u0026gt; \u0026lt;/project\u0026gt;   补齐Maven Web项目缺失webapp的目录结构\n  文件\u0026ndash;\u0026gt;项目结构\u0026ndash;\u0026gt;Facet中按+然后选择Web，选择当前项目\n修改webapp目录，并补齐Maven Web项目缺失WEB-INF/web.xml的目录结构，即可完成构建\n 在IDEA中使用Tomcat 在IDEA中集成使用Tomcat有两种方式，分别是集成本地Tomcat和Tomcat Maven插件。\n集成本地Tomcat  右上角 编辑运行/调试配置 对话框\u0026ndash;\u0026gt;编辑配置\u0026ndash;\u0026gt;+\u0026ndash;\u0026gt;Tomcat服务器\u0026ndash;\u0026gt;本地  指定本地Tomcat的具体路径  将开发项目部署项目到Tomcat中   xxx.war 和 xxx.war exploded 这两种部署项目模式的区别：\n war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上 war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上  war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容\nwar exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署\n建议选war模式进行部署，更符合项目部署的实际情况\n Tomcat Maven插件   在pom.xml中添加Tomcat插件：\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--Tomcat插件 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   使用Maven Helper插件快速启动项目，选中项目，右键 \u0026ndash;\u0026gt;Run Maven \u0026ndash;\u0026gt; tomcat7:run\n   安装Maven Helper插件：File \u0026ndash;\u0026gt; Settings \u0026ndash;\u0026gt; Plugins \u0026ndash;\u0026gt; Maven Helper \u0026mdash;\u0026gt; Install，重启IDEA\n ","date":"2022-09-10T00:00:00Z","permalink":"https://blog.linner.asia/p/tomcat/","title":"Tomcat"},{"content":"MyBatis 介绍 MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。\n 持久层：\n  是负责将数据到保存到数据库的那一层代码。即，操作数据库的Java代码为持久层。\n而Mybatis就是对JDBC代码进行了封装。\n  持久层是JavaEE三层架构中的一层。\nJavaEE三层架构：表现层、业务层、持久层。\n  框架：\n 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。 使用框架的好处：在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。   使用JDBC存在以下问题:\n  硬编码\n手动注册驱动、获取连接、SQL语句等。\n  操作繁琐\n手动设置参数、封装结果集等。\n  使用Mybatis：\n 硬编码可以配置到配置文件。 操作繁琐的地方Mybatis都自动完成。   配置 Mybatis 使用Maven导入Mybatis。\n  在 pom.xml 配置文件中导入坐标：\n\u0026lt;dependencies\u0026gt; \u0026lt;!--mybatis 依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql 驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.46\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写 mybatis-config.xml 文件：\n在模块下的 resources 目录下创建Mybatis的配置文件 mybatis-config.xml：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 需要注意配置标签的前后顺序(按照MyBatis官方文档目录中的顺序去定义) --\u0026gt; \u0026lt;!-- 别名或包扫描 --\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!-- name属性的值是实体类所在包 --\u0026gt; \u0026lt;!-- 包扫描后,别名默认为类名(不区分大小写) --\u0026gt; \u0026lt;!-- 使用别名可以简化映射配置文件中 resultType 属性值的编写 --\u0026gt; \u0026lt;package name=\u0026#34;package.name.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;!-- environments:配置数据库的连接环境信息, 可以配置多个environment信息, 通过对应的default属性切换不同的environment --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 可以配置多个\u0026lt;environment\u0026gt; --\u0026gt; \u0026lt;!-- 使用 id 给每段环境起名 --\u0026gt; \u0026lt;!-- 在 \u0026lt;environments\u0026gt; 中使用 default=\u0026#39;environment-id\u0026#39; 来指定使用哪儿段配置 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;!-- 数据库连接信息 注意url、username和password --\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql:///mybatis1?useSSL=false\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;1234\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;environment id=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;!-- 数据库连接信息 --\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql:///mybatis2?useSSL=false\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;1234\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!-- 加载映射文件 --\u0026gt; \u0026lt;!-- ...... --\u0026gt; \u0026lt;!-- 在下节中讲解 --\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;    更多MyBatis配置请查看官方文档：MyBatis文档——配置\n  使用 Mybatis   编写 Mapper类\n在 java 目录下创建与 pojo 对应的 Mapper接口 ClassNameMapper.java：\npublic interface ClassNameMapper { // 方法 }   编写 SQL 映射文件\n在模块的 resources 目录下创建与 pojo 对应的映射配置文件 ClassNameMapper.xml：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace:名称空间 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;package.name.mapper\u0026#34;\u0026gt; \u0026lt;!-- 相应的SQL语句（XML映射） --\u0026gt; \u0026lt;/mapper\u0026gt;   在Myb atis的配置文件 mybatis-config.xml 中加载映射文件：\n 直接加载映射文件：  \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/abc/mapper/ClassNameMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 使用这种方式加载映射文件，多个映射文件需要定义多个 \u0026lt;mapper\u0026gt;，过于繁琐。\nMapper代理方式（推荐）：  如果 Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。\n\u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;com.abc.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;    注意：使用Mapper代理方式加载映射文件，Mapper接口与其对应的配置文件，它们的路径（包名）要相同。\n即，在java目录下的 Mapper接口的包名，要和映射配置文件在 resources下的路径要一致。\n如 Mapper接口的包名为 com.abc.mapper，那么其映射配置文件的路径则为 com/abc/mapper。\n了解 Maven项目结构，请查看：Maven标准化项目结构\n 实例 在 Mapper 接口中定义方法，方法名就是SQL映射文件中SQL语句的id，并保持参数类型和返回值类型一致。\n例如，为 User对象定义 selectAll()和 selectById()方法：\n  创建 User表:\nCREATE DATABASE mybatis; USE mybatis; DROP table IF EXISTS tb_user; CREATE table tb_user ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20), password VARCHAR(20), gender CHAR(1), addr VARCHAR(30) ); INSERT INTO tb_user VALUES (NULL, \u0026#39;zhangsan\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;北京\u0026#39;); INSERT INTO tb_user VALUES (NULL, \u0026#39;李四\u0026#39;, \u0026#39;234\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;天津\u0026#39;); INSERT INTO tb_user VALUES (NULL, \u0026#39;王五\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;西安\u0026#39;);   pojo包下定义 User实体类:\npackage com.linner.pojo; public class User { private Integer id; private String username; private String password; private String gender; private String addr; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public String getAddr() { return addr; } public void setAddr(String addr) { this.addr = addr; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, username=\u0026#39;\u0026#34; + username + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, gender=\u0026#39;\u0026#34; + gender + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, addr=\u0026#39;\u0026#34; + addr + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   mapper包下定义 UserMapper:\npackage com.linner.pojo; import com.linner.pojo.User; import org.apache.ibatis.annotations.Select; import java.util.List; public interface UserMapper { List\u0026lt;User\u0026gt; selectAll(); User selectById(int id); // 更多操作接口 }   在 resources目录下创建与 UserMapper包名对应的路径，并添加 UserMapper.xml映射配置文件:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.linner.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;!-- select语句使用\u0026lt;select\u0026gt; id 为对应Mapper类中的方法名 resultType 为对应的实体类, 使用了\u0026lt;typeAliases\u0026gt;包扫描, 省略了包名 --\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT * FROM tb_user; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;selectById\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT * FROM tb_user WHERE id = #{id}; \u0026lt;/select\u0026gt; \u0026lt;!-- 更多XML映射 --\u0026gt; \u0026lt;/mapper\u0026gt;   resources目录下，配置 mybatis-config.xml文件:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 别名或包扫描 --\u0026gt; \u0026lt;!-- 使用别名可以简化映射配置文件中 resultType 属性值的编写 --\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.linner.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;!-- 数据库连接信息 --\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql:///mybatis?useSSL=false\u0026amp;useServerPerpStmts=true\u0026amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;1234\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!-- Mapper代理方式--\u0026gt; \u0026lt;package name=\u0026#34;com.linner.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   编写测试类:\npackage com.linner.test; import com.linner.mapper.UserMapper; import com.linner.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.InputStream; import java.util.List; public class UserMapperTest { @Test public void testSelectAll() throws IOException { // 1. 加载mybatis的核心配置文件,获取SqlSessionFactory  String resource = \u0026#34;./mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2. 获取SqlSession对象,用它来执行SQL  SqlSession sqlSession = sqlSessionFactory.openSession(); // 3. 执行sql语句  // 3.1 方式一:  // List\u0026lt;User\u0026gt; users = sqlSession.selectList(\u0026#34;com.linner.mapper.UserMapper.selectAll\u0026#34;);  // 3.2 方式二:  // 3.2.1 获取UserMapper接口的代理对象  UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 3.2.2 执行对应Mapper对象的方法  List\u0026lt;User\u0026gt; users = userMapper.selectAll(); // 4. 处理数据(模拟)  System.out.println(users); // 5. 释放资源(仅需释放SqlSession对象)  sqlSession.close(); } @Test public void testSelectById() throws IOException { // 模拟接收参数  int id = 1; // 1. 获取sqlSessionFactory  String resource = \u0026#34;./mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2. 获取SqlSession对象  SqlSession sqlSession = sqlSessionFactory.openSession(); // 3. 获取Mapper接口的代理对象  UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 4. 执行方法  User user = userMapper.selectById(id); // 5. 处理数据(模拟)  System.out.println(user); // 6. 释放资源  sqlSession.close(); } }    XML 映射器 通过在 XxxMapper.xml 中使用元素来定义各种CRUD操作。\n常用的元素如下（按照定义的顺序给出）：\n \u0026lt;sql\u0026gt; – 可被其它语句引用的可重用语句块。 \u0026lt;insert\u0026gt; – 映射插入语句。 \u0026lt;update\u0026gt; – 映射更新语句。 \u0026lt;delete\u0026gt; – 映射删除语句。 \u0026lt;select\u0026gt; – 映射查询语句。  Select 查询所有数据 xml 配置文件：\n\u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT * FROM tb_user \u0026lt;/select\u0026gt; Mapper 接口方法：\nList\u0026lt;User\u0026gt; selectAll();  id：相应 Mapper 接口中的方法名。 resultType：相应 Mapper 接口中的返回值类型（可自动封装为对象，不区分大小写）。 Mapper 接口返回值：返回一个List\u0026lt;User\u0026gt;。这个返回值可以是User、List\u0026lt;User\u0026gt;或ArrayList\u0026lt;User\u0026gt;等，MyBatis会根据返回值自动封装。  根据id字段查询 xml 配置文件：\n\u0026lt;select id=\u0026#34;selectById\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT * FROM tb_user WHERE id = #{id}; \u0026lt;/select\u0026gt; Mapper 接口方法：\nUser selectById(int id); \u0026lt;select\u0026gt;中，#{id}为相应 Mapper 接口中的参数 id。#{id}被称为参数占位符，相当于JDBC中的?占位符。\n多条件动态查询 xml 配置文件：\n\u0026lt;select id=\u0026#34;selectByCondition\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT * FROM tb_user \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;username != null and username != \u0026#39;\u0026#39; \u0026#34;\u0026gt; username = #{username} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;password != null and password != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND password = #{password} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null and gender != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;addr != null and addr != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND addr = #{addr} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 多条件查询使用了动态SQL\u0026lt;where\u0026gt;和\u0026lt;if\u0026gt;。如果仅需查询某部分字段，仅仅使用SQL语句在实现上有难度。而Mybatis就提供了动态SQL方便了我们的实现。\n  \u0026lt;if\u0026gt;：能根据User对象的值来决定是否在SQL语句中加入其包含的语句。\n  \u0026lt;where\u0026gt;：只会在子元素返回任何内容的情况下才插入WHERE子句。\n而且，若子句的开头为AND或OR，\u0026lt;where\u0026gt;元素也会将它们去除。\n  单条件动态查询 xml 配置文件：\n\u0026lt;select id=\u0026#34;selectByConditionSingle\u0026#34; resultMap=\u0026#34;brandResultMap\u0026#34;\u0026gt; SELECT * FROM tb_brand \u0026lt;where\u0026gt;\u0026lt;!--使用where标签确保不会出错--\u0026gt; \u0026lt;choose\u0026gt;\u0026lt;!--相当于switch--\u0026gt; \u0026lt;when test=\u0026#34;status != null\u0026#34;\u0026gt;\u0026lt;!--相当于case--\u0026gt; status = #{status} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;companyName != null and companyName != \u0026#39;\u0026#39; \u0026#34;\u0026gt;\u0026lt;!--相当于case--\u0026gt; company_name like #{companyName} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;brandName != null and brandName != \u0026#39;\u0026#39; \u0026#34;\u0026gt;\u0026lt;!--相当于case--\u0026gt; brand_name like #{brandName} \u0026lt;/when\u0026gt; \u0026lt;!--没有条件输入很可能会报错,使用\u0026lt;otherwise\u0026gt;保底--\u0026gt; \u0026lt;!--如果没有使用\u0026lt;where\u0026gt;，则必须使用\u0026lt;otherwise\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;otherwise\u0026gt; 1 = 1 \u0026lt;/otherwise\u0026gt;--\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 单条件动态查询使用了\u0026lt;where\u0026gt;、\u0026lt;choose\u0026gt;、\u0026lt;when\u0026gt;和\u0026lt;otherwise\u0026gt;，它们都是MyBatis提供的动态SQL元素。\n\u0026lt;choose\u0026gt;与\u0026lt;when\u0026gt;（必须）和\u0026lt;otherwise\u0026gt;元素配合使用。它会根据子元素\u0026lt;when\u0026gt;的test属性来判断要选择哪个\u0026lt;when\u0026gt;或\u0026lt;otherwise\u0026gt;元素。\n如果\u0026lt;choose\u0026gt;外没有被\u0026lt;where\u0026gt;包裹则必须使用\u0026lt;otherwise\u0026gt;来包裹一个永真的条件SQL语句，以确保SQL语句不会出错。如果被\u0026lt;where\u0026gt;包裹了，\u0026lt;where\u0026gt;会根据需要判断是否要添加WHERE子句。\n\u0026lt;choose\u0026gt;、\u0026lt;when\u0026gt;和\u0026lt;otherwise\u0026gt;与switch语句的作用十分相似。\nInsert xml 配置文件：\n\u0026lt;insert id=\u0026#34;add\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO tb_user (username, password, ordered, gender, addr) VALUES (#{username}, #{password}, #{ordered}, #{gender}, #{addr}); \u0026lt;/insert\u0026gt; Mapper 接口方法：\nboolean add(User user); 接口方法直接传入对象即可，对象成员要与 VALUES 子句中的参数一一对应（参数符号中的名称要与对象的成员名称相同）。\n 如果XML映射中只有一个参数，那么这个参数的名称不必与接口的参数名称相同。\n   id：含义与 \u0026lt;insert\u0026gt; 的含义相同，为相应 Mapper 接口中的方法名（以下 id均为此含义，省略）。\n  useGeneratedKeys：\n 值为 true 时，Mybatis 会使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（如自增的主键）。 默认为 false。    keyProperty：getGeneratedKeys 获取到的主键值所要赋予的对象成员名。MyBatis 会使用 getGeneratedKeys 的返回值来设置它的值。\n如，keyProperty=\u0026quot;id\u0026quot;——直接将获取到的主键值赋值给 user.id。\n如果生成列不止一个，可以用逗号分隔多个属性名称。\n  Mapper 接口返回值：boolean，插入成功返回 true，插入失败返回 false。\n返回值也可以选择忽略，将add()接口的返回值设置为void即可。\n  Update xml 配置文件：\n\u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; UPDATE tb_user \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null and username != \u0026#39;\u0026#39; \u0026#34;\u0026gt; username = #{username}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;password != null and password != \u0026#39;\u0026#39; \u0026#34;\u0026gt; password = #{password}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;ordered != null\u0026#34;\u0026gt; ordered = #{ordered}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null and (gender == \u0026#39;男\u0026#39; or gender == \u0026#39;女\u0026#39;)\u0026#34;\u0026gt; gender = #{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;addr != null and addr != \u0026#39;\u0026#39;\u0026#34;\u0026gt; addr = #{addr} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; WHERE id = #{id}; \u0026lt;/update\u0026gt; Mapper 接口方法：\nint update(User user); 在 \u0026lt;update\u0026gt; 中有一些用 \u0026lt;set\u0026gt; 包裹起来的 \u0026lt;if\u0026gt;。这是因为需要使用 \u0026lt;set\u0026gt; 动态包含需要更新的列，忽略其它不更新的列。从而能根据User对象的值来决定要更新哪些数据，并且动态地改变SQL语句。\nUpdate的Mapper接口返回值是int类型，返回更新的行数。同样可以将接口的返回值设置为void来忽略它。\nDelete 删除单行数据 xml 配置文件：\n\u0026lt;delete id=\u0026#34;deleteById\u0026#34;\u0026gt; DELETE FROM tb_user WHERE id = #{id}; \u0026lt;/delete\u0026gt; Mapper 接口方法：\nint deleteById(int id); 删除多行数据 xml 配置文件：\n\u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; DELETE FROM tb_brand WHERE id IN \u0026lt;!-- \u0026lt;foreach\u0026gt;参数: - item: 代表数组参数中的每个元素 - separator: 分隔符 - open: 插入开始符 - close: 插入结束符 --\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; Mapper 接口方法：\nint deleteByIds(@Param(\u0026#34;ids\u0026#34;) int[] ids); Mybatis提供了 \u0026lt;foreach\u0026gt; 标签遍历数组，拼接SQL语句。\u0026lt;foreach\u0026gt; 同样也是动态SQL。\n 更多XML映射器请查看官方文档：MyBatis文档——XML映射器\n 结果映射 resultMap 假设SQL表中的字段与实体类的成员变量名无法一一对应，会导致SQL语句的传参出现问题。例如：\nCREATE table tb_user ( user_id INT PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR(20), user_password VARCHAR(20), user_gender CHAR(1), user_addr VARCHAR(30) ); public class User { private Integer id; private String username; private String password; private String gender; private String addr; // setter 和 getter  // ... } 那么可以使用\u0026lt;resultMap\u0026gt;元素来对表字段和成员名做一个映射（结果映射）：\n\u0026lt;!-- \u0026lt;resultMap\u0026gt;: - id: 唯一标识 - type: 映射的类型,支持别名 --\u0026gt; \u0026lt;resultMap id=\u0026#34;userResultMap\u0026#34; type=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;!-- 两种标签: - \u0026lt;id\u0026gt;: 完成主键字段的映射 - column: 表的列名 - property: 实体类的属性名 - \u0026lt;result\u0026gt;: 完成一般字段的映射 - column: 表的列名 - property: 实体类的属性名 --\u0026gt; \u0026lt;id column=\u0026#34;user_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;user_name\u0026#34; property=\u0026#34;userame\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;user_password\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;user_gender\u0026#34; property=\u0026#34;gender\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;user_addr\u0026#34; property=\u0026#34;addr\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultMap=\u0026#34;userResultMap\u0026#34;\u0026gt; SELECT * FROM tb_user \u0026lt;/select\u0026gt;  要使用结果映射，需要把\u0026lt;select\u0026gt;中的resultType属性替换为resultMap，并且其属性值为\u0026lt;resultMap\u0026gt;的id值。\n 自动映射 当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。\n接上节例子，使用SQL语句的 AS 来实现：\n\u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT user_id AS \u0026#34;id\u0026#34;, user_name AS \u0026#34;username\u0026#34;, user_password AS \u0026#34;password\u0026#34;, user_gender AS gender, user_addr AS \u0026#34;addr\u0026#34; FROM tb_user \u0026lt;/select\u0026gt;    通常数据库列使用大写字母组成的单词命名，单词间用下划线分隔；而 Java 属性一般遵循驼峰命名法约定。为了在这两种命名方式之间启用自动映射，需要将 mapUnderscoreToCamelCase 设置为 true。\n\u0026lt;!-- 配置mybatis自动转换为驼峰式命名 --\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   \u0026lt;resultMap\u0026gt;和自动映射可以混用。\n   参数 MyBatis有两种参数：\n #{p} —— 会自动转义。 ${p} —— 不会自动转义。   官方文档：MyBatis——XML映射器参数\n MyBatis 参数封装:\n  单个参数:\n  POJO类型: 直接使用,保证 属性名 和 参数占位符名称 一致\n  Map类型: 直接使用,保证 键名 和 参数占位符名称 一致\n  Collection: 封装为Map集合\n相当于：\nmap.put(\u0026#34;arg0\u0026#34;, collection集合) map.put(\u0026#34;collection\u0026#34;, collection集合)  使用@Param注解，替换Map集合中默认的arg键名    List: 封装为Map集合\n相当于：\nmap.put(\u0026#34;arg0\u0026#34;, list集合) map.put(\u0026#34;collection\u0026#34;, list集合) map.put(\u0026#34;list\u0026#34;, list集合)  使用@Param注解,替换Map集合中默认的arg键名    Array: 封装为Map集合\n相当于：\nmap.put(\u0026#34;arg0\u0026#34;, 数组) map.put(\u0026#34;array\u0026#34;, 数组)  使用@Param注解,替换Map集合中默认的arg键名    其他类型: 直接使用,且占位符名称和参数名称可以不相同\n    多个参数: 封装为Map集合\n  每个参数有两个键:\n相当于：\nmap.put(\u0026#34;arg0\u0026#34;, 参数值1) map.put(\u0026#34;param1\u0026#34;, 参数值1) map.put(\u0026#34;arg1\u0026#34;, 参数值2) map.put(\u0026#34;param2\u0026#34;, 参数值2)   使用@Param注解,替换Map集合中默认的arg键名:\n相当于：\n@Param(\u0026#34;username\u0026#34;) 参数类型 参数名 map.put(\u0026#34;username\u0026#34;, 参数值1) map.put(\u0026#34;param1\u0026#34;, 参数值1)     示例：\npublic interface UserMapper { User selectById(int id); List\u0026lt;User\u0026gt; selectByCondition( @Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); } 注解实现CRUD 对于简单的SQL语句来说，使用注解开发会比配置文件开发更加方便。\n@Select(value = \u0026#34;SELECT * FROM tb_user WHERE id = #{id}\u0026#34;) User selectById(int id);  注意：注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 statement。\n Mybatis 针对 CURD 操作都提供了对应的注解：\n 查询 ：@Select 添加 ：@Insert 修改 ：@Update 删除 ：@Delete  注解适合用于完成简单功能，而使用配置文件来完成复杂功能。如果使用注解来完成动态SQL之类的复杂功能，就需要使用到MyBatis提供的SQL构建器来完成。详情请阅读官方SQL构建器文档：MyBatis文档——SQL语句构建器。\n 动态SQL 动态 SQL 是 MyBatis 的强大特性之一。\nMyBatis提供的动态SQL元素有：\n \u0026lt;if\u0026gt; \u0026lt;choose\u0026gt; (\u0026lt;when\u0026gt;, \u0026lt;otherwise\u0026gt;) \u0026lt;trim\u0026gt; (\u0026lt;where\u0026gt;, \u0026lt;set\u0026gt;) \u0026lt;foreach\u0026gt;   更多与动态SQL请查看官方文档：MyBatis文档——动态SQL\n  SqlSessionFactory工具类抽取 MyBatis重复代码会造成一些问题:\n 不利于后期的维护。 SqlSessionFactory工厂类进行重复创建。  对于Mybatis的基础操作出现的重复代码，可以使用一个静态代码块来自动加载：\npublic class SqlSessionFactoryUtils { private static SqlSessionFactory sqlSessionFactory; static { // 静态代码块会随着类的加载而自动执行，且只执行一次  try { String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } public static SqlSessionFactory getSqlSessionFactory(){ return sqlSessionFactory; } } 工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用：\nSqlSessionFactory sf = SqlSessionFactoryUtils.getSqlSessionFactory(); ","date":"2022-09-06T00:00:00Z","permalink":"https://blog.linner.asia/p/mybatis/","title":"MyBatis"},{"content":"集合的概念   A set is a group of objects. (simplest way) By a set we mean any collection M into a whole of definite disinct objects m (which we called elements of M) of our perception or thought. (Cantor\u0026rsquo;s way)   集合（set）是由 \u0026lt;u\u0026gt;指定范围 \u0026lt;/u\u0026gt;内的 \u0026lt;u\u0026gt;满足给定条件的所有对象 \u0026lt;/u\u0026gt;聚集在一起构成的，指定范围内的每一个对象称为这个集合的元素（element）。\n 集合中的元素是无序的。 集合中的元素是不同的（即，同个集合中相同或重复的元素被认为是一个元素）。  通常情况下，\n 用带（或不带）下标的 \u0026lt;u\u0026gt;大写 \u0026lt;/u\u0026gt;英文字母表示 \u0026lt;u\u0026gt;集合 \u0026lt;/u\u0026gt;：$A,B,C,\\dots,A_1,B_1,C_1,\\dots$ 用带（或不带）下标的 \u0026lt;u\u0026gt;小写 \u0026lt;/u\u0026gt;英文字母表示 \u0026lt;u\u0026gt;元素 \u0026lt;/u\u0026gt;：$a,b,c,\\dots,a_1,b_1,c_1,\\dots$  ZFC 公理化集合论：\n 外延公理， 空集存在公理， 无序对公理， 并集公理， 幂集公理， 无穷公理， 替换公理， 正则公理， 选择公理。   常见的集合  空集 $\\emptyset$； 正整数集 $\\mathbf{N^+}$ or $\\mathbf{W}$：$1,2,3,\\cdots$ 自然数集 $\\mathbf{N}$：$0,1,2,3,\\cdots$ 整数集 $\\mathbf{Z}$：$\\cdots,-2,-1,0,1,2,\\cdots$ 质数/素数集 $\\mathbf{P}$：$2,3,5,7,\\cdots$ 有理数集 $\\mathbf{Q}$； 无理数集 $\\mathbf{I}$； 实数集 $\\mathbf{R}$； 复数集 $\\mathbf{C}$； $\\cdots\\cdots$  关系：\n$$ \\mathbf{W} \\subseteq \\mathbf{N} \\subseteq \\mathbf{Z} \\subseteq \\mathbf{Q} \\subseteq \\mathbf{R} \\subseteq \\mathbf{C} $$\n 集合的表示方法 枚举法 枚举法又称列举法或显示法，是枚举出集合中的所有或部分元素（要能看出其他元素之间的规律）。\nExample：\n 枚举出集合中的所有元素：$A = {a,b,c,d}$； 枚举出集合中的部分元素：$B = {1,3,5,\\cdots,2n+1,\\cdots}$。   叙述法 叙述法又称隐式法，是通过刻画（或用自然语言描述）集合中元素所具备的某种特性来表示集合的方法，通常用符号 $P(x)$ 来表示不同对象 $x$ 所具有的性质 $P$ ，由 $P(x)$ 所定义的集合常记为\n$$ {x|P(x)}。 $$\n 文氏图 文氏图（Venn diagram）又叫维恩图，用于展示集合或类之间的大致关系。\n一般用方向表示全集，用圆形表示某一特定集合。\n 递归指定集合法 递归指定集合法是指通过计算规则定义集合中的元素的方法。\nExample：\n设 $a_0 = 1$，$a_{i+1}=2a_i(i \\ge 0)$，定义 $S={a_0,a_1,\\cdots,a_n,\\cdots}={a_k|k\\ge0}$，可以得出集合 $S$ 为\n$$ S={1,2,2^2,\\cdots,2^n,\\cdots}。 $$\n 归纳法   指出集合至少要包含的元素\n 第一部分：基础，指出某些最 \u0026lt;u\u0026gt;基本元素 \u0026lt;/u\u0026gt;属于某集合； 第二部分：归纳，指出 \u0026lt;u\u0026gt;由基本元素构造新元素的方法 \u0026lt;/u\u0026gt;；    指出集合至多要包含的元素\n 第三部分：极小性，指出该 \u0026lt;u\u0026gt;集合的界限 \u0026lt;/u\u0026gt;。     基数 Definition：\n集合 $A$ 中的元素个数称为集合的基数（base number），记为 $|A|$。\n对于任意集合 $A$ 来说，\n 若 $|A|$ 是 \u0026lt;u\u0026gt;有限的 \u0026lt;/u\u0026gt;，称该集合为有限集（finite set）； 若 $|A|$ 是 \u0026lt;u\u0026gt;无限的 \u0026lt;/u\u0026gt;，称该集合为无限集（infinite set）。   集合与元素的关系 元素与集合之间有两种关系：\n  属于：如 “$a$ 是集合 $A$ 中的元素” 或 “$a$ 属于 $A$ ” 记为\n$$ a \\in A。 $$\n  不属于：如 “$a$ 不是是集合 $A$ 中的元素” 或 “$a$ 不属于 $A$” 记为\n$$ a \\notin A。 $$\n   集合与集合的关系 外延性原理 Theorem：\n两个集合 $A$ 和 $B$ 相等，当且仅当它们的元素完全相同，记为 $A\\ =\\ B$，否则 $A$ 和 $B$ 不相等，记为 $A\\ \\neq\\ B$。\n 包含关系 Definitions：\n设 $A$，$B$ 是任意两个集合，\n  包含与不包含：如果 $B$ 的每个元素都是 $A$ 中的元素，则称 $B$ 是 $A$ 的子集（subset），也称 ${B}$ 被 ${A}$ 包含或 ${A}$ 包含 ${B}$，记作 ${B \\subseteq A}$ 或 $A \\supseteq B$，称 $\\subseteq$ 或 $\\supseteq$ 为被包含关系（included relation）或包含关系（inclusion relation）；否则记作 ${B \\nsubseteq A}$。\n“$\\subseteq$” 定义的数学语言描述为：\n$$ B \\subseteq A\n\\Longleftrightarrow\\ \\forall x， 如果 x \\subseteq B， 则 x \\subseteq A。 $$\n由子集的定义可推出 $A \\subseteq A$。\n  真包含：如果 $B \\subseteq A$ 并且 $A \\neq B$，则称 $B$ 是 $A$ 的真子集（proper subset），也称做 ${B}$ 被 ${A}$ 真包含或 ${A}$ 真包含 ${B}$，记作 ${B \\subset A}$，称 $\\subset$ 为真包含关系（properly inclusion relation）。\n“$\\subset$” 定义的数学语言描述为：\n$$ B \\subset A \\Longleftrightarrow 对 \\forall x，若 x \\in B，则 x \\in A，并且 \\exists y \\in A，但 y \\notin B。 $$\n   相等关系 Theorem：\n设 $A$，$B$ 为任意两个集合，则 ${A\\ =\\ B}\\ \\Longleftrightarrow\\ {A \\subseteq B}$ 并且 ${B \\subseteq A}$。\n 常见特殊的集合 空集 Definition：\n不含任何元素的集合叫做空集（empty set），记作 $\\emptyset$。\n$$ \\emptyset = {x|x \\neq x} $$\n 空集是一切集合的子集。 空集是绝对唯一的。  Example：\n $|\\emptyset| = 0$， $|{\\emptyset}| = 1$。   证明空集是绝对唯一的  对 “唯一性” 的证明通常采用反证法（先假设 “不唯一”，得出矛盾，从而证明 “唯一性” 是正确的）。\n 证明：\n假设有两个不同的空集 $\\emptyset_1$ 和 $\\emptyset_2$ ，由空集是一切集合的子集得\n$$ \\empty_1 \\subseteq \\emptyset_2\\ 和\\ \\emptyset_2 \\subseteq \\emptyset_1 $$\n根据集合的相等关系，得 $\\emptyset_1 = \\emptyset_2$，与假设矛盾。因此空集是绝对唯一的。\n 全集 Definition：\n在一个相对固定的范围内，包含此范围内所有元素的集合，称为全集或论集（universal set），用 $U$ 或 $E$ 表示。\n在维恩图中一般用方形表示全集。\n全集是相对唯一的。\n m 元子集 Definition：\n如果一个集合含有 $n$ 个元素，则称集合 $A$ 为 $n$ 元子集，称含有 $A$ 中 $m(0 \\le m \\le n)$个元素的子集为它的 $m$ 元子集。\n对于任意 $n$ 元集合 $A$，它的 $m$ 元（$0 \\le m \\le n$）子集（包含空集）个数为 $C_n^m$ 个，所以不同的子集个数为：\n$$ C_n^0 + C_n^1 + \\cdots + C_n^n = (1 + 1)^n = 2^n。 \\tag{1} $$\n 幂集 Definition：\n设 $A$ 为任意集合，把 $A$ 的所有不同子集构成的集合叫做 $A$ 的幂集（power set），记作 $P(A)$，即\n$$ P(A)\\ =\\ {x|x \\subseteq A}。 $$\n由公式 $(1)$ 可得 $|A| = 2^n(n=|A|)$。\n幂集也叫做集族（family of set）或集合的集合。\n 对集族的研究在数学方面、知识库和表处理语言以及人工智能等方面都有十分重要的意义。\n  集合的运算 集合运算的定义 Definition：\n设 $U$ 是全集，$A$、$B$ 是 $U$ 的两个子集，则\n  “$\\cup$” 并运算（union operation）：$A \\cup B = {x|x \\in A\\ or\\ x \\in B}$ 是 $A$ 与 $B$ 的并集（union）。\n并集可代表两个集合 “相加”。\n  “$\\cap$” 交运算（intersection operation）：$A \\cap B = {x|x \\in A\\ and\\ B}$ 是 $A$ 与 $B$ 的交集（intersection）。\n  “$\\overline{A}$” 补运算（complement operation）：$\\overline{A} = U - A$ 是集合 $A$ 的补集（complement）（也可记为 $A'$、$~A$、$A^c$ 等）。$A$ 对于全集 $U$ 的补集是绝对补集。\n  “$-$” 差运算（subtraction operation）：$A-B={x|x \\in A\\ and\\ x \\notin B} = A \\cap \\overline{B}$ 是 $A$ 与 $B$ 的差集（subtraction)，又称 $B$ 在 $A$ 中的相对补集。\n当 $A=U$ 时，$A-B=\\overline{B}$。\n  “$\\oplus$” 对称差运算（symmetric difference operation）：$A \\oplus B = {x|(x \\in A\\ and\\ x \\notin B)\\ or\\ (x\\in B\\ and\\ x \\notin A} = (A-B) \\cup (B-A)$ 是 $A$ 与 $B$ 的对称差集（symmetric difference of set）。\n  扩展：\n设 $A_1,A_2,\\cdots,A_n$ 是任意 $n$ 个集合，则\n  这 $\\mathbf n$ 个集合的并集是包含那些至少是这组集合中一个集合成员的元素的集合，即\n$$ \\displaystyle \\bigcup_{i=1}^{n}{A_i} = A_1 \\cup A_2 \\cup \\cdots \\cup A_n = {x|x \\in A_1\\ or\\ x \\in A_2 \\cdots or\\ x \\in A_n} $$\n  这 $\\mathbf n$ 个集合的交集是那些属于这组集合中所有集合成员的元素的集合，即\n$$ \\displaystyle \\bigcap_{i=1}^{n}{A_i} = A_1 \\cap A_2 \\cap \\cdots \\cap A_n = {x|x \\in A_1\\ and\\ x \\in A_2 \\cdots and\\ x \\in A_n} $$\n  当 $n$ 无限增大时，可记为\n $\\displaystyle \\bigcup^{\\infin}_{i=1}A_i = A_1 \\cup A_2 \\cup \\cdots$ $\\displaystyle \\bigcap^{\\infin}_{i=1}A_i = A_1 \\cap A_2 \\cap \\cdots$   集合运算的基本等式 设 $U$ 为全集，$A$，$B$，$C$ 为任意集合，\n   等式 性质     $A \\cup A = A$\n$A \\cap A = A$ 幂等率   $A \\cup B = B \\cup A$\n$A \\cap B = B \\cap A$ 交换律   $A \\cup (B \\cup C) = (A \\cup B) \\cup C$\n$A \\cap (B \\cap C) = (A \\cap B) \\cap C$ 结合律   $A \\cup \\emptyset = A$\n$A \\cap U = A$ 同一律   $A \\cup U = U$\n$A \\cap \\emptyset = \\emptyset$ 零律   $A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)$\n$A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)$ 分配律   $A \\cup (A \\cap B) = A$\n$A \\cap (A \\cup B)$ 吸收律   $\\overline{A} \\cap A = \\emptyset$ 矛盾律   $\\overline{A} \\cup A = U$ 排中律   $\\overline{\\overline{A}}=A$ 双重否定律   $\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}$\n$\\overline{A \\cap B} = \\overline{A}$ 德摩根律    Example：\n证明德摩根律的等式之一：$\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}$\n证明：\n  证明 $\\overline{A \\cup B} \\subseteq \\overline{A} \\cap \\overline{B}$\n$\\begin{aligned} \\forall x \\in \\overline{A \\cup B} \\quad \u0026amp; \\Rightarrow\\ x \\notin A \\cup B\\ \\Rightarrow\\ x \\notin A\\ and\\ x \\notin B\\ \u0026amp; \\Rightarrow x \\in \\overline{A}\\ and\\ x \\in \\overline{B}\\ \\Rightarrow\\ x \\in \\overline{A} \\cap \\overline{B}， \\end{aligned}$\n即 $\\overline{A \\cup B} \\subseteq \\overline{A} \\cap \\overline{B}$；\n  证明 $\\overline{A} \\cap \\overline{B} \\subseteq \\overline{A \\cup B}$\n$\\begin{aligned} \\forall x \\in \\overline{A} \\cap \\overline{B} \\quad \u0026amp; \\Rightarrow\\ x \\in \\overline{A}\\ and\\ x \\in \\overline{B}\\ \\Rightarrow\\ x \\notin A\\ and\\ x \\notin B\\ \u0026amp; \\Rightarrow\\ x \\notin A \\cup B\\ \\Rightarrow\\ x \\in \\overline{A} \\cap \\overline{B}， \\end{aligned}$\n即 $\\overline{A} \\cap \\overline{B} \\subseteq \\overline{A \\cup B}$。\n  综上可得 $\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}$。\n 无限集合 有限集合与无限集合的根本区别是：对于无限集合，表面上个数完全不相等的两个集合之间仍可能存在等势关系，如集合与真子集之间。\n等势 冯·诺依曼的自然数定义：\n基于基数，利用一个集合的序列来定义自然数。\n $\\emptyset \\in \\mathbf{N}$； 若 $n \\in \\mathbf{N}$，则 $n' \\equiv n \\cup {n} \\in \\mathbf{N}$。  从而，这个 \u0026lt;u\u0026gt;集合序列的基数 \u0026lt;/u\u0026gt;可以来定义自然数：\n $0 \\equiv \\emptyset$； $1 \\equiv \\emptyset \\cup {\\emptyset} = {\\emptyset} = {0}$； $2 \\equiv {\\emptyset} \\cup {{\\emptyset}} = {\\emptyset, {\\emptyset}} = {0,1}$； $\\cdots$ $n \\equiv {0,1,2,3,\\cdots,n-1}$； $\\cdots$ $\\mathbf{N} \\equiv {0,1,2,\\cdots,n,\\cdots}$。   实际上，任意含有 $n$ 个元素的集合都可以用 $n$ 表示。即，任意两个基数相同的集合之间都可以建立一一对应关系。\n  Definition：\n设 $A$，$B$ 为两个集合，若在 $A$，$B$ 之间存在一种一一对应的关系：\n$$ \\Psi:\\ A \\rightarrow B $$\n则称 $A$ 与 $B$ 是等势的（equipotential），记作：\n$$ A \\sim B $$\n也称集合 $A$、$B$ 等势（equipotent）。\n由等势定义可得，如果 $A = B$，那么 $A \\sim B$，反之则不一定成立。\nTheorem：\n 两个有限集合等式当且仅当它们有相同的元素个数。 有限集合不和其任何真子集等势。 \u0026lt;u\u0026gt;可数集合可以与其可数的真子集等势 \u0026lt;/u\u0026gt;。   可数集合 Definition：\n凡与自然数集合 $\\mathbf{N}$ 等势的集合，称之为可数集合（countable set），该类集合的基数记为 $\\aleph_0$（aleph，阿列夫）。\nExample：\n证明以下集合是可数集合，\n  $O^+ = {x|x \\in \\mathbf{N}，x是正奇数}$\n在 $O^+$ 与 $\\mathbf{N}$ 之间建立一个一一对应关系 $\\varphi_1 : \\mathbf{N} \\rightarrow O^+$：\n$$ \\begin{matrix} 0\u0026amp; 1\u0026amp; 2\u0026amp; \\cdots\u0026amp; n\u0026amp; \\cdots\\ \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\\ 1\u0026amp; 3\u0026amp; 5\u0026amp; \\cdots\u0026amp; 2n+1\u0026amp; \\cdots\u0026amp;\\ \\end{matrix} $$\n所以 $O^+$ 是可数集合。\n  $P = {x|x \\in \\mathbf{N}，x是素数}$\n在 $P$ 与 $\\mathbf{N}$ 之间建立一个一一对应关系 $\\varphi_2 : \\mathbf{N} \\rightarrow P$：\n$$ \\begin{matrix} 0\u0026amp; 1\u0026amp; 2\u0026amp; 3\u0026amp; 4\u0026amp; \\cdots\\ \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\u0026amp; \\downarrow\\ 2\u0026amp; 3\u0026amp; 5\u0026amp; 7\u0026amp; 11\u0026amp; \\cdots\u0026amp;\\ \\end{matrix} $$\n所以 $P$ 是可数集合。\n  有理数集合 $\\mathbf{Q}$\n将 $\\mathbf{Q}$ 中的所有元素都写成 $p/q$（$p$、$q$ 是整数，且 $q \\neq 0$）的形式，从 $0/1^{[0]}$ 开始，将所有有理数与自然数一一配对（其中 $p/q^{[n]}$ 的上标 $[n]$ 代表对应于该有理数的自然数）：\n所以 $\\mathbf{Q}$ 是可数集合。\n   不可数集合 Definition：\n开区间 $(0,1)$ 称为不可数集合，凡与开区间 $(0,1)$ 等势的集合，都称为不可数集合，该类集合的基数记为 $\\aleph$（或 $\\aleph_1$）。\nExample：\n  闭区间 $[0,1]$ 是不可数集合。\n证明：在 $[0,1]$ 和 $(0,1)$ 之间建立如下对应关系：\n$$ R: \\begin{cases} \\begin{matrix} 0\u0026amp; \\rightarrow\u0026amp; 1/4 \\ 1\u0026amp; \\rightarrow\u0026amp; 1/2 \\ \\cfrac{1}{2^n}\u0026amp; \\rightarrow\u0026amp; \\cfrac{1}{2^{n+2}},\u0026amp; n=1,2,3,\\cdots \\ n\u0026amp; \\rightarrow\u0026amp; n,\u0026amp; 其他 n \\in (0,1)\\ \\end{matrix} \\end{cases} $$\n显然 $[0,1]$ 与 $(0,1)$ 是等势的，所以 $[0,1]$ 是不可数集合。\n  实数集 $\\mathbf R$ 是不可数集合。\n证明：在实数集 $\\mathbf R$ 和开区间 $(0,1)$ 之间建立如下对应关系：\n$$ n \\rightarrow \\tan{\\pi\\bigg(\\cfrac{2n-1}{2}\\bigg)} $$\n显然 $(0,1)$ 与 $\\mathbf{R}$ 之间是等势的，所以 $\\mathbf{R}$ 是一个不可数集合。\n  ","date":"2022-09-02T12:43:41+08:00","permalink":"https://blog.linner.asia/p/%E9%9B%86%E5%90%88%E8%AE%BA/","title":"集合论"},{"content":"数据库连接池 数据库连接池是个容器, 负责分配, 管理数据库连接 (Connection).\n数据库连接池允许应用程序重复使用一个现有的数据库连接, 而不是再重新建立一个. 从而减少资源浪费.\n数据库连接池会自动释放超过最大空闲时间的数据库连接 (强制释放), 来避免因为没有释放数据库连接而引起的数据库连接遗漏.\n使用数据库连接池的好处:\n 资源可以重用 提升系统响应速度 避免数据库连接遗漏  在通常情况下使用JDBC, 有可能会反复地创建和销毁 Connection对象. 这样重复创建销毁的过程特别耗费计算机的性能和时间.\n而数据库使用了数据库连接池后，就能达到Connection对象的复用.\n连接池是在一开始就创建好了一些连接 (Connection) 对象存储起来. 用户需要连接数据库时, 不需要自己创建连接, 而只需要从连接池中获取一个连接进行使用, 使用完毕后再将连接对象归还给连接池; 这样就可以起到资源重用, 也节省了频繁创建连接销毁连接所花费的时间, 从而提升了系统响应的速度.\n常见的数据库连接池有:\n DBCP C3P0 Druid   Druid 配置 Druid   下载Druid jar包, 并导入:\n在项目中, 将下载好的jar包放入项目的 lib目录中.\n 然后点击鼠标右键\u0026ndash;\u0026gt;Add as Library (添加为库). 在添加为库文件的时候，有如下三个选项:   Global Library: 全局有效\n  Project Library: 项目有效\n  Module Library: 模块有效\n选择Module Library.\n      在项目目录下定义Druid配置文件 druid.properties:\ndriverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///db1?useSSL=false\u0026amp;useServerPrepStmts=true username=root password=1234 # 初始化连接数量 initialSize=5 # 最大连接数 maxActive=10 # 最大等待时间 maxWait=3000   加载配置文件:\nProperties prop = new Properties(); prop.load(new FileInputStream(\u0026#34;demo/src/druid.properties\u0026#34;));   使用 Druid Java中从数据库连接池获取连接对象, 使用的是官方提供的数据库连接池标准接口, 由第三方组织实现此接口. 该接口提供了获取连接的功能:\nConnection getConnection() throws SQLException 因此, 使用Druid获取数据库连接还需要以下两步:\n  获取数据库连接池对象:\nDataSource dataSource = DruidDataSourceFactory.createDataSource(prop);   从数据库连接池中获取连接 (Connection):\nConnection connection = dataSource.getConnection();    操作实例 需求分析 完成商品品牌数据的增删改查操作\n 查询：查询所有数据 添加：添加品牌 修改：根据id修改 删除：根据id删除  环境准备   创建数据库表:\n-- 删除tb_brand表 DROP TABLE IF EXISTS tb_brand; -- 创建tb_brand表 CREATE TABLE tb_brand ( id INT PRIMARY KEY AUTO_INCREMENT, -- id 主键  brand_name VARCHAR(20), -- 品牌名称  company_name VARCHAR(20), -- 企业名称  ordered INT, -- 排序字段  description VARCHAR(100), -- 描述信息  status INT -- 状态：0：禁用 1：启用 ); -- 添加数据 INSERT INTO tb_brand (brand_name, company_name, ordered, description, status) VALUES (\u0026#39;三只松鼠\u0026#39;, \u0026#39;三只松鼠股份有限公司\u0026#39;, 5, \u0026#39;好吃不上火\u0026#39;, 0), (\u0026#39;华为\u0026#39;, \u0026#39;华为技术有限公司\u0026#39;, 100, \u0026#39;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界\u0026#39;, 1), (\u0026#39;小米\u0026#39;, \u0026#39;小米科技有限公司\u0026#39;, 50, \u0026#39;are you ok\u0026#39;, 1);   创建 pojo包, 并在包中添加 Brand实体类:\npackage pojo; /** * 品牌 */ public class Brand { private Integer id; // id 主键  private String brandName; // 品牌名称  private String companyName; // 企业名称  private Integer ordered; // 排序字段  private String description; // 描述信息  private Integer status; // 状态：0：禁用 1：启用  public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getBrandName() { return brandName; } public void setBrandName(String brandName) { this.brandName = brandName; } public String getCompanyName() { return companyName; } public void setCompanyName(String companyName) { this.companyName = companyName; } public Integer getOrdered() { return ordered; } public void setOrdered(Integer ordered) { this.ordered = ordered; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } @Override public String toString() { return \u0026#34;Brand{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, brandName=\u0026#39;\u0026#34; + brandName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, companyName=\u0026#39;\u0026#34; + companyName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, ordered=\u0026#34; + ordered + \u0026#34;, description=\u0026#39;\u0026#34; + description + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, status=\u0026#34; + status + \u0026#39;}\u0026#39;; } }   实现操作 package dao; import pojo.Brand; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.FileInputStream; import java.sql.*; import java.util.ArrayList; import java.util.Properties; /** * 品牌数据的增删改查操作 */ public class BrandDAO { private static DataSource dataSource; // 获取Connection:  static { try { // - 导入jar包 \u0026amp; 定义配置文件  // - 加载配置文件  Properties prop = new Properties(); prop.load(new FileInputStream(\u0026#34;demo/src/druid.properties\u0026#34;)); // - 获取连接池对象  dataSource = DruidDataSourceFactory.createDataSource(prop); } catch (Exception e) { e.printStackTrace(); } } /** * 查询所有 * 1. SQL: SELECT * FROM tb_brand * 2. 参数: 不需要 * 3. 结果: ArrayList\u0026lt;Brand\u0026gt; */ public ArrayList\u0026lt;Brand\u0026gt; selectAll() throws Exception{ // 1. 获取数据库连接Connection  Connection conn = dataSource.getConnection(); // *2. 定义SQL  String sql = \u0026#34;SELECT * FROM tb_brand\u0026#34;; // 3. 获取pstmt对象  PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数  // 5. 执行SQL  ResultSet rs = pstmt.executeQuery(); // *6. 处理结果: ArrayList\u0026lt;Brand\u0026gt;  Brand brand = null; ArrayList\u0026lt;Brand\u0026gt; brands = new ArrayList\u0026lt;\u0026gt;(); // - 遍历结果集  while (rs.next()) { // 1. 获取数据  int id = rs.getInt(\u0026#34;id\u0026#34;); String brandName = rs.getString(\u0026#34;brand_name\u0026#34;); String companyName = rs.getString(\u0026#34;company_name\u0026#34;); int ordered = rs.getInt(\u0026#34;ordered\u0026#34;); String description = rs.getString(\u0026#34;description\u0026#34;); int status = rs.getInt(\u0026#34;status\u0026#34;); // 2. 封装Brand对象  brand = new Brand(); brand.setId(id); brand.setCompanyName(companyName); brand.setOrdered(ordered); brand.setDescription(description); brand.setStatus(status); // 3. 装载ArrayList集合  brands.add(brand); } // 7. 释放资源  rs.close(); pstmt.close(); conn.close(); // 8. 返回结果  return brands; } /** * 添加 * 1. SQL: INSERT INTO tb_brand( brand_name, company_name, ordered, description, status) VALUES(?,?,?,?,?) * 2. 参数: 除了id之外的所有参数信息 * 3. 结果: boolean */ public boolean add(Brand brand) throws Exception{ // 1. 获取数据库连接Connection  Connection conn = dataSource.getConnection(); // *2. 定义SQL  String sql = \u0026#34;\u0026#34;\u0026#34; INSERT INTO tb_brand( brand_name, company_name, ordered, description, status) VALUES(?,?,?,?,?)\u0026#34;\u0026#34;\u0026#34;; // 3. 获取pstmt对象  PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数  pstmt.setString(1, brand.getBrandName()); pstmt.setString(2, brand.getCompanyName()); pstmt.setInt(3, brand.getOrdered()); pstmt.setString(4, brand.getDescription()); pstmt.setInt(5, brand.getStatus()); // 5. 执行SQL  int count = pstmt.executeUpdate(); // 返回影响的行数  // 6. 释放资源  pstmt.close(); conn.close(); // 7. 返回结果  return count \u0026gt; 0; } /** * 修改 * 1. SQL: UPDATE tb_brand SET brand_name=?, company_name=?, ordered=?, description=?, status=? WHERE id=? * 2. 参数: 所有 * 3. 结果: boolean */ public boolean update(Brand brand) throws Exception{ // 1. 获取数据库连接Connection  Connection conn = dataSource.getConnection(); // *2. 定义SQL  String sql = \u0026#34;\u0026#34;\u0026#34; UPDATE tb_brand SET brand_name=?, company_name=?, ordered=?, description=?, status=? WHERE id=?\u0026#34;\u0026#34;\u0026#34;; // 3. 获取pstmt对象  PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数  pstmt.setString(1, brand.getBrandName()); pstmt.setString(2, brand.getCompanyName()); pstmt.setInt(3, brand.getOrdered()); pstmt.setString(4, brand.getDescription()); pstmt.setInt(5, brand.getStatus()); pstmt.setInt(6, brand.getId()); // 5. 执行SQL  int count = pstmt.executeUpdate(); // 返回影响的行数  // 6. 释放资源  pstmt.close(); conn.close(); // 8. 返回结果  return count \u0026gt; 0; } /** * 删除 * 1. SQL:DELETE FROM tb_brand WHERE id=? * 2. 参数: id * 3. 结果: boolean */ public boolean deleteById(int id) throws Exception{ // 1. 获取数据库连接Connection  Connection conn = dataSource.getConnection(); // *2. 定义SQL  String sql = \u0026#34;DELETE FROM tb_brand WHERE id=?\u0026#34;; // 3. 获取pstmt对象  PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数  pstmt.setInt(1, id); // 5. 执行SQL  int count = pstmt.executeUpdate(); // 返回影响的行数  // 6. 释放资源  pstmt.close(); conn.close(); // 7. 返回结果  return count \u0026gt; 0; } } ","date":"2022-08-14T00:00:00Z","permalink":"https://blog.linner.asia/p/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","title":"Druid 数据库连接池"},{"content":"Maven 简介 Apache Maven是专门用于管理和构建Java项目的工具, 它基于项目对象模型 (POM) 的概念, 通过一小段描述信息来管理项目的构建, 报告和文档.\nMaven的主要功能有:\n 提供了一套标准化的项目结构. 提供了一套标准化的构建流程 (编译, 测试, 打包, 发布\u0026hellip;). 提供了一套依赖管理机制.  Maven 模型 Maven模型包含:\n 项目对象模型 (Project Object Model) 依赖管理模型 (Dependency) 插件 (Plugin)  Maven模型图示:\n其中紫色框框起来的部分, 就是用来完成标准化构建流程.\n仓库 Maven仓库是项目中依赖的第三方库, 这个库所在的位置叫做仓库 (在Maven的术语中，仓库是一个位置, place).\nMaven中, 任何一个依赖、插件或者项目构建的输出，都可以称之为构件. Maven仓库能帮助我们管理构件 (主要是JAR), 它就是放置所有JAR文件 (WAR, ZIP, POM等等) 的地方.\n仓库有三种类型:\n 本地 (local) 中央 (central) 远程 (remote)  在项目中使用坐标引入对应依赖jar包后, Maven会按照本地仓库 \u0026ndash;\u0026gt; 远程仓库\u0026ndash;\u0026gt; 中央仓库的顺序去查找相应的jar包. 只要jar包存在, 如果是在本地仓库则直接使用, 而如果在远程仓库或中央仓库, Maven则将jar包自动下载到本地仓库.\n本地仓库 本地仓库在第一次执行maven命令的时候才被创建.\n运行 Maven 的时候, Maven 所需要的任何构件都是直接从本地仓库获取的. 如果本地仓库没有, 它会首先尝试从远程仓库下载构件至本地仓库, 然后再使用本地仓库的构件.\nMaven 本地仓库默认为用户主目录 (USER HOME) 中的 .m2/repository.\n中央仓库 Maven 中央仓库是由 Maven 社区提供的仓库, 其中包含了大量常用的库.\n中央仓库包含了绝大多数流行的开源Java构件, 以及源码、作者信息、SCM、信息、许可证信息等. 一般来说，简单的Java项目依赖的构件都可以在这里下载到.\nMaven 社区提供了一个 URL: search.maven.org/#browse, 来浏览中央仓库的内容.\n远程仓库 远程仓库是开发人员自己定制的仓库, 包含了所需要的代码库或者其他工程中用到的 jar 文件. 一般是由公司团队搭建的私有仓库.\n Maven标准化项目结构 Maven提供了一套标准化的项目结构, 所有的IDE使用Maven构建的项目完全一样. 所以, 使用Maven创建的项目在所有IDE中可以通用.\n使用Maven构建的项目结构示例:\n 📁project_name \u0026mdash; 项目主目录  📁src \u0026mdash; 源代码和测试代码文件目录  📁main \u0026mdash; 源代码文件目录  📁java \u0026mdash; 源代码Java文件目录 📁resourcs \u0026mdash; 源代码配置文件目录   📁test \u0026mdash; 测试代码文件目录  📁java \u0026mdash; 测试代码Java文件目录 📁resource \u0026mdash; 测试代码配置   📄pom.xml \u0026mdash; 项目核心配置文件       项目核心配置文件 pom.xml \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;!-- 模型版本 --\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- The Basics --\u0026gt; \u0026lt;!-- 公司或者组织的唯一标志 --\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;!-- 当前项目唯一ID --\u0026gt; \u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 本项目目前所处的版本号 --\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; \u0026lt;!-- 打包的机制 --\u0026gt; \u0026lt;packaging\u0026gt;...\u0026lt;/packaging\u0026gt; \u0026lt;!-- 项目依赖关系 --\u0026gt; \u0026lt;dependencies\u0026gt;...\u0026lt;/dependencies\u0026gt; \u0026lt;parent\u0026gt;...\u0026lt;/parent\u0026gt; \u0026lt;dependencyManagement\u0026gt;...\u0026lt;/dependencyManagement\u0026gt; \u0026lt;modules\u0026gt;...\u0026lt;/modules\u0026gt; \u0026lt;!-- pom常量 --\u0026gt; \u0026lt;properties\u0026gt;...\u0026lt;/properties\u0026gt; \u0026lt;!-- Build Settings --\u0026gt; \u0026lt;build\u0026gt;...\u0026lt;/build\u0026gt; \u0026lt;reporting\u0026gt;...\u0026lt;/reporting\u0026gt; \u0026lt;!-- More Project Information --\u0026gt; \u0026lt;!-- 项目的名称 --\u0026gt; \u0026lt;name\u0026gt;...\u0026lt;/name\u0026gt; \u0026lt;!-- 项目的详细描述 --\u0026gt; \u0026lt;description\u0026gt;...\u0026lt;/description\u0026gt; \u0026lt;!-- 项目主页的URL --\u0026gt; \u0026lt;url\u0026gt;...\u0026lt;/url\u0026gt; \u0026lt;inceptionYear\u0026gt;...\u0026lt;/inceptionYear\u0026gt; \u0026lt;licenses\u0026gt;...\u0026lt;/licenses\u0026gt; \u0026lt;organization\u0026gt;...\u0026lt;/organization\u0026gt; \u0026lt;developers\u0026gt;...\u0026lt;/developers\u0026gt; \u0026lt;contributors\u0026gt;...\u0026lt;/contributors\u0026gt; \u0026lt;!-- Environment Settings --\u0026gt; \u0026lt;issueManagement\u0026gt;...\u0026lt;/issueManagement\u0026gt; \u0026lt;ciManagement\u0026gt;...\u0026lt;/ciManagement\u0026gt; \u0026lt;mailingLists\u0026gt;...\u0026lt;/mailingLists\u0026gt; \u0026lt;scm\u0026gt;...\u0026lt;/scm\u0026gt; \u0026lt;prerequisites\u0026gt;...\u0026lt;/prerequisites\u0026gt; \u0026lt;!-- 发现依赖和扩展的远程仓库列表 --\u0026gt; \u0026lt;repositories\u0026gt;...\u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt;...\u0026lt;/pluginRepositories\u0026gt; \u0026lt;distributionManagement\u0026gt;...\u0026lt;/distributionManagement\u0026gt; \u0026lt;profiles\u0026gt;...\u0026lt;/profiles\u0026gt; \u0026lt;/project\u0026gt; pom.xml中描述符的根为\u0026lt;project\u0026gt;.\nMaven坐标  Maven 中的坐标是资源的唯一标识. 使用坐标来定义项目或引入项目中需要的依赖.  Maven坐标的主要组成 (在pom.xml文件中):\n \u0026lt;groupId\u0026gt;: 公司或者组织的唯一标志. 配置时生成的路径也是由此生成. 如com.linner.blog (通常是域名反写), Maven会将该项目打成的jar包放本地路径：/com/linner/blog. \u0026lt;artifactId\u0026gt;: 当前项目的唯一ID (通常是模块名称). 一个groupId下面可能多个项目, 就是靠\u0026lt;artifactId\u0026gt;来区分. \u0026lt;version\u0026gt;: 本项目目前所处的版本号.  Maven 中, 根据 groupId、artifactId、version 组合成 groupId:artifactId:version 来唯一识别一个 jar 包. 这三个标签构成了Maven坐标.\n其他基本配置  \u0026lt;modelVersion\u0026gt;: 指定pom.xml符合哪个版本的描述符. Maven2和3只能为4.0.0. \u0026lt;packaging\u0026gt;: 打包的机制. 有以下几种:  pom jar \u0026mdash; 默认值 maven-plugin ejb war ear rar par   \u0026lt;dependencies\u0026gt;: 定义本项目的依赖关系.   Maven依赖管理 依赖管理是指管理项目中所依赖的第三方资源 (jar包, 插件). 而Maven使用标准的坐标配置来管理各种依赖, 只需要简单的配置就可以完成依赖管理.\nMaven的依赖资源是在pom.xml配置文件中的\u0026lt;dependencies\u0026gt;描述的. 其结构如下:\n \u0026lt;project\u0026gt;  \u0026hellip; \u0026lt;dependencies\u0026gt;  \u0026lt;dependency\u0026gt;: 一个\u0026lt;dependency\u0026gt;代表一个依赖项. \u0026lt;groupId\u0026gt;, \u0026lt;artifactId\u0026gt;和\u0026lt;version\u0026gt;的含义与\u0026lt;project\u0026gt;的子标签\u0026lt;groupId\u0026gt;, \u0026lt;artifactId\u0026gt;和\u0026lt;version\u0026gt;的含义相同.  \u0026lt;groupId\u0026gt; \u0026lt;artifactId\u0026gt; \u0026lt;version\u0026gt; \u0026lt;type\u0026gt;: 依赖的打包机制. 对应\u0026lt;packaging\u0026gt;的类型, 有pom, jar(默认), maven-plugin, ejb, war, ear, rar, par. \u0026lt;scope\u0026gt;: 任务的类路径 (编译和运行时, 测试等) 以及如何限制依赖关系的传递性.    scope取值 有效范围(compile, runtime, test) 依赖传递     compile all 是   provided compile, test 否   runtime runtime, test 是   test test 否   system compile, test 是     \u0026lt;optional\u0026gt; \u0026lt;exclusions\u0026gt;  \u0026lt;exclusion\u0026gt;  \u0026lt;groupId\u0026gt; \u0026lt;artifactId\u0026gt;   \u0026lt;exclusion\u0026gt;  \u0026hellip;   多个\u0026lt;exclusion\u0026gt;\u0026hellip;     多个\u0026lt;dependency\u0026gt;\u0026hellip;   \u0026hellip;    \u0026lt;scope\u0026gt;取值说明:\n Maven常用命令  compile: 编译 clean: 清理 test: 测试 package: 打包 install: 安装  使用Maven命令需要先配置PATH, 然后在项目目录下执行.\n例如项目路径为~/project:\ncd ~/project 编译 mvn compile 第一次执行该命令, Maven会自动从仓库 (中央仓库或远程仓库, 介绍常用命令时, 如无特别指出, 仓库均指中央仓库或远程仓库) 下载编译所需的jar插件包. 然后在项目下会生成一个 target 目录. 编译后的字节码文件就放在该目录下.\n清理 mvn clean 第一次执行该命令, Maven会从仓库下载清理所需要的jar插件包. 接着便使用插件清除项目下的target目录.\n打包 mvn package 第一次执行该命令, Maven会从仓库下载打包所需要的jar插件包. 然后在项目的 terget 目录下生成一个jar包 (将当前项目打成的jar包).\n测试 mvn test 该命令会执行所有的测试代码, 即project/scr/text下的代码.\n安装 mvn install 该命令会将当前项目打成jar包, 并安装到本地仓库. 执行完上述命令后可以到本地仓库查看结果. 仓库中的路径为pom.xml文件中\u0026lt;groupId\u0026gt;相应的路径, 生成的jar包名为\u0026lt;artifactId\u0026gt;和\u0026lt;version\u0026gt;组成的内容.\n Maven生命周期 Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件.\nMaven对项目构建的生命周期划分为3套:\n clean: 清理工作. default: 核心工作, 例如编译, 测试, 打包, 安装等. site: 产生报告, 发布站点等. 这套声明周期一般不会使用.  同一套生命周期内, 执行后边的命令, 前面的所有命令会自动执行.\ndefault 生命周期如下:\n如执行install命令, maven会按照上图中从左到右的顺序先执行compile, 再执行test, package, 最后执行install; 如果执行package, 除了install命令, 其它命令按照上图左到右顺序执行.\n 默认的生命周期其实有对应的很多命令, 上图中只展示了常用的.\n ","date":"2022-08-14T00:00:00Z","permalink":"https://blog.linner.asia/p/maven/","title":"Maven"},{"content":"创建.ssh目录并生成公钥:\nssh-keygen -t rsa 所有选项全部回车, 使用默认选项即可.\n然后切换到用户目录下的.ssh目录:\ncd ~/.ssh 该目录下默认有三个文件:\n id_rsa: 用户私钥, 不要复制发送给任何人. id_rsa.pub: 公钥, 将里面内容发送给客户端. authorized_keys: 信任的公钥.  只需要将id_rsa.pub里的内容以 (ssh-rsa开头的一行内容) 复制到客户端的authorized_keys的目录下即可.\n接着在客户端使用:\nssh username@ip -p port 即可连接到服务器.\n","date":"2022-08-13T00:00:00Z","permalink":"https://blog.linner.asia/p/ssh-%E5%85%AC%E9%92%A5%E9%85%8D%E7%BD%AE/","title":"SSH 公钥配置"},{"content":"JDBC 简介 JDBC (Java DataBase Connectivity, Java 数据库连接) 是使用Java语言操作关系型数据库的一套 API.\nJDBC其实是SUN公司制订的一套操作数据库的标准接口. JDBC中定义了所有操作关系型数据库的规则. 由各自的数据库厂商给出实现类 (驱动jar包).\nJava, JDBC和各种数据库的关系如下图:\n使用JDBC的好处:\n 不需要针对不同数据库分别开发. 可随时替换底层数据库, 访问数据库的Java代码基本不变.   JDBC 使用的基本步骤   导入JDBC驱动jar包:\n  下载MySQL jar驱动包, 菜鸟教程 Java MySQL 连接。\n  在项目中, 将下载好的jar包放入项目的 lib目录中.\n  然后点击鼠标右键\u0026ndash;\u0026gt;Add as Library (添加为库).\n  在添加为库文件的时候，有如下三个选项:\n  Global Library: 全局有效\n  Project Library: 项目有效\n  Module Library: 模块有效\n选择Global Library.\n      注册驱动:\nClass.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;);  MySQL提供的 Driver的静态代码块会自动执行 DriverManager.registerDriver() 方法来注册驱动. 所以我们只需加载 Driver即可. MySQL5之后的驱动包, 可以省略注册驱动的步骤.\n   获取数据库连接:\nConnection conn = DriverManager.getConnection(url, username, password);   其中, url, username和 password都是 String类型.\n  url格式:\njdbc:数据库软件名称://ip地址或域名:端口/数据库名称?参数键值对1\u0026amp;参数键值对2... 例如, 连接本地mysql中名为test的数据库:\njdbc:mysql://127.0.0.1:3306/test 本地mysql, 且端口为3306, url可简写为:\njdbc:mysql:///数据库名称?参数键值对 常用的参数键值对有:\nuseSSL=false // 禁用安全连接方式, 解决警告提示 useServerPrepStmts=true // 开启预编译(默认为false) serverTimezone=GMT%2B8 // 设置时区, 东八区(即GMT+8) serverTimezone=Asia/Shanghai // 设置时区东八区 useUnicode=true\u0026amp;characterEncoding=UTF-8 // 设置字符集为UTF-8     获取执行SQL对象:\n执行SQL语句需要SQL执行对象 (Statement对象):\nStatement stmt = conn.createStatement(); Statement对象存在安全问题 (SQL注入等问题), 而使用 PreparedStatement不仅可以提升查询速度, 而且还能防止SQL注入问题.\nString sql = \u0026#34;...SQL语句...\u0026#34;; PreparedStatement pstmt = conn.prepareStatement(sql);   执行SQL语句:\nint count = pstmt.executeUpdate(sql); 用于执行DML, DDL语句.\n或者:\nResultSet rs = pstmt.executeQuery(sql); 用于执行DQL语句.\n  处理返回结果\n  释放资源:\nResultSet、Statement和 Connection对象都要 \u0026lt;i\u0026gt;按照顺序 \u0026lt;/i\u0026gt;释放资源.\nrs.close(); stmt.close(); conn.close();   大致代码如下:\nimport java.sql.*; public class JDBCDemo { public static void main(String[] args) throws Exception { // - 接收用户输入的用户名和密码  String name = \u0026#34;...\u0026#34;; String pwd = \u0026#34;...\u0026#34;; // 1. 注册驱动（装载类，并实例化）  Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); // 2. 获取连接  String url = \u0026#34;jdbc:mysql://127.0.0.1:3306/test\u0026#34; + \u0026#34;?useServerPrepStmts=true\u0026#34;; String username = \u0026#34;root\u0026#34;; String password = \u0026#34;1234\u0026#34;; Connection conn = DriverManager.getConnection(url, username, password); // 3. 定义SQL语句 (用?作占位符)  String sql = \u0026#34;SELECT id,username,password\u0026#34; + \u0026#34; FROM tb_user\u0026#34; + \u0026#34; WHERE username = ?\u0026#34; + \u0026#34; AND password = ?\u0026#34;; // 4. 获取执行SQL的PreparedStatement对象  PreparedStatement pstmt = conn.prepareStatement(sql); // 设置参数（?）的值 pstmt.setXxx(index, value)  pstmt.setString(1, name); pstmt.setString(2, pwd); // 5. 执行SQL  ResultSet rs = pstmt.executeQuery(); // 6. 处理结果  while (rs.next) { /* ... */ } // 7. 释放资源  rs.close(); pstmt.close(); conn.close(); } }  PreparedStatement 对象 PreparedStatement 对象可以:\n 预编译SQL语句并执行 预防SQL注入问题  获取 PreparedStatement需要先传入SQL语句:\n// SQL语句中的参数值,使用 ? 占位符替代 String sql = \u0026#34;SELECT id,username,password\u0026#34; + \u0026#34; FROM tb_user\u0026#34; + \u0026#34; WHERE username = ?\u0026#34; + \u0026#34; AND password = ?\u0026#34;; // 通过Connection对象获取PreparedStatement, 并传入对应的SQL语句 PreparedStatement pstmt = conn.prepareStatement(sql); 接着我们需要设置SQL对象中的参数值:\n使用 pstmt.setXxx(index, value), 给 ? 赋值. 其中, index的值从 1开始, value的类型为 Xxx或 xxx.\n例如, 给 int类型的 value赋值使用 setInt(), String类型使用 setString(). 除此之外还有 setFloat(), setDouble(), setArray(), setByte()等.\n如果 prepareStatement()方法传入的是DML, DDL语句, 则使用 executeUpdate() 方法:\nint executeUpdate() throws SQLException 如果该方法执行的是DML语句 (INSERT, UPDATE和 DELETE), 则返回DML语句操作的行数; 如果是DDL语句则返回 0.\n 需要注意, 在开发中很少使用java代码操作DDL语句.\n 如果 prepareStatement()方法传入的是DQL语句 (SELECT), 使用的是 executeQuery() 方法:\nResultSet executeQuery() throws SQLException 该方法返回的是DQL语句查询后的结果集.\n在使用 PreparedStatement对象后, 需要使用 close()方法释放资源.\nStatement 和 PreparedStatement Statement 对象的一般用法如下:\nString sql = \u0026#34;UPDATE tb_user SET password = \\\u0026#34;abc\\\u0026#34; WHERE id = 1\u0026#34;; Statement stmt = conn.createStatement(); int count = stmt.executeUpdate(sql); Statement的SQL语句是作为 executeUpdate()和 executeQuery()的参数传入, 而 PreparedStatement则是在创建对象就已经作为 prepareStatement()方法的参数传入.\n这是因为 PreparedStatement需要预先传入SQL语句, 来起到预编译SQL语句和预防SQL注入问题.\n预编译 一般情况下, java执行SQL语句的过程如下:\njava程序请求数据库执行SQL语句后:\n 检查: 数据库接收指令, 检查SQL语法 编译: 如果SQL语句无语法错误, 则将该语句编译成可执行的函数 执行: 编译完成后执行SQL语句  而检查SQL和编译SQL花费的时间比执行SQL的时间还要长, 如果需要一次性执行多条SQL语句, 那会浪费大量时间和资源. 所以, PreparedStatement的出现解决了这个问题.\n通过使用 PreparedStatement对象, 并且在连接数据库的 url中添加 useServerPrepStmts=true参数来开启SQL语句预编译功能. 预编译功能会将我们设置的SQL语句 (如 \u0026quot;SELECT id,username,password FROM tb_user WHERE username = ? AND password = ?\u0026quot;) 预先传给数据库, 让其先完成检查和编译的工作 (先完成耗时的工作), 然后再一次性执行所有SQL语句 (这些SQL语句都是相同的, 只是占位符处设置的值不同).\nSQL注入 SQL注入是指通过把SQL命令插入到Web表单提交, 或输入域名或页面请求的查询字符串, 最终达到欺骗服务器执行恶意的SQL命令.\n而 PreparedStatement通过在SQL语句中使用 ?占位符, 并且使用相应的 setXxx()方法来设置值 (设置的值如果含有特殊字符, 如 \u0026quot; 和 ' 等, 则会进行转义), 防止了SQL注入的发生.\n下面代码说明了 PreparedStatement如何防止SQL注入:\nclass Demo { public static void main(String[] args) { // useServerPrepStmts=true开启预编译  String url = \u0026#34;jdbc:mysql:///test?useSSL=false\u0026amp;useServerPrepStmts=true\u0026#34;; String username = \u0026#34;root\u0026#34;; String password = \u0026#34;n546,Lin0\u0026#34;; Connection conn = DriverManager.getConnection(url, username, password); // - 接收用户输入的用户名和密码  String name = \u0026#34;zhangsan\u0026#34;; String pwd = \u0026#34;\u0026#39; OR \u0026#39;1\u0026#39; = \u0026#39;1\u0026#34;; // - 定义SQL（用?作占位符）  String sql = \u0026#34;SELECT id,username,password\u0026#34; + \u0026#34; FROM tb_user\u0026#34; + \u0026#34; WHERE username = ?\u0026#34; + \u0026#34; AND password = ?\u0026#34;; // - 获取PreparedStatement对象  // - 预编译SQL，性能更高  // 默认关闭，在url加上参数useServerPrepStmts=true开启  // - 防止SQL注入  PreparedStatement pstmt = conn.prepareStatement(sql); // - 设置参数（?）的值  // - 防注入原理：  // 字符串参数在setString中会被转义，  // 即整个参数被当成sql里面的字符串，而不是java的字符串  pstmt.setString(1, name); // 从mysql日志文件可以发现：  // \u0026#39; OR \u0026#39;1\u0026#39; = \u0026#39;1 转义成了 \\\u0026#39; OR \\\u0026#39;1\\\u0026#39; = \\\u0026#39;1  pstmt.setString(2, pwd); // - 执行SQL  ResultSet rs = pstmt.executeQuery(); // - 判读登录是否成功  if (rs.next()) { System.out.println(\u0026#34;登录成功！\u0026#34;); } else { System.out.println(\u0026#34;登陆失败！\u0026#34;); } rs.close(); pstmt.close(); conn.close(); } } 下面代码演示了把SQL代码片段插入到SQL命令, 来进行免密登录:\nclass LoginInject { public static void main(String[] args) throws Exception { String url = \u0026#34;jdbc:mysql:///test\u0026#34;; String username = \u0026#34;root\u0026#34;; String password = \u0026#34;1234\u0026#34;; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入的用户名和密码  String name = \u0026#34;abcdefg\u0026#34;; // 用户名随意  String pwd = \u0026#34;\u0026#39; OR \u0026#39;1\u0026#39; = \u0026#39;1\u0026#34;; // 密码传入SQL代码片段  String sql = \u0026#34;SELECT id,username,password\u0026#34; + \u0026#34; FROM tb_user\u0026#34; + \u0026#34; WHERE username = \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39; AND password = \u0026#39;\u0026#34;+ pwd + \u0026#34;\u0026#39;\u0026#34;; // 将sql语句where部分展开：  // WHERE username = \u0026#39;abcdefg\u0026#39; AND password = \u0026#39;\u0026#39; OR \u0026#39;1\u0026#39; = \u0026#39;1\u0026#39;  // 发现where语句条件始终为真  System.out.println(sql); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); // 判读登录是否成功  if (rs.next()) { System.out.println(\u0026#34;登录成功！\u0026#34;); } else { System.out.println(\u0026#34;登陆失败！\u0026#34;); } // 返回的是登录成功  rs.close(); stmt.close(); conn.close(); } }  ResultSet 对象 ResultSet (结果集对象) 作用: 封装了SQL查询语句的结果, 是 executeQuery()方法的返回值类型.\nResultSet对象有三个方法:\n  next():\nboolean next() throws SQLException 每次执行时, 将光标从当前位置向前移动一行 (光标从第0行开始), 并且判断当前行是否为有效行 (返回 true则代表为有效行)。\n  getXxx():\nxxx getXxx(arg) throws SQLException arg类型:\n int: 代表列的编号 (按照 SELECT语句中的查询顺序), 从1开始 String: 列的名称    close():\nvoid close() throws SQLException 释放 ResultSet对象.\n  下面演示了 ResultSet的使用:\nclass Demo { public static void main(String[] args) { // ...  String sql = \u0026#34;SELECT id,username,password FROM tb_user\u0026#34;; Statement stmt = conn.createStatement(); PreparedStatement pstmt = conn.prepareStatement(sql); // - 处理结果，遍历rs中的所有数据  // - rs.next()：光标向下移动一行，并判断当前行是否有效  while (rs.next()) { // - 获取数据 getXxx()  int id = rs.getInt(1); // getXxx()方法可以使用列索引（从1开始）也可以使用列名  String usrname = rs.getString(\u0026#34;username\u0026#34;); String passwd = rs.getString(3); System.out.println(\u0026#34;id: \u0026#34; + id); System.out.println(\u0026#34;username: \u0026#34; + usrname); System.out.println(\u0026#34;passwd: \u0026#34; + passwd); System.out.println(\u0026#34;-----------------------\u0026#34;); } // - 释放资源  // ResultSet、Statement和Connection都要按照顺序释放资源  // 先释放ResultSet, 再释放Statement, 最后是Connection  rs.close(); stmt.close(); conn.close(); } }  操作实例 用户账号密码增删改操作.\n在编写JDBC代码之前需要先完成创建数据库, 创建 pojo包并编写 User实体类的工作:\n  创建数据库并运行下方SQL代码:\n-- 删除tb_user表 DROP TABLE IF EXISTS tb_user; -- 创建tb_user表 CREATE TABLE tb_user( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20), password VARCHAR(32) ); -- 添加数据 INSERT INTO tb_user VALUES(NULL, \u0026#39;zhangsan\u0026#39;, \u0026#39;123\u0026#39;), (NULL, \u0026#39;lisi\u0026#39;, \u0026#39;234\u0026#39;);   创建 pojo包, 并在包中添加 User实体类:\npackage pojo; // pojo包存放实体类  public class User { private Integer id; private String username; private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \u0026#34;Account{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, username=\u0026#39;\u0026#34; + username + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   增删改操作 JDBC数据访问层的代码放在 DAO包下:\npackage dao; import pojo.User; import java.sql.*; public class UserDAO { private static String URL = \u0026#34;jdbc:mysql:///test\u0026#34; + \u0026#34;?useSSL=false\u0026amp;useServerPrepStmts=true\u0026#34;; private static String USERNAME = \u0026#34;root\u0026#34;; private static String PASSWORD = \u0026#34;1234\u0026#34;; /** * 根据用户名和密码查询 * @param username * @param password * @return User * @throws SQLException */ public User select(String username, String password) throws SQLException { // 参数有null值时  if (username == null || password == null) { return null; } // 连接数据库  Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 获取PreparedStatement对象, 并设置SQL语句  String sql = \u0026#34;SELECT id, username, password\u0026#34; + \u0026#34; FROM tb_user\u0026#34; + \u0026#34; WHERE username = ?\u0026#34; + \u0026#34; AND password = ?\u0026#34;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); pstmt.setString(2, password); // 获取ResultSet  ResultSet rs = pstmt.executeQuery(); User user = null; if (rs.next()) { user = new User(); Integer id = rs.getInt(\u0026#34;id\u0026#34;); String name = rs.getString(\u0026#34;username\u0026#34;); String pw = rs.getString(\u0026#34;password\u0026#34;); user.setId(id); user.setUsername(name); user.setPassword(pw); } rs.close(); pstmt.close(); conn.close(); return user; } /** * 根据用户名和密码添加数据 * @param username * @param password * @return boolean * @throws SQLException */ public boolean add(String username, String password) throws SQLException { Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = \u0026#34;INSERT INTO tb_user\u0026#34; + \u0026#34; VALUE(null, ?, ?)\u0026#34;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); pstmt.setString(2, password); int count = pstmt.executeUpdate(); pstmt.close(); conn.close(); return count \u0026gt; 0; } /** * 根据用户名和密码删除数据 * @param username * @param password * @return boolean * @throws SQLException */ public boolean delete(String username, String password) throws SQLException { Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = \u0026#34;DELETE FROM tb_user\u0026#34; + \u0026#34; WHERE username = ?\u0026#34; + \u0026#34; AND password = ?\u0026#34;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); pstmt.setString(2, password); int count = pstmt.executeUpdate(); pstmt.close(); conn.close(); return count \u0026gt; 0; } } ","date":"2022-08-12T14:46:53Z","permalink":"https://blog.linner.asia/p/jdbc/","title":"JDBC"},{"content":"  下载code-server：\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz 可以访问code-server GitHub 页面获取下载连接。\n  解压：\ntar -zxvf code-server-4.5.1-linux-amd64.tar.gz   将解压后的文件移动到/opt目录下，并重命名：\nmv code-server-4.5.1-linux-amd64 /opt/code-server   创建软链到/usr/bin目录下：\nln -s /opt/code-server/code-server /usr/bin/code-server   修改配置文件~/.config/code-server/config.yaml：\nvim ~/.config/code-server/config.yaml   添加code-server服务：\nvim /lib/systemd/system/codeweb.service 写入如下内容：\n[Unit] Description=The nginx HTTP and reverse proxy server After=network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/usr/bin/code-server KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true StandardOutput=syslog StandardError=inherit [Install] WantedBy=multi-user.target   ","date":"2022-07-23T00:00:00Z","permalink":"https://blog.linner.asia/p/%E6%90%AD%E5%BB%BA-code-server/","title":"搭建 code-server"},{"content":"  下载frp：\nwget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz 或者访问frp项目获取自己需要的版本。\n  解压：\ntar -zxvf frp_0.44.0_linux_amd64.tar.gz   进入目录后，配置frps.ini和frpc.ini：\ncd frp_0.44.0_linux_amd64   服务端：\nvim frps.ini 将文件按照下面修改：\n[common] # frp监听的端口，默认是7000，可以改成其他的 bind_port = 7000 # 授权码，请改成更复杂的 token = 123456 # 这个token之后在客户端会用到 # frp管理后台端口，请按自己需求更改 dashboard_port = 7500 # frp管理后台用户名和密码，请改成自己的 dashboard_user = admin dashboard_pwd = admin enable_prometheus = true # frp日志配置 log_file = /var/log/frps.log log_level = info log_max_days = 3   客户端：\nvim frpc.ini 将文件按照下面修改：\n# 客户端配置 [common] server_addr = 服务器ip server_port = 7000 # 与frps.ini的bind_port一致 token = 52010 # 与frps.ini的token一致 # 配置ssh服务 [ssh] type = tcp local_ip = 127.0.0.1 # 默认本地ip local_port = 22 remote_port = 6000 # 这个自定义，之后再ssh连接的时候要用 # 配置http服务，可用于小程序开发、远程调试等，如果没有可以不写下面的 [web] type = http local_ip = 127.0.0.1 local_port = 8080 subdomain = test.hijk.pw # web域名 remote_port = 自定义的远程服务器端口，例如8080     接着需要在防火墙开启相应的端口。\n  启动服务：\n  服务端：\n./frps -s frps.ini 或者配置frps.server文件：\nsudo vim /lib/systemd/system/frps.service [Unit] Description=The nginx HTTP and reverse proxy server After=network.target remote-fs.target nss-lookup.target [Service] Type=simple # 根据实际情况修改这条命令或者将frps、frps.ini移动到相应位置 ExecStart=/usr/bin/frps -c /etc/frp/frps.ini KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true StandardOutput=syslog StandardError=inherit [Install] WantedBy=multi-user.target   客户端：\n./frpc -c frpc.ini 如果是Linux也可以配置frpc.service：\n[Unit] Description=Frp Client Service After=network.target [Service] Type=simple #User=nobody Restart=on-failure RestartSec=5s # 根据实际情况修改以下两条命令或者将frps、frps.ini移动到相应位置 ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini ExecReload=/usr/bin/frpc reload -c /etc/frp/frpc.ini [Install] WantedBy=multi-user.target     更多请见Frp官方文档。\n","date":"2022-07-23T00:00:00Z","permalink":"https://blog.linner.asia/p/%E6%90%AD%E5%BB%BA-frp-%E6%9C%8D%E5%8A%A1/","title":"搭建 frp 服务"},{"content":"二分查找 二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。\n算法步骤 以升序数列$L[0\u0026hellip;n-1]$为例，假设要查找的数为$x$：\n让$x$与数列中间位置的元素$L[\\lfloor \\frac n2 \\rfloor]$进行比较，如果相等则返回该元素下标，否则：\n 如果$x$比中间元素小，递归地对中间元素左边的数列（比二分查找小的元素）进行二分查找； 如果$x$比中间元素大，递归地对中间元素右边的数列（比二分查找大的元素）进行二分查找。  代码实现 Python实现  递归实现： def BinarySearch(arr, target, left = 0, right = 0): \u0026#34;\u0026#34;\u0026#34;二分排序（递归实现） left=0,right=len(arr)-1\u0026#34;\u0026#34;\u0026#34; if left == 0 and right == 0: right = len(arr)-1 if left \u0026gt; right or len(arr) == 0: return -1 mid = int((left + right) / 2) if target == arr[mid]: return mid elif target \u0026lt; arr[mid]: return BinarySearch(arr, target, left, mid-1) else: return BinarySearch(arr, target, mid+1, right) if __name__ == \u0026#34;__main__\u0026#34;: arr = list(range(100)) target = 66 result = BinarySearch(arr, target) if result == -1: print(False) else: print(result)  非递归实现： def BinarySearch(arr, target): \u0026#34;\u0026#34;\u0026#34;二分排序（非递归实现）\u0026#34;\u0026#34;\u0026#34; if len(arr) == 0: return -1 left = 0 right = len(arr)-1 while left \u0026lt;= right: mid = int((left + right) / 2) if target == arr[mid]: return mid elif target \u0026lt; arr[mid]: right = mid - 1 else: left = mid + 1 return -1 if __name__ == \u0026#34;__main__\u0026#34;: arr = list(range(100)) target = 66 result = BinarySearch(arr, target) if result == -1: print(False) else: print(result)   C实现  递归实现： #include \u0026lt;stdio.h\u0026gt;#define LEN 100  int BinarySearch(int arr[], int left, int right, int target) { if (left \u0026gt; right || arr == NULL) return -1; int mid = (left + right) / 2; if (target == arr[mid]) return mid; else if (target \u0026lt; arr[mid]) return BinarySearch(arr, left, mid-1, target); else return BinarySearch(arr, mid+1, right, target); } int main(void) { int arr[LEN]; for (int i = 0; i \u0026lt; LEN; i++) arr[i] = i; int target = 66; int result = BinarySearch(arr, 0, LEN-1, target); if (result == -1) printf(\u0026#34;False\\n\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, result); return 0; }  非递归实现： #include \u0026lt;stdio.h\u0026gt;#define LEN 100  int BinarySearch(int arr[], int left, int right, int target) { if (left \u0026gt; right || arr == NULL) return -1; while (left \u0026lt;= right) { int mid = (left + right) / 2; if (target == arr[mid]) return mid; else if (target \u0026lt; arr[mid]) right = mid - 1; else left = mid + 1; } return -1; } int main(void) { int arr[LEN]; for (int i = 0; i \u0026lt; LEN; i++) arr[i] = i; int target = 66; int result = BinarySearch(arr, 0, LEN-1, target); if (result == -1) printf(\u0026#34;False\\n\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, result); return 0; }    散列表查找 散列表查找又叫哈希表查找，是通过记录存储位置和关键字构建一个确定的关系$f$，使得每个关键字$key$对应一个存储位置$f(key)$，称这个为散列技术。其中，$f$称为散列函数或者哈希函数。\n通过散列技术将记录存储在一块连续的存储空间中，这块连续的空间称为散列表或者哈希表。\n散列表最适合查找与给定的值相等的记录。\n散列函数的冲突：\n在使用散列表的过程中，可能会有两个关键字通过散列函数得到的存储地址是一样的，这个现象被称为冲突。此时就需要通过冲突解决办法来解决冲突。在解决冲突的同时也要保证查找和插入效率问题。同时为了避免冲突，散列函数的构造也是很重要的。\n算法步骤 散列函数的构造方法 选取散列函数的参考：\n 计算散列地址所需的时间； 关键字长度；   散列表大小；  关键字的分布情况；  查找记录的频率。  直接定址法 直接定址法就是直接通过取关键字的某个线性值作为散列地址：\n$$ f(key)=a \\cdot key+b\\quad(a,b为常数) $$\n例如，要存储0-100岁的人口统计表，就可以采用散列函数为：\nf(key) = key 数字分析法 数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布比较 均匀，就可以考虑这个方法。\nExample：\n假设某公司的员工登记表以员工的手机号作为关键字。手机号一共11位。前3位是接入号，对应不同运营商的子品牌；中间4位表示归属地；最后4位是用户号。不同手机号前7位相同的可能性很大，所以可以选择后4位作为散列地址，或者对后4位反转（1234 -\u0026gt; 4321）、循环右移（1234 -\u0026gt; 4123）、循环左移等等之后作为散列地址。\n平方取中法 假设关键字是1234，平方之后是1522756，再抽取中间3位227，用作散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。\n折叠法 将关键字从左到右分割成位数相等的几部分，最后一部分位数不够时可以短些，然后将这几部分叠加求和， 并按散列表表长，取后几位作为散列地址。\n比如关键字是9876543210，散列表表长是3位，将其分为四组，然后叠加求和：987 + 654 + 321 + 0 = 1962，取后3位962作为散列地址。\n折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。\n除留取余数法 此方法为最常用的构造散列函数方法。\n除留取余数法：\n$$ f(key)=key\\enspace mod\\enspace p\\quad (p\\le m),\\ m为散列表长 $$\n这种方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。根据经验，若散列表表长为$m$，通常$p$为小于或等于表长（最好接近$m$）的最小质数，可以更好的减小冲突。\n随机数法 $$ f(key)=random(key),\\quad random是随机函数 $$\n当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。\n处理散列表冲突问题的方法 开放地址法 开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。有三种寻找空散列地址的方法：\n  线性探测法\n$$ f'(key)=(f(key)+d)% n,\\quad 其中d取(0,1,2,\u0026hellip;,n-1),\\ n为散列表的长度 $$\n$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。\nExample：\n   下标 0 1 2 3 4 5 6 7 8 9 10 11     关键字 12 25   16   67 56      在如上所示的散列表中插入37。首先使用散列函数计算37的散列地址：$f'(37)=f(37)%12=1$（这里假设$f(key)=key$）。                而下标为1的位置已经存放了25，那就只能继续寻找下一个空散列地址：$f'(37)=(f(37)+1)%12=2$。\n2这个位置没有内容，所以得到：\n   下标 0 1 2 3 4 5 6 7 8 9 10 11     关键字 12 25 37  16   67 56      使用线性探测来解决冲突问题，会造成冲突堆积。所谓的冲突堆积就是上例的37，它本来是属于下标1的元素，现在却占用了下标为2的空间。如果现在需要存放原本存放在下标为2的元素，就会再次发生冲突，这个冲突会一直传播下去，大大减低查找和插入效率。                  二次探测法\n$$ f'(key)=(f(key)+q^2)%n,\\quad 其中q取(0,1,-1,2,-2,\u0026hellip;,\\frac n2,-\\frac n2),\\ n为散列表的长度 $$\n二次探测法其实是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。\nExample：\n   下标 0 1 2 3 4 5 6 7 8 9 10 11     关键字 12 25 37  16   67 56      插入元素7，通过二次探测的散列函数计算得到：$f'(7)=f(7)%12=7$。                但下标为7的位置已经存放了67，所以需要寻找下一个存储地址：$f'(7)=(f(7)+1^2)%12=8$。\n下标为8的位置已经存放了56，继续寻找： $f'(7)=(f(7)+(-1^2))%12=6$。\n6这个位置为空，得到：\n   下标 0 1 2 3 4 5 6 7 8 9 10 11     关键字 12 25 37  16  7 67 56         随机探测法\n$$ f'(key)=(f(key)+d)%m,\\quad d为随机数,m为表长 $$\n在实现中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避免或减少堆积。\n  多重散列法 多重散列法又叫再散列函数法。其公式如下：\n$$ f'(key)=RH(key) $$\n其中$RH$就是不同的散列函数，这些散列函数可以是任何散列函数。只要其中一个发生了冲突，就马上换一个散列函数，直到冲突解决。缺点就是增加了很多计算时间。\n链地址法 链地址法就是当冲突发生时，用链表来存放同义词（即存放在当前位置，每个位置使用链表存放同义词）。这个思路和图的邻接表存储方式很相似。\n公共溢出区法 公共溢出区法就是把那些冲突的元素直接追加到另外一个溢出表中，如下图所示：\n在查找的时候，如果在基本表没有找到，那么就只能去溢出表中进行顺序查找。这个方法比较适合冲突元素少的情况。\n代码实现 Python实现  除留取余数法构造散列函数，开放地址法-线性探测处理散列表冲突： class HashTable: def __init__(self, size): self.elem = [None for i in range(size)] self.size = size def hash(self, key): \u0026#34;\u0026#34;\u0026#34;除留取余数法构造哈希函数\u0026#34;\u0026#34;\u0026#34; return key % self.size def insert_hash(self, key): address = self.hash(key) # 开放地址法-线性探测 while self.elem[address]: address = (address+1) % self.size self.elem[address] = key def search_hash(self, key): star = address = self.hash(key) while self.elem[address] != key: address = (address + 1) % self.size if not self.elem[address] or address == star: return -1 return address if __name__ == \u0026#34;__main__\u0026#34;: list_a = [12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34] hash_table = HashTable(12) for i in list_a: hash_table.insert_hash(i) for i in hash_table.elem: if i: print((hash_table.elem.index(i), i), end=\u0026#34; \u0026#34;) print(\u0026#34;\u0026#34;) print(hash_table.search_hash(15)) print(hash_table.search_hash(33))   ","date":"2022-02-27T14:44:00Z","permalink":"https://blog.linner.asia/p/%E7%BB%8F%E5%85%B8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","title":"经典查找算法"},{"content":"Ubuntu MySQL 8 安装：\n  首先更新本地存储库索引：\nsudo apt update   从 APT 存储库安装 MySQL：\nsudo apt install MySQL-server -y   查看 MySQL 版本，验证是否安装成功：\nmysql --version   检查 MySQL 是否正在运行：\nsystemctl status mysql.service   如果服务未运行：\nsudo systemctl start mysql  MySQL 安装完成后需要更改密码。\n  查看默认账户和密码：\n执行后找到 user 和 password，如：\nsudo vim /etc/mysql/debian.cnf 或：\nsudo cat /etc/mysql/debian.cnf 找到如下：\nuser = debian-sys-maint password = 12E0cDBeusG6vANp   使用默认账户登录：\n然后输入默认密码：\nmysql -udebian-sys-maint -p 12E0cDBeusG6vANp   输入以下命令修改 root 密码：\nALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified WITH mysql_native_password BY \u0026#39;your_password\u0026#39;;   修改完成后执行：\nFLUSH privileges; QUIT   最后重启 MySQL 后就可以使用 root 用户了：\nsudo service mysql restart mysql -uroot -p   ","date":"2022-02-20T00:00:00Z","permalink":"https://blog.linner.asia/p/mysql-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"MySQL 环境配置"},{"content":"oh-my-zsh主页： https://ohmyz.sh/\n安装并设置zsh 安装zsh：\nsudo apt install zsh 查看系统中所有的shell：\ncat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /bin/dash /usr/bin/dash /usr/bin/tmux /usr/bin/screen /bin/zsh /usr/bin/zsh 将zsh设置为默认的shell：\nsudo chsh -s /bin/zsh 重新连接到Ubuntu，然后查看当前默认shell：\necho $SHELL 如果显示/bin/zsh则配置成功。\n 安装 oh-my-zsh 下载install.sh：\nwget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh 给install.sh添加权限：\nchmod +x install.sh 执行install.sh：\n./install.sh  📌在执行install.sh之前还需要安装git。否则会报错。\n安装git：\nsudo apt install git   配置zsh zsh的配置文件为：~/.zshrc。\nvim ~/.zshrc 修改主题 主题配置项为：ZSH_THEME。\n默认主题配置为：\nZSH_THEME=\u0026#34;robbyrussell\u0026#34; 可以修改为其中之一：\nZSH_THEME=\u0026#34;ys\u0026#34; ZSH_THEME=\u0026#34;geoffgarside\u0026#34; 还可以访问https://github.com/ohmyzsh/ohmyzsh/wiki/Themes 查看更多主题。\n","date":"2022-01-26T00:00:00Z","permalink":"https://blog.linner.asia/p/ubuntu-%E5%AE%89%E8%A3%85-oh-my-zsh/","title":"Ubuntu 安装 Oh my zsh"},{"content":"命题的定义 具有确切真值的陈述句称为命题（proposition）。命题可以取一个 “值”，称为真值。真值只有 “真”（用 “T” or “1” 表示，即 True）和 “假”（用 “F” or “0” 表示，即 False）。\n 通常用带或不带下标的大写英文字母表示命题。\n  非命题 一切没有判断内容的句子，如命令句（祈使句）、感叹句、疑问句、二义性的陈述句等都不能作为命题。\n 原子命题与复合命题  原子命题（简单命题）：不能再分解为更简单命题的命题。 复合命题：可以分解为更为简单命题的命题。这些简单命题之间是通过联结词和标点符号复合而成。   命题变元 一个特定的命题是一个常值命题，它不是具有值 “T”，就是具有值 “F”。\n一个任意的没有赋予具体内容的原子命题就是一个变量命题，常称它为命题变量（或命题变元，propositional vatiable）。\n命题变元无具体的真值，它的变域是集合 ${T,F}$（或 ${0,1}$）。\n 联结词 联结词是两个命题真值之间的联结，而不是命题内容之间的连接，因此复合命题的真值只取决于构成它们的各简单命题的真值，而与它们的内容无关，与二者之间是否有关系无关。\n 否定联结词 设 $P$ 是任意一个命题，复合命题 “非 $P$”（或 “$P$ 的否定”）称为 $P$ 的否定式（negation），记作 $\\neg P$，“$\\neg$” 为否定联结词。\n$P$ 为真当且仅当 $\\neg P$ 为假。\n真值表：\n   $P$ $\\neg P$     0 1   1 0     “$\\neg$” 是自然语言中的 “非”、“不”、“没有” 等的逻辑抽象。\n  合取联结词 设 $P$、$Q$ 是任意两个命题，复合命题 “$P$ 并且 $Q$”（或 “$P$ 和 $Q$”）称为 $P$ 与 $Q$ 的合取式（conjunction），记作 $P \\wedge Q$，“$\\wedge$” 为合取联结词。\n$P \\wedge Q$ 为真当且仅当 $P$、$Q$ 同为真。\n真值表：\n   $P \\qquad Q$ $P \\wedge Q$     $0 \\qquad 0$ $0$   $0 \\qquad 1$ $0$   $1 \\qquad 0$ $0$   $1 \\qquad 1$ $1$     析取联结词 设 $P$、$Q$ 是任意两个命题，复合命题 “$P$ 或 $Q$” 称为 $P$ 与 $Q$ 的析取式（disjunction），记作 $P \\vee Q$，“$\\vee$” 为析取联结词。\n$P \\vee Q$ 为真当且仅当 $P$、$Q$ 至少有一个为真。\n真值表：\n   $P \\qquad Q$ $P \\vee Q$     $0 \\qquad 0$ $0$   $0 \\qquad 1$ $1$   $1 \\qquad 0$ $1$   $1 \\qquad 1$ $1$     联结词 “$\\vee$” 是自然语言中的 “或”、“或者” 等的逻辑抽象。\n自然语言中的 “或” 有 “可兼或”（或称为同或）、“不可兼或”（即异或）两种。\n严格来讲，析取联结词实际上代表的是可兼或。\n  异或联结词 设 $P$、$Q$ 是任意两个命题，复合命题 “$P$ 或 $Q$” 有时代表不可兼或，记作 $P \\oplus Q$ 或 $P \\overline{\\vee} Q$，“$\\oplus$” 或 “$\\overline{\\vee}$” 为异或联结词。\n$P \\oplus Q$ 为真当且仅当 $P$、$Q$ 中有且仅有一个为真。\n真值表：\n   $P \\qquad Q$ $P \\vee Q$     $0 \\qquad 0$ $0$   $0 \\qquad 1$ $1$   $1 \\qquad 0$ $1$   $1 \\qquad 1$ $0$     蕴涵联结词 设 $P$、$Q$ 是任意两个命题，复合命题 “如果 $P$，则 $Q$” 称为 $P$ 与 $Q$ 的蕴涵式（implication），记作 $P \\rightarrow Q$，“$\\rightarrow$” 为蕴含联结词。\n$P \\rightarrow Q$ 为假当且仅当 $P$ 为真且 $Q$ 为假（$P$ 为假时，认为该蕴涵式为真）。\n一般把蕴涵式 $P \\rightarrow Q$ 中的 $P$ 称为该蕴涵式的前件，$Q$ 称为蕴涵式的后件。\n真值表：\n   $P \\qquad Q$ $P \\vee Q$     $0 \\qquad 0$ $1$   $0 \\qquad 1$ $1$   $1 \\qquad 0$ $0$   $1 \\qquad 1$ $1$     等价联结词 设 $P$、$Q$ 是任意两个命题，复合命题 “$P$ 当且仅当 $Q$” 称为 $P$ 与 $Q$ 的蕴涵式（implication），记作 $P \\leftrightarrow Q$，“$\\leftrightarrow$” 为等价联结词。\n$P \\leftrightarrow Q$ 为真当且仅当 $P$、$Q$ 同为真假。\n真值表：\n   $P \\qquad Q$ $P \\vee Q$     $0 \\qquad 0$ $1$   $0 \\qquad 1$ $0$   $1 \\qquad 0$ $0$   $1 \\qquad 1$ $1$     “$\\leftrightarrow$” 是自然语言中的 “等价”、“充分必要条件”、“当且仅当” 等的逻辑抽象。\n  总结 命题联结词 “$\\wedge$”、“$\\vee$”、“$\\leftrightarrow$” 具有对称性，而 “$\\neg$”、“$\\rightarrow$” 没有。\n 优先级 优先顺序：括号、否定、合取、析取、蕴涵、等价。同级的联结词，按出现的先后次序（从左到右）。\n 命题联结词的应用 联结词与开关电路 设命题 $P$：开关 $S_1$ 闭合；命题 $Q$：开关 $S_2$ 闭合。则以下电路可用复合命题表示：\n “串联”：$P \\wedge Q$； “并联”：$P \\vee Q$； “断开”：$\\neg P$。   联结词与逻辑电路   与门：$\\wedge$\n  或门：$\\vee$\n  非门：$\\neg$\n   联结词与网页检索 在布尔检索中，\n $\\wedge$（一般用 AND 表示）用于匹配包含两个检索项的记录； $\\vee$（一般用 OR 表示）用于匹配包含两个检索项至少一个的记录； $\\neg$（一般用 NOT 表示）用于排除某个特定的检索项。   联结词与位运算  按位与：$\\wedge$； 按位或：$\\vee$； 按位取反：$\\neg$。   命题公式 复合命题是由原子命题与联结词构成的命题。所以，当其中的原子命题是命题变元时，此复合命题也即为命题变元的函数，且该函数的值仍为 “真” 或 “假” 值，这样的函数可形象地称为 “真值函数” 或 “命题公式”，此命题公式没有确切的真值。\n 命题公式的定义 命题演算的合式公式（Well Formed Formula，WFF），又称命题公式（简称公式），按如下规则生成：\n 命题变元本身是一个公式； 如果 $G$ 是公式，则 $(\\neg G)$ 也是公式； 如果 $G$、$H$ 是公式，则 $(G \\wedge H)$、$(G \\vee H)$、$(G \\rightarrow H)$、$(G \\leftrightarrow H)$ 也是公式； 仅由有限步使用规则 1、2、3 后所得到的包含命题变元、联结词和括号的符号串才是命题公式。  如果 $G$ 是含有 $n$ 个命题变元 $P_1、P_2、P_3、\\cdots、P_n$ 的公式，可记为：$G(P_1,P_2,P_3,\\cdots,P_n)$ 或简写为 $G$。\n  原子命题变元是最简单的合式公式，称为原子合式公式，简称原子公式； 命题公式没有真值，只有对其命题变元进行真值指派后，方可确定命题公式的真值； 整个公式的最外层括号可以省略，公式中不影响运算次序的括号也可以省略； 在实际应用中，为了便于存储和运算，命题公式常用二元数方式来表达。   命题公式的解释 设 $P_1、P_2、P_3、\\cdots、P_n$ 是出现在公式 $G$ 中的所有命题变元，给 $P_1、P_2、P_3、\\cdots、P_n$ 指定一组真值，则这组真值称为 $G$ 的一个解释，常记为 $I$。\n 如果公式 $G$ 在解释 $I$ 下是真的，则称 $I$ 满足 $G$，此时 $I$ 是 $G$ 的成真赋值； 如果 $G$ 在解释 $I$ 下是假的，则称 $I$ 弄假于 $G$，此时 $I$ 是 $G$ 的成假赋值。   命题公式的分类  永真公式（又叫重言式，tautology）：如果在它的所有解释之下其真值都为 “真”。 永假公式（又叫矛盾式，contradiction）：如果在它的所有解释下其真值都为 “假”。    不可满足公式：即永假公式。 可满足公式（satisfiable）：不为永假公式的公式。    $G$ 是永真的当且仅当 $\\neg G$ 是永假的； $G$ 是可满足的当且仅当至少有一个解释 $I$，使 $G$ 在 $I$ 下为真； 若 $G$ 是永真式，则 $G$ 一定是可满足式，但反之可满足式不一定是永真式。   等价的命题公式 设 $G$、$H$ 是两个命题公式，$P_1、P_2、P_3、\\cdots、P_n$ 是出现在 $G$、$H$ 中所有的命题变元，如果对于 $P_1、P_2、P_3、\\cdots、P_n$ 的 $2^n$ 个解释，$G$ 与 $H$ 的真值结果都相同，则称公式 $G$ 与 $H$ 是等价的，记作 $G = H$（或 $G \\Leftrightarrow H$）。\n 公式等价的充分必要条件 对于任意两个公式 $G$ 和 $H$，$G = H$ 的充分必要条件是公式 $G \\leftrightarrow H$ 是永真公式。\nProof：\n 必要性：假定 $G = H$，则 $G$、$H$ 在其任意解释 $I$ 下或同为真或同为假，于是由 “$\\leftrightarrow$” 的意义知，公式 $G \\leftrightarrow H$ 在其任何的解释 $I$ 下，其真值为 “真”，即 $G \\leftrightarrow H$ 为永真公式。 充分性：假定公式 $G \\leftrightarrow H$ 是永真公式，$I$ 是它的任意解释，在 $I$ 下，$G \\leftrightarrow H$ 为真，因此，$G$，$H$ 或同为真或同为假，由于 $I$ 的任意性，故有 $G = H$。   可判定性：能否给出一个可行方法，完成对任意公式的判定问题（类型或等价判定）。\n 命题公式是可判定的。\n 命题公式的基本等价关系 设 $G$、$H$、$S$ 为任意的命题公式。\n   性质 等式     幂等律 $G \\vee G = G$$G \\wedge G = G$   交换律 $G \\vee H = H \\vee G$$G \\wedge H = H \\wedge G$   结合律 $G \\vee (H \\vee S) = (G \\vee H) \\vee S$$G \\wedge (H \\wedge S) = (G \\wedge H) \\wedge S$   同一律 $G \\wedge 0 = G$$G \\vee 1 = G$   零律 $G \\vee 1 = 1$$G \\wedge 0 = 0$   分配律 $G \\vee (H \\wedge S) = (G \\vee H) \\wedge (G \\vee S)$$G \\wedge (H \\vee S) = (G \\wedge H) \\vee (G \\wedge S)$   吸收率 $G \\vee (G \\wedge H) = G$$G \\wedge (G \\vee H) = G$   矛盾律 $\\neg G \\wedge G = 0$   排中律 $\\neg G \\vee G = 1$   双重否定律 $\\neg(\\neg G) = G$   德摩根律 $\\neg(G \\vee H) = \\neg G \\wedge \\neg H$$\\neg(G \\wedge H) = \\neg G \\vee \\neg H$   蕴涵式 $G \\rightarrow H = \\neg G \\vee H$   假言易位 $G \\rightarrow H = \\neg H \\rightarrow \\neg G$   等价式 $G \\leftrightarrow H = (G \\rightarrow H) \\wedge (H \\rightarrow G) = (\\neg G \\vee H) \\wedge (\\neg H \\vee G)$   等价否定等式 $G \\leftrightarrow H = \\neg G \\leftrightarrow \\neg H$   归谬论 $(G \\rightarrow H) \\wedge (G \\rightarrow \\neg H) = \\neg G$     基本等价关系的应用 （1）判断公式类型\n（2）证明公式等价\n（3）开关电路化简\n（4）逻辑电路化简\n（5）其他\n 范式  命题变元或命题变元的否定称为文字。 有限个文字（$\\ge 1$）的析取称为简单析取式（或子句）。 单个文字可构成子句。 有限个文字（$\\ge 1$）的合取称为简单合取式（或短语）。 单个文字可构成短语。 $P$ 与 $\\neg P$ 称为互补对。    有限个（$\\ge 1$）简单合取式（短语）的析取式称为析取范式（disjunctive normal form）。 有限个（$\\ge 1$）简单析取式（子句）的合取式称为合取范式（conjunctive normal form）。  文字可以是子句、短语、析取范式、合取范式。\n 命题公式的析取范式可以指出公式何时为真，而合取范式可以指出公式何时为假，从而能够替代真值表。 命题公式的范式表达并不唯一。  Example：\n  $P$、$\\neg P$ 可以是文字、短语、子句、析取范式、合取范式。\n  $P \\vee Q \\vee \\neg R$ 是子句、合取范式、析取范式。\n  将该式认为是子句，那么单个子句就可构成合取范式。\n  将 $P$、$Q$、$\\neg R$ 认为是短语，那么三个短语析取可构成析取范式。\n  $(P \\vee Q \\vee \\neg R)$ 是子句、合取范式。\n加了括号后该式就被认为是一个整体，不能作为析取范式。\n    $\\neg P \\wedge Q \\wedge R$ 是短语、析取范式、合取范式。\n 将该式认为是短语，那么单个短语就可构成析取范式。 将 $\\neg P$、$Q$、$R$ 认为是子句，那么三个子句合取可构成合取范式。 $(\\neg P \\wedge Q \\wedge R)$ 是短语、析取范式。    $P \\vee (Q \\vee \\neg R)$ 即不是析取范式也不是合取范式，但转换为 $P \\vee Q \\vee \\neg R$ 后，即是析取范式又是合取范式。\n   范式存在定理 联结词之间可以通过命题公式的基本等价关系进行相互转换，因此可以通过逻辑等价公式求出等价的析取范式和合取范式，具体步骤如下：\n 将公式中的 $\\rightarrow$、$\\leftrightarrow$ 用联结词 $\\neg$、$\\wedge$、$\\vee$ 来取代（使用蕴涵式和等价式）。 将否定联结词移到各个命题变元的前端，并消去多余的否定号（使用双重否定律和德摩根律）。 利用分配律，可将公式化成一些合取式的析取，或化成一些析取式的合取。  对任意一个公式，经过以上步骤（期间可用其他等价公式来化简），必能化成与其等价的析取范式和合取范式。\n 主范式 范式是不唯一的，对构成范式的子句或短语进一步进行规范化，形成唯一的主析取范式和主合取范式。\n 极大项和极小项 在含有 $n$ 个命题变元 $P_1、P_2、P_3、\\cdots、P_n$ 的短语或子句中，若 每个命题变元与其否定不同时存在，但二者之一恰好出现一次且仅一次，并且出现的次序与 $P_1、P_2、P_3、\\cdots、P_n$ 一致，则\n 称此短语为关于 $P_1、P_2、P_3、\\cdots、P_n$ 的一个极小项， 称此子句为关于 $P_1、P_2、P_3、\\cdots、P_n$ 的一个极大项。  若有 $n$ 个命题，则应有 $2^n$ 个不同的极小项和 $2^n$ 个不同的极大项。\n 对于极小项：\n 没有两个不同的极小项是等价的。 每个极小项只有一组成假赋值，因此可用于给极大项编码。 编码规则为：命题变元与 0 对应，命题变元的否定与 1 对应。  Example：\n设命题变元 $P$、$Q$，\n 对于极大项（与极小项相反的规定）：\n 没有两个不同的极大项是等价的。 每个极大项只有一组成假赋值，因此可用于给极大项编码。 编码规则为：命题变元与 0 对应，命题变元的否定与 1 对应。  Example：\n设命题变元 $P$、$Q$，\n 极小项的编码可对应为真情况时，相应的短语为真的真值序列。极大项的编码可对应为假情况时，相应的子句为假的真值序列。\n极小项和极大项还有以下性质：\n设有 $n$ 个命题变元，设 $i,j \\in {0, 1, \\cdots, 2^{n-1}}$ 且 $i \\neq j$，$m_i、m_j$ 代表这 $n$ 个命题变元对应的极小项，$M_i、M_j$ 代表对应的命题变元的极大项。那么就有\n  $m_i \\wedge m_j = 0$，\n$M_i \\vee M_j = 1$；\n  $m_i = \\neg M_i$，\n$M_i = \\neg m_i$；\n  $\\displaystyle \\bigvee_{i=0}^{2^n-1}{m_i} = 1$，\n$\\displaystyle \\bigwedge_{i=0}^{2^n-1}{M_i} = 0$。\n   主析取范式和主合取范式  在给定的析取范式中，若每一个短语都是极小项，且按照编码从小到大的顺序排列，则称该范式为主析取范式(principal disjunctive normal form)。 在给定的合取范式中，若每一个子句都是极大项，且按照编码从小到大的顺序排列，则称该范式为主合取范式(principal conjunctive normal form)。  如果一个主析取范式不包含任何极小项，则称该主析取范式为 “空”；如果一个主合取范式不包含任何极大项，则称主合取范式为 “空”。\n 任何一个公式都有与之等价的主析取范式和主合取范式。\n 如果某一公式的主析取范式包含所有的极小项，即主合取范式为空，则该公式为永真公式。 如果某一公式主合取范式包含所有的极大项，即主析取范式为空，则该公式为永假公式。 若有两个公式，它们具有相同的主析取范式或主合取范式，则两公式等价。   主范式求解定理   求出该公式所对应的析取范式和合取范式。\n  消去重复出现的命题变元，矛盾式或重言式。\n 先利用幂等律、矛盾律和排中律消去重复出现的命题元素； 再使用同一律和零律消去其中的常数。    若析取（合取）范式的某一个短语（子句）$B_i$ 中缺少命题变元 $P$，则可用如下方式将 $P$ 补进去：\n 求主析取范式：$B_i = B_i \\wedge 1 = B_i \\wedge (\\neg P \\vee P) = (B_i \\wedge \\neg P) \\vee (B_i \\wedge P)$； 求主合取范式：$B_i = B_i \\vee 0 = B_i \\vee (\\neg P \\wedge P) = (B_i \\vee \\neg P) \\wedge (B_i \\vee P)$。    利用幂等律将重复的极小项和极大项合并，并利用交换律进行顺序调整，由此可转换成标准的主析取范式和主合取范式。\n  主析取范式的极小项编码序列与主合取范式的极大项变编码序列是互补的。因此，只需求出主析取范式或主合取范式中其中之一，就可对应求出主合取范式或主析取范式。\n 公式转换法  真值表技术 从真值表按所给的算法求出主范式的方法，称为真值表技术 (technique of truth table)。\n方法：\n 列出真值表，选出公式的真值结果为真的所有的行，在这样的每一行中，找到其每一个解释所对应的极小项，将这些极小项进行析取即可得到相应的主析取范式。 列出真值表，选出公式的真值结果为假的所有的行，在这样的每一行中，找到其每一个解释所对应的极大项，将这些极大项进行合取即可得到相应的主合取范式。   推理 推理是指从一组前提合乎逻辑的推出结论的思维过程。\n 基本推理形式 设 $G_1、G_2、\\cdots、G_n、H$ 是命题公式，称 $H$ 是 $G_1、G_2、\\cdots、G_n$ 的逻辑结果当且仅当对任意解释 $I$，如果 $I$ 使得 $G_1 \\wedge G_2 \\wedge \\cdots \\wedge G_n$ 为真，则 $I$ 也会使 $H$ 为真，记为 $G_1、G_2、\\cdots、G_n\\ \\Rightarrow\\ H$，“$\\Rightarrow$” 称为蕴涵关系，此时称 $G_1、G_2、\\cdots、G_n\\ \\Rightarrow\\ H$ 为有效的，否则称为无效的。\n$G_1、G_2、\\cdots、G_n$ 称为一组前提，有时用集合 $\\Gamma$ 来表示，记为 $\\Gamma = {G_1,G_2,\\cdots,G_n}$，$H$ 称为结论。此时也称 $H$ 是前提集合 $\\Gamma$ 的逻辑结果，记为 $\\Gamma \\Rightarrow H$。\n 推理的判定定理 公式 $H$ 是前提集合 $\\Gamma = {G_1,G_2,\\cdots,G_n}$ 的逻辑结果当且仅当 $(G_1 \\wedge G_2 \\wedge \\cdots \\wedge G_n) \\rightarrow H$ 为永真公式。\n判定方法：\n 真值表技术， 公式转换法， 主析取范式法。   基本蕴涵关系 设 $G$、$H$、$I$ 为任意命题公式。\n   规则 公式     简化规则 $G \\wedge H \\Rightarrow G$$G \\wedge H \\Rightarrow H$   添加规则 $G \\Rightarrow G \\vee H$   合取引入规则 $G,H \\Rightarrow G \\wedge H$   选言三段论 $G \\vee H, \\neg G \\Rightarrow H$   假言推理规则 $G \\rightarrow H, G \\Rightarrow H$   否定后件式 $G \\rightarrow H, \\neg H \\Rightarrow \\neg G$   假言三段论 $G \\rightarrow H, H \\rightarrow I \\Rightarrow G \\rightarrow I$   二难推论 $G \\vee H, G \\rightarrow I, H \\rightarrow I \\Rightarrow I$    ![])(16265520749814.jpg)\n 自然演绎法推理   规则 $\\mathbf{P}$（称为前提引用规则）：在推导过程中，可随时引入前提集合中的任意一个前提，引入附加前提时需作声明。\n  规则 $\\mathbf{T}$（称为逻辑结果引用规则）：在推导过程中，可随时引入公式 $S$，该公式 $S$ 是由其前的一个或多个公式（可以是前提条件或推导出来的公式）推导出来的逻辑结果。\n  规则 $\\mathbf{CP}$（称为附加前提规则）：如果能从给定的前提集合 $\\Gamma$ 与公式 $P$ 推导出 $S$，则能从此前提集合 $\\Gamma$ 推导出 $P \\rightarrow S$。\n原理：$P \\rightarrow (Q \\rightarrow R) = (P \\wedge Q) \\rightarrow R$。 使用场合：当结论公式是蕴涵式或析取式时使用。\n  命题演算推理系统 = 三个推理规则 + 基本等价公式 + 基本蕴涵公式。\n 从前提集合 $\\Gamma$ 推出结论 $H$ 的一个演绎是构造命题公式的一个有限序列：\n$$ H_1, H_2, H_3, \\cdots, H_{n-1}, H_n $$\n其中，$H_i$ 或者是 $\\Gamma$ 中的某个前提，或者是前面的某些 $H_j(j \u0026lt; i)$ 的有效结论，并且 $H_n$ 就是 $H$，则称公式 $H$ 为该演绎的有效结论，或者称从前提 $\\Gamma$ 能够演绎出结论 $H$ 来。\n 直接证明法  规则 CP 证明法  间接证明法 间接证明法又叫反证法、归谬法。\n 反证法在逻辑推理中有时十分方便。反证法实际上是规则 CP 的一种变形，所以可以使用 CP 证明法来代替它。\n  谓词逻辑 对简单命题进行分解，利用个体词、谓词和量词来描述简单命题句子，从而研究其中的逻辑关系，并研究个体与总体的内在联系和数量关系。\n 个体词 在原子命题中，可以独立存在的客体（句子中的主语、宾语等），称为个体词。\n个体词可分为个体常量和个体变量，均在个体域内取值。\n 表示具体或特定的个体词称为个体常量。一般用带或不带下标的小写英文字母 $a, b, c, \\cdots, a_1, b_1, c_1, \\cdots$ 等表示。 表示抽象的或泛指的个体词称为个体变量。一般用带或不带下标的小写英文字母 $x, y, z, \\cdots, x_1, y_1, z_1, \\cdots$ 等表示。    个体词的取值范围称为个体域（或论域），常用 $D$ 表示。 宇宙间的所有个体域聚集在一起所构成的个体域称为全总个体域。无特别说明时，默认使用全总个体域。   谓词 在原子命题中，用以刻划客体的性质或客体之间的关系即是谓词。\n设 $D$ 为非空的个体域，定义在 $D^n$ 上取值为 ${0,1}$ 上的 $n$ 元函数，称为 $n$ 元命题函数或 $n$ 元谓词，记为 $P(x_1, x_2, \\cdots, x_n)$。其中，个体变量 $x_1, x_2, \\cdots, x_n \\in D$。\n 表示具体性质或关系的谓词称为谓词常量。 表示抽象的或泛指的性质或关系的谓词称为谓词变量。  谓词均使用大写英文字母 $P, Q, R, \\cdots, F, G, H, \\cdots$ 来表示。\n$D^n$ 表示 $n$ 个个体都在个体域 $D$ 上取值。\n 谓词中个体词的顺序不能随意变更。 一元谓词用以描述某一个个体的某种特性，而 $n$ 元谓词（$n \\ge 2$）则用以描述 $n$ 个个体之间的关系。 谓词 $P(x_1, x_2, \\cdots, x_n)$ 包含了个体变量，因而本身并不是命题，只有用谓词常量取代 $P$，用个体常量取代 $x_1, x_2, \\cdots, x_n$ 后才会称为命题。 一般将没有任何个体变量的谓词称为 0 元谓词（如，$F(a_1, a_2, \\cdots, a_n$）。当 $F$ 为谓词常量时，0 元谓词就成为命题。命题逻辑中的所有命题都可以表示成 0 元谓词。   量词  全称量词（$\\forall x$）：所有的 $x$；任意的 $x$；一切的 $x$；每一个 $x$；…… 存在量词（$\\exists x$）：有些 $x$；至少有一个 $x$；某一些 $x$；存在 $x$；……  其中的 $x$ 称为作用变量。一般将其量词加在其谓词之前，记为 $(\\forall x)F(x)$、$(\\exists x)F(x)$。此时，$F(x)$ 称为全称量词和存在量词的辖域。\n![16267650196113.jpg]\n引入更准确的表达方式：以上符号化必须要特别注明个体域，在表达比较复杂的命题时会容易混淆。\n其中，$T(x)$、$C(x)$、$H(x)$ 和 $N(x)$ 分别是各自个体变量的个性谓词。\n 统一一个全总个体域，而对每一个句子中个体变量的变化范围用一元特性谓词刻划之。这种特性谓词在加入到命题函数中时必定遵循如下原则：\n 对于全称量词（$\\forall x$），刻划其对应个体域的特性谓词作为蕴涵式的前件加入。 对于存在量词（$\\exists x$），刻划其对应个体域的特性谓词作为合取式的合取项加入。   谓词逻辑的真值  $(\\forall x)G(x)$：对 $\\forall x \\in D$，$G(x)$ 都成立。  $(\\forall x)G(x)$ 取值为 1 当且仅当对任意 $x \\in D$，$G(x)$ 都取值为 1； $(\\forall x)G(x)$ 取值为 0 当且仅当存在 $x_0 \\in D$，使得 $G(x_0)$ 取值为 0。   $(\\exists x)G(x)$：存在一个 $x_0 \\in D$（是有一个的意思，即可以存在一个以上，且包括一个），使得 $G(x_0)$ 成立。  $(\\exists x)G(x)$ 取值为 1 当且仅当存在 $x_0 \\in D$，使得 $G(x_0)$ 取值为 1； $(\\exists x)G(x)$ 取值为 0 当且仅当对任意 $x \\in D$，$G(x)$ 都取值为 0。    当个体域 $D = {x_0, x_1, \\cdots, x_n}$ 是有限集合时，\n $(\\forall x)G(x) = G(x_0) \\wedge G(x_1) \\wedge \\cdots \\wedge G(x_n)$； $(\\exists x)G(x) = G(x_0) \\vee G(x_1) \\vee \\cdots \\vee G(x_n)$。  注意：量词对变元的约束往往与量词的次序有关。不同的量词次序，可以产生不同的真值。因此当多个量词同时出现时，不能随意颠倒它们的顺序，否则会改变原有的含义。\n 谓词合式公式 在基于谓词的形式化中，将使用如下四种符号：\n 常量符号：指所属个体域 $D$ 中的某个元素，用带或不带下标的小写英文字母 $a, b, c, \\cdots, a_1, b_1, c_1, \\cdots$ 来表示。 变量符号：指所属个体域 $D$ 中的任意元素，用带或不带下标的小写英文字母 $x, y, z, \\cdots, x_1, y_1, z_1, \\cdots$ 来表示。 函数符号：$n$ 元函数符号 $f(x_1, x_2, \\cdots, x_n)$ 可以是所属个体域集合 $D^n \\rightarrow D$ 的任意一个函数，用带或不带下标的小写英文字母 $f, g, h, \\cdots, f_1, g_1, h_1, \\cdots$ 来表示。 谓词符号：$n$ 元谓词符号 $P(x_1, x_2, \\cdots, x_n)$ 可以是所属个体域集合 $D_n \\rightarrow {0, 1}$ 的任意一个谓词，用带或不带下标的大写英文字母 $P, Q, R, \\cdots, P_1, Q_1, R_1, \\cdots$ 来表示。  函数可用于表达个体词之间的转换关系，可以更方便地表示谓词逻辑中的个体词。\n$n$ 元函数是个体域集合 $D^n$ 到 $D$ 的映射。\n 项的定义 谓词逻辑中的项（Term），被递归地定义为：\n 任意的常量符号或任意的变量符号是项。 若 $f(x_1, x_2, \\cdots, x_n)$ 是 $n$ 元函数符号，$t_1, t_2, \\cdots, t_n$ 是项，则 $f(t_1, t_2, \\cdots, t_n)$ 是项。 仅由有限次使用以上两个规则产生的符号串才是项。   合式公式的定义 若 $P(x_1, x_2, \\cdots, x_n)$ 是 $n$ 元谓词， $t_1, t_2, \\cdots, t_n$ 是项，则称 $P(t_1, t_2, \\cdots, t_n)$ 为原子谓词公式，简称原子公式。\n 满足下列条件的表达式，称为合式公式（well-formed formulae/wff），简称公式。\n 原子公式是合式公式。 若 $G$、$H$ 是合式公式，则 $(\\neg G), (\\neg H), (G \\vee H), (G \\wedge H), (G \\rightarrow H), (G \\leftrightarrow H)$ 也是合式公式。 若 $G$ 是合式公式，$x$ 是个体变量，则 $(\\forall x)G$、$(\\exists x)G$ 也是合式公式。 由有限次使用以上三个规则产生的表达式是合式公式。    公式的最外层括号可省略。 量词后面的括号省略方式为：一个量词的辖域中仅出现一个原子公式，则此辖域的外层括号可省略，否则不能省略。 一个个体词只能接受一个量词的约束，否则就是没有意义的。   自由变元与约束变元 给定一个合式公式 $G$，若变元 $x$ 出现在使用变元的量词的辖域之内，则称变元 $x$ 的出现为约束出现，此时的变元 $x$ 称为约束变元。若 $x$ 的出现不是约束出现，则称它为自由出现，此时的变元 $x$ 称为自由变元。\n 若量词后有括号，则括号内的子公式就是该量词的辖域； 若量词后无括号，则与量词邻接的子公式为该量词的辖域。   为了区分同一公式中，变量符号相同但不是同为自由变元或约束变元的符号（这样的变量是不同的变量，仅是符号相同），可以分别使用不同的变量符号来表示。\n  约束变元的命名规则：\n 将量词中的变元以及该量词辖域中此变量的所有约束出现都用新的个体变元替换； 新的变元一定要有别于改名辖域中的其他变量。    自由变元的命名规则：\n  将公式中出现该自由变元的每一处都用新的个体变元替换；\n  新的变元不允许在源公式中以任何约束形式出现。\n也可用个体常量代入。但是代入个体常量后，公式的含义就发生了变化，即公式从具有普遍意义变为仅针对该个体变量有意义。\n     闭式 设 $G$ 是任意一个公式，若 $G$ 中无自由出现的个体变元，则称 $G$ 为封闭的合式公式，简称闭式。\n闭式是一个命题。\n 谓词逻辑公式的解释 谓词逻辑中，公式 $G$ 的每一个解释 $I$ 由如下四部分组成：\n 非空的个体域集合 $D$。 $G$ 中的每个常量符号，指定 $D$ 中的某个特定元素。 $G$ 中的每个 $n$ 元函数符号，指定 $D^n$ 到 $D$ 中的某个特定的函数。 $G$ 中的每个 $n$ 元谓词符号，指定 $D^n$ 到 ${0,1}$ 中的某个特定的谓词。  规定：公式中无自由变元，或将自由变元看成是常量符号。\n 谓词公式的分类   如果公式 $G$ 在它所有的解释下都取值为真，则称 $G$ 为有效公式。\n如 $(\\forall x)(\\forall y)(P(x, y) \\wedge Q(x, y) \\rightarrow P(x, y))$。\n  如果公式 $G$ 在它所有的解释下都取值为假，则称 $G$ 为矛盾公式。\n如，$(\\forall x)(\\forall y)(\\neg P(x, y) \\wedge P(x, y))$。\n  如果至少有一种解释使得公式 $G$ 取值为真，则称 $G$ 为可满足公式。\n   谓词公式的可判定性   一般情况下，谓词逻辑是不可判定的。\n  只含有一元谓词变项的公式是可判定的。\n  如下形式的公式：\n$(\\forall x_1) (\\forall x_2) \\cdots (\\forall x_n) P(x_1, x_2, \\cdots, x_n)$，\n$(\\exists x_1) (\\exists x_2) \\cdots (\\exists x_n) P(x_1, x_2, \\cdots, x_n)$。\n若 $P$ 中无量词和其他自由变元时，是可判定的。\n  个体域有穷时的谓词公式是可判定的。\n   谓词公式的等价关系 如果公式 $G \\leftrightarrow H$ 是有效公式，则公式 $G$、$H$ 称为等价的，记为 $G=H$。\n 设 $G(P_1, P_2, \\cdots, P_n)$ 是命题演算1中的命题公式，$P_1, P_2, \\cdots, P_n$ 是出现在 $G$ 中的命题变元，当用任意的谓词公式 $G_i(1\\le i \\le n)$ 分别代入 $P_i$ 后，得到的新谓词公式 $G(G_1, G_2, \\cdots, G_n)$​ 称为原公式的代入实例。\n定理：永真公式的任意一个代入实例必为有效公式。\n ##谓词演算中的基本等价公式\n命题演算中的基本等价公式在谓词演算中依然成立。\n   性质 等式     改名规则 (\\exists x)G(x) = (\\exists y)G(y)(\\forall x)G(x) = (\\forall y)G(y)   量词转换律or量词否定等价式 \\neg (\\exists x)G(x) = (\\forall x)G(x)\\neg (\\forall x) \\neg G(x) = (\\exists x) \\neg G(x)      命题公式、范式和推理都是针对命题演算，它们的对象都是命题。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-01-23T02:03:41+08:00","permalink":"https://blog.linner.asia/p/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/","title":"命题逻辑"},{"content":"经典字符串匹配 BF暴力匹配算法 暴力匹配，即Brute Force，简称BF算法。BF算法是一种简单朴素的模式匹配算法，常用于在一个主串S内查找一个子串T的出现位置。\n算法步骤 假设有主串S与子串P，主串S的长度为N，子串T的长度为M。\n 将S和T左对齐，并比较其第一个元素。 若匹配，则继续比较下一个元素，一直到第M个元素。 若不匹配则T向右移动一个位置。 接着根据步骤3和4进行比较，直到匹配到或者T移动了N-M且仍未匹配到。  代码实现 Python实现 实现1：\ndef BFMatch(s, p): if len(s) \u0026lt; len(p): return -1 i, j = 0, 0 # 匹配阶段 while i \u0026lt; len(s) and j \u0026lt; len(p): # 匹配，s和p的指针均向前一步 if s[i] == p[j]: i += 1 j += 1 # 不匹配，i后退到下一个要匹配的位置，j后头到p开头 else: i = i - j + 1 j = 0 if j == len(p): return i - j return -1 if __name__ == \u0026#34;__main__\u0026#34;: s = \u0026#34;abcdefghijkl\u0026#34; p = \u0026#34;ijk\u0026#34; result = BFMatch(s, p) if result == -1: print(\u0026#34;False\u0026#34;) else: print(result) 实现2：\ndef BFMatch(s, p): if len(s) \u0026lt; len(p): return -1 # 最多移动len(s)-len(p)+1次 # 如果s的前len(s)-len(p)+1个与p均没有匹配 # 那么直接判断为不匹配，无需比较后len(p)-1个 for i in range(len(s)-len(p)+1): index = i # 当前比较的字符 for j in range(len(p)): # 相等继续比较下一个 if s[index] == p[j]: index += 1 # 不相等停止比较 else: break # 如果完全相等，返回当前位置 if index - i == len(p): return i return -1 if __name__ == \u0026#34;__main__\u0026#34;: s = \u0026#34;abcdefghijkl\u0026#34; p = \u0026#34;ijk\u0026#34; result = BFMatch(s, p) if result == -1: print(\u0026#34;False\u0026#34;) else: print(result) C实现 #include \u0026lt;stdio.h\u0026gt; int BFMatch(char s[], int len_s, char p[], int len_p) { if (len_s \u0026lt; len_p) return -1; int i = 0, j = 0; // 之匹配s的前len_s-len_p+1个  // 如果s[len(s)-len(p)] != p[0]  // 那么就不用继续匹配  // i-j代表s与p对齐的位置  while (i-j \u0026lt;= len_s-len_p) { if (s[i] == p[j]) { i++; j++; if (j == len_p) return i - j; continue; } i = i - j + 1; j = 0; } return -1; } int main(void) { #define S \u0026#34;abcdefghijkl\u0026#34; #define P \u0026#34;ijk\u0026#34;  char s[sizeof(S)] = S; char p[sizeof(P)] = P; int result = BFMatch(s, sizeof(S)-1, p, sizeof(P)-1); if (result == -1) printf(\u0026#34;False\\n\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, result); return 0; }  KMP快速匹配算法 快速模式匹配算法，即Knuth Morris Pratt（简称KMP）算法，是解决字符串匹配问题的经典算法。\nKMP算法是在 BF 算法基础上改进得到的算法。BF算法的实现过程是用子串与主串中的字符一一配对，算法执行效率不高。对于主串S和子串P，BF算法如果遇到了不匹配的情况，主串S和子串P的指针都会回退，而且子串会回退到子串首部。KMP算法的实现过程接近人为进行模式匹配的过程。它只需回退子串，并且是根据情况回退，并不一定要回退到子串首部。\n算法步骤 假设有主串S与子串P，主串S的长度为N，子串T的长度为M。\n 求字串P的部分匹配表。 将S和T左对齐，并比较其第一个元素。 若匹配，则继续比较下一个元素，一直到第M个元素。 若不匹配，根据部分匹配表回退P的指针。 接着根据步骤3和4进行比较，直到匹配到或者T移动了N-M且仍未匹配到。  失配指针求解 让KMP尽量减少回移的关键在于，用一个部分匹配表（也称失配移动表）记录每次需要回退的位置。部分匹配表是一个与原字符串长度相等的整数数组。表中的元素是字符串中相对于元素的前缀集合和后缀集合的交集中的长度最大的字符串的\n假设一个长度为n的模式串为$P=a_0a_1\u0026hellip;a_{n-1}$，其中$a_i(0\\le i\u0026lt;n)$是单个字符， $Next[\\ n+1\\ ]$为其部分匹配表。\n那么对于$a_{i-1}$：\n  前缀集合：\n$$ P_1={a_0,a_0a_1,\\cdots,a_0\u0026hellip;a_{i-1}} $$\n  后缀集合：\n$$ P_2={a_{i-1},a_{i-2}a_{i-1},\\cdots,a_1\u0026hellip;a_{i-1}} $$\n  失配指针：\n$$ Next[i] = \\begin{cases} -1 \u0026amp; 当\\ i=0 时 \\ max \u0026amp; { k|0\u0026lt;k\u0026lt;j 且 \u0026ldquo;p_0\\cdots p_{k-1}\u0026rdquo; = \u0026ldquo;p_{j-k}\\cdots p_{j-1}\u0026rdquo; } \\ 0 \u0026amp; 其他情况 \\end{cases} $$\n即：\n $Next[0] = -1$； $Next[i] = maxLength(P_1 \\cap P_2),\\ i \\neq 0$。    过程代码演示：\ndef get_next_process(p, i, j, next_val): print(\u0026#34;第\u0026#34;, i + 1, \u0026#34;趟：\u0026#34;) print(p) if j != -1: for k in range(i - j): print(\u0026#34; \u0026#34;, end=\u0026#34;\u0026#34;) print(p) for k in range(i): print(\u0026#34; \u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;^\u0026#34;) if i == 0: print(\u0026#34;初始化\u0026#34;) print(next_val) def get_next(p): \u0026#34;\u0026#34;\u0026#34;求部分匹配表（失配指针）\u0026#34;\u0026#34;\u0026#34; i = 0 # 指向主串的指针 j = -1 # 指向模式串的指针，一开始 next_val = [-1] * len(p) # 要返回的next数组 get_next_process(p, i, j, next_val) # next[0]==-1，只需要求后面的len(p)-1个值即可 while i \u0026lt; len(p)-1: # 匹配成功，相同前缀长度增加1 if j == -1 or p[i] == p[j]: i += 1 j += 1 next_val[i] = j get_next_process(p, i, j, next_val) # 匹配不成功则在前面的子串中继续搜索，直至找不到 else: j = next_val[j] return next_val if __name__ == \u0026#34;__main__\u0026#34;: p = \u0026#34;abababc\u0026#34; get_next(p) 输出：\n第 1 趟： abababc 初始化 [-1, -1, -1, -1, -1, -1, -1] 第 2 趟： abababc abababc ^ [-1, 0, -1, -1, -1, -1, -1] 第 3 趟： abababc abababc ^ [-1, 0, 0, -1, -1, -1, -1] 第 4 趟： abababc abababc ^ [-1, 0, 0, 1, -1, -1, -1] 第 5 趟： abababc abababc ^ [-1, 0, 0, 1, 2, -1, -1] 第 6 趟： abababc abababc ^ [-1, 0, 0, 1, 2, 3, -1] 第 7 趟： abababc abababc ^ [-1, 0, 0, 1, 2, 3, 4] 代码实现 Python实现 def get_next(p): \u0026#34;\u0026#34;\u0026#34;求部分匹配表（失配指针）\u0026#34;\u0026#34;\u0026#34; i = 0 # 指向主串的指针 j = -1 # 指向模式串的指针 next_val = [-1] * len(p) # 要返回的next数组 # next[0]==-1，只需要求后面的len(p)-1个值即可 while i \u0026lt; len(p)-1 and j \u0026lt; len(p)-1: # 匹配成功，相同前缀长度增加1 if j == -1 or p[i] == p[j]: i += 1 j += 1 next_val[i] = j # 匹配不成功则在前面的子串中继续搜索，直至找不到 else: j = next_val[j] return next_val def KMP(s, p): if len(s) \u0026lt; len(p): return -1 i, j = 0, 0 # 求next数组 next = get_next(p) # 匹配阶段 while i \u0026lt; len(s) and j \u0026lt; len(p): if j == -1 or s[i] == p[j]: i += 1 j += 1 else: j = next[j] if j == len(p): return i - j return -1 if __name__ == \u0026#34;__main__\u0026#34;: s = \u0026#34;ababababca\u0026#34; p = \u0026#34;abababc\u0026#34; result = KMP(s, p) if result == -1: print(\u0026#34;False\u0026#34;) else: print(result) 优化代码：去除get_next()，边匹配边计算部分匹配表\ndef KMP(s, p): if len(s) \u0026lt; len(p): return -1 i, j = 0, 0 p_i, p_j = 0, -1 next = [-1] * len(p) # 边计算部分匹配表，边匹配 while i \u0026lt; len(s) and j \u0026lt; len(p): # 求部分匹配表 if p_i \u0026lt; len(p)-1: if p_j == -1 or p[p_i] == p[p_j]: p_i += 1 p_j += 1 next[p_i] = p_j else: p_j = next[p_j] # 匹配阶段 if j == -1 or s[i] == p[j]: i += 1 j += 1 else: j = next[j] if j == len(p): return i - j return -1 if __name__ == \u0026#34;__main__\u0026#34;: s = \u0026#34;ababababca\u0026#34; p = \u0026#34;abababc\u0026#34; result = KMP(s, p) if result == -1: print(\u0026#34;False\u0026#34;) else: print(result) C语言 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int KMP(char s[], int len_s, char p[], int len_p) { if (len_s \u0026lt; len_p) return -1; // 创建和初始化部分匹配表  int* next = (int*)malloc(len_p*sizeof(int)); for (int i = 0; i \u0026lt; len_p; i++) next[i] = -1; // 边计算部分匹配表，边匹配  int i = 0, j = 0, p_i = 0, p_j = -1; while (i \u0026lt; len_s \u0026amp;\u0026amp; j \u0026lt; len_p) { // 求部分匹配表  if (p_i \u0026lt; len_p-1) { if (p_j == -1 || p[p_i] == p[p_j]) { p_i++; p_j++; next[p_i] = p_j; } else p_j = next[p_j]; } // 匹配阶段  if (j == -1 || s[i] == p[j]) { i++; j++; } else j = next[j]; } free(next); if (j == len_p) return i - j; return -1; } #define LEN(S) sizeof(S)-1  int main(void) { #define S \u0026#34;ababababca\u0026#34; #define P \u0026#34;abababc\u0026#34;  char s[sizeof(S)] = S; char p[sizeof(P)] = P; int result = KMP(s, LEN(s), p, LEN(p)); if (result == -1) printf(\u0026#34;False\\n\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, result); return 0; } ","date":"2022-01-21T00:15:00Z","permalink":"https://blog.linner.asia/p/%E7%BB%8F%E5%85%B8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","title":"经典字符串匹配"},{"content":"临时变量 通过建立一个临时变量来实现两数交换：\ndef swap(x, y): print(x, y) tmp = x x = y y = tmp print(x, y) return x, y if __name__ == \u0026#39;__main__\u0026#39;: swap(1, 2) 缺点：\n需要消耗额外的内存。\n优点：\n不限制类型，大多数类型都能使用该操作。\n 加减交换 通过加减法实现：\ndef swap(x, y): print(x, y) x = x + y y = x - y x = x - y print(x, y) return x, y if __name__ == \u0026#39;__main__\u0026#39;: swap(1, 2) 假设两个数保存在x和y中：\n  先将y中的值加到x中。\n即这两个数一同保存在同一内存空间x中。\n  然后用x的值减去y的值，再将其保存到内存y中。\nx-y即为x最初的值。\n  最后再用x的值减去y的值，赋给内存x。\nx最初的值已经在y中，所以x-y的值为y最初的值。\n  缺点：\n该方法只适用于数值不大的数，如果数值过大，可能会越界（对于某些语言来说）。\n 异或交换 通过异或的操作实现：\ndef swap(x, y): print(x, y) x = x ^ y y = x ^ y x = x ^ y print(x, y) return x, y if __name__ == \u0026#39;__main__\u0026#39;: swap(1, 2) 缺点：\n只能对整数类型执行位操作，不能对实数类型进行位操作。\n","date":"2022-01-16T00:00:00Z","permalink":"https://blog.linner.asia/p/%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/","title":"两数交换算法"},{"content":"Python 语法 注释 Python 的注释风格：\n# 行注释 \u0026#39;\u0026#39;\u0026#39; 块注释1 \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; 块注释2 \u0026#34;\u0026#34;\u0026#34; 注释中的内容将不会被执行。\n 标识符   首字母必须是大写或小写的英文字母或者下划线 _。\n  其他部分由大写或小写的英文字母、数字和下划线组成。\n  大小写敏感（区分大小写）。\n  Python3 中允许使用非 ASCII 标识符，即中文也可作为标识符：\n\u0026gt;\u0026gt;\u0026gt; 变量 = 5 \u0026gt;\u0026gt;\u0026gt; print(变量) 5  关键字 Python 关键字（keyword）不能作为标识符使用，关键字又称保留字。\n使用 keyword 模块输出 Python 的所有关键字：\n\u0026gt;\u0026gt;\u0026gt; import keyword \u0026gt;\u0026gt;\u0026gt; print(keyword.kwlist) [\u0026#39;False\u0026#39;, \u0026#39;None\u0026#39;, \u0026#39;True\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;as\u0026#39;, \u0026#39;assert\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;continue\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;elif\u0026#39;, \u0026#39;else\u0026#39;, \u0026#39;except\u0026#39;, \u0026#39;finally\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;lambda\u0026#39;, \u0026#39;nonlocal\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;or\u0026#39;, \u0026#39;pass\u0026#39;, \u0026#39;raise\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;try\u0026#39;, \u0026#39;while\u0026#39;, \u0026#39;with\u0026#39;, \u0026#39;yield\u0026#39;]  变量的赋值 Python 中的变量并不需要声明，直接赋值后就可使用。还可以同时为多个变量赋值。\npai, e = 3.14, 2.72 a = b = c = 1  代码规范 Python 代码中的所有块都是使用空格缩进来表示。同一块中的所有语句都必须包含相同的缩进空格数，一般使用 4 个空格作为缩进，并且最好在代码编辑器中设置将 Tab 转化为空格。\ntotal = 0 # 输出数字 1~9 的平方数 for n in range(1, 10): # 块的开始 square = n * n total += square print(square) # 块的结束 # 输出数字 1~9 的所有平方数的总和 print(total) 缩进相同的一组语句构成一个代码块，或称之为代码组。\n 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n空行是程序代码的一部分，但并不是 Python 语法的一部分。空行的作用在于分割两段不同功能或含义的代码，便于日后代码的维护或重构，有无空行并不影响程序运行。\n 反斜杠 \\ 作为续行符，表示下一行是上一行的延续。对于过长的语句，Python 使用反斜杠、换行再加上缩进来将长语句分为多行。\ntotal = item_one + \\ item_two + \\ item_three 在 [],{}, 或 () 中的多行语句，不需要使用反斜杠 \\ 来换行。\ntotal = [\u0026#39;item_one\u0026#39;, \u0026#39;item_two\u0026#39;, \u0026#39;item_three\u0026#39;, \u0026#39;item_four\u0026#39;, \u0026#39;item_five\u0026#39;]  Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割。\n\u0026gt;\u0026gt;\u0026gt; str = \u0026#39;123\u0026#39;; print(str) 123  标准数据类型 Python 支持 6 种基本数据类型：\n  Number —— 数字类型\n  String —— 字符串类型\n  List —— 列表\n  Tuple —— 元组\n  Set —— 集合\n  Dictionary —— 字典\n  List、Dictionary、Set 是 Python 内置的数据结构。\nPython 变量分为可变和不可变数据类型，以下是它们的定义：\n  不可变（immutable）数据类型：当该数据类型对应的变量的值发生了改变，它对应的内存地址也会发生改变（重新分配内存空间），如 Number、String、Tuple。即，数据中的元素不能被更改。\n# 测试 Number 类型是否是不可变数据类型 n = 1 # 赋值 print(id(n), type(n)) n = 2 # 改变值 print(id(n), type(n)) # 可能输出： # 1562536992 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; # 1562537024 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;   可变（mutable）数据类型：当该数据类型对应的变量的值发生了改变，它对应的内存地址不发生改变，如 List、Dictionary、Set。即，数据中的元素可以被更改。\n  可迭代对象：List、Tuple、Set 、 Dictionary 和 String。\n Number类型 Python 支持的数字类型：\n  int —— 整数类型。\n  float —— 浮点数类型（实数类型），如 3.14、3E-2。\n  bool —— 布尔类型（True 和 False）。\n  complex —— 复数类型，如 1.1 + 2.2j、complex(a, b)。\n  Python 2 中有 long 型，Python 3 中没有。\n 数字函数 数字函数需要导入 math 模块：import math\n   函数 描述     abs(x) 返回数字 x（可以是复数）的绝对值（内置函数，不用导入 math 模块）。   ceil(x) 返回数字 x 的上入整数（向上取整）。   cmp(x, y) 如果 x \u0026lt; y 返回 -1，如果 x == y 返回 0，如果 x \u0026gt; y 返回 1。 Python 3 已废弃，使用 (x\u0026gt;y)-(x\u0026lt;y) 替换。   exp(x) 返回 e 的 x 次幂 $e^x$。   fabs(x) 返回数字 x（不能是复数）的绝对值。   floor(x) 返回数字的下舍整数（向下取整）。   log(x[, y]) log(x) —— 返回 x 的自然对数； log(x, y) —— 返回以 y 为基数的 x 的对数：$\\log_y{x}$。   log10(x) 返回以 10为基数的 x 的对数。   max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。   min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。   modf(x) 返回 x 的整数部分与小数部分，两部分的数值符号与 x 相同，整数部分以浮点型表示。   pow(x, y[, z]) pow(x, y) —— x**y 运算后的值； pow(x, y, z) —— 相当于 pow(x, y) % z。 通过内置方法调用，会把参数作为整型，而 math 会把参数转换为 float。   round(x [, n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。 其实准确的说是保留值将保留到离上一位更近的一端。   sqrt(x) 返回数字 x 的平方根。     String类型 Python 的字符串（String）有以下特点：\n  字符串常量可以使用单引号 ' 和双引号 \u0026quot; 指定。\n\u0026gt;\u0026gt;\u0026gt; str1 = \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; str2 = \u0026#39;World\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(str1, str2, \u0026#39;!\u0026#39;) Hello World ! \u0026gt;\u0026gt;\u0026gt; str1 = \u0026#39;打印 \u0026#34;双引号\u0026#34; \u0026#39; \u0026gt;\u0026gt;\u0026gt; str1 += \u0026#34;要用 \u0026#39;单引号\u0026#39; 将其括起来\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(str1) 打印 \u0026#34;双引号\u0026#34; 要用 \u0026#39;单引号\u0026#39; 将其括起来   使用三个引号可指定一个多行字符串常量。\n\u0026gt;\u0026gt;\u0026gt; str1 = \u0026#34;\u0026#34;\u0026#34;这是一个段落， ... 可以由多行组成\u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(str1) 这是一个段落， 可以由多行组成   转义符用 \\ 开头。单个反斜杠依然可以作为续行符。\n\u0026gt;\u0026gt;\u0026gt; str = \u0026#39;str\\ ... ing\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(str) string   使用 r 或 R 可以让反斜杠不发生转义。这样的字符串被称为原始字符串。\n\u0026gt;\u0026gt;\u0026gt; print(r\u0026#34;this is a line with \\n\u0026#34;) this is a line with \\n   按字面意义级联字符串。\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;this \u0026#39; \u0026#39;is \u0026#39; \u0026#39;string\u0026#39;) this is string   字符串可以用 + 运算符连接在一起，用 * 运算符重复。\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;this \u0026#39; + \u0026#39;is \u0026#39; + \u0026#39;string\u0026#39;) this is string \u0026gt;\u0026gt;\u0026gt; str = \u0026#39;Hello World!\u0026#39; * 3 \u0026gt;\u0026gt;\u0026gt; print(str) Hello World!Hello World!Hello World!   有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。\n  字符串的截取的语法格式：变量[头下标:尾下标:步长]。字符串被截取后返回一个包含所需字符的新字符串。遵循左闭右开原则。\n尾下标从 1 开始。\n步长是指输出字符串中第 $n$ 个字符后，接着输出第 $(n + 步长)$ 个字符，直至到达尾下标指定处。\n省略步长代表按字符串顺序输出，省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。\n\u0026gt;\u0026gt;\u0026gt; str=\u0026#39;123456789\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(str[0]) # 输出字符串第一个字符 1 \u0026gt;\u0026gt;\u0026gt; print(str[2:5]) # 输出从第三个开始到第五个的字符 345 \u0026gt;\u0026gt;\u0026gt; print(str[0:-1]) # 输出第一个到倒数第二个的所有字符 12345678 \u0026gt;\u0026gt;\u0026gt; print(str[2:]) # 输出从第三个开始后的所有字符 3456789 \u0026gt;\u0026gt;\u0026gt; print(str[:3]) # 输出从第一个开始到第三个的字符 123 \u0026gt;\u0026gt;\u0026gt; print(str[1:5:2]) # 输出从第二个开始到第五个且每隔一个的字符（步长为2） 24 \u0026gt;\u0026gt;\u0026gt; print(str[:]) # 同时省略头下标和尾，创建了一个str的副本   字符串不能改变。即，字符串的切片不能被赋值。\n\u0026gt;\u0026gt;\u0026gt; str = \u0026#39;string\u0026#39; \u0026gt;\u0026gt;\u0026gt; str[0] = \u0026#39;S\u0026#39; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;str\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt; str = \u0026#39;string\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(str) string \u0026gt;\u0026gt;\u0026gt; str = \u0026#39;String\u0026#39; # 修改字符串只能重新进行赋值 \u0026gt;\u0026gt;\u0026gt; print(str) String   Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n  在Python2中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 unicode 字符串。使用的语法是在字符串前面加上前缀 u。\n在Python3中，所有的字符串都是 Unicode 字符串。\n 转义符    转义字符 描述     \\（在代码行尾时） 续行符。   \\\\ 反斜杠符号。   \\' 单引号。   \\\u0026quot; 双引号。   \\a 响铃 print(\u0026quot;\\a\u0026quot;)执行后电脑有响声。   \\b 退格（Backspace）。   \\000 空。   \\n 换行。   \\v 纵向制表符。   \\t 横向制表符。   \\r 回车，将 \\r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \\r 后面的内容完全替换完成。   \\f 换页。   \\yyy 八进制数，y 代表 0~7 的字符，如 \\012 代表换行。   \\xyy 十六进制数，以 \\x 开头，y 代表的字符，例 \\x0a 代表换行。   \\other 其它的字符以普通格式输出。     格式化字符串 print() 函数能够使用 % 来进行格式化字符串的输出。例如：\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;%e\u0026#39; % 3.14) 3.140000e+00 字符串格式化符号：\n   符 号 描述     %c 格式化字符及其 ASCII 码。   %s 格式化字符串。   %d 格式化整数。   %u 格式化无符号整型。   %o 格式化无符号八进制数。   %x 格式化无符号十六进制数。   %X 格式化无符号十六进制数（大写）。   %f 格式化浮点数字，可指定小数点后的精度。   %e 或 %E 用科学计数法格式化浮点数。 %e 中显示的字母为小写，%E 则为大写。   %g %f和%e的简写。   %G %f 和 %E 的简写。   %p 用十六进制数格式化变量的地址。    格式化操作符辅助符号：\n   符号 功能     * 定义宽度或者小数点精度。   - 用做左对齐。   + 在正数前面显示加号。   \u0026lt;sp\u0026gt; 在正数前面显示空格。   # 在八进制数前面显示零 '0'，在十六进制前面显示 '0x' 或者 '0X'（取决于用的是 'x' 还是 'X'）。   0 显示的数字前面填充 '0' 而不是默认的空格。   % '%%' 输出一个单一的 '%'。   (var) 映射变量(字典参数)。   m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)。    辅助符号在格式字符串 % 和符号中间使用，如需指定其它参数需要在字符串后的 % 使用括号 () 指定参数和要显示的值。如：\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;%*d\u0026#39; % (10, 2)) 2  f-string f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。f-string格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去。\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#39;World!\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#39;Hello {name}\u0026#39; # 替换变量 \u0026#39;Hello World!\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#39;{1+2}\u0026#39; # 使用表达式 \u0026#39;3\u0026#39;  str.format() str.format() 是用于格式化字符串的字符串方法。旧式的格式化最终会从该语言中移除，应该更多的使用 str.format()。\nformat() 将 str 中的格式化字段（{} 及其里面包含的字符）替换为 format() 中的参数。它的用法如下：\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;{}and {}\u0026#39;.format(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)) # 按照参数顺序 a and b \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;{1}and {0}\u0026#39;.format(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)) # 指定参数位置（从 0 开始） b and a \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;{}and {b}\u0026#39;.format(\u0026#39;a\u0026#39;, b = \u0026#39;b\u0026#39;)) # 指定关键字 a and b !a（使用 ascii())，!s（使用 str()）和 !r（使用 repr()）可以用于在格式化某个值之前对其进行转化：\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;常量 PI 的值近似为： {}。\u0026#39;.format(math.pi)) 常量 PI 的值近似为： 3.141592653589793。 \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;常量 PI 的值近似为： {!r}。\u0026#39;.format(math.pi)) 常量 PI 的值近似为： 3.141592653589793。 可以使用 :，在右边指定输出形式，在 : 左边的是 format() 参数位置：\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;常量 PI 的值近似为 {0:.3f}。\u0026#39;.format(math.pi)) 常量 PI 的值近似为 3.142。 在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。\n\u0026gt;\u0026gt;\u0026gt; table = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; for name, number in table.items(): ... print(\u0026#39;{0:10}==\u0026gt; {1:10d}\u0026#39;.format(name, number)) ... a ==\u0026gt; 1 b ==\u0026gt; 2 c ==\u0026gt; 3 传入一个字典，然后使用方括号 [] 来访问键值：\n\u0026gt;\u0026gt;\u0026gt; table = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;b: {0[b]:d}; a: {0[a]:d}; c: {0[c]:d}\u0026#39;.format(table)) b: 2; a: 1; c: 3 也可以通过在变量前使用 ** 来实现相同的功能：\n\u0026gt;\u0026gt;\u0026gt; table = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;b: {b:d}; a: {a:d}; c: {c:d}\u0026#39;.format(**table)) b: 2; a: 1; c: 3  字符串方法    方法 说明     str.capitalize() 将字符串的第一个字符转换为大写。   str.center(width[, fillchar]) 返回一个指定的宽度 width 居中的字符串。 fillchar 为填充的字符，默认为空格。   str.count(sub[, start= 0, end=len(string)]) 返回 sub 在 str 的指定范围里面出现的次数。 sub —— 搜索的子字符串。 start —— 字符串开始搜索的位置。默认为第一个字符（索引为 0）。 end —— 字符串中结束搜索的位置。默认为字符串的最后一个位置。   str.encode(encoding='UTF-8',errors='strict') 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是 'ignore' 或者 'replace'。   bytes.decode(encoding=\u0026quot;utf-8\u0026quot;, errors=\u0026quot;strict\u0026quot;) 以指定的编码格式解码 bytes 对象。 encoding —— 要使用的编码，默认为 \u0026quot;utf-8\u0026quot;。 errors —— 设置不同错误的处理方案。默认为 \u0026quot;strict\u0026quot;，意为编码错误引起一个 UnicodeError。 其他可能的值有 \u0026quot;ignore\u0026quot;，\u0026quot;replace\u0026quot;，\u0026quot;xmlcharrefreplace\u0026quot;，\u0026quot;backslashreplace\u0026quot; 以及通过 codecs.register_error() 注册的任何值。 Python3 中没有 decode() 方法，但可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回↩。   str.endswith(suffix[, start=0, end=len(string)]) 检查字符串指定范围是否以 suffix 结束，如果是，返回 True，否则返回 False。 suffix —— 可以是一个字符串或者是一个元素。 start —— 指定的开始位置。默认为字符串第一个字符（索引为 0）。 end —— 指定的结束位置。默认为字符串的最后一个字符。   str.expandtabs(tabsize=8) 把字符串 str 中的 Tab 符号 \\t 转为空格。 tabsize —— Tab 符号的长度，默认为 8。   str.find(sub[, beg=0, end=len(str)]) 检测 sub 是否包含在字符串 str 的指定范围中，如果包含则返回开始的索引值，否则返回 -1。 sub —— 字符串。 beg —— 指定的开始位置。默认为字符串第一个字符（索引为 0）。 end —— 指定的结束位置。默认为字符串的最后一个字符。   str.index(sub[, beg=0, end=len(string)]) 同 find()方法一样，只不过如果 sub 不在字符串中会报一个异常。   str.isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False。   str.isalpha() 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False。   str.isdigit() 如果字符串只包含数字则返回 True，否则返回 False。   str.islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False。   str.isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False。   str.isspace() 如果字符串中只包含空白，则返回 True，否则返回 False。   str.istitle() 如果字符串是标题化的（见 title()），则返回 True，否则返回 False。   str.isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False。   str.join(sequence) 字符串 str 作为分隔符，将 sequence 中所有的元素（的字符串表示）合并为一个新的字符串。   len(string) 返回字符串长度。   str.ljust(width[, fillchar]) 返回一个原字符串左对齐，并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。如果指定的长度小于原字符串的长度则返回原字符串。   str.lower() 转换字符串中所有大写字符为小写。   str.lstrip([chars]) 截掉字符串左边的空格或指定字符。 chars —— 指定截取的字符。   str.maketrans(intab, outtab) 创建字符映射的转换表。↩intab —— 字符串，表示需要转换的字符。 outtab —— 字符串表示转换的目标。   max(str) 返回字符串 str 中最大的字母。   min(str) 返回字符串 str 中最小的字母。   str.replace(old, new[, max]) 将字符串中的 old 替换成 new，如果 max 指定，则替换不超过 max 次。   str.rfind(sub[, beg=0,end=len(string)]) 类似于 find() 函数，不过是从右边开始查找。即，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。   str.rindex(sub[, beg=0, end=len(string)]) 类似于 index()，不过是从右边开始。即，返回子字符串 sub 在字符串中最后出现的位置，如果没有匹配的字符串会报异常。   str.rjust(width[, fillchar]) 返回一个原字符串右对齐，并使用 fillchar（默认空格）填充至长度 width 的新字符串。   str.rstrip([chars]) 删除字符串末尾的指定字符 chars，默认为空格。   str.split([str1=\u0026quot;\u0026quot;, num=string.count(str1)]) 以参数 str1 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串↩。   str.splitlines([keepends]) 按照行（'\\r'，'\\r\\n'，\\n'）分隔，返回一个包含各行作为元素的列表。如果参数 keepends 为 False，返回的列表则不包含换行符；如果为 True，则保留换行符。   str.startswith(substr[, beg=0, end=len(string)]) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果 beg 和 end 指定值，则在指定范围内检查。   str.strip([chars]) 在字符串上执行 lstrip() 和 rstrip()。即移除字符串头尾指定的字符 chars（默认为空格）。   str.swapcase() 将字符串中大写转换为小写，小写转换为大写。   str.title() 返回 “标题化” 的字符串，即转化为所有单词都是以大写开始，其余字母均为小写的形式。   str.translate(table[, deletechars=\u0026quot;\u0026quot;]) 根据 str 给出的表（包含 256 个字符）转换 str 的字符，要过滤掉的字符放到 deletechars 参数中。   str.upper() 转换字符串中的小写字母为大写。   str.zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充 0。   str.isdecimal() 检查字符串是否只包含十进制字符（只存在于 unicode 对象。），如果是返回 True，否则返回 False。    encode() 和 decode() 用法实例：\n\u0026gt;\u0026gt;\u0026gt; str = \u0026#34;Hello World!\u0026#34;; \u0026gt;\u0026gt;\u0026gt; str_utf8 = str.encode(\u0026#34;UTF-8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; str_gbk = str.encode(\u0026#34;GBK\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(str) Hello World! \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;UTF-8 编码：\u0026#34;, str_utf8) UTF-8 编码： b\u0026#39;Hello World!\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;GBK 编码：\u0026#34;, str_gbk) GBK 编码： b\u0026#39;Hello World!\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;UTF-8 解码：\u0026#34;, str_utf8.decode(\u0026#39;UTF-8\u0026#39;,\u0026#39;strict\u0026#39;)) UTF-8 解码： Hello World! \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;GBK 解码：\u0026#34;, str_gbk.decode(\u0026#39;GBK\u0026#39;,\u0026#39;strict\u0026#39;)) GBK 解码： Hello World! maketrans() 的用法：\n\u0026gt;\u0026gt;\u0026gt; intab = \u0026#34;aeiou\u0026#34; \u0026gt;\u0026gt;\u0026gt; outtab = \u0026#34;12345\u0026#34; \u0026gt;\u0026gt;\u0026gt; trantab = str.maketrans(intab, outtab) \u0026gt;\u0026gt;\u0026gt; str = \u0026#34;this is string example....wow!!!\u0026#34; \u0026gt;\u0026gt;\u0026gt; print (str.translate(trantab)) th3s 3s str3ng 2x1mpl2....w4w!!! split() 的用法：\n\u0026gt;\u0026gt;\u0026gt; str = \u0026#34;this is string example....wow!!!\u0026#34; \u0026gt;\u0026gt;\u0026gt; print (str.split( )) # 以空格为分隔符 [\u0026#39;this\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;string\u0026#39;, \u0026#39;example....wow!!!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print (str.split(\u0026#39;i\u0026#39;,1)) # 以 i 为分隔符 [\u0026#39;th\u0026#39;, \u0026#39;s is string example....wow!!!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print (str.split(\u0026#39;w\u0026#39;)) # 以 w 为分隔符 [\u0026#39;this is string example....\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;!!!\u0026#39;]  byte样式字符串 在字符串前面加上字符 b，可以得到该字符串的字节类型对象：\nb\u0026#39;Hello World!\u0026#39; 使用 16 进制 ASCII 码赋值：\n\u0026gt;\u0026gt;\u0026gt; b\u0026#39;\\x48\\x65\\x6C\\x6C\\x20\\x57\\x6F\\x72\\x6C\\x64\\x21\u0026#39; b\u0026#39;Hell World!\u0026#39; \u0026gt;\u0026gt; b\u0026#34;\\x01\\x02\\x03\u0026#34; b\u0026#39;\\x01\\x02\\x03\u0026#39; Python 会自动将可读的部分按照转换为文字。如果数据是不可读的，则使用 16 进制来表示。\nbyte 对象的元素是字节：\n\u0026gt;\u0026gt;\u0026gt; bt = b\u0026#39;Hello World!\u0026#39; \u0026gt;\u0026gt;\u0026gt; bt[2] 108 可以使用 bin() 查看每个字节在内存中的存储方式：\n\u0026gt;\u0026gt;\u0026gt; bin(bt[2]) \u0026#39;0b1101100\u0026#39; 除字面量表示之外，还可以用 bytes() 函数来得到字节类型。\n List 列表（List）由一系列按特定顺序排列的元素组成，它是写在方括号 [] 之间、用逗号分隔开的元素列表。列表其实更像是 Python 中的线性数据结构的实现，它具有绝大多数常见的线性数据结构的操作。\n  列表中元素的类型可以不相同，它支持数字，字符串，甚至可以包含列表（嵌套）。\n\u0026gt;\u0026gt;\u0026gt; list = [1, \u0026#39;2\u0026#39;, 3.4, [5, 6], (7, 8), {9, 10}] \u0026gt;\u0026gt;\u0026gt; print(list) [1, \u0026#39;2\u0026#39;, 3.4, [5, 6], (7, 8), {9, 10}]   有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。\n  列表的截取的语法格式：变量[头下标:尾下标:步长]。遵循左闭右开原则。\n尾下标从 1 开始。\n步长是指输出字符串中第 $n$ 个元素后，接着输出第 $(n + 步长)$ 个元素，直至到达尾下标指定处。\n省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。\n\u0026gt;\u0026gt;\u0026gt; list = [1, \u0026#39;2\u0026#39;, 3.4, [5, 6], (7, 8), {9, 10}] \u0026gt;\u0026gt;\u0026gt; print (list[0]) # 输出列表第一个元素 1 \u0026gt;\u0026gt;\u0026gt; print (list[1:3]) # 从第二个开始输出到第三个元素 [\u0026#39;2\u0026#39;, 3.4] \u0026gt;\u0026gt;\u0026gt; print (list[2:]) # 输出从第三个元素开始的所有元素 [3.4, [5, 6], (7, 8), {9, 10}] \u0026gt;\u0026gt;\u0026gt; print(list[:]) # 同时省略头下标和尾，创建了一个list的副本 \u0026gt;\u0026gt;\u0026gt; tinylist = [123, \u0026#39;list\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print (list + tinylist) # 连接列表 [1, \u0026#39;2\u0026#39;, 3.4, [5, 6], (7, 8), {9, 10}, 123, \u0026#39;list\u0026#39;] \u0026gt;\u0026gt;\u0026gt; double = tinylist * 2 # 重复列表 \u0026gt;\u0026gt;\u0026gt; print(double) [123, \u0026#39;list\u0026#39;, 123, \u0026#39;list\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print(list[::-1]) # 步长为-1，表示逆向 [{9, 10}, (7, 8), [5, 6], 3.4, \u0026#39;2\u0026#39;, 1] \u0026gt;\u0026gt;\u0026gt; list[len(list):] = [6] # 在列表末尾插入元素 \u0026gt;\u0026gt;\u0026gt; print(list) [1, \u0026#39;2\u0026#39;, 3.4, [5, 6], (7, 8), {9, 10}, 6]   列表中的元素是可更改的，并且列表长度也是可改变的。List 内置了许多方法来支持这种特性。\n\u0026gt;\u0026gt;\u0026gt; list = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; list[1] = 6 \u0026gt;\u0026gt;\u0026gt; print(list) [1, 6, 3]   列表可以用 + 运算符拼接，用 * 运算符重复。\n\u0026gt;\u0026gt;\u0026gt; list1 = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; list2 = [4, 5, 6] \u0026gt;\u0026gt;\u0026gt; list = list1 + list2 \u0026gt;\u0026gt;\u0026gt; print(list) [1, 2, 3, 4, 5, 6] \u0026gt;\u0026gt;\u0026gt; list = list1 * 2 \u0026gt;\u0026gt;\u0026gt; print(list) [1, 2, 3, 1, 2, 3]   虽然列表和字符串有一些特性很相似，但它们是两个完全不同的类型。\n删除列表或列表元素：\n\u0026gt;\u0026gt;\u0026gt; list = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; del list[3] \u0026gt;\u0026gt;\u0026gt; print(list) [1, 2, 3]  列表方法    方法 说明     list.append(obj) 在列表末尾添加新的对象 obj，无返回值。相当于 list[len(list):] = [x]   list.count(obj) 返回 obj 在列表中出现的次数。   list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。 seq —— 元素列表，可以是列表、元组、集合、字典，若为字典，则仅会将键（key）作为元素依次添加至原列表的末尾。   list.index(x[, start[, end]]) 从列表中找出某个值第一个匹配项的索引位置。如果没有找到对象则抛出异常。 x—— 查找的对象； start —— 可选，查找的起始位置； end —— 可选，查找的结束位置。   list.insert(index, obj) 将对象插入列表，无返回值。 index —— 对象 obj 需要插入的索引位置； obj —— 要插入列表中的对象。   list.pop([index=-1]) 移除列表中 index 指定的元素（默认最后一个元素），并且返回该元素的值。   list.remove(obj) 移除列表中值与 obj 相同的第一个匹配项，无返回值。   list.reverse() 反向列表中元素。   list.sort(key=None, reverse=False) 对原列表进行排序。 key —— 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序；↩ reverse —— 排序规则，reverse = True 降序， reverse = False 升序（默认）。   list.clear() 清空列表，类似于 del list[:]。   list.copy() 返回复制后的新列表，类似于 list[:]。    list.sort() 指定排序元素：\n# 获取列表的第二个元素 def takeSecond(elem): return elem[1] # 列表 random = [(2, 2), (3, 4), (4, 1), (1, 3)] # 指定第二个元素排序 random.sort(key=takeSecond) # 输出类别 print (\u0026#39;排序列表：\u0026#39;, random) # 输出：排序列表：[(4, 1), (2, 2), (1, 3), (3, 4)] Python 列表的特性可以很方便地将其封装成其他线性数据结构。\n 列表推导式 列表推导式是指在方括号 [] 中使用 for 语句生成一串序列，这个 for 语句可以有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。\n\u0026gt;\u0026gt;\u0026gt; [x**2 for x in range(10)] [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \u0026gt;\u0026gt;\u0026gt; [str(round(355/113, i)) for i in range(1, 6)] [\u0026#39;3.1\u0026#39;, \u0026#39;3.14\u0026#39;, \u0026#39;3.142\u0026#39;, \u0026#39;3.1416\u0026#39;, \u0026#39;3.14159\u0026#39;]  Tuple 元组（tuple）与列表类似，不同之处在于元组的元素可修改。元组写在小括号 () 里，元素之间用逗号隔开。\n  元素的类型可以不相同。\n  元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用。\n  有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。\n  列表的截取的语法格式：变量[头下标:尾下标:步长]。遵循左闭右开原则。\n  元组元素不可修改是指元组中每个元素的指向永远不变。 无法对元组的元素进行增删操作，但并非所有类型的元素都不可修改。\n  对于不可变数据类型的元素，的确不能修改。\n  对于可变数据类型的元素，可以按照其规则修改。\n\u0026gt;\u0026gt;\u0026gt; tuple = (1, [1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; print(tuple) (1, [1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; tuple[1][0] = 2 \u0026gt;\u0026gt;\u0026gt; print(tuple) (1, [2, 2, 3])     可以用 + 运算符拼接，用 * 运算符重复。\n  元组的某些操作可以参照列表，除了增加和删除元素的操作。\n 元组支持推导式：\n\u0026gt;\u0026gt;\u0026gt; tuple(x**2 for x in range(10)) (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)  Set 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。集合的基本功能是进行成员关系测试和删除重复元素。可以使用大括号 {} 或者构造函数 set() 创建集合。\n  集合是一个无序不重复元素的集。\n  元素的类型可以不相同。\n  元素是可更改的。\n  创建空集：\n使用不带参数的构造函数 set() 创建，不可使用 {} 创建（{} 代表空字典）。\n\u0026gt;\u0026gt;\u0026gt; s = set() \u0026gt;\u0026gt;\u0026gt; print(s) set()   不包含多余的重复元素。在集合中，不会多次出现的相同元素。\n  不可使用索引或截取等操作。\n  可以使用集合运算。\n\u0026gt;\u0026gt;\u0026gt; set1 = {1, 2, 3, 4, 5, 7} \u0026gt;\u0026gt;\u0026gt; set2 = {2, 4, 6, 7, 8} \u0026gt;\u0026gt;\u0026gt; print(set1 - set2) # set1 和 set2 的差集 {1, 3, 5} \u0026gt;\u0026gt;\u0026gt; print(set1 | set2) # set1 和 set2 的并集 {1, 2, 3, 4, 5, 6, 7, 8} \u0026gt;\u0026gt;\u0026gt; print(set1 \u0026amp; set2) # set1 和 set2 的交集 {2, 4, 7} \u0026gt;\u0026gt;\u0026gt; print(set1 ^ set2) # set1 和 set2 的对称差集 {1, 3, 5, 6, 8}    集合支持推导式：\n\u0026gt;\u0026gt;\u0026gt; {x**2 for x in range(10)} {0, 1, 64, 4, 36, 9, 16, 49, 81, 25}  集合的成员测试：\navengers = {\u0026#39;captain america\u0026#39;, \u0026#39;iron man\u0026#39;, \u0026#39;thor\u0026#39;, \u0026#39;doctor strange\u0026#39;, \u0026#39;star-Lord\u0026#39;, \u0026#39;hulk\u0026#39;, \u0026#39;black widow\u0026#39;, \u0026#39;black panther\u0026#39;, \u0026#39;spider man\u0026#39;} if \u0026#39;spider man\u0026#39; in avengers: print(\u0026#39;蜘蛛侠是复仇者\u0026#39;) else: print(\u0026#39;蜘蛛侠不是复仇者\u0026#39;) if \u0026#39;thanos\u0026#39; in avengers: print(\u0026#39;灭霸是复仇者\u0026#39;) else: print(\u0026#39;灭霸不是复仇者\u0026#39;)  集合方法    方法 描述     set.add() 为集合添加元素。   set.clear() 移除集合中的所有元素。   set.copy() 拷贝一个集合。   set.difference(set1, set2, ...) 返回集合 $(set - set1)\\cap(set - set2)\\cap\\cdots$。   set.difference_update(set1, set2, ...) 移除集合 set 中的元素，该元素在指定的集合 set1, set2, ... 也存在。 即，将集合 set 更新为集合 $(set - set1)\\cap(set - set2)\\cap\\cdots$。   set.discard(value) 删除集合 set 中指定的元素 value。 与 remove() 不同的是，如果 value 不存在 set 中，并不会发生错误。   set.intersection(set1, set2, ...) 返回集合 $set \\cap set1 \\cap set2 \\cap \\cdots$。   set.intersection_update(set1, set2, ...) 将集合 set 更新为集合 $set \\cap set1 \\cap set2 \\cap \\cdots$。   set1.isdisjoint(set2) 判断集合 set1 和 set2 是否包含相同的元素，如果没有返回 True，否则返回 False。   set1.issubset(set2) 判断集合 set1 是否是集合 set2 的子集。如果是，则返回 True；否则返回 False。   set1.issuperset(set2) 判断集合 set1 是否是集合 set2 的父集。如果是，则返回 True；否则返回 False。   set.pop() 随机移除元素，并返回该元素。   set.remove(item) 移除指定元素 item。如果 item 不存在 set 中，会发生错误。   set1.symmetric_difference(set2) 返回集合 set1 和 set2 的对称差集 $set1 \\oplus set2$。   set1.symmetric_difference_update(set2) 将集合 set1 更新为 $set1 \\oplus set2$。   set.union(set1, set2...) 返回集合 $set \\cup set1 \\cup set2 \\cup \\cdots$。   set.update(added_set) 添加新的元素或集合到当前集合中。 added_set —— 可以是元素或集合。     Dictionary 字典是一种映射类型，用 {} 标识，是一个无序的 key:value （键 - 值对）的集合。字典当中的元素是通过键来存取的，而不是通过偏移存取。字典还可以使用构造函数 dict() 创建。\n# 一般方法： dic = { \u0026#39;name\u0026#39;: \u0026#39;tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;height\u0026#39;: 185, # cm \u0026#39;weight\u0026#39;: 71 # kg } print(dic) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;height\u0026#39;: 185, \u0026#39;weight\u0026#39;: 71} # 构造函数： # 1. dic = dict( name = \u0026#39;lucy\u0026#39;, age = 18, height = 169, weight = 56 ) print(dic) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;lucy\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;height\u0026#39;: 169, \u0026#39;weight\u0026#39;: 56} # 2. dic = dict([ (\u0026#39;name\u0026#39;, \u0026#39;jiessie\u0026#39;), (\u0026#39;age\u0026#39;, 25), (\u0026#39;height\u0026#39;, 178), (\u0026#39;weight\u0026#39;, 63) ]) print(dic) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;jiessie\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;height\u0026#39;: 178, \u0026#39;weight\u0026#39;: 63} # 使用 for 循环： dic = { x: x**2 for x in (2, 4, 6) } print(dic) # 输出：{2: 4, 4: 16, 6: 36} 更多构造字典的方法↩。\n  键（key）必须使用不可变类型，且是唯一的。\n\u0026gt;\u0026gt;\u0026gt; dic = {1:20, \u0026#39;a\u0026#39;:50, (1, 2, 3):6} \u0026gt;\u0026gt;\u0026gt; print(dic) {1: 20, \u0026#39;a\u0026#39;: 50, (1, 2, 3): 6} \u0026gt;\u0026gt;\u0026gt; print(dic[1]) 20 \u0026gt;\u0026gt;\u0026gt; print(dic[\u0026#39;a\u0026#39;]) 50 \u0026gt;\u0026gt;\u0026gt; print(dic[(1, 2, 3)]) 6   值（value）可以是任何类型的元素。\n  使用键作为索引。\n  使用 in 操作符判断键是否存在字典中，如 key in dict ，如果键在字典dict里返回 True，否则返回 False。not in 操作符与 in 相反。\n   字典方法    方法 说明     radiansdict.clear() 删除字典内所有元素，无返回值。   radiansdict.copy() 返回一个字典的浅复制。   radiansdict.fromkeys(seq[, value]) 创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值（可选）。   radiansdict.get(key, default=None) 返回指定键 key 的值，如果键不在字典中返回 default 设置的默认值。   radiansdict.items() 以列表返回一个视图对象，视图对象中的元素以键-值对 (key, value) 的形式显示。 视图对象不是列表，不支持索引，其中的元素是键-值对。字典的视图对象都是只读的，但字典改变，视图也会跟着变化。   radiansdict.keys() 返回一个只包含键的视图对象。   radiansdict.setdefault(key, default=None) 和 get() 类似，如果 key 存在于 radiandict 中，就返回其值；但如果 key 不存在于字典中，将会添加键并将值设为 default。   radiansdict.update(dict2) 把字典 dict2 的键-值对更新到 dict 里，无返回值。   radiansdict.values() 返回一个只包含值的视图对象。   radiansdict.pop(key[, default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出。否则，返回 default 值。如果 key 不存在字典中，返回 default 值（default 值必须给出，否则会报错。   radiansdict.popitem() 随机返回并删除字典中的最后一对键和值 (key, value)。 如果字典已经为空，却调用了此方法，就报出 KeyError 异常。     函数操作    函数 说明     len(obj) 返回对象的元素个数   max(x1[, x2[, x3[, ...]]]) 返回参数中最大值，参数还可以是集合、列表或元组。   min(x1[, x2[, x3[, ...]]]) 返回参数中最小值，参数还可以是集合、列表或元组。     数据类型转换 将数据类型作为函数名即可进行数据类型的转换。以下内置的数据类型转换函数返回一个新的对象，表示转换的值。\n   函数 描述     int(x, base = 10) 将 x 转换为一个整数。 x —— 字符串或数字； base —— 基数（进制数），默认 10。   float(x = 0.0) 将 x 转换为一个浮点数。 x —— 字符串或数字，默认为 0.0。   complex(real[, imag]) 创建一个值为 real + imag * j  的复数。 real —— 为字符串时不需要指定第二个参数，还可以为 int 或 float； imag —— int、float。   str(object = '') 将对象 object 转换为字符串，默认为空字符串。   repr(object) 将对象 object 转换为表达式字符串。↩   eval(expression[, globals[, locals]]) 用来执行字符串中的有效表达式，并返回表达式的值。 expression —— 表达式字符串； globals —— 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象； locals —— 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。   tuple(iterable) 将序列 iterable 转换为一个元组。 iterable —— 可迭代对象，如列表、字典、元组等等。   list(seq) 将序列 seq 转换为一个列表。 seq —— 元组或字符串。   set([iterable]) 将 iterable 转换为可变集合，默认创建空集。 iterable —— 可迭代对象。   dict(**kwarg)、 class dict(mapping, **kwarg) 、 class dict(iterable, **kwarg) 创建一个字典，默认创建空集。↩**kwargs —— 关键字，如 key=value； mapping —— 元素的容器； iterable —— 可迭代对象。   frozenset([iterable]) 将 iterable 转换为不可变集合，默认创建空集。 iterable —— 可迭代的对象。   chr(i) 将一个整数 i（in rang(256)）转换为一个字符。 返回值是当前整数对应的 ASCII 字符。   ord(c) 将一个字符 c 转换为它的整数值（ASCII 数值，或者 Unicode 数值）。 c —— 字符（长度为 1 的字符串）。 如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。   hex(x) 将整数 x 转换为一个十六进制字符串（以 0x 为前缀）。   oct(x) 将整数 x 转换为一个八进制字符串。 Python2.x 版本的 8 进制以 0 作为前缀表示； Python3.x 版本的 8 进制以 0o 作为前缀表示。    repr 的用法：\n\u0026gt;\u0026gt;\u0026gt; dic = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; repr(dic) \u0026#39;[1, 2, 3]\u0026#39; dict() 的用法：\n\u0026gt;\u0026gt;\u0026gt;dict() # 创建空字典 {} \u0026gt;\u0026gt;\u0026gt; dict(a=\u0026#39;a\u0026#39;, b=\u0026#39;b\u0026#39;, t=\u0026#39;t\u0026#39;) # 传入关键字 {\u0026#39;a\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;t\u0026#39;: \u0026#39;t\u0026#39;} \u0026gt;\u0026gt;\u0026gt; dict(zip([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;], [1, 2, 3])) # 映射函数方式来构造字典 {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; dict([(\u0026#39;one\u0026#39;, 1), (\u0026#39;two\u0026#39;, 2), (\u0026#39;three\u0026#39;, 3)]) # 可迭代对象方式来构造字典 {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3}  其他操作 使用 Python 的 type() 函数查看变量的类型：\n\u0026gt;\u0026gt;\u0026gt; a, b, c, d = 20, 5.5, True, 4+3j \u0026gt;\u0026gt;\u0026gt; print(type(a), type(b), type(c), type(d)) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt; 使用 isinstance 判断数据类型是否正确：\n\u0026gt;\u0026gt;\u0026gt; a = 111 \u0026gt;\u0026gt;\u0026gt; isinstance(a, int) True isinstance() 和 type() 的区别在于：\n  type() 不会认为子类是一种父类类型。\n  isinstance() 会认为子类是一种父类类型。即，子类和父类被认为是同一类型。\n  \u0026gt;\u0026gt;\u0026gt; class A: ... pass ... \u0026gt;\u0026gt;\u0026gt; # B 是 A 的子类 \u0026gt;\u0026gt;\u0026gt; class B(A): ... pass ... \u0026gt;\u0026gt;\u0026gt; isinstance(A(), A) True \u0026gt;\u0026gt;\u0026gt; type(A()) == A True \u0026gt;\u0026gt;\u0026gt; isinstance(B(), A) True \u0026gt;\u0026gt;\u0026gt; type(B()) == A False  Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加。\n\u0026gt;\u0026gt;\u0026gt; True == 1 True \u0026gt;\u0026gt;\u0026gt; False == 0 True 可以通过 is 来判断：\n\u0026gt;\u0026gt;\u0026gt; True is 1 False \u0026gt;\u0026gt;\u0026gt; flag = True \u0026gt;\u0026gt;\u0026gt; flag is True True  使用 del 删除对象：\ndel var # 删除一个对象 del var_1, var_2 # 删除多个对象  print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\u0026quot;\u0026quot;：\n\u0026gt;\u0026gt;\u0026gt; str1 = \u0026#39;Hello \u0026#39; \u0026gt;\u0026gt;\u0026gt; str2 = \u0026#39;World!\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(str1); print(str2) Hello World! \u0026gt;\u0026gt;\u0026gt; print(str1, end = \u0026#39;\u0026#39;); print(str2) Hello World!  运算符 算术运算符    Operators Explains     + 加 操作对象为字符串、列表或元组时，表示将两个对象拼接在一起。   - 减   * 乘 a * b，若 a 为字符串、列表或元组，b 为整数时，表示将 b 个 a 拼接在一起。   / 除   % 取模   ** 幂，如 a**b 返回 a 的 b 次方   // 整除，向下取整     比较（关系）运算符 所有比较运算符返回 1（或 True）表示真，返回 0（或 False）表示假。\n   Operators Explains     == 相等   != 不等于 Python 3 已不支持 \u0026lt;\u0026gt;   \u0026gt; 大于   \u0026lt; 小于   \u0026gt;= 大于等于 - 返回x是否大于等于y。   \u0026lt;= 小于等于 - 返回x是否小于等于y。     赋值运算符    Operators Explains     = 赋值运算符   += 加法赋值运算符   -= 减法赋值运算符   *= 乘法赋值运算符   /= 除法赋值运算符   %= 取模赋值运算符   **= 幂赋值运算符   //= 取整除赋值运算符   := 海象运算符，可在表达式内部为变量赋值，然后直接进行判断。Python3.8 版本新增运算符。     位运算符    Operators Explain     \u0026amp; 按位与运算符： 参与运算的两个值，如果两个相应位都为 1，则该位的结果为 1，否则为 0。   | 按位或运算符： 只要对应的两个二进位有一个为 1 时，结果位就为 1。   ^ 按位异或运算符： 当两对应的二进位相异时，结果为 1。   ~ 按位取反运算符： 对数据的每个二进制位取反，即把 1 变为 0，把 0 变为 1。~x 类似于 x-1   \u0026lt;\u0026lt; 左移动运算符： 运算数的各二进位全部左移若干位，由 \u0026lt;\u0026lt; 右边的数指定移动的位数，高位丢弃，低位补 0。   \u0026gt;\u0026gt; 右移动运算符： 把 \u0026gt;\u0026gt; 左边的运算数的各二进位全部右移若干位，\u0026gt;\u0026gt; 右边的数指定移动的位数。     逻辑运算符    Operators Expressions Explains     and x and y 布尔 “与” 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。   or x or y 布尔 “或” 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。   not not x 布尔 “非” 如果 x 为 True，返回 False；如果 x 为 False，它返回 True。     成员运算符    Operators Explains     in 如果在指定的序列中找到值返回 True，否则返回 False。   not in 如果在指定的序列中没有找到值返回 True，否则返回 False。     身份运算符    Operators Explains     is 判断两个标识符是不是引用自一个对象。 x is y，类似 id(x) == id(y)。 如果引用的是同一个对象则返回 True，否则返回 False   is not 判断两个标识符是不是引用自不同对象。 x is not y，类似 id(a) != id(b)。 如果引用的不是同一个对象则返回结果 True，否则返回 False。    is 和 == 的区别：\n\u0026gt;\u0026gt;\u0026gt;a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; b is a True \u0026gt;\u0026gt;\u0026gt; b == a True \u0026gt;\u0026gt;\u0026gt; b = a[:] \u0026gt;\u0026gt;\u0026gt; b is a False \u0026gt;\u0026gt;\u0026gt; b == a True  运算符优先级 优先级按从高到底排列：\n   Operators Explains     ** 指数   ~ + - 按位翻转，一元加号和减号（最后两个的方法名为 +@ 和 -@）   * / % // 乘，除，求余数和取整除   + - 加法减法   \u0026gt;\u0026gt; \u0026lt;\u0026lt; 右移，左移运算符   \u0026amp; 按位与   ^ | 按位异或，按位与   \u0026lt;= \u0026lt; \u0026gt; \u0026gt;= 比较运算符   == != 等于运算符   = %= /= //= -= += *= **= 赋值运算符   is is not 身份运算符   in not in 成员运算符   not and or 逻辑运算符     if条件控制 if 语句的形式：\nif condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3 if 语句的条件通常由关系运算符或返回值为布尔值的语句组成，使用逻辑运算符在一条 if 语句中连接多个条件。\n 条件运算符 Python 提供了条件运算符（三目运算符）：\nstatement_1 if condition else statement   如果 condition 为 True，执行 statement_1 并且返回 staement_1 的结果。\n  如果 condition 为 False，执行 statement_2 并且返回 statement_2 的结果。\n   循环语句 Python 有 while 和 for 两种循环语句。\n while条件循环 while 循环的一般用法是，当指定条件成立时执行一次 while 后的代码块。\nwhile condition: statements_block while 语句后可接 else 语句。当指定条件不成立时，执行一次 while 后面的 else 语句。\nwhile condition: statements_block_1 else: statements_block_2  for循环遍历 for 循环的一般用法是，遍历任何可迭代对象。每次循环，都会从指定的可迭代对象中选取一个赋给指定的变量。如此循环下去，直到遍历完指定的可迭代对象中所有元素。\nfor variables in sequence: statements_block for 语句后可接 else 语句。当指定的可迭代对象为空时，执行一次 for 后面的 else 语句。\nfor variable in sequence: statements_block_1 else: statements_block_2  for 循环经常与 range() 函数一起使用。当需要遍历数字序列时，可以使用 range() 函数生成数列。\n# 输出数字 5~12 for i in range(5, 13): print(i, end=\u0026#39; \u0026#39;) print(\u0026#39;\u0026#39;) # 输出一个换行符  遍历技巧 在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：\n\u0026gt;\u0026gt;\u0026gt; dict = {\u0026#39;one\u0026#39;:1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; for key, val in dict.items(): ... print(key, \u0026#39; = \u0026#39;, val) ... one = 1 two = 2 three = 3 在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：\n\u0026gt;\u0026gt;\u0026gt; for index, val in enumerate([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]): ... print(index, \u0026#39;: \u0026#39;, val) ... 0 : one 1 : two 2 : three 同时遍历两个或更多的序列，可以使用 zip() 组合：\n\u0026gt;\u0026gt;\u0026gt; questions = [\u0026#39;name\u0026#39;, \u0026#39;quest\u0026#39;, \u0026#39;favorite color\u0026#39;] \u0026gt;\u0026gt;\u0026gt; answers = [\u0026#39;lancelot\u0026#39;, \u0026#39;the holy grail\u0026#39;, \u0026#39;blue\u0026#39;] \u0026gt;\u0026gt;\u0026gt; for q, a in zip(questions, answers): ... print(\u0026#39;What is your {0}? It is {1}.\u0026#39;.format(q, a)) ... What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. 反向遍历序列，可以调用 reversed() 函数：\n\u0026gt;\u0026gt;\u0026gt; for i in reversed(range(10)): ... print(i, end = \u0026#39;\u0026#39;) ... 9876543210 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：\n\u0026gt;\u0026gt;\u0026gt; basket = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;] \u0026gt;\u0026gt;\u0026gt; for f in sorted(set(basket)): ... print(f) ... apple banana orange pear  列表推导式 列表推导式（又称列表解析式）的基本语法如下：\n[val for val in sequence if_or_for_statement] # if_or_for_statement是一个if判断语句或for循环 # 如果是if语句，那么只有条件位真时val才会在列表中 Example：\n\u0026gt;\u0026gt;\u0026gt; [x for x in range(10)] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 列表推导式中的for语句和if语句是可嵌套的：\n[x*y for x in range(1,5) if x \u0026gt; 2 for y in range(1,4) if y \u0026lt; 3] 上面语句的执行顺序是：\nfor x in range(1,5) if x \u0026gt; 2 for y in range(1,4) if y \u0026lt; 3 x*y 列表推导式除了list还可以被转化成其它对象：\n\u0026gt;\u0026gt;\u0026gt; (x for x in range(10)) \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x0000026F7A655BA0\u0026gt; \u0026gt;\u0026gt;\u0026gt; tuple(x for x in range(10)) (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)  break and continue   break 语句 —— 跳出（终止）循环。不执行当前循环块中 break 语句以下的语句，并且将控制转移到当前循环语句的下一条语句。\n  continue 语句 —— 进入下一轮循环。不执行当前循环块中 continue 语句以下的语句，并且将控制转义到循环语句的开头。\n  break 和 continue 在循环语句中使用。一般在循环中的 if 条件语句中使用。即，达到某个条件便结束或进入下一次循环。\n pass语句 pass 语句是空语句，即不执行任何操作。pass 是为了保持 Python 程序结构的完整性。\npass 一般作为占位语句，当操作都在条件语句或循环语句中完成时，在语句块中使用 pass 占位。如：\nif condition_1: pass while condition_2: pass for variable in sequence: pass  迭代器与生成器 迭代器 迭代是一种访问集合元素的方式。迭代器是一个可以记住遍历位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n迭代器有两个基本的方法：iter() 和 next()。\n字符串、列表或元组对象都可用于创建迭代器。\n\u0026gt;\u0026gt;\u0026gt; list = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; it = iter(list) # 创建迭代器对象 \u0026gt;\u0026gt;\u0026gt; print(next(it)) # 输出迭代器的下一个元素 1 \u0026gt;\u0026gt;\u0026gt; print(next(it)) 2 迭代器对象可以使用常规 for 语句进行遍历：\nlist = [1, 2, 3, 4] it = iter(list) # 创建迭代器对象 for x in it: print(x, end = \u0026#39; \u0026#39;) 使用 next() 迭代：\nimport sys # 引入 sys 模块 list=[1, 2, 3, 4] it = iter(list) # 创建迭代器对象 while True: try: print (next(it)) except StopIteration: sys.exit()  创建迭代器 把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。\n  __iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__()方法并通过 StopIteration 异常标识迭代的完成。\n  __next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。\n  class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers() myiter = iter(myclass) i = 0 while i \u0026lt; 10: print(next(myiter), end = \u0026#39; \u0026#39;) i += 1 # 输出：1 2 3 4 5 6 7 8 9 10  迭代结束标志 StopIteration 异常用于标识迭代的完成，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。\n# 迭代 10 次后停止 class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a \u0026lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration myclass = MyNumbers() myiter = iter(myclass) for x in myiter: print(x, end = \u0026#39; \u0026#39;) # 输出：1 2 3 4 5 6 7 8 9 10  生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作。\n在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。\nimport sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 1, 1, 0 while True: if (counter \u0026gt; n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=\u0026#34; \u0026#34;) except StopIteration: sys.exit() # 输出：1 1 2 3 5 8 13 21 34 55 89  函数 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。\n函数的定义形式：\ndef function_name(arguments): \u0026#34;\u0026#34;\u0026#34;explain\u0026#34;\u0026#34;\u0026#34; statements_block return [expression] # end function_name   explain 是使用文档字符串存放的函数说明。\n  return 代表一个函数的结束，并且返回一个值给调用方，这个值放在 return 后面，可以是具体的值也可以是一条有确切值的表达式。不带值或表达式的 return 相当于返回 None。当函数不需要返回值时，可以省略 return。\n  调用一个函数时需要使用该函数名并根据其定义指定参数：\ndef function_name(arguments): \u0026#34;\u0026#34;\u0026#34;explain\u0026#34;\u0026#34;\u0026#34; statements_block return [expression] # end function_name function_name(arguments)  参数   不可变类型的参数传递：类似 C++ 的值传递。传递的只是参数的值，没有影响参数对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。即，修改参数之前函数内部参数的地址和函数外部参数的地址相同，一旦修改了变量，参数的地址将会发生变化。如 Number、String、Tuple。\n  可变类型的参数传递：类似 C++ 的引用传递。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响。无论是否对参数进行修改，参数地址都不会发生改变。如 List、Dictionary、Set。\n  参数类型：\n  必须参数：须以正确的顺序传入函数。调用时，必须参数的数量必须和声明时一样。\n  关键字参数：函数调用时使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。\ndef func(a, b): print(\u0026#39;a = \u0026#39;, a, \u0026#39;b = \u0026#39;, b) return func(b = 2, a = 1)   默认参数：调用函数时，如果没有传递参数，则会使用默认参数。默认参数在定义函数时定义。\ndef func(a, b = 1) print(\u0026#39;a = \u0026#39;, a, \u0026#39;b = \u0026#39;, b) return func(2)   不定长参数：\n  加了星号 * 的参数会以元组的形式导入，存放所有未命名的变量参数。\ndef func(atg1, *vartuple): print(atg1, vartuple) return func(1, 2, 3) # 输出：1 (2, 3)   加了两个星号 ** 的参数会以字典的形式导入。\ndef func(atg1, **vartuple): print(atg1, vartuple) return func(1, a = 2, b = 3) # 输出：1 {\u0026#39;a\u0026#39;: 2, \u0026#39;b\u0026#39;: 3}   如果参数单独出现星号 * 后的参数必须用关键字传入。\n\u0026gt;\u0026gt;\u0026gt; def f(a,b,*,c): ... return a+b+c ... \u0026gt;\u0026gt;\u0026gt; f(1,2,3) # 报错 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: f() takes 2 positional arguments but 3 were given \u0026gt;\u0026gt;\u0026gt; f(1,2,c=3) # 正常 6     强制位置参数：Python3.8 新增了一个函数形参语法 /  用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。\ndef f(a, b, /, c): print(a, b, c) return # 形参 a 和 b 必须使用指定位置参数，c 可以是位置形参或关键字形参 f(1, 2, c = 3)    lambda匿名函数 Python 使用 lambda 来创建匿名函数。\n  lambda 的主体是一个表达式，而不是一个代码块（比 def 简单很多）。仅仅能在 lambda 表达式中封装有限的逻辑进去。\n  lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。\n  虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n  lambda 函数的语法：\nlambda [arg1 [,arg2,.....argn]]: expression 用法：\n\u0026gt;\u0026gt;\u0026gt; sum = lambda arg1, arg2: arg1 + arg2 \u0026gt;\u0026gt;\u0026gt; sum(1, 2) 3  模块 模块是一个包含函数定义和变量的文件，其后缀名是 .py。\n  模块可以被别的程序引入，以使用该模块中的函数等功能。\n  Python 标准库也是一个个内置的模块。\n这些模块会根据不同的操作系统进行不同的配置，不同的操作系统可能会有一些不同的模块。\n  每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用，可以使用 dir() 查看。\n在导入模块后，可以通过 modname.itemname 这样的表示法来访问模块内的函数。\n  模块可以被导入其他模块。被导入的模块的名称将被放入当前操作的模块的符号表中。\n  模块除了方法定义，还可以包括可执行的代码。\n这些代码一般用来初始化这个模块，只有在第一次被导入时才会被执行。\n   包 包是一种管理 Python 模块命名空间的形式，采用 “点模块名称”。如一个模块的名称是 A.B， 那么他表示一个包 A 中的子模块 B。优点是不用担心不同模块之间的名称冲突。\n包结构实例：\nsound/ 顶层包 __init__.py 初始化 sound 包 formats/ 文件格式转换子包 __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ 声音效果子包 __init__.py echo.py surround.py reverse.py ... filters/ filters 子包 __init__.py equalizer.py vocoder.py karaoke.py ... 包还提供一个额外的属性 __path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的 __init__.py，得在其他 __init__.py 被执行前定义。可以修改这个变量，用来影响包含在包里面的模块和子包。这个功能并不常用，一般用来扩展包里面的模块。\n import语句 import module1[, module2[,... moduleN] 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。import 命令一般放在脚本顶端，如：\n#!/usr/bin/python3 # Filename: support.py def print_hello(): print (\u0026#39;Hello World！\u0026#39;) return #!/usr/bin/python3 # Filename: test.py # 导入模块 import hello # 使用 . 运算符调用模块中的函数 hello.print_hello() 对于同一个模块，无论执行了多少次 import 语句，一个模块只会被导入一次。\n搜索路径是一个解释器会先进行搜索的所有目录的列表，由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块（很像环境变量）。搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 sys 模块中的 path 变量。\n以 Windows 系统为例（在 VS2017 中安装的 Python3）：\n\u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; print(sys.path) [\u0026#39;\u0026#39;, \u0026#39;C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\python36.zip\u0026#39;, \u0026#39;C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\DLLs\u0026#39;, \u0026#39;C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\lib\u0026#39;, \u0026#39;C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\u0026#39;, \u0026#39;C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\lib\\\\site-packages\u0026#39;] sys.path 输出是一个列表，其中第一项是空串，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），即我们执行 Python 解释器的目录（对于脚本的话就是运行的脚本所在的目录）。\n如果要引入一些不在搜索路径中的模块，可以在脚本中修改 sys.path。\n如果要经常使用一个模块中的函数，可以赋给它一个本地名称：\nimport module func = module.func func(arg)  from \u0026hellip; import语句 使用 from ... import 语句可以从模块中导入一个指定的部分到当前命名空间中。这种导入的方法不会把被导入的模块的名称放在当前的字符表中。\nfrom modname import item1[, item2[, ... itemN]] 这样只会把 modname 中的指定的部分 item1[, item2[, ... itemN]] 导入到当前命名空间中，并且可以直接使用它们的名称来调用它们（无需使用 . 运算符）。item1[, item2[, ... itemN]] 可以是子模块、函数、类或变量等。\n使用 from package import item 这种形式的时候，import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。\n把一个模块的所有内容全都导入到当前的命名空间（不推荐使用），但是那些由单一下划线 _ 开头的名字不在此例：\nfrom modname import * Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。\n为了解决这个问题，需要提供一个精确包的索引。导入语句遵循如下规则：\n如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。\n以下实例在 file:sounds/effects/_init_.py 中包含如下代码：\n__all__ = [\u0026#34;echo\u0026#34;, \u0026#34;surround\u0026#34;, \u0026#34;reverse\u0026#34;]  from \u0026hellip; import \u0026hellip; as语句 import ... as 可以将导入的模块、函数或者变量等重命名：\nimport name as new_name 该语句也可以接在 from 语句后面：\nfrom modname import name as new_name  __name__ 属性 一个模块被另一个程序第一次引入时，其主程序将运行。可以用 __name__ 属性来使该程序块仅在该模块自身运行时执行（被其它程序或模块引入时不执行）。\n每个模块都有一个 __name__ 属性，当其值是 '__main__' 时，表明该模块自身在运行，否则是被引入。\n#!/usr/bin/python3 # Filename: using_name.py if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;程序自身在运行\u0026#39;) else: print(\u0026#39;我来自另一模块\u0026#39;) $ python using_name.py 程序自身在运行 $ python \u0026gt;\u0026gt;\u0026gt; import using_name 我来自另一模块  dir() 函数 内置的函数 dir() 可以找到指定模块内定义的所有名称，以一个字符串列表的形式返回。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; dir(math) [\u0026#39;__doc__\u0026#39;, \u0026#39;__loader__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__spec__\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;copysign\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;degrees\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;erf\u0026#39;, \u0026#39;erfc\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;expm1\u0026#39;, \u0026#39;fabs\u0026#39;, \u0026#39;factorial\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;frexp\u0026#39;, \u0026#39;fsum\u0026#39;, \u0026#39;gamma\u0026#39;, \u0026#39;gcd\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;inf\u0026#39;, \u0026#39;isclose\u0026#39;, \u0026#39;isfinite\u0026#39;, \u0026#39;isinf\u0026#39;, \u0026#39;isnan\u0026#39;, \u0026#39;ldexp\u0026#39;, \u0026#39;lgamma\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log1p\u0026#39;, \u0026#39;log2\u0026#39;, \u0026#39;modf\u0026#39;, \u0026#39;nan\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;radians\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;, \u0026#39;tau\u0026#39;, \u0026#39;trunc\u0026#39;] 如果没有给定参数，dir() 函数会罗列出当前定义的所有名称。\n\u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = 4 \u0026gt;\u0026gt;\u0026gt; dir() [\u0026#39;__annotations__\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__loader__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__spec__\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]  输入输出 标准输出 在 Python 中使用 print() 来将其参数输出到标准输出上。默认的标准输出是屏幕。\n可以使用 str.format() 函数等方式⤴ 来格式化输出值。\n可以使用 repr() 或 str() 函数来将输出的值转成字符串。\n  str()：函数返回一个用户易读的表达形式。\n  repr()：产生一个解释器易读的表达形式。\n   标准输入 Python 提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。\nPython3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。Python3.x 没有 raw_input()。\ninput() 函数的语法：\ninput([prompt]) # prompt —— 输出到标准输出的提示信息 用法示例：\n\u0026gt;\u0026gt;\u0026gt; a = input(\u0026#39;输入一个整数：\u0026#39;) 输入一个整数：123 \u0026gt;\u0026gt;\u0026gt; type(a) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; # input() 返回的是 string \u0026gt;\u0026gt;\u0026gt; a = int(a) # 使用 int() 类型转换 \u0026gt;\u0026gt;\u0026gt; print(type(a), a) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 123 # 此时 a 才是 int input() 接收多个值：\n#输入三角形的三边长 a, b, c = (input(\u0026#34;请输入三角形三边的长：\u0026#34;).split()) a = int(a) b = int(b) c = int(c) #计算三角形的半周长p p = (a + b + c) / 2 #计算三角形的面积s s = (p * (p - a) * (p - b) * (p - c))**0.5 #输出三角形的面积 print(\u0026#34;三角形面积为：\u0026#34;, format(s, \u0026#39;.2f\u0026#39;))  读写文件 open() 将会返回一个 file 对象，基本语法格式如下：\nopen(filename[, mode=\u0026#39;r\u0026#39;]) # filename —— 包含了要访问的文件名称的字符串值 # mode —— 打开文件的模式的字符串值，默认文件访问模式为只读（r） 打开文件的模式：\n   模式 描述     t 文本模式 (默认)。   x 写模式，新建一个文件，如果该文件已存在则会报错。   b 二进制模式。   + 打开一个文件进行更新（可读可写）。   U 通用换行模式（不推荐）。   r 以只读方式打开文件（默认模式）。文件的指针将会放在文件的开头。   rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。   r+ 打开一个文件用于读写。文件指针将会放在文件的开头。   rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。   w 打开一个文件只用于写入。 如果该文件已存在，则清空原文件内容，并从开头开始编辑。 如果该文件不存在，创建新文件。   wb 以二进制格式打开一个文件只用于写入。 打开方式与 w 相同（会覆盖原有的文件）。   w+ 打开一个文件用于读写。 打开方式与 w 相同。   wb+ 以二进制格式打开一个文件用于读写。 打开方式与 w 相同。   a 打开一个文件用于追加。 如果该文件已存在，文件指针将会放在文件的结尾。 即，新的内容将会被写入到已有内容之后。 如果该文件不存在，创建新文件进行写入。   ab 以二进制格式打开一个文件用于追加。 打开方式与 a 相同。   a+ 打开一个文件用于读写。 打开方式与 a 相同。   ab+ 以二进制格式打开一个文件用于追加。 打开方式与 a 相同。    下图总结了这几种模式：\n   模式 r r+ w w+ a a+     读 + +  +  +   写  + + + + +   创建   + + + +   覆盖   + +     指针在开始 + + + +     指针在结尾     + +    open() 函数的完整语法格式：\nopen(file[, mode=\u0026#39;r\u0026#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None]) # file —— 必需，文件路径（相对或者绝对路径）。 # mode —— 可选，文件打开模式 # buffering —— 设置缓冲 # encoding —— 一般使用 utf8 # errors —— 报错级别 # newline —— 区分换行符 # closefd —— 传入的 file 参数类型 # opener —— 自定义打开文件方式  打开文件后，要进行的就是写入和读取操作，这些操作都是对 file 对象进行操作。\nfile 对象方法：\n   方法 说明     file.close() 关闭文件。关闭后文件不能再进行读写操作。 在执行完文件的读写操作后，有必要执行该方法。   file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。   file.fileno() 返回一个整型的文件描述符（file descriptor FD 整型），可以用在如 os 模块的 read 方法等一些底层操作上。   file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。   file.next() 返回文件下一行。   file.read([size=-1]) 从文件读取指定的字节数，默认为 -1，为负数时表示读取所有。   file.readline([size=-1]) 读取整行（size 默认为 -1，为负数表示读取整行），包括 '\\n' 字符。 如果指定了 size 则读取该行的前 size 字符。 第一次调用时读取第一行，第二次调用时读取第二行，以此类推。   file.readlines([sizeint]) 读取所有行并返回列表，若给定 sizeint \u0026gt; 0，则是设置一次读多少字节，这是为了减轻读取压力。   file.seek(offset[, whence=0]) 设置文件当前位置。 offset —— 开始的偏移量。 whence —— 给 offset 参数一个定义，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1代表从当前位置开始算起，2 代表从文件末尾算起。默认为 0。   file.tell() 返回文件当前位置。   file.truncate([size=file.tell()]) 截取文件，截取的字节通过 size 指定，默认为当前文件位置。   file.write(str) 将字符串写入文件，返回的是写入的字符长度。 如果文件打开模式带 b，那写入文件内容时，str 要用 encode() 方法转为 bytes 形式，否则报错：TypeError: a bytes-like object is required, not \u0026lsquo;str\u0026rsquo;。   file.writelines(sequence) 向文件写入一个序列字符串列表（这一序列字符串可以是由迭代对象产生的，如一个字符串列表），如果需要换行则要自己加入每行的换行符。     file.write() 用法：\nf = open(\u0026#39;test.txt\u0026#39;, \u0026#39;w+\u0026#39;) f.write(\u0026#39;test1\u0026#39;) f.seek(0) print(\u0026#39;从文件中读取到的字符串：\u0026#39;, f.read()) f.close() # 输出： # 从文件中读取到的字符串： test1 f = open(\u0026#39;test.txt\u0026#39;, \u0026#39;wb+\u0026#39;) f.write(\u0026#39;test1\u0026#39;.encode()) f.seek(0) print(\u0026#39;从二进制文件中读取到的内容：\u0026#39;, f.read()) f.seek(0) print(\u0026#39;将其转化为字符串输出：\u0026#39;, f.read().decode()) f.close() # 输出： # 从二进制文件中读取到的内容： b\u0026#39;\u0026#39; # 将其转化为字符串输出： test1  os模块 os 模块提供了非常丰富的方法用来处理文件和目录。以下是一些常用的方法：\n os.access(path, mode)\n检验权限模式（使用当前的 UID/GID 尝试访问路径）。\n  path —— 要用来检测是否有访问权限的路径。\n  mode —— 参数取值如下：\n  os.F_OK —— 测试 path 是否存在；\n  os.R_OK —— 测试 path 是否可读；\n  os.W_OK —— 测试 path 是否可写；\n  os.X_OK —— 测试 path 是否可执行。\n  在相应模式下，如果存在/可读/写/执行返回 True ，否则返回 False。\n        方法 描述         os.chdir(path) 改变当前工作目录到 path 指定的路径。如果允许访问返回 True，否则返回 False。   os.chflags(path, flags) 设置路径 path 的标记为数字标记。多个标记可以使用 OR 来组合起来。 flags —— 参数取值如下： stat.UF_NODUMP —— 非转储文件； stat.UF_IMMUTABLE —— 文件是只读的； stat.UF_APPEND —— 文件只能追加内容； stat.UF_NOUNLINK —— 文件不可删除； stat.UF_OPAQUE —— 目录不透明，需要通过联合堆栈查看； 以下参数值是超级用户可设置的： stat.SF_ARCHIVED —— 可存档文件； stat.SF_IMMUTABLE —— 文件是只读的； stat.SF_APPEND —— 文件只能追加内容； stat.SF_NOUNLINK —— 文件不可删除； stat.SF_SNAPSHOT —— 快照文件。   os.chmod(path, mode) 更改权限   os.chown(path, uid, gid) 更改文件所有者   os.chroot(path) 改变当前进程的根目录   os.close(fd) 关闭文件描述符 fd   os.closerange(fd_low, fd_high) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略   os.dup(fd) 复制文件描述符 fd   os.dup2(fd, fd2) 将一个文件描述符 fd 复制到另一个 fd2   os.fchdir(fd) 通过文件描述符改变当前工作目录   os.fchmod(fd, mode) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。   os.fchown(fd, uid, gid) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。   os.fdatasync(fd) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。   os.fdopen(fd[, mode[, bufsize]]) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象   os.fpathconf(fd, name) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。   os.fstat(fd) 返回文件描述符fd的状态，像stat()。   os.fstatvfs(fd) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。   os.fsync(fd) 强制将文件描述符为fd的文件写入硬盘。   os.ftruncate(fd, length) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。   os.getcwd() 返回当前工作目录   os.getcwdb() 返回一个当前工作目录的Unicode对象   os.isatty(fd) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。   os.lchflags(path, flags) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接   os.lchmod(path, mode) 修改连接文件权限   os.lchown(path, uid, gid) 更改文件所有者，类似 chown，但是不追踪链接。   os.link(src, dst) 创建硬链接，名为参数 dst，指向参数 src   os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。   os.lseek(fd, pos, how) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效   os.lstat(path) 像stat(),但是没有软链接   os.major(device) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。   os.makedev(major, minor) 以major和minor设备号组成一个原始设备号   os.makedirs(path[, mode]) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。   os.minor(device) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。   os.mkdir(path[, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。   os.mkfifo(path[, mode]) 创建命名管道，mode 为数字，默认为 0666 (八进制)   os.mknod(filename[, mode=0600, device]) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。   os.open(file, flags[, mode]) 打开一个文件，并且设置需要的打开选项，mode参数是可选的   os.openpty() 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。   os.pathconf(path, name) 返回相关文件的系统配置信息。   os.pipe() 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写   os.popen(command[, mode[, bufsize]]) 从一个 command 打开一个管道   os.read(fd, n) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。   os.readlink(path) 返回软链接所指向的文件   os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。   os.removedirs(path) 递归删除目录。   os.rename(src, dst) 重命名文件或目录，从 src 到 dst   os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。   os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。   os.stat(path) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。   os.stat_float_times([newvalue]) 决定stat_result是否以float对象显示时间戳   os.statvfs(path) 获取指定路径的文件系统统计信息   os.symlink(src, dst) 创建一个软链接   os.tcgetpgrp(fd) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组   os.tcsetpgrp(fd, pg) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。   os.tempnam([dir[, prefix]]) Python3 中已删除。 返回唯一的路径名用于创建临时文件。   os.tmpfile() Python3 中已删除。 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。   os.tmpnam() Python3 中已删除。 为创建一个临时文件返回一个唯一的路径   os.ttyname(fd) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。   os.unlink(path) 删除文件路径   os.utime(path, times) 返回指定的path文件的访问和修改的时间。   os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) 输出在文件夹中的文件名通过在树中游走，向上或者向下。   os.write(fd, str) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度   os.path 模块 获取文件的属性信息。   os.pardir() 获取当前目录的父目录，以字符串形式显示目录名。     错误和异常 Python 中的语法错误也可称之为解析错。即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。\n异常以不同的类型出现，这些类型都作为信息的一部分打印出来：\n\u0026gt;\u0026gt;\u0026gt; 10 * (1/0) # 0 不能作为除数，触发异常 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in ? ZeroDivisionError: division by zero \u0026gt;\u0026gt;\u0026gt; 4 + spam*3 # spam 未定义，触发异常 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in ? NameError: name \u0026#39;spam\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; \u0026#39;2\u0026#39; + 2 # int 不能与 str 相加，触发异常 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: can only concatenate str (not \u0026#34;int\u0026#34;) to str 错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。\n 异常处理 try/except 异常捕捉可以使用 try/except 语句：\n# 执行一次 try 子句，并尝试捕捉异常 # 如果没有异常发生，忽略 except 子句 # 当捕捉到异常时，将执行对应的 except 子句 # 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中 # 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。但最多只有一个分支会被执行。 try: statement_1 except Error1: statement_2 except Error2: statement_3 ...... except: # 省略异常的名称，将被当作通配符使用 statement_n # 2. 一次处理多个异常 try: statement_1 except (Error1, Error2, ...): # 这里是一个元素为“异常”的元组 statement_2 Example：\nwhile True: try: x = int(input(\u0026#34;请输入一个数字: \u0026#34;)) break except ValueError: print(\u0026#34;您输入的不是数字，请再次尝试输入！\u0026#34;) import sys try: f = open(\u0026#39;myfile.txt\u0026#39;) s = f.readline() i = int(s.strip()) except OSError as err: print(\u0026#34;OS error: {0}\u0026#34;.format(err)) except ValueError: print(\u0026#34;Could not convert data to an integer.\u0026#34;) except: print(\u0026#34;Unexpected error:\u0026#34;, sys.exc_info()[0]) raise # 再次将触发的异常抛出  try/except \u0026hellip; else try/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。else 子句将在 try 子句没有发生任何异常的时候执行。\ntry: statement_1 except Error1: statement_2 except Error2: statement_3 ...... except: statement_n else: statement_e 判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容：\nfor arg in sys.argv[1:]: try: f = open(arg, \u0026#39;r\u0026#39;) except IOError: print(\u0026#39;cannot open\u0026#39;, arg) else: print(arg, \u0026#39;has\u0026#39;, len(f.readlines()), \u0026#39;lines\u0026#39;) f.close() 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。\n try-finally try-finally 语句无论是否发生异常都将执行 finally 子句的代码。\ntry: statement_1 except Error1: statement_2 except Error2: statement_3 ...... except: statement_n else: statement_e finally: statement_f Example：\ntry: runoob() except AssertionError as error: print(error) else: try: with open(\u0026#39;file.log\u0026#39;) as file: read_data = file.read() except FileNotFoundError as fnf_error: print(fnf_error) finally: print(\u0026#39;这句话，无论异常是否发生都会执行。\u0026#39;) finally 子句通常用作定义任何情况下都会执行的清理行为。\n如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。\n 抛出异常 Python 使用 raise 语句抛出一个指定的异常。raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。raise 语法格式如下：\nraise [Exception [, args [, traceback]]] Example：\nx = 10 if x \u0026gt; 5: raise Exception(\u0026#39;x 不能大于 5。x 的值为: {}\u0026#39;.format(x)) 执行以上代码会触发异常：\nTraceback (most recent call last): File \u0026#34;test.py\u0026#34;, line 3, in \u0026lt;module\u0026gt; raise Exception(\u0026#39;x 不能大于 5。x 的值为: {}\u0026#39;.format(x)) Exception: x 不能大于 5。x 的值为: 10  用户自定义异常 异常类都是直接或间接地继承自 Exception 类。\n\u0026gt;\u0026gt;\u0026gt; class MyError(Exception): ... def __init__(self, value): ... self.value = value ... def __str__(self): ... return repr(self.value) ... \u0026gt;\u0026gt;\u0026gt; try: ... raise MyError(2*2) ... except MyError as e: ... print(\u0026#39;My exception occurred, value:\u0026#39;, e.value) ... My exception occurred, value: 4 \u0026gt;\u0026gt;\u0026gt; raise MyError(\u0026#39;oops!\u0026#39;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in ? __main__.MyError: \u0026#39;oops!\u0026#39;  预定义清理行为 with 语句可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法：\nwith open(\u0026#34;myfile.txt\u0026#34;) as f: for line in f: print(line, end=\u0026#34;\u0026#34;)  assert 断言 Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。\n断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。\n语法格式如下：\nassert expression # expression 值为 True 时，正常执行； # 为 False 时，触发异常 它等价于：\nif not expression: raise AssertionError assert 后面也可以紧跟参数:\nassert expression [, arguments] 等价于：\nif not expression: raise AssertionError(arguments) Example：\n\u0026gt;\u0026gt;\u0026gt; assert True # 条件为 true 正常执行 \u0026gt;\u0026gt;\u0026gt; assert False # 条件为 false 触发异常 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AssertionError \u0026gt;\u0026gt;\u0026gt; assert 1==1 # 条件为 true 正常执行 \u0026gt;\u0026gt;\u0026gt; assert 1==2 # 条件为 false 触发异常 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AssertionError \u0026gt;\u0026gt;\u0026gt; assert 1==2, \u0026#39;1 不等于 2\u0026#39; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AssertionError: 1 不等于 2 # 判断当前系统是否为 Linux，如果不满足条件则直接触发异常，不必执行接下来的代码 import sys assert (\u0026#39;linux\u0026#39; in sys.platform), \u0026#34;该代码只能在 Linux 下执行\u0026#34; # ... 接下来要执行的代码  面向对象   类（Class）：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n  方法：类中定义的函数。\n  类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n  数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。\n  方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n  局部变量：定义在方法中的变量，只作用于当前实例的类。\n  实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。\n  继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。继承是模拟 “是一个（is-a）” 关系。\n  实例化：创建一个类的实例，类的具体对象。\n  对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。\n   类定义和类对象 创建类 创建类的语法格式如下：\nclass ClassName(): \u0026lt;statement-1\u0026gt; . . . \u0026lt;statement-N\u0026gt;  创建实例对象 类对象支持两种操作：属性引用和实例化。\n在 Python 中，类的实例化类似函数调用方式，其语法格式如下：\nobj = ClassName([arg1, arg2, ...])  访问对象属性 类的属性是指在类中定义的变量和方法等。\n属性引用使用 obj.name 语法。类对象创建后，类命名空间中所有的命名（如变量、方法等）都是有效属性名。\nExample：\nclass MyClass(): var1 = 1 var2 = 2 def method(self): print(\u0026#34;This is my class.\u0026#34;) obj = MyClass() print(obj.var1, obj.var2) print() obj.func() # 输出： # 1 2 # This is my class.  __init__() 和self 在类定义中有一个特殊的方法，构造方法 __init__()。如果类定义了 __init__() 方法，那么在类实例化时，会自动调用该方法。\n在类定义中，self 代表类的实例，而非类。self 必须存在，且位于其他形参前面。类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，按照惯例它的名称是 self。\nself 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。\n在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数。\nExample：\nclass Complex(): \u0026#34;\u0026#34;\u0026#34;复数类\u0026#34;\u0026#34;\u0026#34; def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart def print_complex(self): print(\u0026#39;{:f}{:+f}i\u0026#39;.format(self.r, self.i)) x = Complex(3.0, -4.5) # 实例化 print(x.r, x.i) # 输出：3.0 -4.5 x.print_complex() # 输出：3.000000-4.500000i 在 Python 调用 __init__() 来创建实例时，将自动传入实参 self。每个与类相关联的方法调用都自动传递实参 self。\n在类的内部使用属性和方法，需要使用 self.attrs 或 self.method()。\n 修改属性值 通常有两种方法可以修改属性值，一种是直接使用 obj.name 语法修改，另一种是通过方法对属性值进行修改。\nExample：\nclass Car(): def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽车的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \u0026#34;\u0026#34;\u0026#34;返回整洁的描述性信息\u0026#34;\u0026#34;\u0026#34; long_name = str(self.year) + \u0026#39; \u0026#39; + self.make + \u0026#39; \u0026#39; + self.model return long_name.title() def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印一条指出汽车里程的消息\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;This car has \u0026#34; + str(self.odometer_reading) + \u0026#34; miles on it.\u0026#34;) def update_odometer(self, mileage): \u0026#34;\u0026#34;\u0026#34; 将里程表读数设置为指定的值 禁止将里程表读数往回调 \u0026#34;\u0026#34;\u0026#34; if mileage \u0026gt;= self.odometer_reading: self.odometer_reading = mileage else: print(\u0026#34;You can\u0026#39;t roll back an odometer!\u0026#34;) def increment_odometer(self, miles): \u0026#34;\u0026#34;\u0026#34;将里程表读数增加指定的量\u0026#34;\u0026#34;\u0026#34; self.odometer_reading += miles my_new_car = Car(\u0026#39;audi\u0026#39;, \u0026#39;a4\u0026#39;, 2016) # 通过方法获取属性 print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() # 输出： # 2016 Audi A4  # This car has 0 miles on it. # 通过方法对属性值进行修改 my_used_car = Car(\u0026#39;subaru\u0026#39;, \u0026#39;outback\u0026#39;, 2013) print(my_used_car.get_descriptive_name()) my_used_car.update_odometer(23500) my_used_car.read_odometer() my_used_car.increment_odometer(100) my_used_car.read_odometer() # 输出： # 2013 Subaru Outback  # This car has 23500 miles on it.  # This car has 23600 miles on it.  继承 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。派生类的定义如下所示：\nclass DerivedClassName(BaseClassName): \u0026lt;statement-1\u0026gt; . . . \u0026lt;statement-N\u0026gt; BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。\n如果基类定义在另一个模块中，需要使用 . 运算符：\nclass DerivedClassName(modname.BaseClassName): Example：\n# 类定义 class people: # 定义基本属性 name = \u0026#39;\u0026#39; age = 0 # 定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 # 定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\u0026#34;%s说: 我 %d岁。\u0026#34; %(self.name,self.age)) # 单继承示例 class student(people): grade = \u0026#39;\u0026#39; def __init__(self,n,a,w,g): # 调用父类的构函 people.__init__(self,n,a,w) self.grade = g # 覆写父类的方法 def speak(self): print(\u0026#34;%s说: 我 %d岁了，我在读 %d年级\u0026#34;%(self.name,self.age,self.grade)) s = student(\u0026#39;ken\u0026#39;,10,60,3) s.speak()  多继承 Python 有限地支持多继承，多继承的类定义如下：\nclass DerivedClassName(Base1, Base2, Base3): \u0026lt;statement-1\u0026gt; . . . \u0026lt;statement-N\u0026gt; 若是父类中有相同的方法名，而在子类使用时未指定，Python 会根据圆括号中父类的顺序从左至右搜索。即方法在子类中未找到时，从左到右查找父类中是否包含方法。\nExample：\n# 接上一个例子 # 另一个类，多重继承之前的准备 class speaker(): topic = \u0026#39;\u0026#39; name = \u0026#39;\u0026#39; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(\u0026#34;我叫 %s，我是一个演说家，我演讲的主题是 %s\u0026#34;%(self.name,self.topic)) # 多重继承 class sample(speaker,student): a =\u0026#39;\u0026#39; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(\u0026#34;Tim\u0026#34;,25,80,4,\u0026#34;Python\u0026#34;) test.speak() # 方法名同，默认调用的是在括号中排前地父类的方法  方法重写 可以在子类中重写其父类的方法：\nclass Parent: # 定义父类 def myMethod(self): print (\u0026#39;调用父类方法\u0026#39;) class Child(Parent): # 定义子类 def myMethod(self): print (\u0026#39;调用子类方法\u0026#39;) c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child,c).myMethod() # 用子类对象调用父类已被覆盖的方法 # 输出： # 调用子类方法 # 调用父类方法  子类继承父类构造函数说明 如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。\n子类不重写 __init__，实例化子类时，会自动调用父类定义的 __init__。\nExample：\nclass Father(object): def __init__(self, name): self.name = name print (\u0026#34;name: %s\u0026#34; % (self.name)) def getName(self): return \u0026#39;Father \u0026#39; + self.name # 重写了 getName 但并没有重写 __init__ class Son(Father): def getName(self): return \u0026#39;Son \u0026#39; + self.name if __name__ == \u0026#39;__main__\u0026#39;: son = Son(\u0026#39;runoob\u0026#39;) print(son.getName()) # 输出： # name: runoob # Son runoob  如果重写了__init__ 时，实例化子类，就不会调用父类已经定义的 __init__。\nExample：\nclass Father(object): def __init__(self, name): self.name=name print ( \u0026#34;name: %s\u0026#34; %( self.name) ) def getName(self): return \u0026#39;Father \u0026#39; + self.name # 重写了 __init__ 和 getName class Son(Father): def __init__(self, name): print ( \u0026#34;hi\u0026#34; ) self.name = name def getName(self): return \u0026#39;Son \u0026#39;+self.name if __name__==\u0026#39;__main__\u0026#39;: son=Son(\u0026#39;runoob\u0026#39;) print (son.getName()) # 输出： # hi # Son runoob  如果重写了 __init__ 时，要继承父类的构造方法，可以在 __init__ 的定义中使用 super 关键字：\nsuper(子类, self).__init__(参数1, 参数2, ....) 另一种写法：\n父类名称.__init__(self, 参数1, 参数2, ...) Example：\nclass Father(object): def __init__(self, name): self.name = name print(\u0026#34;name: %s\u0026#34; % (self.name)) def getName(self): return \u0026#39;Father \u0026#39; + self.name class Son(Father): def __init__(self, name): super(Son, self).__init__(name) print(\u0026#34;hi\u0026#34;) self.name = name def getName(self): return \u0026#39;Son \u0026#39; + self.name if __name__ == \u0026#39;__main__\u0026#39;: son=Son(\u0026#39;runoob\u0026#39;) print (son.getName()) # 输出： # name: runoob # hi # Son runoob  类的私有属性与私有方法 私有属性不能在类的外部被使用或直接访问。使用两个下划线开头，声明该属性为私有：\n__private_attrs 在类内部的方法中使用私有属性：\nself.__private_attrs Example：\nclass JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter() counter.count() counter.count() print (counter.publicCount) print (counter.__secretCount) # 报错，实例不能访问私有变量 输出结果：\n1 2 2 Traceback (most recent call last): File \u0026#34;test.py\u0026#34;, line 16, in \u0026lt;module\u0026gt; print (counter.__secretCount) # 报错，实例不能访问私有变量 AttributeError: \u0026#39;JustCounter\u0026#39; object has no attribute \u0026#39;__secretCount\u0026#39;  私有方法只能在类的内部调用 ，不能在类的外部调用。使用两个下划线开头，声明该方法为私有方法：\ndef __private_method(self[, ...]): 在类内部的方法中使用私有方法：\nself.__private_methods([...]) Example：\nclass Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(\u0026#39;name : \u0026#39;, self.name) print(\u0026#39;url : \u0026#39;, self.__url) def __foo(self): # 私有方法 print(\u0026#39;这是私有方法\u0026#39;) def foo(self): # 公共方法 print(\u0026#39;这是公共方法\u0026#39;) self.__foo() x = Site(\u0026#39;菜鸟教程\u0026#39;, \u0026#39;www.runoob.com\u0026#39;) x.who() # 正常输出 x.foo() # 正常输出 x.__foo() # 报错 输出结果：\nname : 菜鸟教程 url : www.runoob.com 这是公共方法 这是私有方法 Traceback (most recent call last): File \u0026#34;c:/Users/27120/Documents/MyDocuments/Code/test.py\u0026#34;, line 20, in \u0026lt;module\u0026gt; x.__foo() # 报错，外部不能调用私有方法 AttributeError: \u0026#39;Site\u0026#39; object has no attribute \u0026#39;__foo\u0026#39;  类的专有方法    方法 描述     __init__  构造函数，在生成对象时调用   __del__ 析构函数，释放对象时使用   __repr__ 打印，转换   __setitem__ 按照索引赋值   __getitem__ 按照索引获取值   __len__ 获得长度   __cmp__ 比较运算   __call__ 函数调用   __add__ 加运算   __sub__ 减运算   __mul__ 乘运算   __truediv__ 除运算   __mod__ 求余运算   __pow__ 乘方     运算符重载 可以对类的专有方法进行重载：\nclass Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return \u0026#39;Vector (%d, %d)\u0026#39; % (self.a, self.b) def __add__(self, other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print (v1 + v2) # 输出： # Vector(7,8)  命名空间 命名空间（Namespace）是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。\n命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。\n一般有三种命名空间：\n  内置名称（built-in names）：Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。\n  全局名称（global names）：模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。\n  局部名称（local names）：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量（类中定义的也是）。\n    命名空间查找顺序：局部的命名空间 $\\rightarrow$ 全局命名空间 $\\rightarrow$ 内置命名空间。\n  如果找不到变量，将放弃查找并引发一个 NameError 异常：\nNameError: name \u0026#39;runoob\u0026#39; is not defined   命名空间的生命周期：命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。\n  因此，无法从外部命名空间访问内部命名空间的对象。\n 作用域 作用域就是一个 Python 程序可以直接访问命名空间的正文区域。变量的访问权限取决于这个变量是在哪里赋值的。\n变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有 4 种，分别是：\n  L（Local）：最内层，包含局部变量。如一个函数/方法内部。\n  E（Enclosing）：包含了非局部（non-local）也非全局（non-global）的变量。 如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 non-local。\n  G（Global）：当前脚本的最外层。如当前模块的全局变量。\n  B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。\n  作用域查找顺序： L $\\rightarrow$ E $\\rightarrow$ G $\\rightarrow$ B。\ng_count = 0 # 全局作用域 def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量：\n\u0026gt;\u0026gt;\u0026gt; import builtins \u0026gt;\u0026gt;\u0026gt; dir(builtins) Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else、try/except、for/while等）是不会引入新的作用域的：\n 全局变量和局部变量 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。\n局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。\n global和nonlocal global 和 nonlocal 的作用是让内部作用域修改外部作用域变量。\nglobal —— 修改全局变量：\nnum = 1 def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num) fun1() print(num) # 输出： # 1 # 123 # 123 nonlocal —— 修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量：\ndef outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num) outer() # 输出： # 100 # 100  不使用 global 或 nonlocal 修改外部作用域变量：\na = 10 def test(): a = a + 1 print(a) test() 结果：\nTraceback (most recent call last): File \u0026#34;test.py\u0026#34;, line 7, in \u0026lt;module\u0026gt; test() File \u0026#34;test.py\u0026#34;, line 5, in test a = a + 1 UnboundLocalError: local variable \u0026#39;a\u0026#39; referenced before assignment 局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。\n for x in range(1,5)\nif x \u0026gt; 2\nfor y in range(1,4)\nif y \u0026lt; 3\nx*y\n","date":"2022-01-12T00:00:00Z","permalink":"https://blog.linner.asia/p/python-%E5%9F%BA%E7%A1%80/","title":"Python 基础"},{"content":"正则表达式语法 —— Python 正则表达式是一个特殊的字符序列，能方便地检查一个字符串是否与某种模式匹配。\n  正则表达式可以拼接。\n  正则表达式可以包含普通或者特殊字符。\n  绝大部分普通字符，是最简单的正则表达式。它们就匹配自身。\n  特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。\n  重复修饰符（*、+、?、{m,n}, 等）不能直接嵌套。避免了非贪婪后缀 ? 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。\n     特殊字符    序列 说明     . （点）在默认模式，匹配除了换行的任意字符。 如果指定了标签 DOTALL，它将匹配包括换行符的任意字符。   \\ 转义特殊字符（允许你匹配 '*'、'?'，或者其他正则表达式中使用的特殊字符），或者表示一个特殊序列。   […] 用于表示一个字符集合。\n字符可以单独列出：[abc]，匹配 'a'、'b'、'c'。\n可以表示字符范围，通过用 '-' 将两个字符连起来：[a-z] 将匹配任何小写 ASCII 字符； 可以指定多个范围：[a-zA-Z] 将匹配所有英文字符。 如果 - 进行了转义 （比如 [a-z]）或者它的位置在首位或者末尾（如 [-a] 或 [a-]），它就只表示普通字符 '-'。 特殊字符在集合中，失去它的特殊含义：[(+*)] 只会匹配这几个文法字符 '('、'+'、'*' 或 ')'。 字符类如 \\w 或者 \\S 在集合内可以接受，它们可以匹配的字符由 ASCII 或者 LOCALE 模式决定。\n不在集合范围内的字符可以通过取反（'^' 作为首字符）来进行匹配：[^a] 将匹配除了 'a' 之外的所有字符。 '^' 如果不在集合首位，就没有特殊含义。\n在集合内要匹配一个字符 ']'，有两种方法，要么将它进行转义，要么就把它放到集合首位（如 [()[]{}] 和 []()[{}]）。 嵌套集合和集合操作支持可能在未来添加。如果有多以的情况发生，将会抛出 FutureWarning。   | A|B， A 和 B 可以是任意正则表达式，创建一个正则表达式，匹配 A 或者 B。任意个正则表达式可以用 '|' 连接。它可以在集合或组合内使用。 '|' 操作符绝不贪婪：扫描目标字符串时，由 '|' 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。即，一旦 A 匹配成功， B 就不再进行匹配，即便它能产生一个更好的匹配。 如果要匹配 '|' 字符，使用 |， 或者把它包含在字符集里 [|]。   (…) （组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。     定位符 定位符用来描述字符串或单词的边界。\n   序列 说明     ^ （插入符号）匹配字符串的开头， 并且在 MULTILINE 模式也匹配换行后的首个符号。   $ 匹配字符串尾或者在字符串尾的换行符的前一个字符，在 MULTILINE 模式下也会匹配换行符之前的文本。\n在 'foo1\\nfoo2\\n' 中搜索 foo.$，通常匹配 'foo2'，但在 MULTILINE 模式下可以匹配到 'foo1'。\n在 'foo\\n' 中搜索 $ 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。   \\A 只匹配字符串的开始。相当于默认模式下的 ^。   \\b 匹配一个单词边界。即，匹配空字符串，但只在单词开始或结尾的位置。\n通常 \\b 定义为 \\w 和 \\W 字符之间，或者 \\w 和字符串开始/结尾的边界。\n如果使用了 LOCALE 标志，则词的边界由当前语言区域设置。\n在字符集合内表示退格（如 [\\b]）。   \\B 非单词边界匹配。即，匹配除了单词边界外的任何其他位置。\\B 是 \\b 的取非。\n如果使用了 LOCALE 标志，则词的边界由当前语言区域设置。   \\Z 只匹配字符串尾。     重复修饰符（限定符）   {m}\n对其之前的正则式指定匹配 m 个重复；少于 m 的话就会导致匹配失败。\n  贪婪修饰符：\n  *\n对它前面的正则式匹配 0 到任意次重复， 尽量多地匹配字符串。 等价于：{0,}。\n  +\n对它前面的子表达式匹配 1 到任意次重复， 尽量多地匹配字符串。 等价于：{1,}。\n  ?\n对它前面的子表达式匹配 0 到 1 次重复， 尽量多地匹配字符串。 等价于：{0,1}。\n  {m,}\n对它前面的子表达式进行 m 到任意次重复， 尽量多地匹配字符串。\n  {m,n}（中间不要有空白字符）\n对它前面的子表达式进行 m 到 n 次匹配，在 m 和 n 之间取尽量多。\n  非贪婪修饰符：\n  *?、+?、??、{m,}?、{m,n}?：\n在修饰符之后添加 ? 将使样式以非贪婪方式，或者 :dfn: 最小方式进行匹配； 尽量少的字符将会被匹配。\n   扩展标记法   (?…)``'?' 仅跟随 '(' 并无含义。'?' 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； (?P\u0026lt;name\u0026gt;...) 是唯一的例外。\n  (?aiLmsux)\n在 (? 后带 'a'、 'i'、'L'、'm'、's'、'u'、'x' 中的一个或多个。(?aimsx) 将会匹配空字符串。\n这些字符代表内联标记（与 re 模块中的 RegexFlag 标志常量对应）。\n  'a' —— re.A 模式；\n  'i' —— re.I 模式；\n  'L' —— re.L 模式；\n  'm' —— re.M 模式；\n  's' —— re.S 模式；\n  'u' —— re.U 模式；\n  'x' —— re.X 模式。\n    (?:…)\n正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串不能在执行匹配后被获取或是之后在模式中被引用。\n  (?aiLmsux-imsx:…)``'?' 后面 '-' 前面带 'a'、 'i'、'L'、'm'、's'、'u'、'x' 中的 0 个或多个。'-' 后面 ':' 前面带 'i'、'm'、's'、'x' 中的一到多个。表示设置或者去除（'-' 后指定去除的标记）相应标记。\n与 (?aiLmsux) 一样，这些字符分别代表了不同的内联标记。\n'a'、'L' 和 'u' 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 '-' 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。Python3.7 接受 'a'、'L' 和 'u' 存在于一个组合。 这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。\n  (?P\u0026lt;name\u0026gt;…)\n（命名组合）类似正则组合，但是匹配到的子串组在外部可以通过定义的 name 来获取的（也可以通过数字获取）。组合名必须是有效的 Python 标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。 命名组合可以在三种上下文中引用：\n   引用组合 \u0026ldquo;quote\u0026rdquo; 的上下文 引用方法     在正则式自身内 (?P=quote) 或 \\1   处理匹配对象 m m.group('quote') 或 m.end('quote')（等）   传递到 re.sub() 里的 repl 参数中 \\g\u0026lt;quote\u0026gt; 或 \\g\u0026lt;1\u0026gt; 或 \\1      (?P=name)\n反向引用一个命名组合；它匹配前面名为 name 的命名组中匹配到的串同样的字串（如上所示）。\n  (?#…)\n注释，里面的内容会被忽略。\n  (?=…)\nlookahead assertion，匹配 … 的内容，但是并不消费样式的内容。如，abc(?=def) 当 'abc' 后面是 'def' 的时候，才匹配 'abc'。\n  (?!…)\nnegative lookahead assertion（前视取反），匹配 … 不符合的情况。如，abc(?!def) 当 'abc' 后面不是 'def' 的时候，才匹配 'abc'。\n  (?\u0026lt;=…)\n:dfn:positive lookbehind assertion（正向后视断定），匹配字符串的当前位置，它的前面匹配 … 的内容到当前位置。如，(?\u0026lt;=abc)def 当 'def' 前面是 'abc' 时匹配 'def'，该样式是从 'd' 开始往回搜索的。 包含的匹配样式必须是定长的（ abc 或 a|b 是允许的，但是 a* 和 a{3,4} 不可以）。\n  (?\u0026lt;!…)\nnegative lookbehind assertion （后视断定取非），匹配当前位置之前不是 … 的样式。\n包含的样式匹配必须是定长的。\n由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。\n  (?(id/name)yes-pattern|no-pattern)\n如果给定的 id 或 name 存在，将会尝试匹配 yes-pattern ，否则就尝试匹配 no-pattern（no-pattern 可选，可以被忽略）。\n   \\+普通字符 \\ + （ASCII 数字或字母）：\n   序列 说明     \\number 匹配数字代表的组合。每个正则表达式中的括号是一个组合，组合从 1 开始编号。\n如：(.+) \\1 匹配 'the the' 或者 '55 55'。\n这个特殊序列只能用于匹配前面 99 个组合。\n如果 number 的第一个数位是 0， 或者 number 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。   \\A 只匹配字符串开始。   \\b （单词边界定位符）匹配空字符串，但只在单词开始或结尾的位置。\n在字符集合内表示退格（如 [\\b]）。   \\B （非单词边界定位符）匹配空字符串，但不能在词的开头或者结尾。   \\d 对于 Unicode（str）样式：\n匹配任何 Unicode 十进制数（就是在 Unicode 字符目录 [Nd] 里的字符，包括了 [0-9] ，和很多其他的数字字符）。如果设置了 ASCII 标志，就只匹配 [0-9] 。\n对于8位（bytes）样式：\n匹配任何十进制数（[0-9]）。   \\D 匹配任何非十进制数字的字符（\\d 取非）。\n如果设置了 ASCII 标志，就相当于 [^0-9] 。   \\s 对于 Unicode（str）样式：\n匹配任何 Unicode 空白字符（包括 [ \\t\\n\\r\\f\\v] ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 ASCII 被设置，就只匹配 [ \\t\\n\\r\\f\\v] 。\n对于8位（bytes）样式：\n匹配ASCII中的空白字符（[ \\t\\n\\r\\f\\v]） 。   \\S 匹配任何非空白字符（\\s 取非）。\n如果设置了 ASCII 标志，就相当于 [^ \\t\\n\\r\\f\\v] 。   \\w 对于 Unicode（str）样式：\n匹配 Unicode 词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 ASCII 标志，就只匹配 [a-zA-Z0-9_] 。\n对于8位（bytes）样式：\n匹配 ASCII 字符中的数字和字母和下划线，就是 [a-zA-Z0-9_] 。如果设置了 LOCALE 标记，就匹配当前语言区域的数字和字母和下划线。   \\W 匹配非单词字符的字符（与 \\w 正相反）。\n如果使用了 ASCII 标志，就等价于 [^a-zA-Z0-9_]。\n如果使用了 LOCALE 标志，则会匹配当前区域中既非字母数字也非下划线的字符。   \\Z 只匹配字符串尾。\n如果普通字符不是 ASCII 数位或者 ASCII 字母，那么正则样式将匹配第二个字符（如，\\$ 匹配字符 '$'）。    绝大部分 Python 的标准转义字符也被正则表达式分析器支持：\n\\a \\b \\f \\n \\N \\r \\t \\u \\U \\v \\x \\\\ '\\u'、'\\U' 和 '\\N' 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。\n八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。\n re 模块 Python 的 re 模块提供了与 Perl 语言类似的正则表达式匹配操作。\n 函数 匹配一项 在 re 模块中，有三个函数用于查找并返回一个匹配对象：\n  re.match() —— 返回一个从字符串的起始位置匹配的对象。\n  re.search() —— 返回整个字符串中任意位置第一个成功的匹配。\n  re.fullmatch() —— 整个字符串与正则表达式完全匹配。\n   match() 函数 re.match() 尝试从字符串的起始位置匹配一个模式，其语法如下：\nre.match(pattern, string, flags=0) 参数：\n   参数 描述     pattern 匹配的正则表达式。   string 要匹配的字符串。   flags 标志位，用于控制正则表达式的匹配方式。    返回值：\n匹配成功，re.match() 函数返回一个匹配对象（Match）；否则返回 None。\nExample：\n\u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;abc\u0026#39;, \u0026#39;abcdefg\u0026#39;) # 在起始位置匹配 \u0026lt;_sre.SRE_Match object; span=(0, 3), match=\u0026#39;abc\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;efg\u0026#39;, \u0026#39;abcdefg\u0026#39;) # 不在起始位置匹配 None  search() 函数 re.search() 扫描整个字符串并返回第一个成功的匹配，其语法如下：\nre.search(pattern, string, flags=0) 参数用法与 re.match() 类似。匹配成功，re.search() 方法返回一个匹配对象（Match）；否则返回 None。\nExample：\n\u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;abc\u0026#39;, \u0026#39;abcdefg\u0026#39;) # 在起始位置匹配 \u0026lt;_sre.SRE_Match object; span=(0, 3), match=\u0026#39;abc\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;efg\u0026#39;, \u0026#39;abcdefg\u0026#39;) # 不在起始位置匹配 \u0026lt;_sre.SRE_Match object; span=(4, 7), match=\u0026#39;efg\u0026#39;\u0026gt;  fullmatch() 函数 fullmatch() 将整个字符串与正则表达式匹配，其语法如下：\nre.fullmatch(pattern, string, flags=0) 参数用法与 re.match() 类似。如果 string 与 pattern 完全匹配，那么返回一个匹配对象（Match）；否则返回 None。\nExample：\n\u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.fullmatch(\u0026#39;abc\u0026#39;, \u0026#39;abcdefg\u0026#39;) # 在起始位置匹配 None \u0026gt;\u0026gt;\u0026gt; re.fullmatch(\u0026#39;abcdefg\u0026#39;, \u0026#39;abcdefg\u0026#39;) # 匹配整个字符串 \u0026lt;_sre.SRE_Match object; span=(0, 7), match=\u0026#39;abcdefg\u0026#39;\u0026gt;  匹配多项 有两个函数用于查找并返回匹配的多个匹配对象：\n  re.findall —— 在字符串的任意位置匹配，并返回一个包含了所有匹配对象的列表。\n  re.finditer —— 在字符串的任意位置匹配，并返回一个包含了所有匹配对象的迭代器。\n   finall() finall() 在字符串中找到正则表达式所匹配的所有子串，其语法如下：\nre.findall(pattern, string, flags=0) 参数：\n   参数 描述     pattern 匹配的正则表达式。   string 要匹配的字符串。   flags 标志位，用于控制正则表达式的匹配方式。    返回值：\n返回一个列表，包含了所有匹配对象；如果没有任何匹配项，则返回空列表。\n finditer() 与 finall() 类似，其语法如下：\nre.finditer(pattern, string, flags=0) 该函数返回的是迭代器。\n如果可能存在大量的匹配项的话，建议使用 finditer()。\n split() 正则分割 re.split() 按照能够匹配的子串对字符串进行分割，其语法如下：\nre.split(pattern, string[, maxsplit=0, flags=0]) 参数：\n   参数 描述     pattern 匹配的正则表达式。   string 要匹配的字符串。   maxsplit 最大分割次数，maxsplit=1 分割一次，默认为 0，不限制次数。   flags 标志位，用于控制正则表达式的匹配方式。    返回值：\n返回一个用 patterm 模式匹配的字符分割的字符串列表。如果查找不到任何匹配，则返回一个仅包含 string 的列表。\nstr 模块下也有一个 split() 函数，但它并不支持正则分割。\n 替换 有两个替换函数：re.sub() 和 re.subn()。\nre.sub(pattern, repl, string, count=0, flags=0) re.subn(pattern, repl, string, count=0, flags=0) 参数：\n   参数 描述     pattern 匹配的正则表达式。   repl 替换内容，可以是字符串，也可以是函数。如果 repl 为函数，只能有一个匹配对象作为参数。   string 要匹配的字符串。   count 最大替换次数。   flags 标志位，用于控制正则表达式的匹配方式。    repl 替换掉 string 中被 pattern 匹配的字符。\n返回值：\nre.sub() 返回一个替换后的字符串。如果 string 中没有任何匹配项，则返回 string。\nre.subn() 返回一个元组，包含了替换后的字符串和替换次数：(str, n)。\n excape() 转义函数 re.exvape() 函数可以转义参数 pattern 中的特殊字符。\nre.exvape(pattern) Example：\n\u0026gt;\u0026gt;\u0026gt; print(re.escape(\u0026#39;http://www.python.org\u0026#39;)) http://www\\.python\\.org Python3.3：_ 不再被转义。\nPython3.7：只有在正则表达式中具有特殊含义的字符才会被转义。 因此， !、\u0026quot;、%、'、,、/、:、;\u0026lt;'、=\u0026gt;'、@ 和 ` 将不再会被转义。\n使用 re.exvape() 函数很容易出现转义错误的问题，所以并不建议使用它转义。\n purge() 清除正则表达式缓存 re.purge() 用于清除正则表达式的缓存。它没有参数，没有返回值。\n RegexFlag 标志常量   re.ASCII：\n  简写：re.A。\n  让 \\w, \\W, \\b, \\B, \\d, \\D, \\s 和 \\S 只匹配 ASCII 编码支持的字符，而不是 Unicode。这只对 Unicode 样式（Python3 默认）有效，会被 byte 样式忽略。\n  Example：\n\u0026gt;\u0026gt;\u0026gt; re.search(r\u0026#39;\\w+\u0026#39;, \u0026#39;中文字符和ASCII\u0026#39;, re.A) \u0026lt;_sre.SRE_Match object; span=(5, 10), match=\u0026#39;ASCII\u0026#39;\u0026gt;   对应内联标记：(?a) 。\n    re.DEBUG：\n  显示编译时的 debug 信息，没有内联标记。\n  Example：\n\u0026gt;\u0026gt;\u0026gt; re.search(r\u0026#39;.*\u0026#39;, \u0026#39;显示debug信息\u0026#39;, re.DEBUG) MAX_REPEAT 0 MAXREPEAT ANY None \u0026lt;_sre.SRE_Match object; span=(0, 9), match=\u0026#39;显示debug信息\u0026#39;\u0026gt;   对应内联标记：(?i) 。\n    re.IGNORECASE：\n  简写：re.I。\n  进行忽略大小写匹配。\n  Example：\n\u0026gt;\u0026gt;\u0026gt; re.findall(r\u0026#39;[a-z]\u0026#39;, \u0026#39;大写字母：ABCDE 小写字母：abcde\u0026#39;, re.I) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]     re.LOCALE：\n  简写：re.L。\n  语言依赖，由当前语言区域决定 \\w, \\W, \\b, \\B 和大小写敏感匹配。这个标记只能对 byte 样式有效。这个标记官方并不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对 8 位字节有效。\n  对应内联标记：(?L) 。\n    re.MULTILINE：\n  简写：re.M。\n  多行模式，样式字符 '^' 匹配每一个行开始（字符串的开始和换行符后紧跟的符号）；样式字符 '$' 匹配每一个行结尾（字符串结尾和换行符前面的符号）。\n默认情况下不支持换行符特性，'^' 匹配字符串开始，'$' 匹配字符串结尾。\n  Example：\n\u0026gt;\u0026gt;\u0026gt; re.findall(r\u0026#39;^.*$\u0026#39;, \u0026#39;第1行\\n第2行\\n第3行\u0026#39;, re.M) [\u0026#39;第1行\u0026#39;, \u0026#39;第2行\u0026#39;, \u0026#39;第3行\u0026#39;]   对应内联标记：(?m)。\n    re.DOTALL：\n  简写：re.S。\n  让 '.' 特殊字符匹配全部字符，包括换行符。\n默认情况下，'.' 仅匹配除了换行符的其他任意字符。\n  对应内联标记：(?s) 。\n    re.VERBOSE：\n  简写：re.X。\n  冗长模式，允许在正则表达式中换行和添加注释。 该模式下空白符号会被忽略，除非在一个字符集合中或者由反斜杠转义，或者在 *?、(?:、(?P\u0026lt;…\u0026gt; 分组之内。 当一个行内有 # 不在字符集和转义序列，那么它之后的所有字符都是注释。\n  Example：\n\u0026gt;\u0026gt;\u0026gt; re.search(r\u0026#39;\u0026#39;\u0026#39;\\d + # the integral part ... \\. # the decimal point ... \\d * # some fractional digits\u0026#39;\u0026#39;\u0026#39;, ... \u0026#39;圆周率：3.14\u0026#39;, re.X) \u0026lt;_sre.SRE_Match object; span=(4, 8), match=\u0026#39;3.14\u0026#39;\u0026gt;   对应内联标记：(?x) 。\n    re.UNICODE：\n  简写：re.U。\n  匹配 Unicode 编码支持的字符，是 Python3 默认的字符串模式。虽然保留着，但对 Python3 来说是个冗余的常量。\n    re.TEMPLATE：\n  简写：re.T。\n  re 模块的源码是这样描述该常量的（官方文档中并没有具体的描述）：\nTEMPLATE = T = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking      正则对象 Pattern 使用 compile() 和 template() 可以将正则表达式编译为正则表达式对象（Pattern，正则对象）。\nre.compile() 的语法如下：\nre.compile(pattern, flags=0)    参数 描述     pattern 要转化为正则对象的正则表达式。   flags 标志位，用于控制正则表达式的匹配方式。 可以通过位的 OR（'|'）操作来结合多个模式。    Example：\n\u0026gt;\u0026gt;\u0026gt; pattern_obj = re.compile(r\u0026#39;abc\u0026#39;) \u0026gt;\u0026gt;\u0026gt; pattern_obj.search(\u0026#39;abcdefg\u0026#39;) \u0026lt;_sre.SRE_Match object; span=(0, 3), match=\u0026#39;abc\u0026#39;\u0026gt; 使用正则对象和函数：\n  正则对象和函数是一致的。\n模块的底层实现中，re.compile() 与其他 re 函数内部调用的是同一个函数 re._compile()。\n  如果需要多次使用某个正则表达式的话，使用 re.compile() 和保存这个正则对象以便复用，可以让程序更加高效。通过 re.compile() 编译后的样式，和模块级的函数会被缓存。\n   正则对象方法 正则对象支持以下方法：\n   方法 说明     Pattern.search(string[, pos[, endpos]]) 扫描整个 string 寻找第一个匹配的位置， 并返回一个相应的匹配对象（Match）。如果没有匹配，就返回 None。\npos —— 字符串中开始搜索的位置索引，默认为 0，它不完全等价于字符串切片。^ 样式字符匹配行开头，但不会匹配索引规定开始的位置。\nendpos —— 字符串搜索的结束。只有从 pos 到 endpos - 1 的字符会被匹配。\n如果 endpos 小于 pos，就不会有匹配产生。\npattern_obj.search(string, 0, 50)等价于pattern_obj.search(string[:50], 0)`。   Pattern.match(string[, pos[, endpos]]) 如果 string 的开始位置能够找到这个正则样式 Pattern 的任意个匹配，就返回一个相应的匹配对象（Match）。如果不匹配，就返回 None。\n可选参数 pos 和 endpos 指定 string 的查找范围，与 Pattern.search() 含义相同。   Pattern.fullmatch(string[, pos[, endpos]]) 如果整个 string 匹配这个正则表达式，就返回一个相应的匹配对象（Match）。如果不匹配，就返回 None。\n可选参数 pos 和 endpos 指定 string 的查找范围。   Pattern.findall(string[, pos[, endpos]]) 类似 re.findall()，使用了编译后样式，在 string 中找到 Pattern 所匹配的所有子串，以列表形式返回所有匹配项。\n可选参数 pos 和 endpos 指定 string 的查找范围。   Pattern.finditer(string[, pos[, endpos]]) 类似函数 finiter() ， 使用了编译后样式，在 string 中找到 Pattern 所匹配的所有子串，以迭代器形式返回所有匹配项。\n可选参数 pos 和 endpos 指定 string 的查找范围。   Pattern.split(string, maxsplit=0) 等价于 split() 函数，使用了编译后的样式，按照能够匹配的子串对字符串进行分割。\nmaxsplit —— 最大分割次数。   Pattern.sub(repl, string, count=0) 等价于 sub() 函数，使用了编译后的样式，使用 repl 替换掉 string 中被 Pattern 匹配的字符。\ncount —— 最大替换次数。\n返回一个替换后的字符串。如果 string 中没有任何匹配项，则返回 string。   Pattern.subn(repl, string, count=0) 等价于 subn() 函数，使用了编译后的样式，使用 repl 替换掉 string 中被 Pattern 匹配的字符。\ncount —— 最大替换次数。\n返回一个元组，包含了替换后的字符串和替换次数。     正则对象属性    属性 说明     Pattern.flags 正则匹配标记。\n可以传递给 compile() 的参数。任何 (?…) 内联标记，隐性标记（re.U）的结合。   Pattern.groups 捕获到的模式串中组的数量。   Pattern.groupindex 映射由 (?P\u0026lt;id\u0026gt;) 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。   Pattern.pattern 编译对象的原始样式字符串。     匹配对象 匹配对象（Match）是调用 re 模块中的函数或方法匹配后返回的对象。\n匹配对象总是有一个布尔值 True。如果没有匹配的话 re.match() 和 re.search() 返回 None。可以简单的用 if 语句来判断是否匹配：\n\u0026gt;\u0026gt;\u0026gt; if re.search(r\u0026#39;a\u0026#39;, \u0026#39;abc\u0026#39;): ... print(True) ... True \u0026gt;\u0026gt;\u0026gt; if re.search(r\u0026#39;d\u0026#39;, \u0026#39;abc\u0026#39;): ... print(True) ... else: ... print(False) ... False  匹配对象方法 匹配对象支持以下方法：\n  Match.expand(template)：\n 对 template 进行反斜杠（'\\'）转义替换并且返回。    Match.group([group1, ...])：\n  返回一个或者多个匹配的子组。\n  如果只有一个参数，结果就是一个字符串； 如果有多个参数，结果就是一个元组（每个参数对应一个项）； 如果没有参数，group1 默认为 0（整个匹配都被返回）。\n  如果一个 groupN 参数值为 0，相应的返回值就是整个匹配字符串； 如果它是一个范围 [1..99]，结果就是相应的括号组字符串。\n  如果一个组号是负数，或者大于样式中定义的组数，会抛出一个 IndexError。\n  Example：\n\u0026gt;\u0026gt;\u0026gt; m = re.match(r\u0026#39;(\\w+) (\\w+)\u0026#39;, \u0026#39;Python PHP Java C++\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.group() # 返回整个匹配 \u0026#39;Python PHP\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.group(1) # 返回第一个括号组 \u0026#39;Python\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.group(2) # 返回第二个括号组 \u0026#39;PHP\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.group(1, 2) # 多个参数返回一个元组 (\u0026#39;Python\u0026#39;, \u0026#39;PHP\u0026#39;)   如果正则表达式使用了 (?P\u0026lt;name\u0026gt;…) 语法， groupN 参数可以是索引值，也可以是组名。\n\u0026gt;\u0026gt;\u0026gt; m = re.match(r\u0026#39;(?P\u0026lt;name_1\u0026gt;\\w+) (?P\u0026lt;name_2\u0026gt;\\w+)\u0026#39;, \u0026#39;Python PHP\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.group(\u0026#39;name_1\u0026#39;, \u0026#39;name_2\u0026#39;) (\u0026#39;Python\u0026#39;, \u0026#39;PHP\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.group(1, 2) (\u0026#39;Python\u0026#39;, \u0026#39;PHP\u0026#39;)   如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。\n\u0026gt;\u0026gt;\u0026gt; m = re.match(r\u0026#39;(..)+\u0026#39;, \u0026#39;a1b2c3\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.group(1) \u0026#39;c3\u0026#39;     Match.getitem(g)：\n  Python3.6 新增功能。\n  等价于 m.group(g)，允许更方便地引用一个匹配。\n\u0026gt;\u0026gt;\u0026gt; m = re.match(r\u0026#39;(?P\u0026lt;name_1\u0026gt;\\w+) (?P\u0026lt;name_2\u0026gt;\\w+)\u0026#39;, \u0026#39;Python PHP\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m[0] \u0026#39;Python PHP\u0026#39; \u0026gt;\u0026gt;\u0026gt; m[1] \u0026#39;Python\u0026#39; \u0026gt;\u0026gt;\u0026gt; m[2] \u0026#39;PHP\u0026#39;     Match.groups(default=None)：\n  返回一个元组，包含所有匹配的子组，在样式中出现的从 1 到任意多的组合。default 参数用于不参与匹配的情况，默认为 None。\n  Example： 使小数部分可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 None ，除非指定了 default 参数。\n\u0026gt;\u0026gt;\u0026gt; m = re.match(r\u0026#39;(\\d+)\\.(\\d+)\u0026#39;, \u0026#39;3.14\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.groups() (\u0026#39;3\u0026#39;, \u0026#39;14\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m = re.match(r\u0026#34;(\\d+)\\.?(\\d+)?\u0026#34;, \u0026#39;3\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.groups() # 第二个子组默认为 None (\u0026#39;3\u0026#39;, None) \u0026gt;\u0026gt;\u0026gt; m.groups(\u0026#39;0\u0026#39;) # 第二个子组被设置为指定的默认值 \u0026#39;0\u0026#39; (\u0026#39;3\u0026#39;, \u0026#39;0\u0026#39;)     Match.groupdict(default=None)：\n  返回一个字典，包含了所有的命名子组。key 就是组名。 default 参数用于不参与匹配的组合；默认为 None。\n  Example：\n\u0026gt;\u0026gt;\u0026gt; m = re.match(r\u0026#39;(?P\u0026lt;name_1\u0026gt;\\w+) (?P\u0026lt;name_2\u0026gt;\\w+)\u0026#39;, \u0026#39;Python PHP\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.groupdict() {\u0026#39;name_1\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;name_2\u0026#39;: \u0026#39;PHP\u0026#39;}     Match.start([group]) 和 Match.end([group])：\n  返回 group 匹配到的字串在原字符串的开始和结束索引。group 默认为 0（意思是整个匹配的子串）。如果 group 存在，但未产生匹配，就返回 -1 。\n  从 email 地址中移除掉 remove_this：\n\u0026gt;\u0026gt;\u0026gt; email = \u0026#34;tony@tiremove_thisger.net\u0026#34; \u0026gt;\u0026gt;\u0026gt; m = re.search(\u0026#34;remove_this\u0026#34;, email) \u0026gt;\u0026gt;\u0026gt; email[:m.start()] + email[m.end():] \u0026#39;tony@tiger.net\u0026#39;     Match.span([group])：\n 对于一个匹配 m ， 返回一个二元组 (m.start(group), m.end(group)) 。 如果 group 没有在这个匹配中，就返回 (-1, -1) 。 group 默认为 0，就是整个匹配。     ","date":"2022-01-12T00:00:00Z","permalink":"https://blog.linner.asia/p/python-%E8%BF%9B%E9%98%B6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AF%87/","title":"Python 进阶 — 正则表达式篇"},{"content":"假设有三个 bat 程序需要后台运行（称为 A.bat、B.bat、C.bat）：\nSet ws = CreateObject(\u0026quot;Wscript.Shell\u0026quot;) ws.run \u0026quot;cmd /c A.bat\u0026quot;,0 ws.run \u0026quot;cmd /c B.bat\u0026quot;,0 ws.run \u0026quot;cmd /c C.bat\u0026quot;,0 ","date":"2022-01-12T00:00:00Z","permalink":"https://blog.linner.asia/p/vbs-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C-bat/","title":"vbs 后台运行 bat"},{"content":"冒泡排序 冒泡排序（Bubble Sort）是一种简单直观的排序算法。\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n时间复杂度：$O(n^2)$\n算法步骤 假设一个序列长度为n，m（m≤n）是已排序完成的在末尾的数。\n  比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。对比结束后，最后的元素会是最大的数。\n  对接下来n-m个未排序的数重复步骤1和2，直到没有任何一对数字需要比较。\n第一趟对序列中所有n个数进行比对，第二趟对序列中n-1个未排序完成的数进行比对，以此类推。每次比对的数为n-m。\n  动画演示：\n代码实现 Python实现 def bubbleSort(arr): for i in range(len(arr)-1): for j in range(len(arr)-1-i): if arr[j] \u0026gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] bubbleSort(arr) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt; void bubbleSort(int arr[], int len) { for (int i = 0; i \u0026lt; len - 1; i++) for (int j = 0; j \u0026lt; len - 1 - i; j++) if (arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bubbleSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; } 优化算法 有序标志 冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。\n  Python实现：\ndef bubbleSort(arr): for i in range(len(arr)-1): # 有序flag，初始为True isSorted = True for j in range(len(arr)-1-i): if arr[j] \u0026gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] # 发生交换，序列定为无序 isSorted = False # 序列有序，停止循环 if isSorted: break return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] bubbleSort(arr) print(arr)   C实现：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; void bubbleSort(int arr[], int len) { for (int i = 0; i \u0026lt; len - 1; i++) { // 有序flag，初始为True  bool isSorted = true; for (int j = 0; j \u0026lt; len - 1 - i; j++) if (arr[j] \u0026gt; arr[j + 1]) { arr[j] = arr[j] ^ arr[j+1]; arr[j+1] = arr[j] ^ arr[j+1]; arr[j] = arr[j] ^ arr[j+1]; // 发生交换，序列定为无序  isSorted = false; } // 序列有序，停止循环  if (isSorted) break; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bubbleSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }   数列有序区 通常，有序区的长度和排序的轮数是相等的。如，第一轮排序后的有序区长度是1，第二轮排序后是2 ……\n但实际上，数列的有序区长度可能会大于这个长度，并且每轮增加的有序区长度也不一定仅为1。\n该优化算法解决了这个问题，通过在每一轮排序的最后，记录下最后一次元素交换的位置（该位置也就是无序数列的边界，再往后就是有序区），而每轮的交换只要交换到无序区边界。\n  Python实现：\ndef bubbleSort(arr): # 无序数列的边界 sortBorder = len(arr) - 1 for i in range(len(arr)-1): # 有序flag，初始为True isSorted = True # 每次仅需交换到无序区边界 for j in range(sortBorder): if arr[j] \u0026gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] # 把无序数列的边界更新为最后一次交换元素的位置 sortBorder = j # 发生交换，序列定为无序 isSorted = False # 序列有序，停止循环 if isSorted: break return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 5, 50, 3, 32, 37, 34, 35, 9, 55, 64, 70, 82, 89 ] bubbleSort(arr) print(arr)   C实现：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; void bubbleSort(int arr[], int len) { int sortBorder = len - 1; for (int i = 0; i \u0026lt; len - 1; i++) { // 有序flag，初始为True  bool isSorted = true; for (int j = 0; j \u0026lt; len - 1 - i; j++) if (arr[j] \u0026gt; arr[j + 1]) { arr[j] = arr[j] ^ arr[j+1]; arr[j+1] = arr[j] ^ arr[j+1]; arr[j] = arr[j] ^ arr[j+1]; // 把无序数列的边界更新为最后一次交换元素的位置  sortBorder = j; // 发生交换，序列定为无序  isSorted = false; } // 序列有序，停止循环  if (isSorted) break; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bubbleSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }    选择排序 选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去都是 $O(n²)$ 的时间复杂度。\n算法步骤  在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复步骤2，直到所有元素均排序完毕。  动画演示：\n代码实现 Python实现 def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] \u0026lt; arr[minIndex]: minIndex = j # i 不是最小数时，将 i 和最小数进行交换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] arr = selectionSort(arr) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt; void selectionSort(int arr[], int len) { for (int i = 0 ; i \u0026lt; len - 1 ; i++) { int min = i; for (int j = i + 1; j \u0026lt; len; j++) // 走访未排序的元素  // 找到最小值  if (arr[j] \u0026lt; arr[min]) min = j; // i 不是最小数时，将 i 和最小数进行交换  if (i != min) { int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); selectionSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  插入排序 插入排序（Insertion Sort）是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n插入排序的有一种优化算法，叫做拆半插入。\n算法步骤 假设序列的长度为$n$，其待排序序列第一个元素的位置为$m$（$1 \\le m \\le n$，元素位置从0开始）。\n  将元素$m$与已排序序列中的每个元素进行比较。如果已排序元素比元素$m$大，将元素$m$中比已排序序列大的元素往后移，直到前面没有比元素$m$大的元素（或前面已经没有元素）。将元素m插入。\n如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。\n  从头到尾依次扫描未排序序列，直到没有未排序元素。\n  动画演示：\n代码实现 Python实现 def insertionSort(arr): for i in range(len(arr) - 1): preIndex = i current = arr[i + 1] # 找出要插入的位置 while preIndex \u0026gt;= 0 and arr[preIndex] \u0026gt; current: # 将比current大的元素往后移 arr[preIndex + 1] = arr[preIndex] preIndex -= 1 # 将current插入到适当的位置 arr[preIndex + 1] = current return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] insertionSort(arr) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt; void insertionSort(int arr[], int len) { for (int i = 0 ; i \u0026lt; len - 1 ; i++) { int current = arr[i + 1]; int j = i; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; current) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = current; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); insertionSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  希尔排序 算法步骤 希尔排序（Shell Sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。  希尔排序的基本思想是：先将整个待排序的增量序列根据增量分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n算法步骤  选择一个增量序列$t_1,t_2,\u0026hellip;,t_k$，其中$t_i \u0026lt; t_{i-1}(1 \\le i \\le k),t_k = 1$； 按增量序列个数$k$，对序列进行$k$趟排序； 每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为$t_i$的子序列，分别对各子表进行直接插入排序。仅增量因子为$1$时，整个序列作为一个表来处理，表长度即为整个序列的长度。  动画演示：\n详细过程（引用自博客：一个很懒的人）：\n代码实现 Python实现 def shellSort(arr): # 将增量d初始化为len(arr)//2 d = len(arr) // 2 while d \u0026gt; 0: # 分别用插入排序排序每个以d为增量的分组 for i in range(d, len(arr)): tmp = arr[i] j = i - d while j \u0026gt;= 0 and tmp \u0026lt; arr[j]: arr[j + d] = arr[j] j -= d arr[j + d] = tmp # 每次将增量d缩小1/2 d //= 2 return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] shellSort(arr) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt; void shellSort(int arr[], int len) { // 将增量d初始化为len/2，每次将增量d缩小1/2  for (int d = len \u0026gt;\u0026gt; 1; d \u0026gt; 0; d \u0026gt;\u0026gt;= 1) { // 分别用插入排序排序每个以d为增量的分组  for (int i = d; i \u0026lt; len; i++) { int tmp = arr[i]; int j; for (j = i - d; j \u0026gt;= 0 \u0026amp;\u0026amp; tmp \u0026lt; arr[j]; j -= d) arr[j + d] = arr[j]; arr[j + d] = tmp; } } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); shellSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n 自上而下的递归； 自下而上的迭代。  算法步骤  申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。  动画演示：\n图片演示：\n  递归演示：\n  合并演示：\n  代码实现 Python 实现 def mergeSort(arr): # 结束递归 if(len(arr) \u0026lt; 2): return arr # 计算中间位置下标 middle = len(arr) // 2 # 将序列切分为两半 left, right = arr[:middle], arr[middle:] # 进行归并排序 return merge(mergeSort(left), mergeSort(right)) def merge(left, right): result = [] while left and right: # 将较小的元素放在前面 if left[0] \u0026lt;= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) # 将某一序列中剩下的元素全部放入 while left: result.append(left.pop(0)) while right: result.append(right.pop(0)) return result if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] arr = mergeSort(arr) print(arr) C实现 非递归实现：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int min(int x, int y) { return x \u0026lt; y ? x : y; } void mergeSort(int arr[], int len) { int* a = arr; int* b = (int*)malloc(len * sizeof(int)); if (!b) return; // 分为约log_2(len)次  for (int seg = 1; seg \u0026lt; len; seg += seg) { // 每次对下标区间为[low,high)的子序列进行归并排序  for (int start = 0; start \u0026lt; len; start += seg * 2) { // 当前排序区间：[low,high)  int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len); // 第1段：[low,mid)  int start1 = low, end1 = mid; // 第2段：[mid,high)  int start2 = mid, end2 = high; // 对子序列进行归并排序  int i = low; // 将两个序列中较小的放在前面  while (start1 \u0026lt; end1 \u0026amp;\u0026amp; start2 \u0026lt; end2) b[i++] = a[start1] \u0026lt; a[start2] ? a[start1++] : a[start2++]; // 将某一序列中剩下的元素全部放入  while (start1 \u0026lt; end1) b[i++] = a[start1++]; while (start2 \u0026lt; end2) b[i++] = a[start2++]; } int* tmp = a; a = b; b = tmp; } if (a != arr) { for (int i = 0; i \u0026lt; len; i++) b[i] = a[i]; b = a; } free(b); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); mergeSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; } 递归实现：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; void merge_sort_recursive(int arr[], int reg[], int start, int end) { // 结束递归  if (start \u0026gt;= end) return; // 当前排序区间：[start,end]  int len = end - start, mid = (len \u0026gt;\u0026gt; 1) + start; // 第1段：[start,mid]  int start1 = start, end1 = mid; // 第2段：[mid+1,end]  int start2 = mid + 1, end2 = end; // 对第1段进行递归地排序  merge_sort_recursive(arr, reg, start1, end1); // 对第2段进行递归地排序  merge_sort_recursive(arr, reg, start2, end2); int i = start; while (start1 \u0026lt;= end1 \u0026amp;\u0026amp; start2 \u0026lt;= end2) reg[i++] = arr[start1] \u0026lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 \u0026lt;= end1) reg[i++] = arr[start1++]; while (start2 \u0026lt;= end2) reg[i++] = arr[start2++]; for (int i = start; i \u0026lt;= end; i++) arr[i] = reg[i]; } void mergeSort(int arr[], int len) { int* reg = (int*)malloc(len * sizeof(int)); merge_sort_recursive(arr, reg, 0, len - 1); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); mergeSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  快速排序 快速排序在平均状况下，排序$n$个项目是$O(n\\log {n})$。最坏运行情况是$O(n^2)$，但这种状况并不常见，比如说数列为顺序数列的情况下。一般，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\n事实上，快速排序通常明显比其他$O(n\\log {n})$算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。\n本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\n算法步骤  从序列中选择一个元素作为“基准”（pivot）。 将所有比基准数小的放在基准左边，所有比基准数大的放在基准右边（相同的数可以在任一边）。这个称为分区（partition）操作。 分区完成后，该基准就会归到序列中的相应位置，该位置是排序完成后的位置。 分别递归地把小于基准数的子序列（左边）和大于基准数的子序列（右边）执行1~3操作。  动画演示：\n代码实现 Python实现 def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] def partition(arr, left, right): # 设置基准 pivot = left # 索引从基准的下一个元素开始 index = pivot + 1 # 遍历:[index,right] for i in range(index, right + 1): # 将小于基准值的元素全部放到左边 if arr[i] \u0026lt; arr[pivot]: swap(arr, i, index) index += 1 i += 1 # 将基准归位 # 此时index位置上的是比基准值大的元素 # 或者等于right+1 # 即1\u0026lt;=index\u0026lt;=right+1 # 只有index-1才是基准真正的位置 swap(arr, pivot, index - 1) return index - 1 def quickSort(arr, left=None, right=None): # 设定参数值 left = 0 if not isinstance(left, (int, float)) else left right = len(arr) - 1 if not \\ isinstance(right, (int, float)) else right if left \u0026lt; right: # 先进行“治”操作并取得分区索引 partitionIndex = partition(arr, left, right) # 分别对左右两个分区递归地进行快速排序 quickSort(arr, left, partitionIndex - 1) quickSort(arr, partitionIndex + 1, right) return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] quickSort(arr) print(arr) C实现 递归实现：\n#include \u0026lt;stdio.h\u0026gt; void quick_sort_recursive(int arr[], int start, int end) { if (start \u0026gt;= end) return; // 设置基准  int pivot = arr[start]; int left = start, right = end; while (left \u0026lt; right) { // 先从右边起找出比基准小的  while (arr[right] \u0026gt;= pivot \u0026amp;\u0026amp; left \u0026lt; right) right--; // 把比基准小的放到基准左边  arr[left] = arr[right]; // 再从左边起找出比基准大的  while (arr[left] \u0026lt;= pivot \u0026amp;\u0026amp; left \u0026lt; right) left++; // 把比基准大的放到基准右边  arr[right] = arr[left]; } // 将基准归位  arr[left] = pivot; // 分别递归地排序左右两个分区  quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end); } void quickSort(int arr[], const int len) { quick_sort_recursive(arr, 0, len - 1); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); quickSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; } 非递归实现：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // 范围 typedef struct _stack { int start, end; } Range; // 申请一个新的栈元素 Range new_Range(int start, int end) { Range s = { .start = start, .end = end }; return s; } void quickSort(int arr[], const int len) { if (len \u0026lt;= 1) return; // s模拟栈，p为数量，r[p++]为push，r[--p]为pop0  Range* s = (Range*)malloc(len * sizeof(Range)); int p = 0; // 范围为[0,len-1]  s[p++] = new_Range(0, len - 1); while (p) { // pop出当前要排序的范围  Range range = s[--p]; if (range.start \u0026gt;= range.end) continue; // 设置基准  int pivot = arr[range.start]; int left = range.start, right = range.end; while (left \u0026lt; right) { // 先从右边起找出比基准小的  while (arr[right] \u0026gt;= pivot \u0026amp;\u0026amp; left \u0026lt; right) right--; // 把比基准小的放到基准左边  arr[left] = arr[right]; // 再从左边起找出比基准大的  while (arr[left] \u0026lt;= pivot \u0026amp;\u0026amp; left \u0026lt; right) left++; // 把比基准大的放到基准右边  arr[right] = arr[left]; } // 将基准归位  arr[left] = pivot; // 分别设置左右两个分区的范围  if (range.start \u0026lt; left) s[p++] = new_Range(range.start, left - 1); if (range.end \u0026gt; left) s[p++] = new_Range(left + 1, range.end); } free(s); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); quickSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。\n堆积是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；  堆排序的平均时间复杂度为 Ο(nlogn)。\n堆排序是不稳定的。\n算法步骤   将待排序的数组构造出一个堆 H[0……n-1]；\n  把堆首（堆顶结点，即最大值）和堆尾（堆的最下层最右边的结点）互换；\n此时不再对原堆顶（最大值）进行操作，即原堆顶已经被“移出”，堆的长度缩小1。\n  把新的数组顶端数据调整到相应位置；\n  重复步骤 2~3，直到堆的尺寸为 1。\n  动画演示：\n代码实现 Python实现 def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] def heapify(arr, len, i): # 子结点 son = 2*i + 1 # 最大值元素位置 largest = i # 将最大值置为堆顶结点 if son \u0026lt; len: if son + 1 \u0026lt; len and arr[son + 1] \u0026gt; arr[son]: son += 1 if arr[son] \u0026gt; arr[largest]: largest = son swap(arr, i, largest) # 重新构造子堆 heapify(arr, len, largest) def buildMaxHeap(arr): # int(len(arr)/2)递减至0 for i in range(int(len(arr)/2) - 1, -1, -1): heapify(arr, len(arr), i) def heapSort(arr, left=None, right=None): global arrLen arrLen = len(arr) # 构造堆 buildMaxHeap(arr) # len(arr)-1递减至1 for i in range(len(arr)-1, 0, -1): # 交换堆顶和最下层最右元素 swap(arr, 0, i) # 将原堆顶移出并重新调整堆 heapify(arr, i, 0) return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] heapSort(arr) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; void swap(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; } void heapify(int arr[], int len, int i) { // 子节点  int son = i*2 + 1; // 最大值元素位置  int largest = i; // 将最大值置为堆顶结点  if (son \u0026lt; len) { if (son + 1 \u0026lt; len \u0026amp;\u0026amp; arr[son + 1] \u0026gt; arr[son]) son++; if (arr[son] \u0026gt; arr[largest]) { largest = son; swap(\u0026amp;arr[i], \u0026amp;arr[largest]); // 重新构造子堆  heapify(arr, len, largest); } } } void buildMaxHeap(int arr[], int len) { for (int i = len / 2 - 1; i \u0026gt;= 0; i--) heapify(arr, len, i); } void heapSort(int arr[], int len) { // 构造堆  buildMaxHeap(arr, len); for (int i = len - 1; i \u0026gt; 0; i--) { // 交换堆顶和最下层最右元素  swap(\u0026amp;arr[0], \u0026amp;arr[i]); // 将原堆顶移出并重新调整堆  heapify(arr, i, 0); } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); heapSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是$Θ(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。\n由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。\n算法步骤  找出待排序的数组中最大和最小的元素。 统计数组中每个值为 i的元素出现的次数，存入数组 C的第 i项。 对所有的计数累加（从 C中的第一个元素开始，每一项和前一项相加）。 反向填充目标数组：将每个元素 i放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。  动画演示：\n代码实现 Python实现 def countingSort(arr): # 找出最大值 max = arr[0] for i in range(1, len(arr)): if arr[i] \u0026gt; max: max = arr[i] # 构建一个长度为max+1的数组 bucket = [0] * (max + 1) # 计数 for i in range(len(arr)): if not bucket[arr[i]]: bucket[arr[i]] = 0 bucket[arr[i]] += 1 # 反向填充 index = 0 for i in range(len(bucket)): while bucket[i] \u0026gt; 0: arr[index] = i bucket[i] -= 1 index += 1 return arr if __name__ == \u0026#39;__main__\u0026#39;: arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] countingSort(arr) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; void countingSort(int arr[], int len) { // 找出最大值  int max = arr[0]; for (int i = 0; i \u0026lt; len; i++) if (arr[i] \u0026gt; max) max = arr[i]; // 构造和初始化  int bucketLen = max + 1; int* bucket = (int*)malloc(bucketLen * sizeof(int)); for (int i = 0; i \u0026lt; bucketLen; i++) bucket[i] = 0; // 计数  for (int i = 0; i \u0026lt; len; i++) if (arr[i] \u0026lt; bucketLen) bucket[arr[i]]++; // 反向填充  for (int i = 0, j = 0; i \u0026lt; bucketLen; i++) while (bucket[i] \u0026gt; 0) { arr[j++] = i; bucket[i]--; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); countingSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，需要做到两点：\n 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中  同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\n 最快的情况：当输入的数据可以均匀的分配到每一个桶中。 最慢的情况：当输入的数据被分配到了同一个桶中。  算法步骤   将数列中的数均匀地分布到每个桶中（有时候并不是均匀分布）。\n  将每个桶中的数进行排序。\n这里的排序可以使用桶排序也可以使用其它方法排序。\n  按照顺序将所有桶中的数据取出。\n  图片演示：\n将元素分布在桶中：\n元素在每个桶中排序：\n代码实现 Python实现 from quick_sort import quickSort def bucketSort(arr, bucketsize): if len(arr) == 0 or bucketsize \u0026lt;= 0: return arr # 确定最大最小值 maxValue = minValue = arr[0] for i in arr: if i \u0026lt; minValue: minValue = i elif i \u0026gt; maxValue: maxValue = i # 桶数量 count = (maxValue - minValue) // bucketsize + 1 # 对应的桶 buckets = [[] for i in range(count + 1)] # 把数据放入相应的桶 for i in arr: index = (i - minValue) // bucketsize buckets[index].append(i) # 桶内排序并合并数据 arr.clear() for j in buckets: if len(j) != 0: # 桶排序 # bucketSort(j, bucketsize-1) # 快速排序 quickSort(j) # 还可以换其它方法排序 arr.extend(j) return arr if __name__ == \u0026#34;__main__\u0026#34; : arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] bucketSort(arr, 5) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; extern void quickSort(int arr[], const int len); typedef struct _list { int* bucket; int len; } List; void append(List* pl, int num) { if (!pl-\u0026gt;len) { pl-\u0026gt;bucket = (int*)malloc(sizeof(int)); pl-\u0026gt;bucket[pl-\u0026gt;len++] = num; return; } int* tmp = (int*)malloc((pl-\u0026gt;len + 1) * sizeof(int)); for (int i = 0; i \u0026lt; pl-\u0026gt;len; i++) tmp[i] = pl-\u0026gt;bucket[i]; tmp[pl-\u0026gt;len++] = num; free(pl-\u0026gt;bucket); pl-\u0026gt;bucket = tmp; } void bucketSort(int arr[], int len, int bucketsize) { // 确定最大最小值  int max = arr[0], min = max; for (int i = 0; i \u0026lt; len; i++) if (arr[i] \u0026lt; min) min = arr[i]; else if (arr[i] \u0026gt; max) max = arr[i]; // 桶数量  int count = (max - min) / bucketsize + 1; // 对应的桶  List* buckets = (List*)malloc(count * sizeof(List)); for (int i = 0; i \u0026lt; count; i++) { buckets[i].bucket = NULL; buckets[i].len = 0; } // 方案一：动态数组  // 把数据放入相应的桶  for (int i = 0; i \u0026lt; len; i++) { int index = (arr[i] - min) / bucketsize; append(\u0026amp;buckets[index], arr[i]); } // 方案二：二维数组  // int* size = (int*)malloc(count * sizeof(int));  // // 计算最大宽度  // for (int i = 0; i \u0026lt; count; i++)  // size[i] = 0;  // for (int i = 0; i \u0026lt; len; i++)  // size[(arr[i] - min) / bucketsize]++;  // int maxSize = 0;  // for (int i = 0; i \u0026lt; count; i++)  // if (size[i] \u0026gt; maxSize)  // maxSize = size[i];  // // 把数据放入相应的桶  // for (int i = 0; i \u0026lt; len; i++)  // {  // int index = (arr[i] - min) / bucketsize;  // if (!buckets[index].len)  // buckets[index].bucket = (int*)malloc(maxSize * sizeof(int));  // buckets[index].bucket[buckets[index].len++] = arr[i];  // }  // free(size);  // 桶内快排并合并数据  int index = 0; for (int i = 0; i \u0026lt; count; i++) if (buckets[i].len) { quickSort(buckets[i].bucket, buckets[i].len); for (int j = 0; j \u0026lt; buckets[i].len; j++) arr[index + j] = buckets[i].bucket[j]; index += buckets[i].len; free(buckets[i].bucket); buckets[i].bucket = NULL; buckets[i].len = 0; } free(buckets); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bucketSort(arr, len, 5); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序还可以用于其它数据类型的排序（但其本质上还是整型，如字符型）。\n基数排序用到了桶的概念，是桶排序的扩展，它是根据键值的每位数字来分配桶。\n算法步骤 有两类基数排序：\n 最低位优先法，简称LSD法：先从最低位开始排序，再对次低位排序，直到对最高位排序后得到一个有序序列； 最高位优先法，简称MSD法：先从最高位开始排序，再逐个对各分组按次高位进行子排序，循环直到最低位。   📌如果位没有数的话，补0。\n 动画演示：\n代码实现 Python实现 def getBit(num, i): return (num // i) % 10 def getMax(arr): max = arr[0] for i in range(len(arr)): if arr[i] \u0026gt; max: max = arr[i] return max def radixSort(arr): if len(arr) \u0026lt;= 1: return arr # 获取最大值 max = getMax(arr) # 根据最大位数排序 index = 1 while max // index: # 桶排序 buckets = [[] for i in range(10)] for x in arr: bit_num = getBit(x, index) buckets[bit_num].append(x) arr.clear() for x in buckets: arr.extend(x) index *= 10 return arr if __name__ == \u0026#34;__main__\u0026#34; : arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] radixSort(arr) print(arr) C实现 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct _list { int* bucket; int len; } List; void append(List* pl, int num) { if (!pl-\u0026gt;len) { pl-\u0026gt;bucket = (int*)malloc(sizeof(int)); pl-\u0026gt;bucket[pl-\u0026gt;len++] = num; return; } int* tmp = (int*)malloc((pl-\u0026gt;len + 1) * sizeof(int)); for (int i = 0; i \u0026lt; pl-\u0026gt;len; i++) tmp[i] = pl-\u0026gt;bucket[i]; tmp[pl-\u0026gt;len++] = num; free(pl-\u0026gt;bucket); pl-\u0026gt;bucket = tmp; } int getBit(int num, int i) { return (num / i) % 10; } void radixSort(int arr[], int len) { if (len \u0026lt;= 1) return; // 获取最大值  int max = arr[0]; for (int i = 1; i \u0026lt; len; i++) if (arr[i] \u0026gt; max) max = arr[i]; // 根据最大位数排序  // 方案一：动态数组  for (int i = 1; max / i; i *= 10) { // 桶排序  List buckets[10] = { {NULL, 0} }; for (int j = 0; j \u0026lt; len; j++) append(\u0026amp;buckets[getBit(arr[j], i)], arr[j]); int index = 0; for (int j = 0; j \u0026lt; 10; j++) if (buckets[j].len) { for (int k = 0; k \u0026lt; buckets[j].len; k++) arr[index + k] = buckets[j].bucket[k]; index += buckets[j].len; free(buckets[j].bucket); buckets[j].bucket = NULL; buckets[j].len = 0; } } // 方案二：二维数组  // for (int i = 1; max / i; i *= 10)  // {  // // 计算最大宽度  // int size[10] = { 0 };  // for (int j = 0; j \u0026lt; len; j++)  // size[getBit(arr[j], i)]++;  // int maxSize = size[0];  // for (int j = 0; j \u0026lt; 10; j++)  // if (size[j] \u0026gt; maxSize)  // maxSize = size[j];  // // 桶排序  // List buckets[10] = { {NULL, 0} };  // for (int j = 0; j \u0026lt; len; j++)  // {  // int index = getBit(arr[j], i);  // if (!buckets[index].len)  // buckets[index].bucket = (int*)malloc(maxSize*sizeof(int));  // buckets[index].bucket[buckets[index].len++] = arr[j];  // }  // int index = 0;  // for (int j = 0; j \u0026lt; 10; j++)  // if (buckets[j].len)  // {  // for (int k = 0; k \u0026lt; buckets[j].len; k++)  // arr[index + k] = buckets[j].bucket[k];  // index += buckets[j].len;  // free(buckets[j].bucket);  // buckets[j].bucket = NULL;  // buckets[j].len = 0;  // }  // } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); radixSort(arr, len); for (int i = 0; i \u0026lt; len; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); return 0; }  ","date":"2022-01-12T00:00:00Z","permalink":"https://blog.linner.asia/p/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"经典排序算法"},{"content":"基本概念 SQL（Structured Query Language，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进行各种操作。\n 标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSISQL。\n  数据库 数据库（database）是一个用于保存有组织的数据的容器或数据集合。\n每个数据库都有唯一的标识符。\n 表 表（table）是某种特定类型数据的结构化清单，用于存储某种特定类型的数据。\n在同一个数据库中的每个表都有一个唯一的标识符来标识自己。因此，在同个数据库中，不能拥有两个名称相同的表，但在不同的数据库中可以使用相同的表名。\n 模式 模式（schema）是一种关于数据库和表的布局及特性的信息。它是用来描述数据库中表的特性（如，存储的数据类型、数据的分解方式、各部分的信息的命名），或描述整个数据库（和其中表的关系）。\n 行和列 列 列（column）是表中的一个字段（即，表的组成部分）。所有的表都是由一个或多个列组成的。列存储表中的某部分信息，且这部分信息必须是同一种数据类型（datatype）。\n数据类型限制（或允许）该列中存储的数据的种类。它还能帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。\n利用特定的列，可以对数据进行分类和过滤。所以，数据分解十分重要。\n数据类型及其名称是 SQL 不兼容的重要原因之一。对于不同的 DBMS，大多数基本数据类型都得到了一致的支持，但许多高级数据类型却没有。\n 行 表中每一条记录的数据都是按行（row）存储的。\n 主键 主键（primary key）是用来唯一标识表中每一行的列（如国际标准书号 ISBN 就可作为主键），可以是一列或多列。\n满足以下条件的列即可作为主键：\n  任意两行都不具有相同的主键值。\n  每一行都必须具有一个主键值（主键列不允许空值 NULL）。\n  主键列中的值不允许修改或更新。\n  主键值不能重用（即使某行从表中删除，它的主键依然不能赋给以后的新行）。\n  在使用多列作为主键时，上述条件必须应用到所有列，即所有列值的组合必须是唯一的（但不同列中可以存在相同的值）。\n 关系数据库 关系数据库由关系表组成，而关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联。\n常见的两个关系表都会有至少一个相同类型且表示相同的列，对于其中一个表，该列是这个表的主键，从而能使另一个表甚至关系数据库中的其他表通过这个主键对应到这个表中的行。\n一个优秀的关系数据库通常具有以下优点：\n  关系库中的每个表中的每个行的信息重复很少，减少了时间和空间的浪费。\n  如果信息有更新，仅需更新对应的表中的数据。\n  数据是一致的（没有重复的数据），使得处理数据和生成报表更简单。\n  总结：关系数据库的可伸缩性（scale）远比非关系数据库要好。\n 可伸缩是指，能够适应不断增加的工作量而不失败。\n  数据库管理系统 数据库管理系统（DataBase Management System，DBMS）是一种用于创建和操纵数据库的软件。\n绝大多数 DBMS 都支持 ANSI SQL，但一些 DBMS 有自己的扩展。不同的 SQL 实现有自己的名称（如 Oracle 的 PL/SQL、微软 SQL Server 的 Transact-SQL 等）。\nDBMS 可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。\n数据库管理系统、数据库和表的关系：\n SQL 语句分类   DDL（Data Definition Language，数据定义语言）：用来定义数据库对象：数据库，表，列等。\n关键字：create、drop、alter 等。\n  DML（Data Manipulation Language，数据操作语言）：用来对数据库中表的数据进行增删改。\n关键字：insert、delete、update 等。\n  DQL（Data Query Language，数据查询语言）：用来查询数据库中表的记录。\n关键字：select、where 等。\n  DCL（Data Control Language，数据控制语言）：用来定义数据库的访问权限和安全级别，及创建用户。\n关键字：GRANT、REVOKE 等。\n   SQL 语法   SQL语句可以单行或多行书写，以分号结尾。\n  可使用空格和缩进来增强语句的可读性。\n  大多数数据库的 SQL 语句不区分大小写，关键字建议使用大写（可以提高运行速度）。\n   字段 字段（filed）基本上与列的意思相同，但字段这个术语通常在计算字段这种场合下使用。\n SELECT 语句 任何 SQL 语句都是查询（query）。但此术语一般指 SELECT 语句。\n   检索列：\n-- 从 tab_name 中检索出filed1, filed2 等列（字段） -- 可以检索单个列或多个列 SELECT filed1, filed2, ... FROM tab_name; 列的顺序是按照指令中指出的列名的顺序显示。行的顺序是按照存储在物理内存中的顺序显示。\n   使用通配符 * 检索表中的所有列：\n-- 检索出 tab_name 中所有的列 SELECT * FROM tab_name; 一般情况下，返回的列是按照存储在物理内存中的顺序显示的，并没有特定顺序。可能是按照数据被添加到表中的顺序显示（在没有增删数据的情况下），也可能不是（在有数据进行过更新或删除，这个顺序将会受到 DBMS 重用回收存储空间的方式的影响）。\n使用通配符可以很方便地显示表中所有的列（包括名字未知的列），但这么做可能会降低检索速度和应用程序的性能（因为程序会检索所有表中的所有列）。\n   ALL 和 DISTINCT 可以在列名前指定 ALL（默认）和 DISTINCT 关键字，它们表示：\n  ALL —— 列出当前指定的列的所有行。\n  DISTINCT —— 列出由当前所有列组合的不重复的行。\n  可以对聚集函数使用 ALL 和 DISTINCT 关键字指定。\n  ALL —— 默认选项，包含所有的行，对聚集函数指定 ALL（可忽略）表示对所有的行执行计算。\n  DISTINCT —— 指定 DISTINCT，包含不重复的行。\n  对聚集函数指定 DISTINCT 表示只对不重复的行进行计算。\n  使用 DISTINCT 必须明确指出列名，而不能使用 *。\n    列出不重复的行：\n-- filed1, filed2, ... 不重复 SELECT DISTINCT filed1, filed2, ... FROM tab_name; DISTINCT 作用于所有指定的列，该 SELECT 语句会返回所有不重复的 filed1, filed2, ... 组合的行。使用 DISTINCT * 可以返回由所有列组合的不重复的行。\n 限制返回的行 各 DBMS 实现并不相同：\n  SQL Server：使用 TOP 关键字。\n-- 返回前 n 行 -- n 是任一正整数 SELECT TOP n filed1, filed2, ... FROM tab_name;    DB2：FETCH FIRST n ROWS ONLY。\n-- 返回前 n 行 -- n 是任一正整数 SELECT filed1, filed2, ... FROM tab_name FETCH FIRST n ROWS ONLY;    Oracle：基于 ROWNUM（行计数器）。\n-- 返回前 n 行 -- n 是任一正整数 SELECT filed1, filed2, ... FROM tab_name WHERE ROWNUM \u0026lt;= n;    MySQL、MariaDB、PostgreSQL and SQLite：使用 LIMIT 子句。\n-- 返回前 n 行 -- n 是任一正整数 SELECT filed1, filed2, ... FROM tab_name LIMIT n; -- 返回从第 m 行开始的前 n 行 -- n 是任一正整数，m 是任一非负整数 SELECT filed1, filed2, ... FROM tab_name LIMIT n OFFSET m; 在 MySQL、MariaDB 和 SQLite 中，上条指令可简化为：\n-- 返回从第 m 行开始的前 n 行 -- n 是任一正整数，m 是任一非负整数 -- m 指定开始的行数，n 指定返回的行数 SELECT filed1, filed2, ... FROM tab_name LIMIT m, n; 行是从 0 开始计数。\n   ORDER BY 排序数据   使用 ORDER BY 子句取一个或多个列的名字，据此对数据进行排序：\n-- order1, order2, ... 是排序的依据 -- 该语句会先对 order1 进行排序 -- 仅在具有多行相同 order1 值时，才按照 order2 排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY order1, order2, ...; ORDER BY 子句必须是 SELECT 语句中的最后一条子句。默认是升序排序（从 A 到 Z）。\n   按相对列位置进行排序：\n-- n1、n2 …… 是小于或等于指定的列的总数的正整数 -- n1、n2 …… 这组数中的每两个数都不相等 SELECT filed1, filed2, ... FROM tab_name ORDER BY n1, n2, ...; 按相对位置排序的好处是不用输入列名，但有可能会造成错用列进行排序（特别是在对 SELECT 清单进行更改时）。\n  实际列名排序和相对列位置排序可混合使用。\n 📌最好的排序方式是，对冗长的列名重命名，然后使用列名进行排序。这样可以减少错误的出现。\n  指定排序方向 指定排序的关键字：ASC —— 升序排序、DESC —— 降序排序。ASC 和 DESC 必须对每一列进行指定，因为它们只会对直接位于其前面的列名指定排序方式。可以对某一列指定 ASC（或 DESC）后对其它列指定 DESC（或 ASC）。\n-- order1, order2, ... 是排序的依据，且都被指定了升序排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY order1 ASC, order2, ...   DESC 关键字指定降序排序。\n-- order1, order2, ... 是排序的依据，且都被指定了降序排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY order1 DESC, order2 DESC, ...;   对某些列指定升序排序，对另外某些列指定升序排序。\n-- asc_order1, asc_order2, ... 都是指定升序排序 -- desc_order1, desc_order2, ... 都是指定降序排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY asc_order1 ASC, asc_order2, ..., desc_order1 DESC, desc_order2 DESC, ...;   大多数 DBMS 默认使用字典（dictionary）排序（即大小写字母被视为相同），但许多 DBMS 允许改变这种方式。\n WHERE 过滤数据 使用 WHERE 子句能够根据指定的搜索条件（search criteria），检索用户需要的数据。搜索条件也被称为过滤条件（filter condition1）。\n  检索单一条件：\n-- condition1 是表中任一列名 -- condition1 的类型和 n 的类型要一致 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 = n; 数据也可以在应用层进行过滤，但当 DBMS 返回的数据超出实际所需的数据时，会影响应用的性能，并且降低应用的可伸缩性，这还会造成网络宽带的浪费（服务器不得不通过网络发送多余的数据）。\n   WHERE 子句操作符（条件操作符）：\n并非所有 DBMS 都支持所有的操作符，某些 DBMS 可能不支持个别操作符。\n   操作符 说明 操作符 说明     = 等于 \u0026gt; 大于   \u0026lt;\u0026gt; or != 不等于 \u0026gt;= 大于等于   \u0026lt; 小于 !\u0026gt; 不大于   \u0026lt;= 小于等于 BETWEEN 范围在指定的两个值之间   !\u0026lt; 不小于 IS NULL 为 NULL 的值       使用 BETWEEN 在指定范围内检索：\n-- condition1 是表中任一列名 -- condition1 的类型和 n 、m 的类型要一致 -- n 和 m 为低端值和高端值 -- 检索时匹配的值包括 n 和 m SELECT filed1, filed2, ... FROM tab_name WHERE condition11 BETWEEN n AND m;    使用 IS NULL 检索空值：\n-- condition1 是表中任一列名 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 IS NULL;   IS NOT NULL 检索不为空值的行：\n-- condition1 是表中任一列名 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 IS NOT NULL;    逻辑操作符 可以在一条 WHERE 子句中包含任意数量的逻辑操作符（logical operator），且允许两者结合以进行复杂、高级的过滤。\n  AND 操作符检索满足所有给定条件的行：\n-- condition11，condition12 …… 是包含条件操作符的子句 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 AND condition12 AND ...;    OR 操作符检索满足任一条件的行：\n-- condition11，condition12 …… 是包含条件操作符的子句 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 OR condition12 OR ...; 许多 DBMS 在使用 OR 操作符时，当第 1 个条件满足的情况下，就不再计算第 2 个条件。\n   NOT 操作符是否定操作符，否定跟随在其后的条件。\n-- condition1 是任意条件子句 SELECT filed1, filed2, ... FROM tab_name WHERE NOT condition11; 大多数 DBMS 允许使用 NOT 否定任何条件。\n   IN 指定条件范围 IN 操作符用来指定条件范围，匹配范围中指定的每个条件。IN 操作符后的括号中的合法值用逗号分隔。\n-- condition1 是表中任一列 -- val1, val2, ... 是与 condition1 类型相同的一组合法值 SELECT filed1, filed2, ... FROM tab_name WHERE condition1 IN (val1, val2, ...); IN 操作符和 OR 操作符的功能类似，但在某些方面，IN 操作符有其优点。\n  在有很多合法选项时，IN 操作符可读性更强。\n  与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。\n  IN 操作符一般比一组 OR 操作符执行得更快。\n  IN 操作符可包含其他 SELECT 语句，能更动态地建立 WHERE 子句。\n   通配符 通配符（wildcard）是用于匹配值的一部分的特殊字符。\n搜索模式（search pattern）由字面值、通配符或两者组合构成的搜索条件。\n利用通配符，可以创建比较特定数据的搜索模式。要使用通配符，必须在搜索子句中使用 LIKE 操作符。且通配符只能用于字符串。\n  使用通配符搜索一般比其他简单搜索耗费更长的处理时间。\n  不要过度使用通配符。\n  尽量不要把通配符用在搜索模式的开始处（通配符置于开始处是最慢的）。\n  不同类型的通配符可以混合使用。\n     % 通配符：表示任何字符出现任意次数。\n-- condition1 是表中任一字符类型的列 -- 该语句表示在 condition1 列中搜索以 ABC 开头的字符串 SELECT filed1, filed2, ... FROM tab_name WHRER condition1 LIKE \u0026#39;ABC%\u0026#39;;   包含 ABC 的字符串：'%ABC%'；\n  以 ABC 结尾的字符串：'ABC%'；\n  以 A 为开头，以 B 为结尾的字符：'A%B'；\n  某些 DBMS 会用空格来填补字段内容，可能会对该搜索模式造成影响。\n  包含 AB 和 CD 的字符串：'%AB%CD%'；\n  ……\n     _ 通配符：表示匹配单个任意字符。\n-- condition1 是表中任一字符类型的列 -- 该语句表示匹配以 ABC 结尾，开头为任意一个字符的字符串 SELECT filed1, filed2, ... FROM tab_name WHERE condition1 LIKE \u0026#39;_ABC\u0026#39;;    [] 通配符：用来指定一个字符集，它必须匹配指定位置的一个字符。\nExample:\n-- condition1 是表中任一字符类型的列 -- 该语句匹配以 A 或 B 其中之一与 C 的组合的字符串（仅有两个字符） SELECT filed1, filed2, ... FROM tab_name WHERE condition1 LIKE \u0026#39;[AB]C\u0026#39;; 使用 ^ 可以来否定 [] 定义的字符集：'[^AB]' —— 该模式会匹配除了 A 和 B 之外的任何一个字符。\n  子查询 子查询通过嵌套的SELECT语句，将查询结果作为值返回。\nSELECT可以嵌套地使用。\n 拼接 拼接（concatenate）是指将值联结到一起（将一个值附加到另一个值）构成单个值。\n  SQL Server 使用 + 号拼接：\n-- filed1, filed2, filed3, ... 可以是任意同类型的字段 SELECT filed1 + filed2 + filed3 + ... FROM tab_name;   DB2、Oracle、PostgreSQL 和 SQLite 使用 ||：filed1 || filed2 || filed3 || ...。\n  MySQL 和 MariaDB 使用 Concat() 函数：Concat(filed1, filed2, filed3, ...)。\n  某些 DBMS 会用空格填充字段，可以使用 RTRIM() 函数来清除这些空格。\n AS 指定别名 使用 AS 关键字赋予字段或值一个别名（alias）。别名既可以是一个单词，也可以是一个字符串，字符串需用引号括起。使用别名时不应使用表中实际的列名，虽然这样做也算合法，但可能会产生模糊的错误消息。\n-- filed 是一个字段或值 -- alias 是 filed 的别名 -- 赋予别名后可以在接下来的子句中使用别名来替代这个字段 SELECT filed AS alias FROM tab_name ORDER BY alias;  函数 数值处理函数 数值处理函数仅处理数值数据，是最一致、最统一的函数。\n常用的数值处理函数：\n   Functions Explain     ABC() 返回一个数的绝对值。   COS() 返回一个角度的余弦。   EXP() 返回一个数的指数值。   PI() 返回圆周率 $\\pi$ 值。   SIN() 返回一个角度的正弦。   SQRT() 返回一个数的平方根。   TAN() 返回一个角度的正切。     文本处理函数 常用的文本处理函数：\n   Functions Explain     LEFT(str, num) 返回字符串 str 左边前 num 个字符。   LENGTH(str)、 DATALENGTH(str) or LEN(str) 返回字符串的长度。   LOWER(str) 将字符串转换为小写。   LTRIM(str) 去掉字符串左边的空格。   RIGHT(str, num) 返回字符串 str 右边前 num 个字符。   RTRIM(str) 去掉字符串右边的空格。   SUBSTR(str, n, size) or SUBSTRING(str, n, size) 提取字符串的组成部分。 DB2、Oracle、PostgreSQL 和 SQLite 使用 SUBSTR()； MariaDB、MySQL 和 SQL Server 使用 SUBSTRING()。 n 是指字符串中第 n 个字符（从 1 开始计数）， size 是指截取的字符串长度，截取出的字符串包括第 n 个字符。   SOUNDEX(str) 返回字符串的 SOUNDEX 值（描述 str 语音表示的字母数字模式）。 PostgreSQL 不支持。SQLite 要开启 SQLITE_SOUNDEX 编译选项。 使用 SOUNDEX() 函数对两个字符串进行比较， 使得能对字符串进行发音比较而不是字母比较。 如 WHERE SOUNDEX(str1) = SOUNDEX(str2)。   UPPER(str) 将字符串转换为大写。     日期和时间处理函数 日期和时间函数在 SQL 中可移植性最差。\n  SQL Server 使用 DATEPART(part, date) 返回日期中的一部分，part（不是字符型的参数）指定要返回的成分，date 是要从中国年返回成分的日期。\n  PostgreSQL 使用 DATE_PART(part_str, date) 返回日期中的一部分，part_str 指定要返回的成分，date 是要从中国年返回成分的日期。\n  Oracle 和 PostgreSQL 都支持 EXTRACT(part FROM date) 返回日期中的一部分。part（不是字符型）指定要返回的成分，date 是要从中国年返回成分的日期。\n  Oracle 还支持 to_date(date_str, form_str) 将字符串转化成日期，date_str 是某个带有日期格式的字符串，form_str 指定日期的形式。一般这样使用：WHERE date_column BETWEEN to_date('2020-01-01', 'yyyy-mm-dd') AND todate('2020-12-31', 'yyyy-mm-dd')。\n  DB2、MySQL 和 MariaDB 中有 YEAR(date) 和 MONTH(date) 等函数用于提取年份和月份等信息。\n  在 SQLite 可以使用 strftime('%Y', date) 提取年份，也可以提取月份等。\n   MySQL Date 函数：\n   函数 描述     NOW() 返回当前的日期和时间。   CURDATE() 返回当前的日期。   CURTIME() 返回当前的时间。   DATE() 提取日期或日期/时间表达式的日期部分。   EXTRACT() 返回日期/时间的单独部分。   DATE_ADD() 向日期添加指定的时间间隔。   DATE_SUB() 从日期减去指定的时间间隔。   DATEDIFF() 返回两个日期之间的天数。   DATE_FORMAT() 用不同的格式显示日期/时间。     SQL Server Date 函数：\n   函数 描述     GETDATE() 返回当前的日期和时间   DATEPART() 返回日期/时间的单独部分   DATEADD() 在日期中添加或减去指定的时间间隔   DATEDIFF() 返回两个日期之间的时间   CONVERT() 用不同的格式显示日期/时间     汇总数据 使用聚集函数（aggregate function）可以对某些行进行计算并返回一个值。\nSQL 聚集函数：\n   Functions Explain     AVG(filed) 返回某字段的平均数，类型必须是数值类型，AVG() 会忽略值为 NULL 的行。   COUNT(filed) 返回某字段的行数   MAX(filed) 返回某字段的最大值，允许 filed 是日期值，许多 DBMS 还允许 filed 是字符串，如果 filed 是字符串，那么 MAX() 会返回按该列排序后的最后一行。MAX() 忽略值为 NULL 的行。   MIN(filed) 返回某字段的最小值，与 MAX() 类似，如果 filed 是字符串，那么 MAX() 会返回按该列排序后的最前面一行。   SUM(filed) 返回某列值之和，类型必须是数值类型，SUM() 会忽略值为 NULL 的行。    Usage for Example:\nSELECT AVG(filed) AS average FROM tab_name WHERE condition1; SELECT 语句可以根据需要包含多个聚集函数。\n GROUP BY 数据分组 分组是使用 SELECT 语句的 GROUP BY 子句，将数据分为多个逻辑组，对每个组进行操作。\n-- 显示 filed1, filed2, ... 并根据它们进行分组 -- COUNT(*) 表示计算分组中的所有行 -- 该语句是先按照 filed1 进行分组，然后再按照 filed2 进行分组 -- 使用分组后输出的结果可能是根据 filed1, filed2, ... 排序好的 SELECT filed1, filed2, ..., COUNT(*); FROM tab_name GROUP BY filed1, filed2, ...; GROUP BY 子句指示 DBMS 分组数据，然后对每个组（不是整个结果集）进行聚集。\n使用 GROUP BY 的规定：\n  GROUP BY 子句可以包含任意数目的列。所以可以对分组进行嵌套，更细致地进行数据分组。\n  在建立分组后，操作的最小单位只能是分组，而无法再对个别列进行操作。\n  GROUP BY 子句中列出的每一列都必须是检索列或有效表达式列（但不能是聚集函数）。在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式，而不能使用别名。\n  大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。\n  除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出。\n  分组列中所有包含具有 NULL 值的行，都将 NULL 作为一个分组返回。\n  GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。\n   📌并非所有 SQL 实现都支持在使用 GROUP BY 子句时，使用相对位置指定列，并且使用它容易在编辑 SQL 语句时出错。\n  HAVING 过滤分组 使用 HAVING 子句来过滤分组。HAVING 支持所有 WHERE 子句支持的操作符，两者的区别是 WHERE 仅对行进行过滤，而 HAVING 可以对分组进行过滤（在没有指定 GROUP BY 时，大多数 DBMS 会同等对待 WHERE 和 HAVING，即 HAVING 也可以对行进行过滤）。\n-- filed_1, filed_2, ... 是聚集操作 -- condition1 是相对于每行的条件，condition1_ 是相对于每个分组的条件 SELECT filed1, filed2, ... filed_1, filed_2, ...; FROM tab_name WHERE condition1 GROUP BY filed1, filed2, ... HAVING condition1_; 在同时使用 WHERE 和 GROUP BY 时，被 WHERE 过滤掉的行并不会包括在分组中。\n 分组和排序 ORDER BY 与 GROUP BY 的区别\n   ORDER BY GROUP BY     对产生的输出排序 对行分组，但输出可能不是分组的顺序   任意列都可以使用（甚至非选择的列也可以使用，即 SELECT 没有给出的列也能使用） 只可能使用选择列或表达式列（SELECT 中给出的列），而且必须使用每个选择列表达式（不能使用别名）   是可选的，任何情况下都能根据需要选择是否使用 在使用聚集函数的情况下， 还要显示列（或表达式），则必须使用    GROUP BY 分组不一定是按照分组顺序输出的，所以应该提供明确的 ORDER BY 子句指定排序方式，以确保在任何情况下输出都能正确地排序。\n 子查询 子查询（subquery）是指嵌套在其他查询中的查询。\n-- 每个子查询中的 SELECT 语句有且仅有一个字段 -- 在子查询中企图检索多个列将返回错误 -- 理论上可以无限嵌套，但实际使用时由于性能的限制，不能嵌套太多的子查询 SELECT filed1, filed2, ... FROM table1 WHERE condition11 IN (SELECT filed_1 FROM table2 WHERE condition12 IN (SELECT filed_2 FROM table3 WHERE condition13 IN (...)); 在 SELECT 语句中，子查询总是从内向外处理（类似递归的处理方式）。\n 使用计算字段进行子查询 -- filed_1, filed_2, ... 是计算字段，是由其 AS 前的圆括号中的子查询建立的 -- table1._filed1 是 table1 中名为 _filed1 的列或列表达式 -- table2._filed1 是 table2 中名为 _filed2 的列或列表达式 -- table1._filed1 和 table2._filed1 是两个不同表格中同名同类型的列，并不是同一个列 -- table1._filed2 和 table3._filed2 的关系与 table1._filed1 和 table2._filed1 类似 -- 第 1 条子查询的解释是，对所有 table2 中符合 table1._filed1 = table2._filed1 的行进行计数 SELECT filed1, filed2, ... (SELECT COUNT(*) FROM table2 WHERE table1._filed1 = table2._filed1) AS filed_1 (SELECT COUNT(*) FROM table3 WHERE table1._filed2 = table3._filed2) AS filed_2 ... FROM table1; 计算字段用一个句点分隔表名和列名，句点前是表名，句点后是列名，即 tab_name.column，这种写法也叫完全限定列名。在有可能混淆列名时（如使用子查询时）必须使用这种语法。\n JOIN 联结表 联结（join）是一种机制，用来在一条 SELECT 语句中关联表，可以联结多个表返回一组输出。\n 联结不是物理实体，它在实际的数据库表总并不存在，它仅在数据查询的执行期间存在。 对于联结，需要考虑性能，如果联结过多的表，可能会非常耗费资源，使性能下降。 SQL 本身不限制每个联结约束中表的数目，但实际上许多 DBMS 都有限制。\n 联结类型：\n  内联结（inner join）\n  外联结（outer join）\n  自联结（self-join）\n  自然联结（natural join）\n  可以在一个 SELECT 语句中使用联结多个表，而且每个表的联结类型可以不相同。\n INNER JOIN 内联结 内联结（inner join）又称为等值联结（equijoin），是基于两个表之间的项等测试。\n许多子查询都可以使用内联结来替代，但是子查询与联结同样需要耗费一定的资源，所以在一个语句中，不应使用过多的子查询和联结。\n   在 FROM 中指定多个列（等值联结）。\n对于联结，需要保证所有联结都有 WHERE 子句，并且要保证 WHERE 子句的正确性。\n-- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式 -- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定 -- 完全限定名：tab_name.column_name -- condition1s 中必须给出联结条件 SELECT filed1, filed2, ... FROM table1, table2, ... WHERE condition1s; 如果上述语句没有在 WHERE 中指出配对方式，那么 table1 中的每一行会与 table2 中的每一行进行配对，然后 table1 和 table2 已经配对完成的行会再次与 table3 中的每一行配对，以此类推，直到所有的表都完成了配对。这种由没有联结条件的表联结后返回的结果为笛卡尔积（cartesian product）。\n  使用 INNER JOIN（内联结）指定要联结的表，联结条件用特定的 ON 子句给出。\n同样地，对于这种方式的联结，需要保证所有联结都有有效的 ON 子句。如果没有 ON 子句，也会出现笛卡尔积。\n-- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式 -- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定 -- condition1 中必须给出联结条件 SELECT filed1, filed2, ... FROM table1 INNER JOIN table2 ON condition11 INNER JOIN table3 ON condition12 INNER JOIN ... -- 如果有其他条件的话 WHERE 子句在 INNER JOIN 之后给出   ANSI SQL 规范首选 INNER JOIN 语法。\n 自联结 自联结（self-join）是指在同一个 SELECT 语句中，多次联结同一个表。\n对于自联结来说，由于多次引用同一个表，如果不对表起别名的话，会造成系统混乱（同一个表，表名自然相同，所以系统无法区分究竟指的是哪个表，虽然本质上都是同一个表）。\nSELECT T1.filed1, T1.filed2, ... FROM tab_name AS T1, tab_name AS T2 WHERE T1.filed_1 = T2.filed_1 AND T2.filed_2 = value; 虽然自联结也可以用子查询替换，但对于大多数 DBMS 来说，处理联结远比处理子查询快。\nSELECT filed1, filed2, ... FROM tab_name WHERE filed_1 = (SELECT filed_1 FROM tab_name WHERE filed_2 = value);  自然联结 自然联结（natural join）指每个含义相同的列仅出现一次的联结。自然联结一般是通过对一个表使用通配符，而对其他表的列使用明确的子集来完成。\nSELECT T1.*, T2.filed1, T2.filed2, ... FROM table1 AS T1, table2 AS T2 WHERE T1.filed_1 = T2.filed_1 AND ...;  OUTER JOIN 外联结 外联结（outer join）是指包含无关联行的联结。通常，内联结都是将一个表格中的行与另一个表格中的行通过联结条件进行关联，此时两个表格中没有被联结条件关联起来的行将会被忽略。而外联结则会包含这些没有被联结条件所关联起来的行，并根据需要给某些列赋予 NULL 值。\n外联结有三种类型：\n  LEFT OUTER JOIN —— 左外联结，包含左表的所有行（即 FROM 后面紧跟的表，示例中为 T1），即使在右表（示例中为 T2）中没有被匹配（结果为 NULL）。\n基本上所有的 DBMS 都支持。\nSELECT T1.filed1, T1,filed2, ... T2.filed_1, T2.filed_2, ... FROM table1 AS T1 LEFT OUTER JOIN table2 AS T2 ON T1.filed = T2.filed;   RIGHT OUTER JOIN —— 右外联结，包含左表的所有行（即 JOIN 关键字后紧跟的表，示例中为 T2），即使在右表（示例中为 T1）中没有被匹配（结果为 NULL）。\nSQLite 不支持。\nSELECT T1.filed1, T1,filed2, ... T2.filed_1, T2.filed_2, ... FROM table1 AS T1 RIGHT OUTER JOIN table2 AS T2 ON T1.filed = T2.filed;   FULL OUTER JOIN —— 全外联结，只要左表和右表其中一个表中存在匹配，就返回。\nMariaDB、MySQL 和 SQLite 都不支持。\n  左外联结和右外联结可以相互转换。\n 联结、聚合函数与分组 联结的一种用法是使用聚合函数从另一个表格中汇总数据。\n-- condition1 是联结条件 SELECT T1.filed1, T2.filed2, ... COUNT(T2.filed_1) AS name_filed FROM table1 AS T1 INNER JOIN table2 AS T2 ON condition1 GROUP BY T1.filed1, T1,filed2, ...; 对于上述语句也可以指定外联结，仅需将 INNER JOIN 替换成外联结的关键字。\n使用外联结从另一个表中汇总数据，那些没有被关联的行经过 COUNT() 函数计算后的返回值将会为 0。\n UNION 组合查询 组合查询通常称为并（union）或符合查询（compound query）。通过组合查询可以同时执行多条 SELECT 语句，并将结果作为一个查询结果集返回。\n需要使用组合查询的情况：\n  在一个查询中从不同的表返回结构数据；\n  对一个表执行多个查询，按一个查询返回数据。\n   📌\n  组合相同表的查询所完成的工作一般可以用 WHERE 子句替代。\n理论上使用 WHERE 子句和组合查询从性能上看并没有太大差别，但各实现之间任有差别。\n  第一条 SELECT 中的列名或指定的别名作为整个组合查询的结果集的列名。因此组合查询所返回的结果集的列名是第一条 SELECT 中的列名，且在组合查询中的 ORDER BY 子句中指出的列名应是第一条 SELECT 中第列名。\n  每一个组合查询最多仅能有一条 ORDER BY 子句，且必须位于整个组合查询语句的最后（即最后一条 SELECT 语句）。\n即，无法对某条 SELECT 指定一种排序方式，而对另一条 SELECT 指定另一种排序方式，所有的 SELECT 只能用同一种方式排序。\n   使用组合查询的规则：\n  必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 UNION 分隔。\n  每个查询必须包含相同的列、表达式或聚集函数（数量必须要相同，类型必须要兼容）。\n   使用 UNION 关键字，会自动去除重复的行：\n-- filed1, filed2, ... 和 filed_1, filed_2, ... 数量必须相同，类型要兼容 -- table1 和 table2 可以是同个表格，也可以是不同的表格 -- ORDER BY 必须位于语句的最后 SELECT filed1, filed2, ... FROM table1 WHERE condition11 UNION SELECT filed_1, filed_2, ... FROM table2 WHERE condition12 UNION ... ORDER BY filed; 在上述语句中，将 UNION 替换成 UNION ALL，返回的结果集将包含重复的行。\n INSERT 语句 INSERT 语句用来将行插入（或添加）到数据库表。\n 插入完整的行   简单但不保险的方法：\nINSERT INTO tab_name VALUES(value1, value2, value3, ..., NULL, ...); VALUES 后面的括号中，按照表中列的定义次序，指出了要存储到表中的数据，且必须给每一列提供一个值（在没有指定列名的情况下）。如果某列没有值，则该列应该使用 NULL（在允许对该列指定空值的情况下）。各列必须以它们在表定义中出现的次序填充。\n这种语法虽然简单但并不安全，因为这种 SQL 语句高度依赖于表中列的定义次序。如果表结构发生变动，那么这样的语句并不能按照预期的情况执行。\n 📌在某些 SQL 实现中，INTO 关键字是可选的。但为了确保可移植，还是要提供 INTO 关键字。\n   保险但比较繁琐的方法：\n-- filed1 与 value1 对应，filed2 与 value2 对应，以此类推 INSERT INTO tab_name(filed1, filed2, filed3, ...) VALUES(value1, value2, value3, ...); 这种方法需要在表名后面，使用括号将表中的所有列名指出（不用按照表中列的定义顺序）。在插入行时，VALUES 必须以其指定的次序匹配指定的列名，这样即使表结构改变，该 INSERT 语句仍能正确工作。不要使用没有明确给出列的 INSERT 语句。\n  主键的值必须有唯一性，DBMS 不允许插入主键值重复的行。如果确实需要插入，应先删除原有的记录。\n 插入行的一部分 -- filed1 与 value1 对应，filed2 与 value2 对应，以此类推 INSERT INTO tab_name(filed1, filed2, ...) VALUES(value1, value2, ...); 同样使用表名后面的括号指定列，只不过仅需指出需要插入的部分列，并且只需给这些列提供值。\n无论是插入完整的行还是插入行的一部分，都必须确保 VALUES 的数目正确。如果不提供列名，则必须给每个表列提供一个值；如果提供列名，则必须给列出的每一个列一个值。否则，就会产生错误。\n在 VALUES 中没有指出的列，DBMS 将赋予它们默认值或空值。这些列必须满足：\n  列定义为允许 NULL 值。\n  在表定义中给出了默认值。\n   INSERT SELECT INSERT 还允许利用 SELECT 语句将检索到的结果插入表中。\n-- 将 table2 中满足条件的 filed_1, filed_2, ... 列按照对应顺序插入到 table1 中 -- table1 和 table2 可以是同一个表 INSERT INTO table1(filed1, filed2, ...) SELECT filed_1, filed_2, ... FROM table2 WHERE condition1s; 一般 INSERT 只插入一行。而 INSERT SELECT 可以用一条语句插入多行。\n SELECT INTO SELECT ... INTO 用于从一个表中复制数据，然后把数据插入到另一个新表中（INTO 子句后指定的表，该语句执行后会自动创建）。\n 📌MySQL 不支持 SELECT ... INTO 语句。\n -- INTO 后面的 IN 子句代表插入到其他数据库 -- IN 子句可省略，默认代表当前数据库 -- new_table 的表结构与 old_table 指定列 filed1, filed2, ... 的结构相同 SELECT filed1, filed2, ... INTO new_table [IN external_db] FROM old_table; SELECT INTO 语句可以通过使用促使查询没有数据返回的 WHERE 子句创建一个新的空表：\nSELECT filed1, filed2, ... INTO new_table FROM old_table WHERE 1 = 0;  更新和删除数据  在客户端或服务器的 DBMS 中，使用 UPDATE 和 DELETE 语句可能需要特殊的安全权限。\n  UPDATE 语句 UPDATE 语句用于更新（修改）表中的数据。\n有两种使用 UPDATE 语句的方式：\n  更新表中的特定行 —— 使用 WHERE 子句过滤：\n基本的 UPDATE子句由三部分组成：\n  要更新的表 —— 使用 UPDATE 关键字指定；\n  列名和它们的新值 —— 使用 SET 关键字指定更新的内容（即使用 “列=值” 对将新值赋给被更新的列）；\n  确定要更新哪些行的过滤 —— 使用 WHERE 子句指定过滤条件。 在 UPDATE 中，WHERE 可以使用 SELECT 子查询。\n  -- filed1, filed2, ... 是 tab_name 中的列 -- value1, value2, ... 是与 filed1, filed2, ... 相对应类型的数据 -- filed1 = value1, filed2 = value2, ... 是 “列=值” 对 -- condition1s 是过滤的条件，指定了要更新的行 UPDATE tab_name SET filed1 = value1, filed2 = value2, ... WHERE condition1s;   更新表中的所有行 —— 不使用 WHERE 子句。\n一般的 UPDATE 字句都要使用 WHERE 字句指定过滤条件，否则 SET 子句指定的更新内容将应用到所有的列。\n   📌有的 SQL 实现支持在 UPDATE 语句中使用 FROM 子句，用一个表的数据更新另一个表的行。\n 使用 UPDATE 删除某个列的值：将要删除的列置为 NULL（假设表定义允许 NULL）。如：\nUPDATE tab_name SET del_filed = NULL WHERE condition1s;  DELETE 语句 使用 DELETE 语句可以从一个表中删除（去掉）数据。\n有两种使用 DELETE 语句的方式：\n 从表中删除特定的行 —— 使用 WHERE 子句过滤：  -- condition1s 是过滤条件，指定了要删除的行 DELETE FROM tab_name WHERE condition1s;  从表中删除所有行 —— 不使用 WHERE 子句： 使用 DELETE 语句时应该指定 WHERE 子句，否则它将会删除表中所有的行。 如果确实想删除表中所有行，应该使用速度更快的 TRUNCATE TABLE 语句。  DELETE 语句删除的是表中的行，即它的操作对象是行而不是列，如果想要删除列，则要使用 UPDATE 语句将该列置为 NULL。\n UPDATE 和 DELETE 的使用准则   绝对不要使用不带 子句的 UPDATE 或 DELETE 子句，除非确实打算更新和删除每一行。\n  应保证每个表都有主键。\n  在使用 UPDATE 或 DELETE 之前，应先用 SELETE 进行测试，确保 WHERE 子句过滤的是正确的记录。:\n  使用强制实施引用完整性的数据库，这样 DBMS 将不允许删除其数据与其他表相关的行。\n  如果 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 子句，那么应该使用它。\n   📌如果 SQL 没有撤销（undo）按钮，应该更小心地使用 UPDATE 和 DELETE 语句。\n  创建和删除数据库 创建数据库使用 CREATE DATABASE 语句。\nCREATE DATABASE db_name; 删除数据库使用 DROP DATABASE 语句。\nDROP DATABASE db_name; 注意：删除数据库后，数据库中的所有数据（表、视图、索引等数据都将会被删除）。\n SQL 通用数据类型 数据类型定义列中存放的值的种类。数据库表中的每个列都要求有名称和数据类型。SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。\n不同的 DBMS 数据类型有些不同。有的 DBMS 允许自定义数据类型，有的不允许。\n以下是 SQL 通用数据类型：\n   数据类型 描述     CHARACTER(n) 或 CHAR(n) 字符/字符串。固定长度 n。   VARCHAR(n) 或 CHARACTER VARYING(n) 字符/字符串。可变长度。最大长度 n。   BINARY(n) 二进制串。固定长度 n。   BOOLEAN 存储 TRUE 或 FALSE 值   VARBINARY(n)  或 BINARY VARYING(n) 二进制串。可变长度。最大长度 n。   INTEGER(p) 整数值（没有小数点）。精度 p。   SMALLINT 整数值（没有小数点）。精度 5。   INTEGER 整数值（没有小数点）。精度 10。   BIGINT 整数值（没有小数点）。精度 19。   DECIMAL(p,s) 精确数值，精度 p，小数点后位数 s。 例如：DECIAML(5,2) 是一个小数点前有 3 位数，小数点后有 2 位数的数字。   NUMERIC(p,s) 精确数值，精度 p，小数点后位数 s。（与 DECIMAL 相同）.   FLOAT(p) 近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数。该类型的 size 参数由一个指定最小精度的单一数字组成。   REAL 近似数值，尾数精度 7。   FLOAT 近似数值，尾数精度 16。   DOUBLE PRECISION 近似数值，尾数精度 16。   DATE 存储年、月、日的值。   TIME 存储小时、分、秒的值。   TIMESTAMP 存储年、月、日、小时、分、秒的值。   INTERVAL 由一些整数字段组成，代表一段时间，取决于区间的类型。   ARRAY 元素的固定长度的有序集合。   MULTISET 元素的可变长度的无序集合。   XML 存储 XML 数据。     SQL 数据类型快速参考手册：\n   数据类型 Access SQL Server Oracle MySQL PostgreSQL     boolean Yes/No Bit Byte N/A Boolean   integer Number (integer) Int Number Int、 Integer Int、 Integer   float Number (single) Float Real Number Float Numeric   currency Currency Money N/A N/A Money   string (fixed) N/A Char Char Char Char   string (variable) Text (\u0026lt;256) Memo (65k+) Varchar Varchar、Varchar2 Varchar Varchar   binary object OLE Object Memo Binary (fixed up to 8K) Varbinary (\u0026lt;8K) Image (\u0026lt;2GB) Long Raw Blob Text Binary Varbinary     时间数据格式 MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：\n  DATE - 格式：YYYY-MM-DD\n  DATETIME - 格式：YYYY-MM-DD HH:MM:SS\n  TIMESTAMP - 格式：YYYY-MM-DD HH:MM:SS\n  YEAR - 格式：YYYY 或 YY\n  SQL Server 使用下列数据类型在数据库中存储日期或日期/时间值：\n  DATE - 格式：YYYY-MM-DD\n  DATETIME - 格式：YYYY-MM-DD HH:MM:SS\n  SMALLDATETIME - 格式：YYYY-MM-DD HH:MM:SS\n  TIMESTAMP - 格式：唯一的数字\n   创建和操纵表格 CREATE TABLE 创建表 一般有两种创建表格的方法：\n  使用 SQL 语句 CTEATE TABLE 创建表格；\n  多数 DBMS 都具有交互式创建和管理数据库表的工具。\n 其本质是交互工具根据用户操作自动生成并执行相应的 SQL 语句。     不同的 SQL 实现中，CREATE TABLE 语句的语法会有所不同（主要区别是在列定义上）。\n 使用 CREATE TABLE 创建表，必须给出以下信息：\n  新表的名字，在关键字 CREATE TABLE 之后给出；\n  表列的名字和定义，在列名后的括号中指出，用逗号分隔；\n  有的 DBMS 还要求指定表的位置。\n  CREATE TABLE tab_name ( column_name1 DataType1, column_name2 DataType2, column_name3 DataType3, cluumn_name4 DataType4, ... ); 创建新表时只能指定不存在的表名，SQL 无法通过 CREATE 语句覆盖已有的表。\nALTER TABLE 更新表定义 使用 ALTER TABLE 时需要考虑的事情：\n  理想情况下，不要在表中包含数据时对表结构进行更新（特别是不要删除已有的列）。 应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。\n  所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。\n  许多 DBMS 不允许删除或更改表中的列。\n  多数 DBMS 允许重新命名表中的列。\n  许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。\n  使用 ALTER TABLE 必须给出的信息：\n  在 ALTER TABLE 之后给出表名；\n  列出要更改表的操作。\n     增加表列：\nALTER TABLE tab_name ADD filed DataType;   删除列：\nALTER TABLE tab_name DROP COLUMN filed;   修改列定义：\nALTER TABLE tab_name ALTER COLUMN column_name NewDataType; 在MySQL中使用：\nALTER TABLE tab_name MODIFY column_name NewDataType;    复杂的表结构更改一般需要执行以下步骤：\n  用新的列布局创建一个新表；\n  使用 INSERT SELECT 语句从旧表复制数据到新表；\n  检验包含所需数据的新表；\n  重命名旧表（在确定无误的情况下可删除）；\n  用旧表原来的名字重命名新表；\n  根据需要，重新创建触发器、存储过程、索引和外键。\n   使用 ALTER TABLE 的注意事项：\n  SQLite 对使用 ALTER TABLE 的最重要的限制是：不支持使用 ALTER TABLE 定义主键和外键，必须在最初创建表时指定。\n  在使用 ALTER TABLE 之前应先做好完整的备份（表结构和数据的备份）。\n  表结构的更改不能撤销。\n  如果增加了不需要的列，也许无法删除它们。\n  如果删除了不应该删除的列，可能会丢失该列中的所有数据。\n     DROP TABLE 删除表 DROP TABLE 语句用于删除表本身（包括表数据）。\nDROP TABLE tab_name;  📌删除表时，没有确认步骤，且不能撤销。\n  📌使用关系规则防止意外删除：\n许多 DBMS 允许强制实施有关规则，防止删除与其他表相关联的表。在实施这些规则时，如果对某个表发布一条 DORP TABLE 语句，且该表是某个关系的组成部分，则 DBMS 将阻止这条语句执行，直到该关系被删除为止。\n  TRUNCATE TABLE 删除表数据 TRUNCATE TABLE 语句用于删除表内的数据（但并不包括表本身）。\nTRUNCATE TABLE tab_name;  重命名表 对于重命名表，每个 DBMS 的支持都有所不同：\n  DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 使用 RENAME 语句。\n  SQL Server 使用 sp_rename 存储过程。\n  SQLite 使用 ALTER TABLE 语句。\n   SQL 约束 SQL 约束（Constraints）用于规定表中如何插入或处理数据的规则。如果存在违反约束的数据行为，行为会被约束终止。\n约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。\nSQL 有如下几种约束：\n   关键字 解释     NULL 允许存储 NULL 值。 如果不指定 NOT NULL 或 PRIMARY KEY，则默认为 NULL。 在插入行时允许不给出该列的值。此时，会给该项指定为值 NULL。 对于 DB2，在定义允许 NULL 的列中不能指定 NULL。   NOT NULL 指示某列不能存储 NULL 值。 如果不向字段添加值，就无法插入新记录或者更新记录。   UNIQUE  唯一约束。保证某列的每行必须有唯一的值。 唯一约束可包含 NULL 值，可重复使用，但是不能用来定义外键。   PRIMARY KEY 主键约束。NOT NULL 和 UNIQUE 的结合。 确保某列（或多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。   FOREIGN KEY 外键约束。保证一个表中的数据匹配另一个表中的值的参照完整性。   CHECK 保证列中的值符合指定的条件。   DEFAULT 规定没有给列赋值时的默认值。 在插入行时如果不给出值，则用默认值赋值。    Example：\nCREATE TABLE tab_name ( # 主键约束 column1 Type1 PRIMARY KEY, # 默认为允许 NULL，可以不用指出 column2 Type2 [NULL], # 不允许 NULL 的列，必须用 NOT NULL 指出 column3 Type3 NOT NULL, # 用 DEFAULT 指定默认值 # default_val 是 Type4 类型的值 column4 Type4 NOT NULL DEFAULT default_val, ... );  NOT NULL 非空约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, ... ); 添加 NOT NULL 约束：\nALTER TABLE tab_name MODIFY column_name Type1 NOT NULL;  UNIQUE 唯一约束 每个表可以有多个 UNIQUE 约束。\n创建表时：\nCREATE TABLE tab_name ( column1 Type1 NOT NULL, # 方法一：直接在列定义中用 UNIQUE 关键字指出 column2 Type2 NOT NULL UNIQUE, ... # 方法二：定义列后使用 UNIQUE() UNIQUE (column1) ); -- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, column2 Type2 NOT NULL, ... # 可以不用定义 u_name CONSTRAINT [u_name] UNIQUE (column1, column2, ...) );  更新表定义时：\nALTER TABLE tab_name ADD UNIQUE (column_name); -- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束 ALTER TABLE tab_name # name 可以省略 ADD CONSTRAINT u_name UNIQUE (column1, column2, ...);  撤销 UNIQUE 约束：\nMySQL：\nALTER TABLE tab_name DROP INDEX u_name; SQL Server / Oracle / MS Access：\nALTER TABLE tab_name DROP CONSTRAINT u_name;  PRIMARY KEY 主键约束 只要满足以下条件，就可以被用作主键：\n  任意两行的主键值都不相同（主键必须包含唯一值）。\n  每行都具有一个主键值（主键列不能包含 NULL 值）。\n  包含主键值的列从不修改或更新。\n  主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。\n   创建表时：\n-- 在列定义中直接指出主键 CREATE TABLE tab_name ( column1 Type1 NOT NULL PRIMARY KEY, ... ); -- 通过 PRIMARY KEY () 定义 CREATE TABLE tab_name ( column1 Type1 NOT NULL, ... PRIMARY KEY (column1) ); -- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, column1 Type1 NOT NULL, ... # 可以不用定义 pk_name CONSTRAINT [pk_name] PRIMARY KEY (column1, column2, ...) );  更新表定义时：\nALTER TABLE tab_name ADD PRIMARY KEY (column_name); -- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 ALTER TABLE tab_name # name 可以省略 ADD CONSTRAINT pk_name UNIQUE (column1, column2, ...);  撤销 PRIMARY KEY 约束：\nMySQL：\nALTER TABLE tab_name DROP PRIMARY KEY; SQL Server / Oracle / MS Access：\nALTER TABLE tab_name DROP CONSTRAINT pk_name;  FOREIGN KEY 外键约束 创建表时：\nCREATE TABLE tab_name ( # 方法一：使用 REFERENCES 关键字 column1 Type1 NOT NULL REFERENCES table1(column_1), column2 Type2 NOT NULL, column2 Type2 NOT NULL, ... # 方法二：使用 FOREIGN KEY () FOREIGN KEY (column2) REFERENCES table2(column_2), # 命名 FOREIGN KEY 约束 CONSTRAINT [fk_name] FOREIGN KEY (column3) REFERENCES table3(column_3) );  更新表定义时：\nALTER TABLE tab_name ADD FOREIGN KEY (column1) REFERENCES table1(column_1); -- 命名 FOREIGN KEY 约束 ALTER TABLE tab_name ADD CONSTRAINT fk_name FOREIGN KEY (column1) REFERENCES table1(column_1);  撤销 FOREIGN KEY 约束：\nMySQL：\nALTER TABLE tab_name DROP FOREIGN KEY fk_name; SQL Server / Oracle / MS Access：\nALTER TABLE tab_name DROP CONSTRAINT fk_name;  CHECK 检查约束 CHECK 约束常见用途：\n  检查最小或最大值。\n  指定范围。\n  只允许特定值。\n   创建表时：\nCREATE TABLE tab_name ( # 限制 column1 的值大于 0 column1 Type1 NOT NULL CHECK (column1 \u0026gt; 0), column2 Type2 NOT NULL, ... # 限制 column2 只能取 \u0026#39;Y\u0026#39; 或 \u0026#39;N\u0026#39; CHECK (column2 LIKE \u0026#39;[YN]\u0026#39;) ); -- 命名 CHECK 约束，并定义多个列的 CHECK 约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, column2 Type2 NOT NULL, ... CONSTRAINT chk_name CHECK (column1 \u0026gt; 0 AND column2 LIKE \u0026#39;[YN]\u0026#39;) );  修改表定义时：\nALTER TABLE tab_name ADD CHECK (column1 \u0026gt; 0); -- 命名 CHECK 约束，并定义多个列的 CHECK 约束 ALTER TABLE tab_name ADD CONSTRAINT chk_name CHECK (column1 \u0026gt; 0 AND column2 LIKE \u0026#39;[YN]\u0026#39;);  撤销 CHECK 约束：\nMySQL：\nALTER TABLE tab_name DROP CHECK chk_name; SQL Server / Oracle / MS Access：\nALTER TABLE tab_name DROP CONSTRAINT chk_name;  DEFAULT 默认约束 创建表时：\nCREATE TABLE tab_name ( # default_val 是 Type4 类型的值 column1 Type1 NOT NULL DEFAULT default_val, ... ) -- 可以使用类似 GETDATE() 的函数插入系统值 CREATE TABLE tab_name ( # 默认值为当前的日期 birthday DATE NOT NULL DEFAULT GETDATE(), ... )  更新表结构时：\nMySQL：\nALTER TABLE tab_name ALTER column1 SET DEFAULT default_val; SQL Server / MS Access：\nALTER TABLE tab_name ADD CONSTRAINT name DEFAULT default_val for column1; Oracle：\nALTER TABLE tab_name MODIFY column1 DEFAULT default_val;  撤销 DEFAULT 约束：\nMySQL：\nALTER TABLE tab_name ALTER column1 DROP DEFAULT; SQL Server / Oracle / MS Access：\nALTER TABLE tab_name ALTER COLUMN column1 DROP DEFAULT;  AUTO INCREMENT 字段 在定义表时，在列中添加 auto-increment 字段可以在新纪录插入表时对该列生成一个唯一的数字。\n定义为 auto-increment 字段的列必须是整数类型。\n定义为 auto-increment 的列常常被定义为 PRIMARY KEY。\n MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务：\nCREATE TABLE tab_name ( # 定义 column1 为 AUTO INCREMENT 主键字段 column1 TYPE1 NOT NULL PRIMARY KEY AUTO_INCREMENT, column2 TYPE2, column3 TYPE3, ... ); 定义了 AUTO_INCREMENT 字段后，可以不用对该列指定值，或者对该列指定为 NULL 值（会自动添加一个唯一的值）。\nMySQL 的 AUTO_INCREMENT 只能在 key 上被定义。PRIMARY KEY 和 UNIQUE 都是有效的定义。\n-- val2 和 val3 是分别与 column2 和 column3 同类型的值  -- 不对 auto-increment 列指定值 INSERT INTO tab_name ( column2, column3 ) VALUES ( val2, val3 ); -- 指定为 NULL 值 INSERT INTO tab_name ( column1, column2, column3) VALUES ( NULL, val2, val3); AUTO_INCREMENT 默认的开始值是 1，每新增一条记录都会递增 1。\n让 AUTO_INCREMENT 序列以其他的值起始：\n-- number 是任意数字 ALTER TABLE tab_name AUTO_INCREMENT=number; MySQL 设定起始值只能在建表后使用 ALTER TABLE 语句。也可以在建表后直接使用 ALTER TABLE 语句定义 AUTO_INCREMENT 以及它的起始值。\nCREATE TABLE tab_name ( column1 INT NOT NULL PRIMARY KEY, ... ); ALTER TABLE tab_test AUTO_INCREMENT=number; -- number 是任意数字  MS SQL Server 使用 IDENTITY() 来执行 auto-increment 任务：\n-- IDENTITY(initial, incremental) 中， -- initial 是初始值，incremental 是递增值 -- 即，以 initial 作为初始值，每新增一条记录递增 incremental CREATE TABLE tab_name ( column1 INT IDENTITY(initial, incremental) PRIMARY KEY, ... ) 插入数据的方法同 MySQL。\n Oracle 通过创建 sequence 对象（该对象生成数字序列）创建 auto-increment 字段：\nCREATE SEQUENCE sp_name MINVALUE 1 # 最小值为 1 START WITH 1 # 起始值为 1 INCREMENT BY 1 # 每次递增 1 CACHE 10 # 缓存 10 个值以提高性能 插入新记录时，必须使用 sequence 对象的 nextval 函数（该函数从 sp_name 序列中取回下一个值）：\n-- 假设 tab_name 已被创建， -- 且要对 column1 使用 nextval() 函数 INSERT INTO tab_name ( column1, column2, column3) VALUES ( sp_name.nextval, val2, val3);  视图 视图是虚拟的表。视图并不包含数据，它只包含使用时动态检索数据的查询。视图的 SELECT 用法与表的用法基本相同。\n使用视图的原因：\n  重用 SQL 语句。\n  简化复杂的 SQL 操作（无需知道视图的基本查询细节）。\n  使用表的一部分而不是整个表。\n  保护数据。 可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。\n  更改数据格式和表示。 视图可返回与底层表的表示和格式不同的数据。\n   视图的使用规则：\n  视图名必须为一且不能与其他视图或表重名。\n  对于可创建的视图数目没有限制。\n  创建视图，必须具有足够的访问权限（通常由数据库管理人员授予）。\n  视图可以嵌套，但允许的嵌套层数在不同的 DBMS 中有所不同。 嵌套视图、使用多个联结和过滤创建复杂的视图都会使性能下降。在产品环境中使用之前，应该对其进行全面测试。\n  许多 DBMS 禁止在视图查询中使用 ORDER BY 子句。\n  有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。\n  视图不能索引，也不能有关联的触发器或默认值。\n  有些 DBMS 把视图作为只读的查询（不能将数据写回底层表，如 SQLite）。\n  有些 DBMS 禁止对视图中的行进行插入或更新后，该行不再属于该视图的操作。 默认情况下，如果删除视图中的某行的某列后，可能会导致该行不属于该视图。但是某些 DBMS 会防止这种情况发生。\n   CREATE VIEW 创建视图 使用 CREATE VIEW 语句创建视图，通常包含两部分：\n  视图名；\n  SELECT 查询语句。\n  视图的用途：\n  利用视图简化复杂的联结：\nCREATE VIEW view_name AS SELECT filed1, filed2, ... FROM table1, table2, ... WHERE condition1;   用视图重新格式话检索出的数据：\n-- filed1, filed2, ... 指需要重命名的字段 ALTER VIEW view_name AS SELECT filed1 AS alias1, filed2 AS alias2, ... FROM tab_name;   用视图过滤不想要的数据。\n  一般创建的视图都不会绑定特定的数据，这会提高视图的可重用性。\n从视图检索数据时如果使用了一条 WHERE 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。\n DROP VIEW 删除视图 通过 DROP VIEW 删除视图（仅删除视图的定义，视图中并包含真实的数据）：\nDROP VIEW view_name;  索引 索引通过排序数据以加快搜索和排序操作的速度。\n  索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。\n  索引数据可能要占用大量的存储空间。\n  用户无法看到索引。\n  并非所有数据都适合做索引。\n  索引用于数据过滤和数据排序。如果经常以某种特定的顺序排序数据，则该数据可能适合做索引。\n  可以在索引中定义多个列。这样的索引仅在以这个列组合排序时有用。\n   CREATE INDEX 创建索引 索引使用 CREATE INDEX 语句创建（不同的 DBMS 创建索引的语句变化很大）。\n创建一个允许使用重复值的索引：\nCREATE INDEX index_name ON tab_name (column1, column2, ...); 创建唯一索引（不允许两个行拥有相同的索引值）：\nCREATE INDEX index_name ON tab_name (column1, column2, ...); 索引必须唯一命名。\n DROP INDEX 删除索引 MySQL:\nALTER TABLE tab_name DROP INDEX index_name; MS Access：\nDROP INDEX index_name ON tab_name; MS SQL Server：\nDROP INDEX tab_name.index_name; DB2 / Oracle：\nDROP INDEX index_name;  ","date":"2022-01-11T00:00:00Z","permalink":"https://blog.linner.asia/p/sql-%E8%AF%AD%E5%8F%A5/","title":"SQL 语句"}]