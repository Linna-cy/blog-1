<!DOCTYPE html>
<html lang="zh" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='面向对象基本概念 面向对象（Object-Oriented，00） = 对象（Object）&#43; 分类（Classification）&#43; 继承（Inhe'>


<title>面向对象（软件设计师）</title>

<link rel='canonical' href='https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/'>

<link rel="stylesheet" href="/scss/style.min.7a68e2beb371039eca9f5e8f87aa11bdb1fdc96a55744700a091f658cd1e66a7.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>

<meta property='og:title' content='面向对象（软件设计师）'>
<meta property='og:description' content='面向对象基本概念 面向对象（Object-Oriented，00） = 对象（Object）&#43; 分类（Classification）&#43; 继承（Inhe'>
<meta property='og:url' content='https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/'>
<meta property='og:site_name' content='Linner&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='软考' /><meta property='article:tag' content='软件设计师' /><meta property='article:published_time' content='2023-04-18T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2023-04-18T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="面向对象（软件设计师）">
<meta name="twitter:description" content="面向对象基本概念 面向对象（Object-Oriented，00） = 对象（Object）&#43; 分类（Classification）&#43; 继承（Inhe">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />

<style>
    .article-content {
        position: relative;
    }
    .article-content table, 
    .article-content tbody {
        white-space: normal;
        word-break: keep-all;
    }
    .article-content u {
        text-decoration-line: none;
        border-bottom: 1.5px solid;
        padding-bottom: 1.5px;
    }
    .article-content li {
        margin-top: 0.8em;
        margin-bottom: 0.8em;
    }
    .article-content ul:last-child, 
    .article-content ol:last-child {
        margin-bottom: 0;
    }
    .article-content td * {
         
    }
    .article-content td ol, 
    .article-content td ul {
        padding-left: 1.2em;
    }
    .article-content td {
        padding-top: 1em;
        padding-bottom: 1em;
        padding-left: 1em;
        padding-right: 1em;
    }
    .article-content td li:first-child,
    .article-content td ol:first-child, 
    .article-content td ul:first-child {
        margin-top: 0;
    }
    .article-content td ul:last-child,
    .article-content td ol:last-child,
    .article-content td ul:first-child {
        margin-bottom: 0;
    }
</style>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "auto");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu0c2331fe09320137a3bd1d4b5cc68791_142496_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Linner&#39;s Blog</a></h1>
            <h2 class="site-description">随便看看就行，副标题暂时还没想好</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/Linna-cy'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>

                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives" id="toc-list">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents"></nav>
            
        </div>
    </section>


            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/" >
                软件设计师
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">面向对象（软件设计师）</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Apr 18, 2023</time>
                |
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 52 分钟
                </time>
                |
            </div>
        

        <div class="article-time--reading">共25674字</div>
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="面向对象基本概念">面向对象基本概念</h1>
<p><strong>面向对象</strong>（Object-Oriented，00） = <strong>对象</strong>（Object）+ <strong>分类</strong>（Classification）+ <strong>继承</strong>（Inheritance）+ <strong>通过消息的通信</strong>（Communication with Messages）</p>
<h2 id="对象">对象</h2>
<p>在面向对象的系统中，对象是基本的运行时的实体，它包括：</p>
<ul>
<li><strong>属性</strong>：数据；</li>
<li><strong>行为</strong>：作用于数据的操作。</li>
</ul>
<p>一个对象把属性和行为封装为一个整体。</p>
<blockquote>
<p>封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。</p>
<p>对象可以看作是一个程序模块。</p>
</blockquote>
<p>一个对象通常由以下成分组成：</p>
<ul>
<li>对象名；</li>
<li>属性；</li>
<li>方法。</li>
</ul>
<h2 id="消息">消息</h2>
<p>对象之间进行通信的一种构造叫件消息。</p>
<h2 id="类">类</h2>
<p>类可以分为三种：</p>
<ul>
<li>
<p><strong>实体类</strong>：实体类的对象表示现实世界中真实的实体；</p>
</li>
<li>
<p><strong>接口类</strong>：接口类的对象为用户提供一种与系统合作交互的方式，分
为人和系统两大类（边界类）；</p>
<ul>
<li>人的接口可以是显示屏、窗口、Wb窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。</li>
<li>系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。</li>
</ul>
</li>
<li>
<p><strong>控制类</strong>：控制类的对象用来控制活动流，充当协调者。</p>
</li>
</ul>
<h2 id="继承">继承</h2>
<p>继承是<u>父类</u>和<u>子类</u>之间<u>共享数据</u>和<u>方法</u>的机制。这是<u>类之间的一种关系</u>，在定义和实现一个类的时候，可以在一个已经存在的类的基础上进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p>
<p>一个父类可以有多个子类。所以继承又分为：</p>
<ul>
<li>
<p>单重继承：只从一个父类得到继承；</p>
</li>
<li>
<p>多重继承：一个子类有两个或更多个父类。</p>
<p>多重继承中可能导致子类存在二义性的成员。</p>
</li>
</ul>
<h2 id="多态">多态</h2>
<p>多态（Polymorphism）：不同的对象收到同一消息可以产生完全不同的结果。</p>
<p>同一消息就可以调用不同的方法。多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应。</p>
<p>多态有不同的形式：</p>
<ul>
<li><strong>通用</strong>的多态：
<ul>
<li><strong>参数</strong>多态：应用比较广泛，被称为最纯的多态；</li>
<li><strong>包含</strong>多态：在许多语言中都存在，最常见的例子就是子类型化。即一个类型是另一个类型的子类型。</li>
</ul>
</li>
<li><strong>特定</strong>的多态：
<ul>
<li><strong>过载</strong>（Overloading）多态：同一个名字在不同的上下文中所代表的含义不同；</li>
<li><strong>强制</strong>多态。</li>
</ul>
</li>
</ul>
<h2 id="绑定">绑定</h2>
<p>绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。</p>
<p>绑定分为：</p>
<ul>
<li>
<p><strong>静态绑定</strong>：在编译时进行的；</p>
</li>
<li>
<p><strong>动态绑定</strong>：在运行时进行的。</p>
<p>一个给定的过程调用和代码的结合直到调用发生时才进行。</p>
<p>动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类对象可以出现的地方，子类对象也可以出现。</p>
<p>在运行过程中，当一个对象发送消息请求服务时，要根据匿收对象的其体情况将请求的操作与实现的方法进行连接，即动态绑定。</p>
</li>
</ul>
<hr>
<h1 id="面向对象分析">面向对象分析</h1>
<p>同其他分析方法一样，面向对象分析（Object-Oriented Analysis，OOA）的目的是为了获得对应用问题的理解。</p>
<p>面向对象分析包含5个活动：</p>
<ul>
<li>认定对象；</li>
<li>组织对象；</li>
<li>描述对象间的相互作用；</li>
<li>确定对象的操作</li>
<li>定义对象的内部信息。</li>
</ul>
<h2 id="认定对象">认定对象</h2>
<p>在应用领域中，按自然存在的实体确立对象。</p>
<p>在定义域中，首先将自然存在的“名词”作为一个对象，这通常是研究问题、定义域实体的良好开始。</p>
<h2 id="组织对象">组织对象</h2>
<p>分析对象间的关系，将相关对象抽象成类，其目的是为了简化关联对象，利用类的继承性建立具有继承性层次的类结构。</p>
<p>抽象类时可从以下方面考虑：</p>
<ul>
<li>对象间的操作；</li>
<li>一个对象是另一个对象的一部分，如房子是由门和窗构成的。</li>
</ul>
<hr>
<h1 id="面向对象设计">面向对象设计</h1>
<p><strong>程序设计范型</strong>（Programming Paradigm）是人们在<u>程序设计时所采用的基本方式模型</u>，决定了程序设计时采用的<u>思维方式</u>、<u>使用的工具</u>，同时又<u>有一定的应用范畴</u>。</p>
<p>程序设计范型的发展经历了：</p>
<ul>
<li>过程程序设计；</li>
<li>模块化程序设计；</li>
<li>函数程序设计；</li>
<li>逻辑程序设计；</li>
<li>面向对象程序设计范型。</li>
</ul>
<p><strong>面向对象程序设计</strong>（Object-Oriented Programming，<strong>OOP</strong>）的<u>实质是选用一种<strong>面向对象程序设计语言</strong>（Object-Oriented Programming Language，<strong>OOPL</strong>）</u>：</p>
<ul>
<li>采用对象、类及其相关概念所进行的程序设计；</li>
<li>关键在于加入了类和继承性，从而进一步提高了抽象程度。</li>
</ul>
<p>特定的OOP概念一般是通过OOPL中特定的语言机制来体现的。</p>
<p>OOP现在已经扩展到系统分析和软件设计的范畴，出现了面向对象分析和面向对象设计的概念。</p>
<h2 id="设计原则">设计原则</h2>
<p>面向对象方法中的五大原则：</p>
<ul>
<li>
<p><strong>责任原则</strong>（Single Responsibility Principle，SRP）：当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</p>
</li>
<li>
<p><strong>开放封闭原则</strong>（Open &amp; Close Principle，OCP）：软件实体（类、模块、函数等）应
该可以扩展的，即<strong>开放的</strong>；但是不可修改的，即<strong>封闭的</strong>。</p>
</li>
<li>
<p><strong>里氏替换原则</strong>（Liskov Substitution Principle，LSP）：子类型必须能够替换掉他们的基
类型。</p>
<p>即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</p>
<p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。</p>
</li>
<li>
<p><strong>依赖倒置原则</strong>（Dependence Inversion Principle，DP）：抽象不应该依赖于细节，细
节应该依赖于抽象。即，<u>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</u>。</p>
</li>
<li>
<p><strong>接口分离原则</strong>（Interface Segregation Principle，ISP）：不应该强迫客户依赖于它们不
用的方法。接口属于客户，不属于它所在的类层次结构。</p>
<p>即：<u>依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。</u></p>
<p>这样做的好处就在于可以最大限度地应对可能的变化。</p>
</li>
</ul>
<p>Robert C. Martin提出的面向对象设计原则还包括以下几个：</p>
<ul>
<li>重用发布等价原则（Release Reuse Equivalency Principle，REP）：重用的粒度就是发布的粒度。</li>
<li><strong>共同封闭原则</strong>（Common Closure Principle，CCP）：包中的所有类对于同一类性质的变化应该是共同到闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</li>
<li><strong>共同重用原则</strong>（Common Reuse Principle，CRP）：一个包中的所有类应该是共同重用
的。如果重用了包中的一个类那么就要重用包中的所有类。</li>
<li>无环依赖原则（Acyclic Dependencies Principle，ADP）：在包的依赖关系图中不允许存
在环，即包之间的结构必须是一个直接的五环图形。</li>
<li>稳定依赖原则（Stable Dependencies Principle,SDP）：朝着稳定的方向进行依赖。</li>
<li>稳定抽象原则（Stable Abstractions Principle，SAP）：包的抽象程度应该和其稳定程
度一致。</li>
</ul>
<hr>
<h1 id="uml">UML</h1>
<p>面向对象分析强调的是对一个系统中对象的特征和行为的定义。目前，国际上已经出现了多种面向对象的方法，例如：</p>
<ul>
<li>Peter Coad和Edward Yourdon的OOA和OOD方法（又称Coad/Yourdon方法或Coad方法）；</li>
<li>Booch的OOD方法（又称Booch方法）；</li>
<li>OMT（Object Modeling Technique，面向对象建模技术）方法；</li>
<li>UML（Unified Modeling Language，统一建模语言）。</li>
</ul>
<p>UML是面向对象软件的标准化建模语言。由于其简单、统一，又能够表达软件设计中的动态和静态信息，目前己经成为可视化建模语言事实上的工业标准。</p>
<p>UML中包含3种基本构造块：</p>
<ul>
<li>事物；</li>
<li>关系；</li>
<li>图。</li>
</ul>
<h2 id="事物">事物</h2>
<p>UML中有4种事物：</p>
<ul>
<li>
<p><strong>结构事物</strong>（Structural Thing）：是UML模型中的名词。它们<u>通常是模型的<strong>静态部分</strong>，描述概念或物理元素</u>。</p>
<p>结构事物包括：</p>
<ul>
<li>
<p>类（Class）；</p>
</li>
<li>
<p>接口（Interface）；</p>
</li>
<li>
<p>协作（Collaboration）；</p>
</li>
<li>
<p>用例（Use Case）；</p>
</li>
<li>
<p>主动类（Active Class）；</p>
</li>
<li>
<p>构件（Component）；</p>
</li>
<li>
<p>制品（Artifact）；</p>
</li>
<li>
<p>结点（Node）；</p>
<p>&hellip;&hellip;</p>
</li>
</ul>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055522161.png"
	width="708"
	height="294"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055522161_hu872254ba18803fa50bd84092332d0d27_39442_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055522161_hu872254ba18803fa50bd84092332d0d27_39442_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="结构事物的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="240"
		data-flex-basis="577px"
	
></p>
</li>
<li>
<p><strong>行为事物</strong>（Behavior Thing）：<u>是UML模型的<strong>动态部分</strong></u>。它们是模型中的动词，描述了跨越时间和空间的行为。</p>
<p>行为事物包括：</p>
<ul>
<li>
<p>交互（Interaction）；</p>
</li>
<li>
<p>状态机（State Machine）；</p>
</li>
<li>
<p>活动（Activity）；</p>
<p>&hellip;&hellip;</p>
</li>
</ul>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055712246.png"
	width="621"
	height="133"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055712246_hu926c842303194b37bd3d84d241da7490_18166_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055712246_hu926c842303194b37bd3d84d241da7490_18166_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="行为事物的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="466"
		data-flex-basis="1120px"
	
></p>
</li>
<li>
<p><strong>分组事物</strong>（Grouping Thing）：UML模型的<strong>组织部分</strong>，是一些由模型分解成的“盒子”。</p>
<p><u>在所有的分组事物中，最主要的分组事物是包（Package）</u>。包是把元素组织成组的机制，这种机制具有多种用途。结构事物、行为事物甚至其他分组事物都可以放进包内。</p>
<p>包与构件（仅在运行时存在）不同，它纯粹是概念上的（即它仅在开发时存在）。</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055987585.png"
	width="224"
	height="157"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055987585_hude1f550d1c91183afc794d1e3aa09c46_4122_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055987585_hude1f550d1c91183afc794d1e3aa09c46_4122_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="包的图形化表示"
	
	
		class="gallery-image" 
		data-flex-grow="142"
		data-flex-basis="342px"
	
></p>
</li>
<li>
<p><strong>注释事物</strong>（Annotational Thing）：注释事物是UML模型的<strong>解释部分</strong>。这些注释事物用来描述、说明和标注模型的任何元素。</p>
<p>注解（Note）是一种主要的注释事物。注解是一个依附于一个元素或者一组元素之上，对它进行约束或解释的简单符号。</p>
</li>
</ul>
<h2 id="关系">关系</h2>
<p>UML中有4种关系，这4种关系是UML模型中可以包含的基本关系事物：</p>
<ul>
<li>
<p><strong>依赖</strong>（Dependency）：是<u>两个事物间的语义关系，其中一个事物（<strong>独立事物</strong>）发生变化会影响另一个事物（<strong>依赖事物</strong>）的语义</u>。</p>
<p>在图形上，把一个依赖画成一条<u>可能有方向的虚线</u>，如图：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089.png"
	width="200"
	height="48"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="依赖的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="416"
		data-flex-basis="1000px"
	
></p>
<p>依赖的变体有：</p>
<ul>
<li>精化；</li>
<li>跟踪；</li>
<li>包含；</li>
<li>延伸。</li>
</ul>
<p>依赖有偶然性和临时性，即需要的时候依赖，不需要的时候不依赖。</p>
</li>
<li>
<p><strong>关联</strong>（Association）：是一种<u>结构关系</u>，它描述了一组链，<u>链是对象之间的连接</u>。</p>
<p>关联使用<u>实线</u>表示，在关联上可以标注重复度（Multiplicity）和角色（Role）。</p>
<p>描述了<u>整体和部分</u>间的结构关系的特殊类型的关联：</p>
<ul>
<li>
<p><strong>聚集</strong>（Aggregation，聚合）：<u>部分和整体的生命周期不一致</u>，整体消失了，部分仍然存在，<u>部分可以脱离整体存在</u>。</p>
<p>使用一端带<u>空心菱形</u>的实线表示。</p>
</li>
<li>
<p><strong>组合</strong>：<u>部分和整体的生命周期一致</u>，整体消失了，部分也消失了，<u>部分不可以脱离整体而存在</u>。</p>
<p>使用一端带<u>实心菱形</u>的实线表示。</p>
</li>
</ul>
<p>关联和聚集的图形化表示如图：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153.png"
	width="408"
	height="101"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="关联和聚集的图形化表示"
	
	
		class="gallery-image" 
		data-flex-grow="403"
		data-flex-basis="969px"
	
></p>
<p>聚合和组合中，带菱形的一端指向整体，另一端指向部分。</p>
<p>单向关联：用<u>带箭头实线</u>表示。</p>
<blockquote>
<p>关联的关系强度比依赖的关系强度要强一点。</p>
</blockquote>
<p>多重度：</p>
<p>进行面向对象设计时，类图中可以展现类之间的关联关系，还可以在类图中图示<u>关联中的数量关系</u>，即多重度。表示数量关系时，<u>用多重度说明数量或数量范围</u>，<u>表示有多少个实例（对象）能被连接起来</u>，即<u>一个类的实例能够与另一个类的多少个实例相关联</u>。</p>
<p>关联类：</p>
<p>当两个类之间的关联的重复度是多对多时，需要借助额外的属性来帮助表达它们之间的关系，而这个属性就需要定义在一个新的关联类中。关联类记录了这两个类之间的关联信息。关联中这些额外的属性用一条<u>垂直于关联的实线</u>表示，实线的一段连接接到关联的实线上，另一端指向这些属性。</p>
</li>
<li>
<p><strong>泛化</strong>（Generalization）：是一种特殊/一般关系，<u>特殊元素（子元素）的对象可替代一般元素（父元素）的对象</u>。用这种方法，<u>子元素共享了父元素的结构和行为</u>。</p>
<p>在图形上，把一个泛化关系画成一条<u>带有空心箭头的实线</u>，它指向父元素：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410.png"
	width="162"
	height="53"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="泛化的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="305"
		data-flex-basis="733px"
	
></p>
</li>
<li>
<p><strong>实现</strong>（Realization）：是<u>类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约</u>。</p>
<p>在两种情况下会使用实现关系：</p>
<ul>
<li>在接口和实现它们的类或构件之间：</li>
<li>在用例和实现它们的协作之间。</li>
</ul>
<p>在图形上，把一个实现关系画成一条<u>带有空心箭头的虚线</u>，箭头指向模板类，另一端于实现类连接。</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682058026631.png"
	width="167"
	height="61"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682058026631_hu09469114d42fa29e39948f21a9a04633_1340_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682058026631_hu09469114d42fa29e39948f21a9a04633_1340_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="实现的图形化表示"
	
	
		class="gallery-image" 
		data-flex-grow="273"
		data-flex-basis="657px"
	
></p>
</li>
</ul>
<h2 id="uml中的图">UML中的图</h2>
<p>UML2.0提供了13种图，分别是（<strong>加粗</strong>是重点，其它的作为了解）：</p>
<ul>
<li><strong>类图</strong></li>
<li><strong>对象图</strong></li>
<li><strong>用例图</strong></li>
<li><strong>状态图</strong></li>
<li><strong>活动图</strong></li>
<li><strong>构件图</strong></li>
<li>组合结构图</li>
<li><strong>部署图</strong></li>
<li>包图</li>
<li><strong>交互图</strong>：
<ul>
<li><strong>序列图</strong></li>
<li><strong>通信图</strong></li>
<li>交互概览图</li>
<li>计时图</li>
</ul>
</li>
</ul>
<h3 id="类图">类图</h3>
<p><u>类图</u>（Class Diagram）<u>展现了一组对象、接口、协作和它们之间的关系</u>。在面向对象系统的建模中所建立的<u>最常见的图就是类图</u>。类图给出系统的静态设计视图，包含主动类的类图（少见）给出了系统的静态进程视图。</p>
<p>类图中通常包括下述内容：</p>
<ul>
<li>
<p>类：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570702111.png"
	width="106"
	height="243"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570702111_hu4741eab1f2430fa5cd37f3e95504f684_7846_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570702111_hu4741eab1f2430fa5cd37f3e95504f684_7846_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="类的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="43"
		data-flex-basis="104px"
	
></p>
<p>类中的方法和属性前面有以下三种修饰符：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>public</code> 公有的</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>private</code> 私有的</td>
</tr>
<tr>
<td style="text-align:center"><code>#</code></td>
<td style="text-align:center"><code>protected</code> 受保护的</td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center"><code>package</code> 包的</td>
</tr>
</tbody>
</table></div>
<p>例如：</p>
  <table style="width: 200px; margin: auto;">
      <tr><th>Student</th></tr>
      <tr>
      <td>
      <p>
          <code>- id&nbsp;&nbsp;&nbsp;:&nbsp;int</code>
          <br>
          <code>+ name&nbsp;:&nbsp;String</code>
          <br>
          <code>+ age&nbsp;&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
      <tr>
      <td>
      <p>
          <code>+ getId()&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
  </table>
</li>
<li>
<p>接口：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570786524.png"
	width="135"
	height="74"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570786524_hu5845e575cae00345fed5de09da321787_3491_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570786524_hu5845e575cae00345fed5de09da321787_3491_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="接口的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="182"
		data-flex-basis="437px"
	
></p>
</li>
<li>
<p>协作：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570820946.png"
	width="107"
	height="67"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570820946_huaaba4fad0440f7f5bf987a2dd4b8f107_2415_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570820946_huaaba4fad0440f7f5bf987a2dd4b8f107_2415_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="协作的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="159"
		data-flex-basis="383px"
	
></p>
</li>
<li>
<p>依赖、泛化和关联关系：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089.png"
	width="200"
	height="48"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="依赖的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="416"
		data-flex-basis="1000px"
	
></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153.png"
	width="408"
	height="101"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="关联图形化表示"
	
	
		class="gallery-image" 
		data-flex-grow="403"
		data-flex-basis="969px"
	
></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410.png"
	width="162"
	height="53"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="泛化的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="305"
		data-flex-basis="733px"
	
></p>
</li>
</ul>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921.png"
	width="619"
	height="467"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="类图示例"
	
	
		class="gallery-image" 
		data-flex-grow="132"
		data-flex-basis="318px"
	
></p>
<p>类图中也可以包含：</p>
<ul>
<li>注解和约束；</li>
<li>包或子系统。</li>
</ul>
<p>类图成分总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类</td>
<td style="text-align:left"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684650129674.png"
	width="142"
	height="139"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684650129674_hucae45be9ae605ee21a469444ed126234_7038_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684650129674_hucae45be9ae605ee21a469444ed126234_7038_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="类图中的类的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="102"
		data-flex-basis="245px"
	
></td>
</tr>
<tr>
<td style="text-align:center">接口</td>
<td style="text-align:left"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570786524.png"
	width="135"
	height="74"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570786524_hu5845e575cae00345fed5de09da321787_3491_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570786524_hu5845e575cae00345fed5de09da321787_3491_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="类图接口的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="182"
		data-flex-basis="437px"
	
></td>
</tr>
<tr>
<td style="text-align:center">协作</td>
<td style="text-align:left"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570820946.png"
	width="107"
	height="67"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570820946_huaaba4fad0440f7f5bf987a2dd4b8f107_2415_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684570820946_huaaba4fad0440f7f5bf987a2dd4b8f107_2415_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="协作的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="159"
		data-flex-basis="383px"
	
></td>
</tr>
<tr>
<td style="text-align:center">依赖</td>
<td style="text-align:left"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089.png"
	width="200"
	height="48"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="依赖的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="416"
		data-flex-basis="1000px"
	
></td>
</tr>
<tr>
<td style="text-align:center">泛化</td>
<td style="text-align:left"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410.png"
	width="162"
	height="53"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="泛化的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="305"
		data-flex-basis="733px"
	
></td>
</tr>
<tr>
<td style="text-align:center">关联</td>
<td style="text-align:left"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153.png"
	width="408"
	height="101"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="关联图形化表示"
	
	
		class="gallery-image" 
		data-flex-grow="403"
		data-flex-basis="969px"
	
></td>
</tr>
</tbody>
</table></div>
<p>类图用于对系统的静态设计视图建模，<u>这种视图主要支持系统的功能需求</u>，通常以下述3种方式之一使用类图：</p>
<ul>
<li>
<p>对系统的词汇建模：</p>
<p>涉及做出这样的决定：</p>
<ul>
<li>哪些抽象是考虑中的系统的一部分；</li>
<li>哪些抽象处于系统边界之外。</li>
</ul>
<p>用类图详细描述这些抽象和它们的职责。</p>
</li>
<li>
<p>对简单的协作建模：协作是一些共同工作的类、接口和其他元素的群体，该群体提供的一些合作行为强于所有这些元素的行为之和。</p>
</li>
<li>
<p>对逻辑数据库模式建模：将模式看作为数据库的概念设计的蓝图。在很多领域中，要在关系数据库或面向对象数据库中存储永久信息，可以用类图对这些数据库的模式建模。</p>
</li>
</ul>
<h3 id="对象图">对象图</h3>
<p>对象图（Object Diagram）展现了<u>某一时刻一组对象以及它们之间的关系</u>，<u>描述了在类图中所建立的事物的实例的静态快照</u>。</p>
<p>对象图一般包括对象和链，如图：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263.png"
	width="713"
	height="312"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="对象图示例"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="548px"
	
></p>
<p>对象：对象图中的对象包含了类名、对象名和属性。</p>
<p>其图形化如下：</p>
<table style="width: 150px; text-align: center;">
    <tr>
    <th style="text-align: center;">
        对象名 : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>匿名对象（没有对象名）：</p>
<table style="width: 150px;">
    <tr>
    <th style="text-align: center;">
        : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>和类图一样，对象图给出系统的静态设计视图或静态进程视图，但它们是从真实的或原型实例的角度建立的。</p>
<h3 id="用例图">用例图</h3>
<p>用例图（Use Case Diagram）展现了一组用例、参与者（Actor）以及它们之间的关系。</p>
<p>用例图通常包括以下内容：</p>
<ul>
<li>
<p>用例：是从<strong>用户角度</strong>描述<strong>系统的行为</strong>，它将<strong>系统的一个功能</strong>描述成一系列的事件，这些事件最终对操作者产生有价值的观测结果。</p>
<p>用例是一个类，它代表<strong>一类功能</strong>而不是使用该功能的某一具体实例。</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684574449513.png"
	width="114"
	height="73"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684574449513_hu50f432d3b590de151e3190057472158d_3109_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684574449513_hu50f432d3b590de151e3190057472158d_3109_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="156"
		data-flex-basis="374px"
	
></p>
</li>
<li>
<p>参与者：是与系统交互的<strong>外部实体</strong>，可能是<strong>使用者</strong>，也可能是与系统交互的<strong>外部系统</strong>、<strong>基础设备</strong>等。</p>
<p>参与者用一个<u>人形图标</u>表示。</p>
</li>
<li>
<p>关系：</p>
<ul>
<li>
<p>用例之间的关系：</p>
<ul>
<li>
<p>包含关系：用带<code>&lt;&lt;include&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578078948.png"
	width="613"
	height="182"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578078948_hubb51fa3891e688e7291daaa781680867_10772_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578078948_hubb51fa3891e688e7291daaa781680867_10772_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="包含关系"
	
	
		class="gallery-image" 
		data-flex-grow="336"
		data-flex-basis="808px"
	
></p>
</li>
<li>
<p>扩展关系：用带<code>&lt;&lt;extend&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578542547.png"
	width="607"
	height="136"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578542547_hu0236ed30d2e6f19ac3b3e55246e9489d_7977_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578542547_hu0236ed30d2e6f19ac3b3e55246e9489d_7977_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="扩展关系"
	
	
		class="gallery-image" 
		data-flex-grow="446"
		data-flex-basis="1071px"
	
></p>
<p>扩展用例是指，一个用例中，符合某些特定情况才会触发的另一个用例。</p>
<p>即一个用例执行的时候，可能会发生一些特殊情况或可选情况，这种情况就是这个用例的扩展用例。</p>
</li>
</ul>
</li>
<li>
<p>参与者和用例之间的关联关系。</p>
</li>
<li>
<p>用例与用例以及参与者与参与者之间的泛化关系。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630.png"
	width="756"
	height="382"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例图示例"
	
	
		class="gallery-image" 
		data-flex-grow="197"
		data-flex-basis="474px"
	
></p>
<p>用例图成分总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用例</td>
<td style="text-align:center"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684574449513.png"
	width="114"
	height="73"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684574449513_hu50f432d3b590de151e3190057472158d_3109_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684574449513_hu50f432d3b590de151e3190057472158d_3109_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例的图形表示"
	
	
		class="gallery-image" 
		data-flex-grow="156"
		data-flex-basis="374px"
	
></td>
</tr>
<tr>
<td style="text-align:center">包含关系</td>
<td style="text-align:center"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578078948.png"
	width="613"
	height="182"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578078948_hubb51fa3891e688e7291daaa781680867_10772_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578078948_hubb51fa3891e688e7291daaa781680867_10772_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例之间的包含关系"
	
	
		class="gallery-image" 
		data-flex-grow="336"
		data-flex-basis="808px"
	
></td>
</tr>
<tr>
<td style="text-align:center">扩展关系</td>
<td style="text-align:center"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578542547.png"
	width="607"
	height="136"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578542547_hu0236ed30d2e6f19ac3b3e55246e9489d_7977_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684578542547_hu0236ed30d2e6f19ac3b3e55246e9489d_7977_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例之间的扩展关系"
	
	
		class="gallery-image" 
		data-flex-grow="446"
		data-flex-basis="1071px"
	
></td>
</tr>
<tr>
<td style="text-align:center">泛化关系</td>
<td style="text-align:center"><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410.png"
	width="162"
	height="53"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例与用例以及参与者与参与者之间的泛化关系"
	
	
		class="gallery-image" 
		data-flex-grow="305"
		data-flex-basis="733px"
	
></td>
</tr>
</tbody>
</table></div>
<h3 id="交互图">交互图</h3>
<p>交互图用于<u>对系统的动态方面进行建模</u>。一张交互图表现的是一个交互，由一组对象和它们之间的关系组成，包含它们之间可能传递的消息。</p>
<p>每种交互图针对不同的目的，能适用于不同的情况。交互图表现为：</p>
<ul>
<li><strong>序列图</strong>：强调<strong>消息时间顺序</strong>的交互图；</li>
<li><strong>通信图</strong>：强调<strong>接收和发送消息的对象的结构组织</strong>的交互图；</li>
<li><strong>交互概览图</strong>：强调<strong>控制流</strong>的交互图；</li>
<li><strong>计时图</strong>。</li>
</ul>
<p>其中顺序图和通信图是同构的，它们之间可以相互转换。</p>
<p>在多数情况下，交互图包括对以下内容的具体的或原型化的实例以及它们之间传递的消息进行建模：</p>
<ul>
<li>类；</li>
<li>接口；</li>
<li>构件；</li>
<li>结点。</li>
</ul>
<p>所有这些都位于一个表达行为的脚本的语境中。</p>
<p>交互图一般包含：</p>
<ul>
<li>
<p>对象；</p>
</li>
<li>
<p>链；</p>
</li>
<li>
<p>消息</p>
<p>&hellip;&hellip;</p>
</li>
</ul>
<h4 id="序列图">序列图</h4>
<p>序列图（Sequence Diagram，<strong>顺序图</strong>）是场景（Scenario）的图形化表示，<u>描述了以时间顺序组织的对象之间的交互活动</u>，<u>强调消息时间顺序</u>。</p>
<p>序列图的组成：</p>
<ol>
<li>
<p>把参加交互的对象放在图的上方，沿水平方向排列。</p>
<p>通常把发起交互的对象放在左边，下级对象依次放在右边。</p>
</li>
<li>
<p>把这些对象发送和接收的消息，沿垂直方向，按时间顺序从上到下放置。</p>
</li>
</ol>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751.png"
	width="691"
	height="471"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="序列图示例"
	
	
		class="gallery-image" 
		data-flex-grow="146"
		data-flex-basis="352px"
	
></p>
<p>序列图的组成部分：</p>
<ul>
<li>
<p>对象：用方框框起来的<code>对象名:类名</code>，没有属性和方法等成分。</p>
</li>
<li>
<p><strong>对象生命线</strong>：表示<u>一个对象存在的时间段</u>。</p>
<p>如上图中对象下方垂直的虚线。</p>
<ul>
<li>对象可以在交互过程中创建：生命线从接收到构造型<code>create</code>消息开始；</li>
<li>也可以在交互过程中撤销：生命线从接收到构造型<code>destroy</code>消息结束，并且给出一个大$\times$的标记表明生命线的结束。</li>
</ul>
</li>
<li>
<p><strong>控制焦点</strong>：控制焦点表示<u>一个对象执行一个动作所经历的时间段</u>。</p>
<p>如上图中对象下方的空表矩形条框。</p>
</li>
<li>
<p><strong>消息</strong>：</p>
<p>普通的消息用<u>带箭头的实线</u>表示。所有消息的箭头都是指向接收对象。</p>
<ul>
<li>返回消息：用<u>带箭头的虚线</u>表示。</li>
<li>同步消息（调用消息）：指消息发送给接收对象后，需要等待接收对象返回后才可进行下一步操作。</li>
<li>异步消息：指消息发送给接收对象后，无需等待接收对象返回即可进行下一步操作。</li>
</ul>
</li>
</ul>
<p>序列图有两个不同于通信图的特性：</p>
<ul>
<li>序列图有对象生命线；</li>
<li>序列图有控制焦点。</li>
</ul>
<h4 id="通信图">通信图</h4>
<p><u>通信图</u>（Communication Diagram，<strong>协作图</strong>）<u>强调收发消息的对象的结构组织</u>。</p>
<p>通信图的组成：</p>
<ol>
<li>将参加交互的<u>对象</u>作为图的<u>顶点</u>；</li>
<li>把连接这些对象的<u>链</u>表示为图的<u>弧</u>；</li>
<li>用对象发送和接收的<u>消息</u>来<u>修饰这些链</u>。</li>
</ol>
<p>这就提供了在协作对象的结构组织的语境中观察控制流的一个清晰的可视化轨迹。</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645.png"
	width="719"
	height="314"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="通信图示例"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="549px"
	
></p>
<p>通信图有以下成分：</p>
<ul>
<li>
<p>对象：与序列图一样，是用一个方框框起来的<code>对象名:类名</code>。</p>
</li>
<li>
<p><strong>路径</strong>（链接）：用实线表示，可以在链的末端附上一个路径构造型。</p>
<p>通常仅需显式地表示以下几种链的路径：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">构造型</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;&lt;local&gt;&gt;</code></td>
<td style="text-align:center">局部</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;parameter&gt;&gt;</code></td>
<td style="text-align:center">参数</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;global&gt;&gt;</code></td>
<td style="text-align:center">全局</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;self&gt;&gt;</code></td>
<td style="text-align:center">自身</td>
</tr>
</tbody>
</table></div>
<p>不必表示<code>association</code>（关联）。</p>
</li>
<li>
<p><strong>序号</strong>：用来表示消息的时间顺序。是消息前的一个数字前缀，可使用带小数点的号码表示嵌套消息，嵌套可为任意深度。</p>
<p>如2表示第2个消息，2.1表示嵌套在消息2中的第1个消息。</p>
</li>
<li>
<p>消息：沿同一个链可以显示许多消息（可能发自不同方向），并且每个消息都有唯一的序号。</p>
</li>
</ul>
<p>通信图有两个不同于序列图的特性：</p>
<ul>
<li>通信图有路径；</li>
<li>通信图有序号。</li>
</ul>
<h4 id="总结">总结</h4>
<p>顺序图和通信图是同构的，它们之间可以相互转换。它们的差异如下：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:left"><center>序列图</center></th>
<th style="text-align:left"><center>通信图</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>强调</strong></td>
<td style="text-align:left"><center>消息时间顺序</center></td>
<td style="text-align:left"><center>收发消息的对象的结构组织</center></td>
</tr>
<tr>
<td style="text-align:center"><strong>不同的特性</strong></td>
<td style="text-align:left"><ul><li>有对象生命线：对象存在的时间段</li><li>有控制焦点：对象执行动作所经历的时间段</li></ul></td>
<td style="text-align:left"><ul><li>有路径：表示对象之间有交互</li><li>有序号：表示消息的时间顺序，可嵌套表示</li></ul></td>
</tr>
</tbody>
</table></div>
<h3 id="状态图">状态图</h3>
<p>状态图（State Diagram，状态转换图）展现了一个状态机。状态图关注系统的动态视图，对于接口、类和协作的行为建模尤为重要，<u>强调对象行为的事件顺序</u>。</p>
<p>状态图由以下组成：</p>
<ul>
<li>
<p><strong>状态</strong>：指对象的生命周期中某个条件或者状态，是<u>任何可以被观察到的系统行为模式</u>，<u>一个状态代表系统的一种行为模式</u>。</p>
<p>状态规定了系统内对事件的响应方式。</p>
<p>系统对事件的响应：</p>
<ul>
<li>可以是<u>做一个（或一系列）动作</u>；</li>
<li>可以是仅仅<u>改变系统本身的状态</u>；</li>
<li>可以是<u>即改变状态，又做动作</u>。</li>
</ul>
<p>状态转换图中定义的状态主要有：</p>
<ul>
<li><strong>初态</strong>（初始状态）：用一个<u>实心圆点</u>表示。一张状态图<u>只能有一个初态</u>。</li>
<li><strong>终态</strong>（最终状态）：用一个<u>实心圆点外加一个圆圈</u>表示。一张状态图<u>可以没有终态，也可以有多个</u>。</li>
<li><strong>中间状态</strong>。</li>
</ul>
<p>状态图中的状态用一个<u>圆角矩形</u>表示，可以用两条水平横线将其分为上中下3个部分：</p>
<ol>
<li>上面部分（必须）：状态的名称；</li>
<li>中间部分（可选）：状态变量的名称和值；</li>
<li>下面部分（可选）：活动表。</li>
</ol>
<p>状态还可分为：</p>
<ul>
<li>
<p>简单状态。</p>
</li>
<li>
<p>组合状态：含有子状态的状态，这个状态也称为其子状态的超状态。</p>
<p>子状态：嵌套在另外一个状态中的状态。</p>
</li>
</ul>
</li>
<li>
<p><strong>转换</strong>（迁移）：是两个状态之间的一种关系，表示对象将在源状态中执行一定的动作，并在某个特定事件发生，而且某个特定的警界（监护）条件满足时进入目标状态。</p>
<p>状态转换用一条<u>带箭头的实线</u>表示。</p>
</li>
<li>
<p><strong>事件</strong>：是在某个特定时刻发生的事情，<u>它是对引起系统做动作或（和）从一个状态转换到另个状态的外界事件的抽象</u>。</p>
<ul>
<li>
<p><u>事件触发</u>状态转换：<u>状态变迁通常是由事件触发的。</u>状态之间带箭头实线上的事件发生时，状态转换开始（还可称之为状态“点火”或状态被“触发”）。</p>
<p>这种情况下应在表达状态转换的箭头线上标出触发转换的<u>事件表达式</u>：</p>
<pre tabindex="0"><code>事件说明 [守卫条件] / 动作表达式
</code></pre><p>事件说明的语法为：</p>
<pre tabindex="0"><code>事件名 (参数表)
</code></pre><p>守卫条件（监护条件）：一个布尔表达式。</p>
<ul>
<li>当且仅当事件发生且守卫条件为真时，状态转换才发生；</li>
<li>只有守卫条件没有事件说明时，只要守卫条件为真，状态转换就发生。</li>
</ul>
<p>动作表达式是一个过程表达式，当状态转换（事件）开始时执行。</p>
</li>
<li>
<p><u>自动触发</u>状态转换：如果箭头线上未标明事件，则表示<u>在源状态的内部活动执行完之后自动触发转换</u>。</p>
</li>
</ul>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684587930655.png"
	width="717"
	height="135"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684587930655_hub194f1dce76ed4c99298044c9667a40d_7727_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1684587930655_hub194f1dce76ed4c99298044c9667a40d_7727_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="状态图中的事件和转换"
	
	
		class="gallery-image" 
		data-flex-grow="531"
		data-flex-basis="1274px"
	
></p>
</li>
<li>
<p><strong>活动</strong>：指状态中的活动表中的活动。</p>
<p>语法如下：</p>
<pre tabindex="0"><code>事件名 (参数表) /动作表达式
</code></pre><p>事件名：可以是任何事件的名称。</p>
<p>在活动表中经常使用以下3中标准事件：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>entry</code></td>
<td style="text-align:left"><u>入口动作</u>，指定<u>进入该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>exit</code></td>
<td style="text-align:left"><u>出口动作</u>，指定<u>退出该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>do</code></td>
<td style="text-align:left"><u>内部活动</u>，指定<u>在该状态下</u>的动作，占有有限时间，并可中断地工作</td>
</tr>
</tbody>
</table></div>
<p>活动（动作）可以在状态内执行，也可以在状态转换（迁移）时执行。</p>
</li>
</ul>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326.png"
	width="831"
	height="431"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="状态图示例"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="462px"
	
></p>
<p>可以用状态图对系统的动态方面建模。这些动态方面可以包括出现在系统体系结构的任何视图中的任何一种对象的按事件排序的行为，这些对象包括：</p>
<ul>
<li>类（各主动类）；</li>
<li>接口；</li>
<li>构件；</li>
<li>结点。</li>
</ul>
<p>当对系统、类或用例的动态方面建模时，通常是对反应型对象建模。</p>
<h3 id="活动图">活动图</h3>
<p>活动图（Activity Diagram）是一种特殊的状态图，它<u>展现了在系统内从一个活动到另一个活动的流程</u>。活动图<u>专注于系统的动态视图</u>，它对于系统的功能建模特别重要，并<u>强调对象间的控制流程</u>。</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114.png"
	width="654"
	height="744"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="活动图示例"
	
	
		class="gallery-image" 
		data-flex-grow="87"
		data-flex-basis="210px"
	
></p>
<p>活动图一般包括：</p>
<ul>
<li>
<p>状态：</p>
<p>活动图的状态也包含初态和终态。其余的状态还可分为：</p>
<ul>
<li>动作状态：不能被分解，动作不能被中断。</li>
<li>活动状态：能够被进一步分解，可以被中断，其活动由其它的活动图来表示。</li>
</ul>
</li>
<li>
<p>流（转换）。</p>
</li>
<li>
<p>对象。</p>
</li>
</ul>
<p>活动图可以表示：</p>
<ul>
<li>分支（判断）；</li>
<li>（并发）分岔：将一个流分为多个可并发执行的流；</li>
<li>（并发）汇合：将分岔出去的多个流合并为同一个流。</li>
</ul>
<p>当对一个系统的动态方面建模时，有以下几种使用活动图的方式：</p>
<ul>
<li>对工作流建模；</li>
<li>对操作建模；</li>
<li>对业务的复杂流程建模。</li>
</ul>
<h3 id="构建图">构建图</h3>
<p>构件图（Component Diagram，<strong>组件图</strong>）展现了<u>一组构件之间的组织和依赖</u>。构件图<u>专注于系统的静态实现视图</u>，它<u>与类图相关，通常把构件映射为一个或多个类、接口或协作</u>。</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459.png"
	width="638"
	height="332"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459_hue00d8420ae8e9d060383db5e372a8f97_47534_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459_hue00d8420ae8e9d060383db5e372a8f97_47534_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="构建图示例"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="461px"
	
></p>
<p>构件图的成分有：</p>
<ul>
<li>构件：用<u>矩形</u>表示，在矩形<u>右上方有一个小标记</u>。</li>
<li>供接口：用一个<u><strong>圆圈</strong>和连接到构件上的实线</u>表示。构件提供接口给其它构件使用。</li>
<li>需接口：用一个<u><strong>半圆</strong>和连接到构件上的实线</u>表示。构件使用需接口表示需要其它构件提供接口。</li>
<li>依赖：将供接口（圆圈）和虚接口（半圆）连接到一起，表示两个构建通过这个接口相依赖。</li>
</ul>
<h3 id="部署图">部署图</h3>
<p>部署图（Deployment Diagram）是用来<u>对面向对象系统的<strong>物理方面</strong>建模</u>的方法，展现了运行时处理结点以及其中构件（制品）的配置。部署图<u>对系统的静态部署视图进行建模</u>，它与构件图相关。</p>
<p>部署图<u>展现了系统的软件和硬件之间的关系，在实施阶段使用</u>。</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388.png"
	width="491"
	height="327"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="部署图示例"
	
	
		class="gallery-image" 
		data-flex-grow="150"
		data-flex-basis="360px"
	
></p>
<blockquote>
<p><code>&lt;&lt;artifact&gt;&gt;</code>表示制品。</p>
</blockquote>
<h3 id="总结-1">总结</h3>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">UML图</th>
<th style="text-align:center">静态建模</th>
<th style="text-align:center">动态建模</th>
<th style="text-align:center">物理建模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">构件图（组件图)</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">序列图（顺序图，时序图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">通信图（协作图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">状态图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
</tbody>
</table></div>
<p>活动图是一种特殊的状态图，它们的差异如下：</p>
<ul>
<li>相同点：状态中都有初态和终态。</li>
<li>主要差异：
<ul>
<li>活动图的转换称为流；</li>
<li>活动图有分支、并发分岔和并发汇合。</li>
</ul>
</li>
</ul>
<p>以下是UML图的总结：</p>
<ul>
<li>
<p><strong>类图</strong>：展现一组<u>对象（类）</u>、<u>接口</u>、<u>协作</u>和它们之间的<u>关系</u></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921.png"
	width="619"
	height="467"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="类图示例"
	
	
		class="gallery-image" 
		data-flex-grow="132"
		data-flex-basis="318px"
	
></p>
</li>
<li>
<p><strong>对象图</strong>：展现某一时刻的一组<u>对象</u>以及它们之间的<u>关系</u>，描述了在类图中所建立事物的实例的静态快照</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263.png"
	width="713"
	height="312"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="对象图示例"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="548px"
	
></p>
</li>
<li>
<p><strong>用例图</strong>：展现了一组<u>用例</u>、<u>参与者</u>以及它们之间的<u>关系（包含、扩展、关联和泛化）</u></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630.png"
	width="756"
	height="382"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例图示例"
	
	
		class="gallery-image" 
		data-flex-grow="197"
		data-flex-basis="474px"
	
></p>
</li>
<li>
<p><strong>序列图（顺序图，时序图）</strong>：描述了以<u>时间顺序</u>组织的<u>对象</u>之间的<u>交互活动</u>，强调<u>消息时间顺序</u></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751.png"
	width="691"
	height="471"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="序列图示例"
	
	
		class="gallery-image" 
		data-flex-grow="146"
		data-flex-basis="352px"
	
></p>
</li>
<li>
<p><strong>通信图（协作图）</strong>：强调<u>收发消息的对象的结构组织</u></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645.png"
	width="719"
	height="314"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="通信图"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="549px"
	
></p>
</li>
<li>
<p><strong>状态图（状态转换图）</strong>：展现了一个状态机，强调<u>对象行为的事件顺序</u></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326.png"
	width="831"
	height="431"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="状态图示例"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="462px"
	
></p>
</li>
<li>
<p><strong>活动图</strong>：一种特殊的状态图，展现了在<u>系统内从一个活动到另一个活动的流程</u>，强调<u>对象间的控制流程</u></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114.png"
	width="654"
	height="744"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="活动图示例"
	
	
		class="gallery-image" 
		data-flex-grow="87"
		data-flex-basis="210px"
	
></p>
</li>
<li>
<p><strong>构件图（组件图)</strong>：展现了一组<u>构件之间的组织和依赖</u>，将构件映射为类、接口或协作</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459.png"
	width="638"
	height="332"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459_hue00d8420ae8e9d060383db5e372a8f97_47534_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459_hue00d8420ae8e9d060383db5e372a8f97_47534_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="构件图示例"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="461px"
	
></p>
</li>
<li>
<p><strong>部署图</strong>：对物理建模，展现了<u>运行时处理结点以及其中构件（制品）的配置</u></p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388.png"
	width="491"
	height="327"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="部署图示例"
	
	
		class="gallery-image" 
		data-flex-grow="150"
		data-flex-basis="360px"
	
></p>
</li>
</ul>
<hr>
<h1 id="设计模式">设计模式</h1>
<p>每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。使用设计模式能减少一些重复劳动。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便地复用成功的设计和体系结构。</p>
<p>设计模式分类：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center"><br></th>
<th style="text-align:left">创建型</th>
<th style="text-align:left">结构型</th>
<th style="text-align:left">行为型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类</td>
<td style="text-align:left">Factory Method（工厂方法模式）</td>
<td style="text-align:left">Adapter（适配器模式）</td>
<td style="text-align:left">Interpreter（解释器模式）<br>Template Method（模板方法模式）</td>
</tr>
<tr>
<td style="text-align:center">对象</td>
<td style="text-align:left">Abstract Factory（抽象工厂模式）<br>Builder（生成器模式）<br>Prototype（原型模式）<br>Singleton（单例模式）</td>
<td style="text-align:left">Adapter（适配器模式）<br>Bridge（桥接模式）<br>Composite（组合模式）<br>Decorator（装饰器模式）<br>Facade（外观模式）<br>Flyweight（享元模式）<br>Proxy（代理模式）</td>
<td style="text-align:left">Chain of Responsibility（责任链模式）<br>Command（命令模式）<br>Iterator（迭代器模式）<br>Mediator（中介者模式）<br>Memento（备忘录模式）<br>Observer（观察者模式）<br>State（状态模式）<br>Strategy（策略模式）<br>Visitor（访问者模式）</td>
</tr>
</tbody>
</table></div>
<h2 id="创建型设计模式">创建型设计模式</h2>
<p>创建型模式顾名思义就是针对对象的创建过程所做的设计模式。</p>
<p>创建型模式<u>抽象了实例化过程</u>。</p>
<ul>
<li>类创建型模式：使用继承改变被实例化的类；</li>
<li>对象创建型模式：将实例化委托给另一个对象。</li>
</ul>
<h3 id="工厂模式">工厂模式</h3>
<p>工厂方法（Factory Method）模式定义一个用于<u>创建对象的接口</u>，让<u>子类决定实例化哪一个类</u>。工厂模式使一个类的实例化延迟到其子类。</p>
<blockquote>
<p>即接口不创建具体的对象，交由子类来决定实例化哪个类。</p>
</blockquote>
<p>工厂模式结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682232330534.png"
	width="725"
	height="268"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682232330534_huc77d54806485b83d5b01369d9c023787_25091_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682232330534_huc77d54806485b83d5b01369d9c023787_25091_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="工厂模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="270"
		data-flex-basis="649px"
	
></p>
<ul>
<li>
<p><code>Product</code>：定义工厂方法所创建的对象的接口。</p>
</li>
<li>
<p><code>ConcreteProduct</code>：实现<code>Product</code>接口。</p>
</li>
<li>
<p><code>Creator</code>：声明工厂方法，该方法返回一个<code>Product</code>类型的对象。</p>
<p><code>Creator</code>也可以定义一个工厂方法的默认实现，它返回一个默认的<code>ConcreteProduct</code>对象，可以调用工厂方法以创建一个<code>Product</code>对象。</p>
</li>
<li>
<p><code>ConcreteCreator</code>：重定义工厂方法以返回一个<code>ConcreteProduct</code>实例。</p>
</li>
</ul>
<p>Factory Method模式适用于：</p>
<ul>
<li>当一个类<u>不知道它所必须创建的对象的类</u>的时候。</li>
<li>当一个类<u>希望由它的子类来指定它所创建的对象</u>的时候。</li>
<li>当类<u>将创建对象的职责委托给多个帮助子类中的某一个</u>，并且你希望将哪一个<u>帮助子类是代理者</u>这一信息局部化的时候。</li>
</ul>
<blockquote>
<p>关键词：<u>子类指定创建对象</u>。</p>
</blockquote>
<p>工厂模式：</p>
<ul>
<li>特点：用户类和工厂类分开。</li>
<li>优点：用户需要什么对象，只需向工厂请求即可。用户无需修改就可使用对象。</li>
<li>缺点：对象修改时，工厂类也需要做相应的修改。</li>
</ul>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<p>抽象工厂（Abstract Factory）提供一个<u>创建一系列相关或相互依赖对象的接口</u>，而<u>无须指定它们具体的类</u>。</p>
<blockquote>
<p>即提供对象的接口，用户无需考虑实现类。</p>
</blockquote>
<p>抽象工厂模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682230457950.png"
	width="704"
	height="330"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682230457950_hu9c89e6a2ba3c7411a12e6de71f8df7cf_36899_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682230457950_hu9c89e6a2ba3c7411a12e6de71f8df7cf_36899_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="抽象工厂模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="213"
		data-flex-basis="512px"
	
></p>
<ul>
<li><code>AbstractFactory</code>：声明一个创建抽象产品对象的操作接口。</li>
<li><code>ConcreteFactory</code>：实现创建具体产品对象的操作。</li>
<li><code>AbstractProduct</code>：为一类产品对象声明一个接口。</li>
<li><code>ConcreteProduct</code>：定义一个将被相应的具体工厂创建的产品对象，实现<code>AbstractProduct</code>接口。</li>
<li><code>Client</code>：仅使用由<code>AbstractFactory</code>和<code>AbstractProduct</code>类声明的接口。</li>
</ul>
<p>Abstract Factory模式适用于：</p>
<ul>
<li>一个系统要<strong>独立</strong>于它的<strong>产品的创建</strong>、<strong>组合</strong>和<strong>表示</strong>时。</li>
<li>一个系统要由<u>多个产品系列中的一个来配置</u>时。</li>
<li>当要强调<u>一系列相关的产品</u>对象的设计以便进行<u>联合使用</u>时。</li>
<li>当提供一个<u>产品类库</u>，只想<u>显示它们的接口而不是实现</u>时。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>
<p>提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类。</p>
</li>
<li>
<p>当一个系统应该独立于它的产品创建、构成和表示时。</p>
</li>
<li>
<p>当要强调一系列相关的产品对象的设计以便进行联合使用时。</p>
</li>
<li>
<p>一个系统要由多个产品系列中的一个来配置时。</p>
</li>
<li>
<p>为图形用户界面（GUI）组件定义不同平台的并行类层次结构。</p>
<pre><code>不同平台的GUI组件，使用同样的接口，根据平台使用不同的实现。
</code></pre>
</li>
</ul>
<p>关键词：<u>系列</u>。</p>
</blockquote>
<p>抽象工厂模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做。它仅负责给存储具体工厂类必须实现的接口。</p>
<h3 id="生成器建造者模式">生成器（建造者）模式</h3>
<p>生成器（Builder，建造者）模式将一个<u>复杂对象的<strong>构建</strong>与它的<strong>表示</strong>分离</u>，使得<u>同样的构建过程可以创建不同的表示</u>。</p>
<p>生成器模式结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682231345251.png"
	width="729"
	height="261"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682231345251_hu690497866a39e8a8fdd5b4c1f3b39af4_22986_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682231345251_hu690497866a39e8a8fdd5b4c1f3b39af4_22986_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="生成器模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="279"
		data-flex-basis="670px"
	
></p>
<ul>
<li>
<p><code>Product</code>：表示被构造的复杂对象。</p>
</li>
<li>
<p><code>Builder</code>：为创建一个<code>Product</code>对象的各个部件指定抽象接口。</p>
</li>
<li>
<p><code>ConcreteBuilder</code>：实现<code>Builder</code>的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。</p>
<p><code>ConcreteBuilder</code>创建<code>Product</code>对象产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。</p>
</li>
<li>
<p><code>Director</code>：构造一个使用<code>Builder</code>接口的对象。</p>
</li>
</ul>
<p>Builder模式适用于：</p>
<ul>
<li>当<u>创建复杂对象的算法</u>应该<u>独立于该对象的组成部分以及它们的装配方式时</u>。</li>
<li>当<u>构造过程必须允许被构造的对象有不同的表示时</u>。</li>
</ul>
<blockquote>
<p>题目选项描述</p>
<ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
<li>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li>适用于抽象复杂对象的构建步骤和基于构建过程的具体实现构建复杂对象的不同表示。</li>
</ul>
<p>关键词：<u>复杂对象、不同表示</u>。</p>
</blockquote>
<h3 id="原型模式">原型模式</h3>
<p>原型（Prototype）模式用<u>原型实例指定创建对象的种类</u>，并且<u>通过复制这些原型创建新的对象</u>。</p>
<p>原型模式结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233376386.png"
	width="638"
	height="298"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233376386_hu1813704620029f1adb77611772cb6330_23912_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233376386_hu1813704620029f1adb77611772cb6330_23912_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="原型模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="214"
		data-flex-basis="513px"
	
></p>
<ul>
<li><code>Prototype</code>：声明一个复制自身的接口。</li>
<li><code>ConcretePrototype</code>：实现一个复制自身的操作。</li>
<li><code>Client</code>：让一个原型复制自身从而创建一个新的对象。</li>
</ul>
<p>Prototype模式适用于：</p>
<ul>
<li>当一个系统应该独立于它的产品创建、构成和表示时。</li>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时。</li>
<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>
<p>原型模式：</p>
<ul>
<li>特点：通过给出一个原型对象来指明所要创建的对象的类型，然后复制这个原型对象的方法创建出更多同类型的对象。</li>
<li>优点：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。</li>
<li>缺点：每一个类都必须配备一个克隆方法。</li>
</ul>
<h3 id="单例单态模式">单例（单态）模式</h3>
<p>单例（Singleton，单态）模式保证<u>一个类仅有一个实例</u>，并<u>提供一个访问它的全局访问点</u>。</p>
<blockquote>
<p>就好像Spring中的Bean，每个Bean有且仅有一个实例，通过<code>@Autowired</code>自动装配（来访问）。</p>
</blockquote>
<p>单例模式结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233866165.png"
	width="464"
	height="169"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233866165_huef95807dda454cba71e939a884d0b18a_14126_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233866165_huef95807dda454cba71e939a884d0b18a_14126_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="单例模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="274"
		data-flex-basis="658px"
	
></p>
<ul>
<li><code>Singleton</code>：指定一个<code>Instance</code>操作，允许客户访问它的唯一实例。</li>
<li><code>Instance</code>：是一个类操作；可能负责创建它自己的唯一实例。</li>
</ul>
<p>Singleton模式适用于：</p>
<ul>
<li>当类<u>只能有一个实例</u>而且客户可以从一个众所周知的访问点访问它时。</li>
<li>当这个<u>唯一实例</u>应该是通过子类化可扩展的，并且<u>客户无须更改代码就能使用一个扩展的实例</u>时。</li>
</ul>
<blockquote>
<p>关键词：<u>唯一实例、一个实例</u>。</p>
</blockquote>
<p>单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<h2 id="结构型设计模式">结构型设计模式</h2>
<p>结构型设计模式涉及<u>如何组合类或对象以获得更大的结构</u>。</p>
<ul>
<li>
<p>结构型类模式：<u>采用继承机制来组合接口或实现</u>。</p>
<p>一个简单的例子是<u>采用多重继承方法将两个以上的类组合成一个类</u>，结果这个类包含了所有父类的性质。</p>
<p>这一模式尤其有助于多个独立开发的类库协同工作。</p>
</li>
<li>
<p>结构型对象模式：描述了<u>如何对一些对象进行组合，从而实现新功能的一些方法</u>（不是对接口和实现进行组合）。</p>
<p>因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。</p>
</li>
</ul>
<h3 id="适配器变压器模式">适配器（变压器）模式</h3>
<p>适配器（Adapter，变压器）模式<u>将一个类的接口转换成客户希望的另外一个接口</u>。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>类适配器使用多重继承对一个接口与另一个接口进行匹配：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299306295.png"
	width="885"
	height="674"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299306295_hu274e97e19deac790c686089605963483_65147_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299306295_hu274e97e19deac790c686089605963483_65147_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="适配器模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="131"
		data-flex-basis="315px"
	
></p>
<p>Adapter模式适用于：</p>
<ul>
<li>想使用一个已经存在的类，而它的<u>接口不符合要求</u>。</li>
<li>想创建一个可以服用的类，该类可以<u>与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作</u>。</li>
<li>（仅适用于对象Adapter）想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。<u>对象适配器可以适配它的父类接口。</u></li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>将一个对象加以包装以给客户提供其希望的另外一个接口。</li>
<li>想使用一个已经存在的类，而其接口不符合要求。</li>
<li>使所有接口不兼容类可以一起工作。</li>
<li>将一个类的接口转换成客户希望的另一个接口。</li>
</ul>
<p>关键词：<u>另一个接口、接口不符合要求、接口兼容、接口转换</u>。</p>
</blockquote>
<p>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<h3 id="桥接模式">桥接模式</h3>
<p>桥接（Bridge）模式将<strong>抽象</strong>部分与其<strong>实现</strong>部分<strong>分离</strong>，使它们都可以<strong>独立地变化</strong>。</p>
<p>桥接模式结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299992836.png"
	width="932"
	height="387"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299992836_hudb1c01aa99ecdd687550b15293eda98a_45309_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299992836_hudb1c01aa99ecdd687550b15293eda98a_45309_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="桥接模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="240"
		data-flex-basis="577px"
	
></p>
<ul>
<li>
<p><code>Abstraction</code>：定义<u>抽象类的接口</u>，维护一个指向<code>Implementor</code>类型对象的指针。</p>
</li>
<li>
<p><code>RefinedAbstraction</code>：扩充由<code>Abstraction</code>定义的接口。</p>
</li>
<li>
<p><code>Implementor</code>：定义<u>实现类的接口</u>，该接口不一定要与<code>Abstraction</code>的接口完全一致；事实上这两个接口可以完全不同。</p>
<p>一般来说，<code>Implementor</code>接口仅提供基本操作，而<code>Abstraction</code>：定义了基于这些基本操作的较高层次的操作。</p>
</li>
<li>
<p><code>ConcreteImplementor</code>：实现<code>Implementor</code>接口并定义它的具体实现。</p>
</li>
</ul>
<p>Bridge模式适用于：</p>
<ul>
<li>
<p><u>不希望在抽象和它的实现部分之间有一个固定的绑定关系。</u></p>
<p>例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</p>
</li>
<li>
<p>类的<u>抽象</u>以及它的<u>实现都</u>应该<u>可以通过生成子类的方法加以扩充</u>。</p>
<p>这是Bridge模式使得开发者<u>可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充</u>。</p>
</li>
<li>
<p>对一个<u>抽象的实现部分的修改</u>应对客户不产生影响，即<u>客户代码不必重新编译</u>。</p>
</li>
<li>
<p>（C++）想对客户完全<u>隐藏抽象的实现部分</u>。</p>
</li>
<li>
<p>有许多类要生成的类层次结构。</p>
</li>
<li>
<p>想在<u>多个对象间共享实现</u>（可能使用引用计数），但同时要求<u>客户并不知道这一点</u>。</p>
</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>类的抽象和其实现之间不希望有一个固定的绑定关系。</li>
<li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。</li>
</ul>
<p>关键词：<u>固定的绑定关系</u>。</p>
</blockquote>
<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联。也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<h3 id="组合合成模式">组合（合成）模式</h3>
<p>组合（Composite，合成）模式将对象<u>组合成树型结构</u>以<u>表示“部分——整体”</u>的层次结构。Composite使得用户<u>对单个对象和组合对象的使用具有一致性</u>。</p>
<p>组合模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682300973563.png"
	width="940"
	height="440"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682300973563_hu29c872695ca6ff6ded5279e7e927bfc7_52033_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682300973563_hu29c872695ca6ff6ded5279e7e927bfc7_52033_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="组合模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="213"
		data-flex-basis="512px"
	
></p>
<ul>
<li>
<p><code>Component</code>：为组合中的对象<u>声明接口</u>。</p>
<ul>
<li>在适当情况下<u>实现所有类共有接口的默认行为</u>；</li>
<li>声明一个接口用于访问和管理<code>Component</code>的子组件；</li>
<li>（可选）<u>在递归结构中定义一个接口，用于访问一个父组件</u>，并在合适的情况下<u>实现</u>它。</li>
</ul>
</li>
<li>
<p><code>Leaf</code>：在组合中表示<u>叶结点对象</u>，叶结点没有子结点；在组合中<u>定义图元对象的行为</u>。</p>
</li>
<li>
<p><code>Composite</code>：</p>
<ul>
<li>定义有子组件的那些组件的行为；</li>
<li>存储子组件；</li>
<li>在<code>Component</code>接口中实现与子组件有关的操作。</li>
</ul>
</li>
<li>
<p><code>Client</code>：通过<code>Component</code>接口操纵组合组件的对象。</p>
</li>
</ul>
<p>Composite模式适用于：</p>
<ul>
<li>想表示对象的<u>部分——整体层次结构</u>。</li>
<li>希望用户<u>忽略组合对象与单个对象的不同</u>，用户将<u>统一地使用组合结构中的所有对象</u>。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<p>表示对象的部分——整体层次结构。</p>
</blockquote>
<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<h3 id="装饰器模式">装饰器模式</h3>
<p>装饰器（Decorator）模式<u>动态</u>地给一个对象<u>添加一些额外的职责</u>。装饰器提供了用子类扩展功能的灵活替代。就增加功能而言，<u>Decorator模式比派生子类更加灵活</u>。</p>
<p>装饰器模式结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302304911.png"
	width="862"
	height="392"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302304911_hu87036585f545fff625bfcce0389726df_55394_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302304911_hu87036585f545fff625bfcce0389726df_55394_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="装饰器模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="219"
		data-flex-basis="527px"
	
></p>
<ul>
<li><code>Component</code>：定义一个<u>对象接口</u>，可以给这些对象<u>动态地添加职责</u>。</li>
<li><code>ConcreteComponent</code>：定义一个对象，可以<u>给这个对象添加一些职责</u>。</li>
<li><code>Decorator</code>：<u>维持一个指向<code>Component</code>对象的指针</u>，并<u>定义一个与<code>Component</code>接口一致的接口</u>。</li>
<li><code>ConcreteDecorator</code>：<u>向组件添加职责。</u></li>
</ul>
<p>Decorator模式适用于：</p>
<ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>处理那些可以撤销的职责。</li>
<li>当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>将一个对象加以包装以提供一些额外的行为。</li>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>动态地给一个对象添加一些额外的职责。</li>
</ul>
<p>关键词：<u>提供、添加、额外行为、指责</u>。</p>
</blockquote>
<h3 id="外观门面模式">外观（门面）模式</h3>
<p>外观（Facade，门面）模式<u>为子系统中的一组接口提供一个一致的门面（界面）</u>，Facade模式<u>定义了</u>一个<u>高层接口</u>，这个接口<u>使得这一子系统更加容易使用</u>。</p>
<p>外观模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302810965.png"
	width="950"
	height="376"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302810965_hu0169411cc8d389f824aec2bd1bd88e86_24708_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302810965_hu0169411cc8d389f824aec2bd1bd88e86_24708_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="外观模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="252"
		data-flex-basis="606px"
	
></p>
<ul>
<li>
<p><code>Facade</code>：知道哪些子系统类负责处理请求；<u>将客户的请求代理给适当的子系统对象</u>。</p>
</li>
<li>
<p><code>Subsystem classes</code>：</p>
<ul>
<li>实现子系统的功能；</li>
<li>处理有<code>Facade</code>对象指派的任务；</li>
<li>没有<code>Facade</code>的任何相关信息，即没有指向<code>Facade</code>的指针。</li>
</ul>
</li>
</ul>
<p>Facade模式适用于：</p>
<ul>
<li>
<p>Facade可以提供一个简单的默认视图，供大多数用户使用。</p>
<p>要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。</p>
<p>Facade提供的简单默认视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。</p>
</li>
<li>
<p><u>客户程序</u>与<u>抽象类的实现</u>部分之间<u>存在着很大的依赖性</u>。<u>引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</u></p>
</li>
<li>
<p>当需要<u>构建一个层次结构的子系统</u>时，使用<u>Facade模式定义子系统中每层的入口点</u>。如果<u>子系统之间是相互依赖的</u>，则可以<u>让它们仅通过Facade进行通信，从而简化了它们之间的依赖关系</u>。</p>
</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>将一系列对象加以包装以简化其接口。</li>
<li>需要为一个复杂子系统提供一个简单接口。</li>
</ul>
<p>关键词：<u>简化接口、复杂子系统</u>。</p>
</blockquote>
<p>外观模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。</p>
<p>外观模式提供一个高层次的接口，使得子系统更易于使用：</p>
<ul>
<li>每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个<u>单例模式</u>。</li>
<li>整个系统可以有多个门面类。</li>
</ul>
<h3 id="享元模式">享元模式</h3>
<p>享元（Flyweight）模式运用共享技术有效地支持大量细粒度的对象。</p>
<p>享元模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682305434953.png"
	width="870"
	height="561"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682305434953_hu5d09b2ef7c809ea7781b9cd3cc8a6bd3_70263_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682305434953_hu5d09b2ef7c809ea7781b9cd3cc8a6bd3_70263_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="享元模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="155"
		data-flex-basis="372px"
	
></p>
<ul>
<li>
<p><code>Flyweight</code>：描述一个接口，通过这个接口<code>Flyweight</code>可以<u>接受并作用于外部状态</u>。</p>
</li>
<li>
<p><code>ConcreteFlyweight</code>：<u>实现<code>Flyweight</code>接口，并为内部状态（如果有）增加存储空间。</u></p>
<p><code>ConcreteFlyweight</code>对象必须是可共享的。它所存储的状态必须是内部的，即它必须独立于<code>ConcreteFlyweight</code>对象的场景。</p>
</li>
<li>
<p>并非所有的<code>Flyweight</code>子类都需要被共享。</p>
<p><code>Flyweight</code>接口使共享成为可能，但它并不强制共享。在<code>Flyweight</code>对象结构的某些层次，<code>UnsharedConcreteFlyweight</code>对象通常将<code>ConcreteFlyweight</code>对象作为子结点。</p>
</li>
<li>
<p><code>FlyweightFactory</code>：<u>创建并管理<code>Flyweight</code>对象</u>；确保合理地共享<code>Flyweight</code>，当用户请求一个<code>Flyweight</code>时，<code>FlyweightFactory</code>对象提供一个已创建的实例或者在不存在时创建一个实例。</p>
</li>
<li>
<p><code>Client</code>：维持一个对<code>Flyweight</code>的引用；计算或存储一个或多个<code>Flyweight</code>的外部状态。</p>
</li>
</ul>
<p>Flyweight模式适用于：</p>
<ul>
<li>一个应用程序<u>使用了大量的对象</u>。</li>
<li>完全由于<u>使用大量的对象，造成很大的存储开销</u>。</li>
<li>对象的<u>大多数状态都可变为外部状态</u>。</li>
<li>如果<u>删除对象的外部状态</u>，那么<u>可以用相对较少的共享对象取代很多组对象</u>。</li>
</ul>
<p>享元模式能做到共享的关键是区分状态：</p>
<ul>
<li>内蕴状态：存储在享元内部，不会随环境的改变而有所不同。</li>
<li>外蕴状态：随环境的改变而改变的。</li>
</ul>
<p>外蕴状态不能影响内蕴状态，它们是相互独立的。</p>
<p>享元模式：将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<h3 id="代理模式">代理模式</h3>
<p>代理（Proxy）模式为其他对象<u>提供一种代理以控制对这个对象的访问</u>。</p>
<p>代理模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682306107287.png"
	width="807"
	height="348"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682306107287_hu0d398b0509b4d48f9b3205627bb8971a_28885_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682306107287_hu0d398b0509b4d48f9b3205627bb8971a_28885_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="代理模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="231"
		data-flex-basis="556px"
	
></p>
<ul>
<li>
<p><code>Proxy</code>：保存一个引用使得<u>代理可以访问实体</u>；提供一个与<code>Subject</code>的接口相同的接口，使<u>代理可以用来代替实体</u>；<u>控制对实体的存取</u>，并可能负责创建和删除它。</p>
<p>其他功能依赖于代理的类型：</p>
<ul>
<li><code>Remote Proxy</code>：负责对请求及其参数进行编码，并向不同地址空间中的实体发送己编码的请求；</li>
<li><code>Virtual Proxy</code>：可以缓存实体的附加信息，以便延迟对它的访问；</li>
<li><code>Protection Proxy</code>：检查调用者是否具有实现一个请求所必需的访问权限。</li>
</ul>
</li>
<li>
<p><code>Subject</code>：定义<code>RealSubject</code>和<code>Proxy</code>的共用接口，这样就在任何使用<code>RealSubject</code>的地方都可以使用<code>Proxy</code>。</p>
</li>
<li>
<p><code>RealSubject</code>：定义<code>Proxy</code>所代表的实体。</p>
</li>
</ul>
<p>Proxy模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见情况有:</p>
<ul>
<li>
<p>远程代理（Remote Proxy）：为一个对象在不同地址空间提供局部代表。</p>
</li>
<li>
<p>虚代理(Virtual Proxy）：根据需要创建开销很大的对象。</p>
</li>
<li>
<p>保护代理（Protection Proxy）：控制对原始对象的访问，用于对象应该有不同的访问权限的时候。</p>
</li>
<li>
<p>智能引用（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作。</p>
<p>典型用途包括：</p>
<ul>
<li>对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放；</li>
<li>当第一次引用一个持久对象时，将它装入内存；</li>
<li>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li>
</ul>
</li>
</ul>
<p>某些情况下，用户不想或者不能够直接引用一个对象，代理对象可以在用户和目标对象直接起到中介的作用。</p>
<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h2 id="行为型设计模式">行为型设计模式</h2>
<p>行为模式涉及<u>算法和对象间职责的分配</u>。行为模式不仅<u>描述对象或类的模式</u>，还<u>描述它们之间的通信模式</u>。</p>
<ul>
<li>
<p>行为类模式：使用<u>继承机制</u>在类间分派行为。</p>
</li>
<li>
<p>行为对象模式：使用<u>对象复合</u>。</p>
<p>一些行为对象模式<u>描述了一组<strong>对等</strong>的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务</u>。</p>
</li>
</ul>
<h3 id="责任链模式">责任链模式</h3>
<p>责任链（Chain of Responsibility）模式<u>使多个对象都有机会处理请求</u>，从而避免请求的发送者和接收者之间的耦合关系。<u>将这些对象连成一条链</u>，并<u>沿着这条链传递该请求，直到有一个对象处理它为止</u>。</p>
<p>责任链模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682307471896.png"
	width="680"
	height="348"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682307471896_huf23cf1c3201c893b8b3f5c2bf75098c6_29363_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682307471896_huf23cf1c3201c893b8b3f5c2bf75098c6_29363_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="责任链模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="195"
		data-flex-basis="468px"
	
></p>
<ul>
<li>
<p><code>Handler</code>：</p>
<ul>
<li>定义一个处理请求的接口；</li>
<li>（可选）实现后继链。</li>
</ul>
</li>
<li>
<p><code>ConcreteHandler</code>：</p>
<ul>
<li>处理它所负责的请求；</li>
<li>可访问它的后继者；</li>
<li>如果可处理该请求，就处理它，否则将该请求转发给后继者。</li>
</ul>
</li>
<li>
<p><code>Client</code>：向链上的具体处理者（<code>ConcreteHandler</code>）对象提交请求。</p>
</li>
</ul>
<p>Chain of Responsibility模式适用于以下条件：</p>
<ul>
<li>有<u>多个的对象可以处理一个请求</u>，哪个对象处理该请求<u>运行时刻自动确定</u>。</li>
<li>想在<u>不明确指定接收者的情况下向多个对象中的一个提交一个请求</u>。</li>
<li>可处理一个请求的对象集合应被<u>动态指定</u>。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>有多个对象可以处理一个请求，在运行时刻自动确定由哪个对象处理。</li>
<li>一个客户需要使用一组相关对象。</li>
<li>想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。</li>
</ul>
<p>关键字：<u>多个对象、一个请求、一组相关对象</u>。</p>
</blockquote>
<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。</p>
<p>处理者有两个选择：承担责任或者把责任推给下家。</p>
<p>一个请求可以最终不被任何接收端对象所接受。</p>
<h3 id="命令模式">命令模式</h3>
<p>命令（Command）模式将<u>一个请求封装为一个对象</u>，从而使得可以<u>用不同的请求对客户进行参数化</u>；对<u>请求排队</u>或<u>记录请求日志</u>，以及<u>支持可撤销的操作</u>。</p>
<p>命令模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311014909.png"
	width="924"
	height="305"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311014909_hu71620aca29416c3ad91bf9fc175e50fb_35195_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311014909_hu71620aca29416c3ad91bf9fc175e50fb_35195_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="命令模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="302"
		data-flex-basis="727px"
	
></p>
<ul>
<li>
<p><code>Command</code>：声明执行操作的接口。</p>
</li>
<li>
<p><code>ConcreteCommand</code>：将<u>一个接收者对象绑定于一个动作；调用接收者相应的操作</u>，以实现<code>Execute</code>。</p>
</li>
<li>
<p><code>Client</code>：创建一个具体命令对象并设定它的接收者。</p>
</li>
<li>
<p><code>Invoker</code>：要求该命令执行这个请求。</p>
</li>
<li>
<p><code>Receiver</code>：知道如何实施与执行一个请求相关的操作。</p>
<p>任何类都可能作为一个接收者。</p>
</li>
</ul>
<p>Command模式适用于：</p>
<ul>
<li>
<p><u>抽象出待执行的动作以参数化某对象。</u></p>
<p>Command模式是过程语言中的<u>回调</u>（Callback）<u>机制</u>的一个面向对象的<u>替代品</u>。</p>
</li>
<li>
<p>在不同的时刻指定、排列和执行请求。</p>
<p>一个Command对象可以有一个与初始请求无关的生存期。</p>
<p>如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程，并在那实现该请求。</p>
</li>
<li>
<p>支持取消操作。</p>
<p>Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。</p>
<p>Command接口必须添加一个Unexecute操作，该操作取消上一次Execute 调用的效果。</p>
<p>执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消和“重做”。</p>
</li>
<li>
<p>支持修改日志。</p>
<p>这样当系统崩溃时，这些修改可以被重做一遍。</p>
<p>在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。</p>
<p>从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。</p>
</li>
<li>
<p>用构建在原语操作上的高层操作构造一个系统。</p>
<p>这样一种结构在支持事务（Transaction）的信息系统中很常见。</p>
<p>Command模式提供了对事务进行建模的方法。Command有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。</p>
</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>抽象出执行的动作以参数化某对象。</li>
<li>将请求封装为对象从而可以使用不同的请求对客户进行参数化。</li>
<li>在不同的时刻指定、排列和执行请求。</li>
</ul>
</blockquote>
<p>命令模式：把一个请求或者操作封装到一个对象中。命令模式把<u>发出命令的责任</u>和<u>执行命令的责任</u>分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方：</p>
<ul>
<li>不必知道接收请求的一方的接口；</li>
<li>不必知道请求是怎么被接收</li>
<li>不必知道请求的操作是否执行，何时被执行以及是怎么被执行的。</li>
</ul>
<h3 id="解释器模式">解释器模式</h3>
<p>解释器（Interpreter）模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<p>解释器模式结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311888750.png"
	width="705"
	height="369"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311888750_hu0fd3a707223ef37ad012b4e875690974_34918_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311888750_hu0fd3a707223ef37ad012b4e875690974_34918_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="解释器模式结构"
	
	
		class="gallery-image" 
		data-flex-grow="191"
		data-flex-basis="458px"
	
></p>
<ul>
<li>
<p><code>AbstractExpression</code>：声明一个<u>程序的解释操作</u>，这个接口为抽象语法树中所有的结点所共享。</p>
</li>
<li>
<p><code>TerminalExpression</code>：<u>实现与文法中的终结符相关联的解释操作</u>；一个句子中的每个终结符需要该类的一个实例。</p>
</li>
<li>
<p><code>NonterminalExpression</code>：对文法中的每一条规则都需要一个<code>NonterminalExpression</code>类。</p>
<ul>
<li>为每个符号都维护一个<code>AbstractExpression</code>类型的实例变量；</li>
<li>为文法中的非终结符实现解释（<code>Interpret</code>）操作。</li>
</ul>
</li>
<li>
<p><code>Context</code>：包含解释器之外的一些<u>全局信息</u>。</p>
</li>
<li>
<p><code>Client</code>：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树，该抽象语法树由<code>NonterminalExpression</code>和<code>TerminalExpression</code>的实例装配而成；调用解释操作。</p>
</li>
</ul>
<p>Interpreter模式适用于当<u>有一个语言需要解释执行</u>，且<u>可将该语言中的句子表示为一个抽象语法树</u>时，以下情况效果最好:</p>
<ul>
<li>
<p>该<u>文法简单</u>。</p>
<p>对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。</p>
<p>即Interpreter模式需要构建抽象语法树，如果文法太复杂，需要构建复杂的语法树，不便于管理。</p>
</li>
<li>
<p><u>效率不是一个关键问题。</u></p>
<p>最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。</p>
</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<p>有一个语言需要<u>解释执行</u>，并且可将句子表示为一个<u>抽象语法树</u>。</p>
</blockquote>
<p>解释器模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<h3 id="迭代器模式">迭代器模式</h3>
<p>迭代器（Iterator）模式提供一种方法<u>顺序访问</u>一个<u>聚合对象中的各个元素</u>，且<u>不需要暴露该对象的内部表示</u>。</p>
<p>多个对象聚在一起形成的总体称之为聚合（聚集），聚合对象是能够包容一组对象的容器对象。</p>
<p>迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>
<p>迭代器模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682312615849.png"
	width="845"
	height="401"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682312615849_hub10e6946683a05bf6194a5483b6bc2bc_43952_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682312615849_hub10e6946683a05bf6194a5483b6bc2bc_43952_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="迭代器模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="210"
		data-flex-basis="505px"
	
></p>
<ul>
<li><code>Iterator</code>（迭代器）：定义访问和遍历元素的接口。</li>
<li><code>ConcreteIterator</code>（具体迭代器）：实现迭代器接口；对该聚合遍历时跟踪当前位置。</li>
<li><code>Aggregate</code>（聚合）：定义创建相应迭代器对象的接口。</li>
<li><code>ConcreteAggregate</code>（具体聚合）：实现创建相应迭代器的接口，该操作返回<code>ConcreteIterator</code>的一个适当的实例。</li>
</ul>
<p>Iterator模式适用于：</p>
<ul>
<li><u>访问</u>一个<u>聚合对象的内容</u>而<u>无须暴露它的内部表示</u>。</li>
<li>支持<u>对聚合对象的多种遍历</u>。</li>
<li>为<u>遍历不同的聚合结构提供一个统一的接口</u>。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<p>访问一个聚合对象的内容而无须暴露它的内部表示。</p>
</blockquote>
<h3 id="中介者调停者模式">中介者（调停者）模式</h3>
<p>中介者模式（Mediator，调停者）用一个<u>中介对象</u>来<u>封装</u>一系列的<u>对象交互</u>。中介者<u>使各对象不需要显式地相互引用</u>，从而使其<u>耦合松散</u>，而且<u>可以独立地改变它们之间的交互</u>。</p>
<p>中介者模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682313139750.png"
	width="855"
	height="236"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682313139750_hue770aa3c8fde88302c9d09952e57e382_24131_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682313139750_hue770aa3c8fde88302c9d09952e57e382_24131_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="中介者模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="362"
		data-flex-basis="869px"
	
></p>
<ul>
<li><code>Mediator</code>（中介者）：定义一个接口用于各同事（<code>Colleague</code>）对象通信。</li>
<li><code>ConcreteMediator</code>（具体中介者）：通过协调各同事对象实现协作行为；了解并维护它的各个同事。</li>
<li><code>Colleague</code>（同事类）：知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信。</li>
</ul>
<p>Mediator模式适用于：</p>
<ul>
<li>一组对象以<u>定义良好但是复杂的方式进行通信</u>，产生的<u>相互依赖关系结构混乱且难以理解</u>。</li>
<li>一个对象<u>引用其他很多对象</u>并且<u>直接与这些对象通信</u>，导致<u>难以复用该对象</u>。</li>
<li>想<u>定制一个分布在多个类中的行为</u>，而又<u>不想生成太多的子类</u>。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li>
<li>一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。</li>
<li>减少多个对象或类之间的通信复杂性。</li>
</ul>
</blockquote>
<p>中介者模式：包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>
<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。中介者模式将多对多的相互作用转化为一对多的相互作用。</p>
<p>中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h3 id="备忘录模式">备忘录模式</h3>
<p>备忘录（Memento）模式在<u>不破坏封装性的前提下，捕获一个对象的内部状态</u>，并在对象之外保存这个状态。这样以后就可以<u>将对象恢复到原先保存的状态</u>。</p>
<p>Memento模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314218216.png"
	width="847"
	height="266"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314218216_hu96fb8022010cf254fe57392ea3f8173e_38752_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314218216_hu96fb8022010cf254fe57392ea3f8173e_38752_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="Memento模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="318"
		data-flex-basis="764px"
	
></p>
<ul>
<li><code>Memento</code>（备忘录）：存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录。</li>
<li><code>Originator</code>（原发器）：创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态。</li>
<li><code>Caretaker</code>（管理者）负责保存好备忘录；不能对备忘录的内容进行操作或检查。</li>
</ul>
<p>Memento模式适用于：</p>
<ul>
<li>必须<u>保存</u>一个<u>对象在某一个时刻的（部分）状态</u>，这样以后需要时它才能<u>恢复到先前的状态</u>。</li>
<li>如果一个用接口来让其他对象直接得到这些状态，将会<u>暴露对象的实现细节并破坏对象的封装性</u>。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>将对象的状态恢复到先前的状态。</li>
<li>在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存。</li>
<li>必须保存一个对象在某一个时刻的（部分）状态。</li>
</ul>
<p>关键词：<u>状态</u>。</p>
</blockquote>
<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h3 id="观察者模式">观察者模式</h3>
<p>观察者（Observer）模式定义对象间的一种<u>一对多的依赖关系</u>，当一个对象的<u>状态发生改变</u>时，所有<u>依赖于它的对象都得到通知并被自动更新</u>。</p>
<p>即，观察者模式让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<p>观察者模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314647475.png"
	width="814"
	height="315"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314647475_hu9d1a28a63559700a0e73d11397468ba2_57129_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314647475_hu9d1a28a63559700a0e73d11397468ba2_57129_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="观察者模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="258"
		data-flex-basis="620px"
	
></p>
<ul>
<li><code>Subject</code>（目标）：提供注册和删除观察者对象的接口；知道它的观察者，可以有任意多个观察者观察同一个目标。</li>
<li><code>Observer</code>（观察者）：为那些在目标发生改变时需获得通知的对象<u>定义</u>一个<u>更新接口</u>。</li>
<li><code>ConcreteSubject</code>（具体目标）：将<u>有关状态存入各<code>ConcreteObserver</code>对象</u>；当它的<u>状态发生改变</u>时，向它的各个观察者<u>发出通知</u>。</li>
<li><code>ConcreteObserver</code>（具体观察者）：维护一个指向<code>ConcreteSubject</code>对象的引用；<u>存储有关状态</u>，这些状态应与目标的状态保持一致；实现<code>Observer</code>的更新接口，以<u>使自身状态与目标的状态保持一致</u>。</li>
</ul>
<p>Observer模式适用于：</p>
<ul>
<li>当一个抽象模型有两个方面，其中<u>一个方面依赖于另一个方面</u>，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
<li>当对<u>一个对象的改变需要同时改变其他对象</u>，而不知道具体有多少对象有待改变时。</li>
<li>当<u>一个对象必须通知其他对象</u>，而它又不能假定其他对象是谁，即<u>不希望这些对象是紧耦合的</u>。</li>
</ul>
<h3 id="状态模式">状态模式</h3>
<p>状态（State）模式允许一个对象在其<u>内部状态改变时改变它的行为</u>。对象看起来似乎修改了它的类。</p>
<p>状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>
<p>状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<p>状态模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682315217521.png"
	width="644"
	height="245"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682315217521_hu4dba732357bdf8362aa7b4938d2e11ca_27336_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682315217521_hu4dba732357bdf8362aa7b4938d2e11ca_27336_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="状态模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="262"
		data-flex-basis="630px"
	
></p>
<ul>
<li><code>Context</code>（上下文）：定义客户感兴趣的接口；维护一个<code>ConcreteState</code>子类的实例，这个实例定义当前状态。</li>
<li><code>State</code>（状态）：定义一个接口以封装与<code>Context</code>的一个特定状态相关的行为。</li>
<li><code>ConcreteState</code>（具体状态子类）：每个子类实现与<code>Context</code>的一个状态相关的行为。</li>
</ul>
<p>State模式适用于：</p>
<ul>
<li>
<p>一个对象的<u>行为决定于它的状态</u>，并且它必须<u>在运行时刻根据状态改变它的行为</u>。</p>
</li>
<li>
<p>一个<u>操作中含有庞大的多分支的条件语句</u>，且<u>这些分支依赖于该对象的状态</u>。</p>
<p>这个状态常用一个或多个<u>枚举常量</u>表示。通常，有多个操作包含这一相同的条件结构。</p>
<p>State模式<u>将每一个条件分支放入一个独立的类中</u>。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。</p>
</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>一个对象的行为决定于其状态且必须在运行时刻根据状态改变行为。</li>
<li>一个对象在其内部状态改变时改变其行为。</li>
</ul>
</blockquote>
<h3 id="策略模式">策略模式</h3>
<p>策略（Strategy）模式<u>定义一系列的算法</u>，把它们一个个封装起来，并且<u>使它们可以相互替换</u>。此模式使得算法可以独立于使用它们的客户而变化。</p>
<p>即，策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>
<ul>
<li>
<p><code>Strategy</code>（策略）：定义所有支持的算法的公共接口。</p>
<p><code>Context</code>使用这个接口来调用某<code>ConcreteStrategy</code>定义的算法。</p>
</li>
<li>
<p><code>ConcreteStrategy</code>（具体策略）：以<code>Strategy</code>接口实现某具体算法。</p>
</li>
<li>
<p><code>Context</code>（上下文）：用一个<code>ConcreteStrategy</code>对象来配置；维护一个对<code>Strategy</code>对象的引用；可定义一个接口来让<code>Strategy</code>访问它的数据。</p>
</li>
</ul>
<p>Strategy模式适用于：</p>
<ul>
<li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li>
<li>需要使用一个算法的不同变体例如,定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使厨策略模式。</li>
<li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
<li>一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>需要使用一个算法地不同变体。</li>
<li>许多相关的类仅仅是行为有异。</li>
<li>在设计某购物中心的收银软件系统时，要求能够支持在不同时期推出打折、返利、满减等不同促销活动。</li>
</ul>
</blockquote>
<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p>
<p>策略模把行为和环境分开：环境类负责维持和查询行为类，各种算法在具体的策略类中提供。</p>
<p>由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<h3 id="模板方法模式">模板方法模式</h3>
<p>模板方法模式（Template Method）定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316789017.png"
	width="610"
	height="352"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316789017_hu736eb87456a6272db6aa15cc311737f4_38587_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316789017_hu736eb87456a6272db6aa15cc311737f4_38587_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="模板方法模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="173"
		data-flex-basis="415px"
	
></p>
<ul>
<li>
<p><code>AbstractClass</code>（抽象类）：</p>
<ul>
<li>定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；</li>
<li>实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在<code>AbstractClass</code>或其他对象中的操作。</li>
</ul>
</li>
<li>
<p><code>ConcreteClass</code>（具体类）：实现原语操作以完成算法中与特定子类相关的步骤。</p>
</li>
</ul>
<p>Template Method模式适用于：</p>
<ul>
<li>
<p><u>一次性实现</u>一个<u>算法的不变的部分</u>，并将<u>可变的行为留给子类来实现</u>。</p>
</li>
<li>
<p>各<u>子类中公共的行为应被提取出来并集中到一个公共父类</u>中，以<u>避免代码重复</u>。</p>
</li>
<li>
<p>控制子类扩展。</p>
<p>模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展），这就只允许在这些点进行扩展。</p>
</li>
</ul>
<p>模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h3 id="访问者模式">访问者模式</h3>
<p>访问者（Visitor）模式表示一个作用于某对象结构中的各元素的操作。它<u>允许在不改变各元素的类的前提下，定义作用于这些元素的新操作</u>。</p>
<p>即，访问者模式的目的是<u>封装一些施加于某种数据结构元素之上的操作</u>。一旦<u>这些操作需要修改</u>的话，<u>接受这个操作的数据结构可以保持不变</u>。</p>
<p>访问者模式的结构：</p>
<p><img src="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316261510.png"
	width="823"
	height="653"
	srcset="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316261510_hu39725207e23c3afa845c404a5c71934c_93016_480x0_resize_box_3.png 480w, /p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316261510_hu39725207e23c3afa845c404a5c71934c_93016_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="访问者模式的结构"
	
	
		class="gallery-image" 
		data-flex-grow="126"
		data-flex-basis="302px"
	
></p>
<ul>
<li>
<p><code>ConcreteVisitor</code>（具体访问者）：实现每个有<code>Visitor</code>声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。</p>
<p><code>ConcreteVisitor</code>为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。</p>
</li>
<li>
<p><code>Element</code>（元素）：定义以一个访问者为参数的<code>Accept</code>操作。</p>
</li>
<li>
<p><code>ConcreteElement</code>（具体元素）：实现以一个访问者为参数的<code>Accept</code>操作。</p>
</li>
<li>
<p><code>ObjectStructure</code>（对象结构）：能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合。</p>
</li>
</ul>
<p>Visitor模式适用于：</p>
<ul>
<li>
<p>一个<u>对象结构包含很多类对象</u>，它们有不同的接口，而用户想对这些对象<u>实施一些依赖于其具体类的操作</u>。</p>
</li>
<li>
<p>需要对一个<u>对象结构中的对象进行很多不同的并且不相关的操作</u>，而又想要<u>避免</u>这些操作<u>“污染”</u>这些对象的类。</p>
<p>Visitor使得用户<u>可以将相关的操作集中起来定义在一个类中</u>。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。</p>
</li>
<li>
<p><u>定义对象结构的类很少改变</u>，但经常需要在此结构上定义新的操作。</p>
<p>改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</p>
</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<p>需要对一个对象结构中的对象进行很多不同的并且不相关的操作。</p>
</blockquote>
<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
<h2 id="设计模式总结">设计模式总结</h2>
<p>创建型设计模式（抽象了对象的实例化过程）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>工厂方法</strong></td>
<td style="text-align:center">动态生产对象</td>
<td style="text-align:left">定义创建对象的接口，由子类实例化对象。</td>
</tr>
<tr>
<td style="text-align:center"><strong>抽象工厂模式</strong></td>
<td style="text-align:center">生成系列对象</td>
<td style="text-align:left">提供创建一系列对象的接口，无需指定具体的类。</td>
</tr>
<tr>
<td style="text-align:center"><strong>生成器模式</strong></td>
<td style="text-align:center">构造复杂对象</td>
<td style="text-align:left">将复杂类的构建与表示分离。<br>同样的构建可以创建不同的表示。</td>
</tr>
<tr>
<td style="text-align:center"><strong>原型模式</strong></td>
<td style="text-align:center">克隆对象</td>
<td style="text-align:left">用原型实例指定创建对象的类型，通过复制原型来创建对象。</td>
</tr>
<tr>
<td style="text-align:center"><strong>单例模式</strong></td>
<td style="text-align:center">一个实例</td>
<td style="text-align:left">保证一个类仅有一个实例，并提供一个全局访问点。</td>
</tr>
</tbody>
</table></div>
<p>结构型模式（组合类或对象获得新的结构）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>适配器模式</strong></td>
<td style="text-align:center">接口转换</td>
<td style="text-align:left">将类的接口转换成兼容其他类的接口。</td>
</tr>
<tr>
<td style="text-align:center"><strong>桥接模式</strong></td>
<td style="text-align:center">抽象与实现分离</td>
<td style="text-align:left">将类的抽象与实现分离，使它们可以独立变化。</td>
</tr>
<tr>
<td style="text-align:center"><strong>组合模式</strong></td>
<td style="text-align:center">组合对象</td>
<td style="text-align:left">将对象组合成树型结构以表示“部分——整体”的层次结构。<br>使得用户对单个对象和组合对象的使用具有一致性。</td>
</tr>
<tr>
<td style="text-align:center"><strong>装饰模式</strong></td>
<td style="text-align:center">动态附加职责</td>
<td style="text-align:left">动态地给一个对象添加一些额外的职责，比用子类来扩展功能更灵活。</td>
</tr>
<tr>
<td style="text-align:center"><strong>外观模式</strong></td>
<td style="text-align:center">对外统一接口</td>
<td style="text-align:left">为子系统定义和提供一个统一的对外高层接口（外观）。<br>简化了该子系统的使用。</td>
</tr>
<tr>
<td style="text-align:center"><strong>享元模式</strong></td>
<td style="text-align:center">共享大量细粒度对象</td>
<td style="text-align:left">提供支持大量细粒度对象共享的有效方法。</td>
</tr>
<tr>
<td style="text-align:center"><strong>代理模式</strong></td>
<td style="text-align:center">中介代理</td>
<td style="text-align:left">为其他对象提供一种代理以控制对这个对象的访问。</td>
</tr>
</tbody>
</table></div>
<p>行为型模式：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>责任链模式</strong></td>
<td style="text-align:center">职责传递</td>
<td style="text-align:left">将处理请求的多个对象连成一条链，请求在链中传递，直到有对象处理。<br>给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。</td>
</tr>
<tr>
<td style="text-align:center"><strong>命令模式</strong></td>
<td style="text-align:center">请求封装为对象</td>
<td style="text-align:left">将一个请求封装为一个对象，可用不同请求对客户进行参数化。<br>将请求排队或记录日志，支持撤销操作。</td>
</tr>
<tr>
<td style="text-align:center"><strong>解释器模式</strong></td>
<td style="text-align:center">语句解释</td>
<td style="text-align:left">给定一种语言，定义其文法和解释器，解释器根据文法解释语言中的句子。</td>
</tr>
<tr>
<td style="text-align:center"><strong>迭代器模式</strong></td>
<td style="text-align:center">顺序访问数据集</td>
<td style="text-align:left">提供一个顺序访问聚合对象中元素的方法，不需要暴露对象的内部表示。</td>
</tr>
<tr>
<td style="text-align:center"><strong>中介者模式</strong></td>
<td style="text-align:center">不直接引用</td>
<td style="text-align:left">用中介对象封装一系列的对象交互。<br>使各对象不需显式地相互调用，达到低耦合。<br>可以独立改变对象间的交互。</td>
</tr>
<tr>
<td style="text-align:center"><strong>备忘录模式</strong></td>
<td style="text-align:center">保存状态</td>
<td style="text-align:left">不破坏封装的前提下，捕获对象的内部状态，并在该对象之外保存。<br>可以在以后恢复保存的状态。</td>
</tr>
<tr>
<td style="text-align:center"><strong>观察者模式</strong></td>
<td style="text-align:center">联动</td>
<td style="text-align:left">定义对象间的一种一对多依赖关系。<br>一个对象状态改变，所有依赖于它的对象都得到通知并被自动更新。</td>
</tr>
<tr>
<td style="text-align:center"><strong>状态模式</strong></td>
<td style="text-align:center">状态封装成类</td>
<td style="text-align:left">把对象的行为封装在不同的状态对象中。<br>允许一个对象在其内部状态改变时改变它的行为。</td>
</tr>
<tr>
<td style="text-align:center"><strong>策略模式</strong></td>
<td style="text-align:center">多方案切换</td>
<td style="text-align:left">定义并封装一系列算法，使它们可以在不影响客户端的情况下相互替换。</td>
</tr>
<tr>
<td style="text-align:center"><strong>模板方法模式</strong></td>
<td style="text-align:center">框架</td>
<td style="text-align:left">定义一个操作中的算法骨架，让其子类来实现算法中的剩余逻辑。<br>可以不改变算法结构而重新定义其某些特定步骤。</td>
</tr>
<tr>
<td style="text-align:center"><strong>访问者模式</strong></td>
<td style="text-align:center">数据与操作分离</td>
<td style="text-align:left">封装作用与某对象结构中元素的操作。<br>可以在不改变元素类的前提下，定义或修改作用于这些元素的操作。</td>
</tr>
</tbody>
</table></div>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E8%BD%AF%E8%80%83/">软考</a>
        
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a>
        
    </section>


    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
       
</article>


    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB/">
        
        

        软考图类汇总</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/">
        
        

        算法设计与分析（软件工程师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        计算机网络（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        软件工程（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        结构化开发（软件设计师）</a>
</div>
</section>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 Linner&#39;s Blog

        <span style="padding-left: 5px;padding-right: 5px;">|</span>

        <a href="https://beian.miit.gov.cn/" target="_blank" >粤ICP备2022125602号-1</a>
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
