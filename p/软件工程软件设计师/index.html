<!DOCTYPE html>
<html lang="zh" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='概述 软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。
软件工程学：
 软件开发技术  软件开发方法学 软件工具 软件工程环境   软件工程管理  软件工程管理学 软件经济学    软件工程涉及软件开发、维护、管理等多方面的原理、方法、工具与环境。
计算机软件 计算机软件是指：
  计算机系统中的程序：计算任务的处理对象和处理规则的描述。
  计算任务：任何以计算机为处理工具的任务。
  处理对象：
 数据：如数字、文字、图形、图像、声音等，它们只是表示，而无含义。 信息：数据及有关的含义。    处理规则：一般指处理的动作和步骤。
    程序文档：文档是为了便于了解程序所需的阐述性资料。
  按照软件的应用领域，可以将计算机软件分为十大类：
 系统软件 应用软件 工程/科学软件 嵌入式软件 产品线软件 Web应用 人工智能软件 开放计算 网络资源 开源软件  软件生存周期  可行性分析与项目开发计划 需求分析 概要设计 详细设计 编码 测试 维护   软件过程模型 软件开发中所遵循的路线图（一系列可预测的步骤）称为“软件过程”。过程是活动的集合，活动是任务的集合。'>


<title>软件工程（软件设计师）</title>

<link rel='canonical' href='https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/'>

<link rel="stylesheet" href="/scss/style.min.7a68e2beb371039eca9f5e8f87aa11bdb1fdc96a55744700a091f658cd1e66a7.css">
<link rel="stylesheet" href="/css/katex.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<meta property='og:title' content='软件工程（软件设计师）'>
<meta property='og:description' content='概述 软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。
软件工程学：
 软件开发技术  软件开发方法学 软件工具 软件工程环境   软件工程管理  软件工程管理学 软件经济学    软件工程涉及软件开发、维护、管理等多方面的原理、方法、工具与环境。
计算机软件 计算机软件是指：
  计算机系统中的程序：计算任务的处理对象和处理规则的描述。
  计算任务：任何以计算机为处理工具的任务。
  处理对象：
 数据：如数字、文字、图形、图像、声音等，它们只是表示，而无含义。 信息：数据及有关的含义。    处理规则：一般指处理的动作和步骤。
    程序文档：文档是为了便于了解程序所需的阐述性资料。
  按照软件的应用领域，可以将计算机软件分为十大类：
 系统软件 应用软件 工程/科学软件 嵌入式软件 产品线软件 Web应用 人工智能软件 开放计算 网络资源 开源软件  软件生存周期  可行性分析与项目开发计划 需求分析 概要设计 详细设计 编码 测试 维护   软件过程模型 软件开发中所遵循的路线图（一系列可预测的步骤）称为“软件过程”。过程是活动的集合，活动是任务的集合。'>
<meta property='og:url' content='https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/'>
<meta property='og:site_name' content='Linner&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='软考' /><meta property='article:tag' content='软件设计师' /><meta property='article:tag' content='软件工程' /><meta property='article:published_time' content='2023-05-08T10:02:34&#43;00:00'/><meta property='article:modified_time' content='2023-05-08T10:02:34&#43;00:00'/>
<meta name="twitter:title" content="软件工程（软件设计师）">
<meta name="twitter:description" content="概述 软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。
软件工程学：
 软件开发技术  软件开发方法学 软件工具 软件工程环境   软件工程管理  软件工程管理学 软件经济学    软件工程涉及软件开发、维护、管理等多方面的原理、方法、工具与环境。
计算机软件 计算机软件是指：
  计算机系统中的程序：计算任务的处理对象和处理规则的描述。
  计算任务：任何以计算机为处理工具的任务。
  处理对象：
 数据：如数字、文字、图形、图像、声音等，它们只是表示，而无含义。 信息：数据及有关的含义。    处理规则：一般指处理的动作和步骤。
    程序文档：文档是为了便于了解程序所需的阐述性资料。
  按照软件的应用领域，可以将计算机软件分为十大类：
 系统软件 应用软件 工程/科学软件 嵌入式软件 产品线软件 Web应用 人工智能软件 开放计算 网络资源 开源软件  软件生存周期  可行性分析与项目开发计划 需求分析 概要设计 详细设计 编码 测试 维护   软件过程模型 软件开发中所遵循的路线图（一系列可预测的步骤）称为“软件过程”。过程是活动的集合，活动是任务的集合。">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />

<style>
    u {
        text-decoration-line: none;
        border-bottom: 1.5px solid;
        padding-bottom: 1.5px;
    }
    li {
        margin: 1em 0;
    }
</style>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "auto");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu0c2331fe09320137a3bd1d4b5cc68791_142496_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Linner&#39;s Blog</a></h1>
            <h2 class="site-description">随便看看就行，副标题暂时还没想好</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/Linna-cy'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>

                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives" id="toc-list">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents"></nav>
            
        </div>
    </section>


            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/" >
                软件设计师
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件工程（软件设计师）</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">May 08, 2023</time>
                |
            </div>
        

        

        <div class="article-time--reading">共1754字</div>
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="概述">概述</h1>
<p>软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。</p>
<p>软件工程学：</p>
<ul>
<li>软件开发技术
<ul>
<li>软件开发方法学</li>
<li>软件工具</li>
<li>软件工程环境</li>
</ul>
</li>
<li>软件工程管理
<ul>
<li>软件工程管理学</li>
<li>软件经济学</li>
</ul>
</li>
</ul>
<p>软件工程涉及软件开发、维护、管理等多方面的原理、方法、工具与环境。</p>
<h2 id="计算机软件">计算机软件</h2>
<p>计算机软件是指：</p>
<ul>
<li>
<p>计算机系统中的程序：计算任务的处理对象和处理规则的描述。</p>
<ul>
<li>
<p>计算任务：任何以计算机为处理工具的任务。</p>
</li>
<li>
<p>处理对象：</p>
<ul>
<li>数据：如数字、文字、图形、图像、声音等，它们只是表示，而无含义。</li>
<li>信息：数据及有关的含义。</li>
</ul>
</li>
<li>
<p>处理规则：一般指处理的动作和步骤。</p>
</li>
</ul>
</li>
<li>
<p>程序文档：文档是为了便于了解程序所需的阐述性资料。</p>
</li>
</ul>
<p>按照软件的应用领域，可以将计算机软件分为十大类：</p>
<ul>
<li>系统软件</li>
<li>应用软件</li>
<li>工程/科学软件</li>
<li>嵌入式软件</li>
<li>产品线软件</li>
<li>Web应用</li>
<li>人工智能软件</li>
<li>开放计算</li>
<li>网络资源</li>
<li>开源软件</li>
</ul>
<h2 id="软件生存周期">软件生存周期</h2>
<ol>
<li>可行性分析与项目开发计划</li>
<li>需求分析</li>
<li>概要设计</li>
<li>详细设计</li>
<li>编码</li>
<li>测试</li>
<li>维护</li>
</ol>
<hr>
<h1 id="软件过程模型">软件过程模型</h1>
<p>软件开发中所遵循的路线图（一系列可预测的步骤）称为“软件过程”。过程是活动的集合，活动是任务的集合。</p>
<p>软件过程有3层含义：</p>
<ul>
<li>个体含义</li>
<li>整体含义</li>
<li>工程含义</li>
</ul>
<h2 id="能力成熟度模型">能力成熟度模型</h2>
<p>软件过程能力成熟度模型（Capability Maturity Model of Software，CMM）是对软件组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力经过这些阶段逐步提高。</p>
<p>能力成熟度模型使软件组织能够较容易地确定其当前过程的成熟度并识别其软件过程执行中的薄弱环节，确定对软件质量和过程改进最为关键的几个问题，从而形成对其过程的改进策略。</p>
<p>CMM将软件过程改进分为以下5个成熟度级别：</p>
<ol>
<li>
<p><strong>初始级</strong>（Initial）：</p>
<p>软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤。</p>
</li>
<li>
<p><strong>可重复级</strong>（Repeatable）：</p>
<p>建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性；建立了有必要的过程准则来重复以前在同类项目中的成功。</p>
</li>
<li>
<p><strong>已定义级</strong>（Defined）：</p>
<p>管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</p>
</li>
<li>
<p><strong>己管理级</strong>（Managed）：</p>
<p>制定了软件过程和产品质量的详细度量标准。软件过程和产品质量都被开发组织的成员所理解和控制。</p>
</li>
<li>
<p><strong>优化级</strong>（Optimized）：</p>
<p>加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</p>
</li>
</ol>
<h2 id="能力成熟度模型集成">能力成熟度模型集成</h2>
<p>能力成熟度模型集成（CMMI）是若干过程模型的综合和改进，是支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率</p>
<p>CMMI提供了两种表示方法：</p>
<ul>
<li>
<p><strong>阶段式模型</strong>：</p>
<p>结构类以于CMM，它<u>关注组织的成熟度</u>。</p>
<p>CMMI-SE/SW/IPPD 1.1版中有5个成熟度等级：</p>
<ol>
<li><strong>初始的</strong>：过程不可预测且缺乏控制。</li>
<li><strong>己管理的</strong>：过程为项目服务。</li>
<li><strong>已定义的</strong>：过程为组织服务。</li>
<li><strong>定量管理的</strong>：过程已度量和控制。</li>
<li><strong>优化的</strong>：集中于过程改进。</li>
</ol>
</li>
<li>
<p><strong>连续式模型</strong>：</p>
<p>关注每个<u>过程域的能力</u>，一个组织对不同的过程域可以达到不同的过程域<strong>能力等级</strong>（Capability Level，<strong>CL</strong>）。</p>
<p>能力等级包括：</p>
<ul>
<li>共性目标</li>
<li>共性实践</li>
</ul>
<p>能力等级可以独立地应用于任何单独的过程域，任何一个能力等级都必须满足比它等级低的能力等级的所有准则。</p>
<p>CMMI中包括6个过程域能力等级（0~5）：</p>
  <ol start="0">
  <li>
      $CL_0$（未完成的）：
      <br>
      过程域<u>未执行</u>或<u>未得到$CL_1$中定义的所有目标</u>。
  </li>
  <li>
      $CL_1$（已执行的）：
      <br>
      其共性目标是<u>过程将可标识的输入工作产品转换成可标识的输出工作产品</u>，以<u>实现支持过程域的特定目标</u>。
      <br>
      关注于<u>过程域的特定目标的完成</u>。
  </li>
  <li>
      $CL_2$（已管理的）：
      <br>
      其共性目标集中于<u>已管理的过程的制度化</u>。
      <br>
      关注于<u>针对单个过程实例的能力</u>。
  </li>
  <li>
      $CL_3$（已定义级的）：
      <br>
      其共性目标集中于<u>已定义的过程的制度化</u>。
      <br>
      关注于<u>过程的组织级标准化和部署</u>。
  </li>
  <li>
      $CL_4$（定量管理的）：
      <br>
      其共性目标集中于<u>可定量管理的过程的制度化</u>。
      <br>
      使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。
  </li>
  <li>
      $CL_5$（优化的）：
      <br>
      使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。
      <br>
      其共性目标集中于<u>优化的过程的制度化</u>，表明<u>过程得到很好地执行</u>且<u>持续得到改进</u>。
  </li>
  </ol>
</li>
</ul>
<h2 id="瀑布模型">瀑布模型</h2>
<p>瀑布模型（Waterfall Model）是<u>将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型</u>（它规定了<u>由前至后、相互衔接的固定次序，如同瀑布流水逐级下落</u>），包括：</p>
<ul>
<li><strong>需求分析</strong>：</li>
<li><strong>设计</strong></li>
<li><strong>编码</strong></li>
<li><strong>测试</strong></li>
<li><strong>运行与维护</strong>（运维）</li>
</ul>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683592633324.png"
	width="380"
	height="289"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683592633324_hu10aad72076ed5213bbae0299f40787a3_17688_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683592633324_hu10aad72076ed5213bbae0299f40787a3_17688_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="瀑布模型"
	
	
		class="gallery-image" 
		data-flex-grow="131"
		data-flex-basis="315px"
	
></p>
<p>瀑布模型假设：<u>一个待开发的系统需求是完整的、简明的、一致的</u>，而且<u>可以先于设计和实现完成之前产生</u>。</p>
<p>瀑布模型的一个变体是<strong>V模型</strong>。V模型<u>描述了质量保证活动和沟通、建模相关活动以及早期构建相关的活动之间的关系</u>：</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683593148604.png"
	width="492"
	height="423"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683593148604_hu8d0af94f252673c89f90c5f2916cf2f6_46173_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683593148604_hu8d0af94f252673c89f90c5f2916cf2f6_46173_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="V模型"
	
	
		class="gallery-image" 
		data-flex-grow="116"
		data-flex-basis="279px"
	
></p>
<ul>
<li>
<p>设计、开发：随着软件团队工作沿着<u>V模型左侧步骤向下推进</u>，<u>基本问题需求逐步细化</u>，形成问题及解决方案的技术描述。</p>
</li>
<li>
<p>测试：一旦编码结束，团队沿着<u>V模型右侧的步骤向上推进</u>。</p>
<p>其实际上是<u>执行了一系列测试</u>（质量保证活动），这些测试<u>验证了团队沿着V模型左侧步骤向下推进过程中所生成的每个模型</u>。</p>
</li>
</ul>
<p>V模型提供了一种将验证确认活动应用于早期软件工程工作中的方法。</p>
<p>瀑布模型：</p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>容易理解，管理成本低；</li>
<li>强调开发的阶段性早期计划及需求调查和产品测试。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>客户必须能够完整、正确和清晰地表达他们的需要；</li>
<li>在开始的两个或3个阶段中，很难评估真正的进度状态；</li>
<li>当接近项目结束时，出现了大量的集成和测试工作；</li>
<li>直到项目结束之前，都不能演示系统的能力；</li>
<li>需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。</li>
</ul>
</li>
</ul>
<p>瀑布模式适合用于：</p>
<ul>
<li><u>开发需求明确</u>的，<u>需求大致固定且不会随意变更</u>的系统；</li>
<li>开发人员对软件的应用领域很熟悉；</li>
<li>开发工作对用户参与的要求很低。</li>
</ul>
<h2 id="增量模型">增量模型</h2>
<p>增量模型（Incremental Model）融合了<u>瀑布模型的基本成分</u>和<u>原型实现的迭代特征</u>。</p>
<p>增量模型<u>假设可以将需求分段为一系列增量产品，每一增量可以分别开发</u>。该模型采用<u>随着日程时间的进展而交错的线性序列</u>，每一个线性序列产生软件的一个可发布的“增量”：</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683593818710.png"
	width="747"
	height="325"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683593818710_hudfc99a041ac3ab639e6b9eda80f6b6b9_59071_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683593818710_hudfc99a041ac3ab639e6b9eda80f6b6b9_59071_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="增量模型"
	
	
		class="gallery-image" 
		data-flex-grow="229"
		data-flex-basis="551px"
	
></p>
<ul>
<li>从分析到测试为一个增量的过程（线性序列）。</li>
<li>第1个增量往往是核心的产品。</li>
<li>客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。</li>
<li>增量模型强调<u>每一个增量均发布一个可操作的产品</u>。</li>
</ul>
<p>增量模型作为<u>瀑布模型的一个变体</u>，具有瀑布模型的所有优点。此外，它还有以下优点：</p>
<ul>
<li><u>第一个可交付版本所需要的成本和时间很少</u>；</li>
<li><u>开发由增量表示的小系统所承担的风险不大</u>；</li>
<li>由于很快发布了第一个版本，因此<u>可以减少用户需求的变更</u>；</li>
<li>优先级高的功能先交付，使得重要的功能经历更多的测试。</li>
<li>运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果没有对用户的变更要求进行规划，那么<u>产生的初始增量可能会造成后来增量的不稳定</u>；</li>
<li>如果需求不像早期思考的那样稳定和完整，那么<u>一些增量就可能需要重新开发、重新发布</u>；</li>
<li><u>管理发生的成本、进度和配置的复杂性可能会超出组织的能力</u>。</li>
</ul>
<p>量模型适合用于：</p>
<ul>
<li>需要快速构造可运行的产品的项目（对完成期限严格要求的产品）；</li>
<li>进行已有产品升级或新版本开发；</li>
<li>对所开发的领域比较熟悉而且已有原型系统。</li>
</ul>
<h2 id="演化模型">演化模型</h2>
<p>演化模型（Evolutionary Model）演化模型是<u>迭代的过程模型</u>，使得软件开发人员能够<u>逐步开发出更完整的软件版本</u>。演化模型特别<u>适用于对软件需求缺乏准确认识的情况</u>。</p>
<p>典型的演化模型有原型模型和螺旋模型等。</p>
<h3 id="原型模型">原型模型</h3>
<p><u>并非所有的需求都能够预先定义</u>。大量的实践表明，在<u>开发初期很难得到一个完整的、准确的需求规格说明</u>。原因有：</p>
<ul>
<li><u>客户往往不能准确地表达对未来系统的全面要求</u>，导致形成的需求规格说明不完整、不准确，甚至是有歧义。</li>
<li>在整个开发过程中，<u>用户可能会产生新的要求，导致需求的变更</u>。</li>
</ul>
<p>瀑布模型难以适应这种需求的不确定性和变化，于是出现了快速原型（Rapid Prototype）这种新的开发方法。</p>
<p>原型模型（Prototype Model）：</p>
<ul>
<li>适合于<u>用户需求不清</u>、<u>需求经常变化</u>的情况；</li>
<li><u>不适合大规模系统的开发</u>。</li>
</ul>
<p>原型的目的是能<u>快速、低成本地构建原型系统</u>。</p>
<p>能够采用原型方法是因为开发工具的快速发展，使得能够迅速地开发出一个让用户看得见、摸得着的系统框架。这样，对于计算机不是很熟悉的用户就可以根据这个框架提出自己的需求。</p>
<p>开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型:</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683596611929.png"
	width="398"
	height="318"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683596611929_huf32b7c912e3ca230941152f200b2d348_39995_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683596611929_huf32b7c912e3ca230941152f200b2d348_39995_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="原型模型"
	
	
		class="gallery-image" 
		data-flex-grow="125"
		data-flex-basis="300px"
	
></p>
<ol>
<li>交流：目的是定义软件的总体目标，标识需求，然后</li>
<li>快速计划：快速制订原型开发的计划，确定原型的目标和范围。</li>
<li>采用快速设计方式进行建模。</li>
<li>构建原型。</li>
<li>部署交付和反馈：被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见可在下一轮中对原型进行改进。</li>
<li>下一轮迭代：在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发。</li>
</ol>
<p>根据使用原型的目的不同，原型可以分为：</p>
<ul>
<li>探索型原型：目的是要弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性。</li>
<li>实验型原型：目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。</li>
<li>演化型原型：目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。</li>
</ul>
<h3 id="螺旋模型">螺旋模型</h3>
<p>对于复杂的大型软件，开发一个原型往往达不到要求。</p>
<p>螺旋模型<u>将瀑布模型和演化模型结合起来</u>，<u>加入了两种模型均忽略的风险分析</u>（以风险为驱动），弥补了这两种模型的不足。</p>
<p>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合：</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683597373666.png"
	width="559"
	height="482"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683597373666_huf1bec98ef9b3abd276da6fc698ab12a6_107839_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683597373666_huf1bec98ef9b3abd276da6fc698ab12a6_107839_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="螺旋模型"
	
	
		class="gallery-image" 
		data-flex-grow="115"
		data-flex-basis="278px"
	
></p>
<p>每个螺旋周期分为如下4个工作步骤：</p>
<ol>
<li><strong>制订计划</strong>：
<ol>
<li>确定软件的目标</li>
<li>选定实施方案</li>
<li>明确项目开发的限制条件</li>
</ol>
</li>
<li><strong>风险分析</strong>：
<ol>
<li>分析所选的方案</li>
<li>识别风险</li>
<li>消除风险</li>
</ol>
</li>
<li><strong>实施工程</strong>：
<ol>
<li>实施软件开发</li>
<li>验证阶段性产品</li>
</ol>
</li>
<li><strong>用户评估</strong>：
<ol>
<li>评价开发工作，提出修正建议</li>
<li>建立下一个周期的开发计划</li>
</ol>
</li>
</ol>
<p>螺旋模型适用于：</p>
<ul>
<li><u>庞大、复杂并且具有高风险的系统</u>；</li>
<li>新近开发，需求不明的情况。</li>
</ul>
<p>优点：</p>
<ul>
<li>螺旋模型<u>强调风险分析</u>，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。</li>
<li>螺旋模型<u>支持用户需求的动态变化</u>，有助于提高软件的适应能力，降低了软件开发的风险。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要开发人员具有相当丰富的风险评估经验和专门知识。</li>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ul>
<h2 id="喷泉模型">喷泉模型</h2>
<p>喷泉模型（Water Fountain Model）：</p>
<ul>
<li>以用户需求为动力；</li>
<li>以对象作为驱动；</li>
<li><u>适合于面向对象。</u></li>
</ul>
<p>喷泉模型<u>克服了瀑布模型不支持软件重用和多项开发活动集成的局限性</u>。其开发过程如下：</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683598210327.png"
	width="247"
	height="361"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683598210327_hu1a269d21ed951b906d4bd7f5636da6a5_34545_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683598210327_hu1a269d21ed951b906d4bd7f5636da6a5_34545_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="喷泉模型"
	
	
		class="gallery-image" 
		data-flex-grow="68"
		data-flex-basis="164px"
	
></p>
<p>喷泉模型使开发过程具有以下性质或特点：</p>
<ul>
<li>
<p><strong>迭代性</strong>：意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统。</p>
</li>
<li>
<p><strong>无间隙性</strong>：指在开发活动（如分析、设计、编码）之间不存在明显的边界。</p>
<p>喷泉不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动，而是<u>允许各开发活动交叉、迭代地进行</u>。</p>
<p>喷泉模型的<u>各个阶段没有明显的界线</u>，开发人员<u>可以同步进行</u>。</p>
</li>
<li>
<p>支持软件重用。</p>
</li>
</ul>
<p>优点：可以提高软件项目的开发效率，节省开发时间。</p>
<p>缺点：</p>
<ul>
<li>由于喷泉模型在各个开发阶段是重叠的，在开发过程中<u>需要大量的开发人员，不利于项目的管理</u>。</li>
<li>喷泉模型<u>要求严格管理文档，使得审核的难度加大</u>。</li>
</ul>
<h2 id="统一过程模型">统一过程模型</h2>
<p>统一过程（UP）模型开发过程的特征：</p>
<ul>
<li>
<p>用例和风险驱动。</p>
</li>
<li>
<p>以架构为中心。</p>
</li>
<li>
<p>迭代并且增量：</p>
<p>迭代：将整个软件开发项目划分为许多个小的“袖珍项目”。</p>
<p>每个“袖珍项目”都包含正常软件项目的所有元素：</p>
<ul>
<li>计划</li>
<li>分析和设计</li>
<li>构造</li>
<li>集成和测试</li>
<li>内部和外部发布</li>
</ul>
</li>
</ul>
<p>统一过程模型由UML（统一建模语言，Unified Modeling Language）方法和工具支持。</p>
<p>统一过程定义了4个技术阶段及其制品，这4个技术阶段由主要里程碑所终止：</p>
<ol>
<li>
<p><strong>起始阶段</strong>（Inception Phase）：</p>
<p>确定项目的风险及其优先次序，并对精化阶段进行详细规划和对整个项目进行粗略计算。</p>
<p>专注于：项目的初创活动。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>构想文档（Vision Document）</li>
<li>初始用例模型</li>
<li>初始项目术语表</li>
<li>初始业务用例</li>
<li>初始风险评估</li>
<li>项目计划（阶段及迭代）业务模型</li>
<li>一个或多个原型（需要时）</li>
</ul>
<p>里程碑：生命周期目标。</p>
</li>
<li>
<p><strong>精化阶段</strong>（Elaboration Phase）：</p>
<p>根据主要的用例描述设计出详细的系统构架。主要是解决用例、构架和计划是否足够稳定可靠，风险释放得到充分控制，以便能够按照合同的规定完成整个开发任务。</p>
<p>精华阶段在理解了最初的领域范围之后进行：</p>
<ul>
<li>需求分析</li>
<li>架构演进</li>
</ul>
<p>关注于：需求分析和架构演进。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>
<p>用例模型</p>
</li>
<li>
<p>补充需求：包括非功能需求</p>
</li>
<li>
<p>分析模型</p>
</li>
<li>
<p>软件体系结构描述</p>
</li>
<li>
<p>可执行的软件体系结构原型</p>
</li>
<li>
<p>初步的设计模型</p>
</li>
<li>
<p>修订的风险列表</p>
</li>
<li>
<p>项目计划：</p>
<p>包括：</p>
<ul>
<li>迭代计划</li>
<li>调整的工作流</li>
<li>里程碑</li>
<li>技术工作产品</li>
</ul>
</li>
<li>
<p>初始用户手册</p>
</li>
</ul>
<p>里程碑：生命周期目标。</p>
</li>
<li>
<p><strong>构建阶段</strong>（Construction Phase）：</p>
<p>将设计实现，并进行测试。</p>
<p>关注系统的构建，产生实现模型。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>设计模型</li>
<li>软件构件</li>
<li>集成的软件增量</li>
<li>测试计划及步骤</li>
<li>测试用例</li>
<li>支持文档：
<ul>
<li>用户手册</li>
<li>安装手册</li>
<li>对于并发增量的描述</li>
</ul>
</li>
</ul>
<p>里程碑：初始运作功能。即一个准备交到最终用户手中的产品。</p>
</li>
<li>
<p><strong>移交阶段</strong>（Transition Phase）：</p>
<p>交由用户测试并迭代完善。</p>
<p>关注于软件提交方面的工作，产生软件增量。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>提交的软件增量</li>
<li>$\beta$测试报告</li>
<li>综合用户反馈</li>
</ul>
<p>里程碑：产品发布。</p>
<blockquote>
<p>其实还有一个产生阶段，这里包含在了移交阶段中。</p>
</blockquote>
</li>
</ol>
<p>在每次迭代中有5个核心工作流：</p>
<ul>
<li>需求工作流：捕获系统应该做什么；</li>
<li>分析工作流：精华和结构化需求；</li>
<li>设计工作流：在系统架构内实现需求；</li>
<li>实现工作流：构造软件；</li>
<li>测试工作流：验证实现是否如期望那样工作。</li>
</ul>
<blockquote>
<p>统一过程的典型代表是RUP（Rational Unified Process）。</p>
<p>RUP是UP的商业扩展，完全兼容UP，但比UP更完整、更详细。</p>
</blockquote>
<h2 id="敏捷开发">敏捷开发</h2>
<p>敏捷开发（Agile Development）的总体目标是通过<u>“尽可能早地、持续地对有价值的软件的交付”</u>使客户满意。通过在软件开发过程中加入灵活性，敏捷方法<u>使用户能够在开发周期的后期增加或改变需求</u>。</p>
<p>敏捷过程的典型方法有很多，每一种方法基于一套原则，这些原则实现了<u>敏捷方法所宣称的理念（敏捷宣言）</u>。</p>
<p>敏捷开发有以下几种方法：</p>
<ul>
<li>极限编程（XP）</li>
<li>水晶法（Crystal）</li>
<li>并列争求法（Scrum）</li>
<li>自适应软件开发（ASD）</li>
<li>敏捷统一过程（AUP）</li>
</ul>
<h3 id="极限编程">极限编程</h3>
<p>极限编程是为了<u>降低需求变更所带来的成本</u>，旨在<u>提高软件质量和对客户需求变化的适应性</u>，期望能够让软件开发达到低成本、低缺陷、高产出、高回报（最小投入得到最大结果）的效果。</p>
<p>极限编程（XP）软件开发方式有以下性质：</p>
<ul>
<li>轻量级（敏捷）</li>
<li>高效</li>
<li>低风险</li>
<li>柔性</li>
<li>可预测的</li>
<li>科学的</li>
</ul>
<p>XP由价值观、原则、实践和行为4个部分组成，他们之间彼此相互依赖、关联，并通过行为贯穿于整个生存周期：</p>
<ul>
<li>4大价值观：
<ul>
<li>沟通</li>
<li>简单性</li>
<li>反馈</li>
<li>勇气</li>
</ul>
</li>
<li>5个原则：
<ul>
<li>快速反馈</li>
<li>简单性假设</li>
<li>逐步修改</li>
<li>提倡更改</li>
<li>优质工作</li>
</ul>
</li>
<li>12个最佳实践：
<ul>
<li>计划游戏：快速制定计划、随着细节的不断变化而完善</li>
<li>小型发布：系统的设计要能够尽可能早地交付</li>
<li>隐喻：找到合适的比喻传达信息</li>
<li>简单设计：只处理当前的需求，使设计保持简单</li>
<li>测试先行：先写测试代码，然后再编写程序</li>
<li>重构：重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求</li>
<li>结对编程</li>
<li>集体代码所有制</li>
<li>持续集成：可以按日甚至按小时为客户提供可运行的版本</li>
<li>每周工作40个小时</li>
<li>现场客户</li>
<li>编码标准</li>
</ul>
</li>
</ul>
<h3 id="敏捷统一过程">敏捷统一过程</h3>
<p>敏捷统一过程（Agile Unified Process，AUP）采用以下原理来构建软件系统：</p>
<ul>
<li>“在大型上连续”</li>
<li>“在小型上迭代”。</li>
</ul>
<p>采用经典的UP阶段性活动（初始、精化、构建和转换），提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。</p>
<p>在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。每个AUP迭代执行以下活动：</p>
<ul>
<li><strong>建模</strong>：建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进。</li>
<li><strong>实现</strong>：将模型翻译成源代码。</li>
<li><strong>测试</strong>：像XP一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求。</li>
<li><strong>部署</strong>：对软件增量的交付以及获取最终用户的反馈。</li>
<li><strong>配置及项目管理</strong>：着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。</li>
<li><strong>环境管理</strong>：协调标准、工具以及适用于开发团队的支持技术等过程基础设施。</li>
</ul>
<h3 id="其他敏捷开发方法">其他敏捷开发方法</h3>
<p><strong>水晶法</strong>：</p>
<ul>
<li>
<p>认为每一个不同的项目都需要一套不同的策略、约定和方法论。</p>
</li>
<li>
<p>认为人对软件质量有重要的影响。</p>
<p>随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。</p>
</li>
<li>
<p>通过更好地交流和经常性的交付，软件生产力得到提高。</p>
</li>
</ul>
<p><strong>并列争求法</strong>：</p>
<p>使用迭代的方法。</p>
<ul>
<li>把每30天一次的迭代称为一个“冲刺”。</li>
<li>按需求的优先级别来实现产品。</li>
<li>多个自组织和自治的小组并行地递增实现产品。</li>
<li>协调是通过简短的日常情况会议来进行，就像橄榄球中的“并列争球”。</li>
</ul>
<p><strong>自适应软件开发</strong>：</p>
<p>有6个基本原则：</p>
<ul>
<li>有一个使命作为指导；</li>
<li>特征被视为客户价值的关键点；</li>
<li>过程中的等待是很重要的，因此“重做”与“做”同样关键；</li>
<li>变化不被视为改正，而是被视为对软件开发实际情况的调整；</li>
<li>确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求；</li>
<li>风险也包含其中。</li>
</ul>
<h2 id="总结">总结</h2>
<p>能力成熟度模型（从1开始）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">级别</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始级</td>
<td style="text-align:left">杂乱无章，几乎没有明确定义的步骤。</td>
</tr>
<tr>
<td style="text-align:center">可重复级</td>
<td style="text-align:left">建立基本的项目管理过程和实践来跟踪项目费用、进度和功能特性。</td>
</tr>
<tr>
<td style="text-align:center">已定义级</td>
<td style="text-align:left">将管理和工程文档化、标准化并综合成标准软件过程；<br>使用标准开发过程（或方法论）构建（或集成）系统。</td>
</tr>
<tr>
<td style="text-align:center">己管理级</td>
<td style="text-align:left">对软件过程和产品质量制定了的详细度量标准，且有定量的理解和控制。</td>
</tr>
<tr>
<td style="text-align:center">优化级</td>
<td style="text-align:left">加强了定量分析，通过过程质量和新观念、新技术使过程不断地改进。</td>
</tr>
</tbody>
</table></div>
<p>能力成熟度集成连续式模型（从0开始）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">能力等级</th>
<th style="text-align:left">目标</th>
<th style="text-align:left">关注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未完成的</td>
<td style="text-align:left">未执行或未得到等级1中的所有目标。</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">已执行的</td>
<td style="text-align:left">可标识的输入工作产品到输出工作产品的转换，实现特定目标。</td>
<td style="text-align:left">特定目标的完成</td>
</tr>
<tr>
<td style="text-align:center">已管理的</td>
<td style="text-align:left">已管理的过程的制度化。</td>
<td style="text-align:left">针对单个过程实例的能力</td>
</tr>
<tr>
<td style="text-align:center">已定义级的</td>
<td style="text-align:left">已定义的过程的制度化。</td>
<td style="text-align:left">过程的组织级标准化和部署</td>
</tr>
<tr>
<td style="text-align:center">定量管理的</td>
<td style="text-align:left">可定量管理的过程的制度化。<br>说明：使用测量和质量保证来控制和改进。</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">优化的</td>
<td style="text-align:left">优化的过程的制度化。<br>说明：使用量化手段改变和优化。</td>
<td></td>
</tr>
</tbody>
</table></div>
<p>各模型的适用范围：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模型</th>
<th style="text-align:left">适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瀑布模型</td>
<td style="text-align:left">需求明确、大致固定且变更少</td>
</tr>
<tr>
<td style="text-align:center">增量模型</td>
<td style="text-align:left">快速构造可运行的产品，产品升级，领域熟悉或已有原型</td>
</tr>
<tr>
<td style="text-align:center">演化模型</td>
<td style="text-align:left">需求无法被完整定义，功能在使用过程中不断完善</td>
</tr>
<tr>
<td style="text-align:center">原型模型</td>
<td style="text-align:left">快速、低成本构架原型，需求不清或多变、领域陌生；不适合大规模系统</td>
</tr>
<tr>
<td style="text-align:center">螺旋模型</td>
<td style="text-align:left">庞大、复杂、高风险的系统，开发人员有丰富的风险评估经验和知识</td>
</tr>
<tr>
<td style="text-align:center">喷泉模型</td>
<td style="text-align:left">面向对象的开发过程</td>
</tr>
</tbody>
</table></div>
<p>统一过程模型阶段里程碑和关注点总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">里程碑</th>
<th style="text-align:left">关注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始阶段</td>
<td style="text-align:left">生命周期目标</td>
<td style="text-align:left">项目的初创活动</td>
</tr>
<tr>
<td style="text-align:center">精化阶段</td>
<td style="text-align:left">生命周期架构</td>
<td style="text-align:left">需求分析和架构演进</td>
</tr>
<tr>
<td style="text-align:center">构建阶段</td>
<td style="text-align:left">初始运作功能</td>
<td style="text-align:left">系统的构建</td>
</tr>
<tr>
<td style="text-align:center">移交阶段</td>
<td style="text-align:left">产品发布</td>
<td style="text-align:left">软件提交方面的工作</td>
</tr>
</tbody>
</table></div>
<hr>
<h1 id="需求分析">需求分析</h1>
<h2 id="软件需求">软件需求</h2>
<p>需求分析主要的目的是弄清楚系统需要“做什么”，并将其阐述出来。</p>
<p>软件需求是指<u>用户对目标软件系统在功能、行为、性能、设计约束等方面的期望</u>。通常，这些需求包括：</p>
<ul>
<li>
<p><strong>功能需求</strong>：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</p>
</li>
<li>
<p><strong>性能需求</strong>：考虑软件开发的技术性指标。</p>
<p>例如：</p>
<ul>
<li>存储容量限制；</li>
<li>执行速度；</li>
<li>响应时间；</li>
<li>吞吐量。</li>
</ul>
</li>
<li>
<p><strong>用户或人的因素</strong>：考虑用户的类型。</p>
<p>例如：</p>
<ul>
<li>各种用户对使用计算机的熟练程度，需要接受的训练；</li>
<li>用户理解、使用系统的难度；</li>
<li>用户错误操作系统的可能性。</li>
</ul>
</li>
<li>
<p><strong>环境需求</strong>：考虑未来软件应用的环境，包括硬件和软件。</p>
<ul>
<li>对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等；</li>
<li>对软件的需求包括：操作系统、网络、数据库等。</li>
</ul>
</li>
<li>
<p><strong>界面需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>来自其他系统的输入；</li>
<li>到其他系统的输出；</li>
<li>对数据格式的特殊规定；</li>
<li>对数据存储介质的规定。</li>
</ul>
</li>
<li>
<p><strong>文档需求</strong>：考虑需要哪些文档，文档针对哪些读者。</p>
</li>
<li>
<p><strong>数据需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>输入、输出数据的格式；</li>
<li>接收、发送数据的频率；</li>
<li>数据的准确性和精度；</li>
<li>数据流量；</li>
<li>数据需保持的时间。</li>
</ul>
</li>
<li>
<p><strong>资源使用需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>软件运行时所需要的数据、其他软件、内存空间等资源；</li>
<li>软件开发、维护时，所需的人力、支撑软件、开发设备。</li>
</ul>
</li>
<li>
<p><strong>安全保密要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>是否需要对访问系统或系统信息加以控制；</li>
<li>隔离用户数据的方法；</li>
<li>用户程序如何与其他程序和操作系统隔离</li>
<li>系统备份要求。</li>
</ul>
</li>
<li>
<p><strong>可靠性要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>系统的可靠性要求；</li>
<li>系统是否必须检测和隔离错误；</li>
<li>出错后，重启系统允许的时间。</li>
</ul>
</li>
<li>
<p><strong>软件成本消耗与开发进度需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>开发是否有规定的时间表；</li>
<li>软/硬件投资有无限制。</li>
</ul>
</li>
<li>
<p><strong>其他非功能性要求</strong>：</p>
<p>如采用某种开发模式，需要确定：</p>
<ul>
<li>质量控制标准；</li>
<li>里程碑和评审；</li>
<li>验收标准；</li>
<li>各种质量要求的优先级；</li>
<li>可维护性方面的要求。</li>
</ul>
</li>
</ul>
<p>软件需求的出处：</p>
<ul>
<li>可以来自于用户（实际的和潜在的）、用户的规约、应用领域的专家、相关的技术标准和法规；</li>
<li>可以来自于原有的系统、原有系统的用户、新系统的潜在用户；</li>
<li>可以来自于竞争对手的产品。</li>
</ul>
<h2 id="需求工程">需求工程</h2>
<p>需求工程可以细分为6个阶段：</p>
<ol>
<li>需求获取</li>
<li>需求分析与协商</li>
<li>系统建模</li>
<li>需求规约</li>
<li>需求验证</li>
<li>需求管理</li>
</ol>
<hr>
<h1 id="系统设计">系统设计</h1>
<p>进入设计阶段，需要把软件系统“做什么”的逻辑模型转换成“怎么做”的物理模型。即着手实现软件系统需求。</p>
<p>系统设计的主要目的就是为系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，最终勾画出新系统的详细设计方案。</p>
<p>系统设计的主要内容包括：</p>
<ul>
<li>新系统总体结构设计</li>
<li>代码设计</li>
<li>输出、输入设计</li>
<li>处理过程设计</li>
<li>数据存储设计</li>
<li>用户界面设计</li>
<li>安全控制设计</li>
</ul>
<p>常用的设计方法有以下两种：</p>
<ul>
<li>面向数据流的结构化设计方法（SD）。</li>
<li>面向对象的分析方法（OOD）。</li>
</ul>
<p>系统设计的基本任务大体上可以分为两个步骤：</p>
<ol>
<li>概要设计</li>
<li>详细设计</li>
</ol>
<h2 id="概要设计">概要设计</h2>
<ol>
<li>
<p><strong>设计软件系统总体结构</strong>（<strong>总体结构设计</strong>）：</p>
<p>其基本任务是：</p>
<ul>
<li>采用某种设计方法，将一个复杂的系统按功能划分成模块；</li>
<li>确定每个模块的功能；</li>
<li>确定模块之间的调用关系；</li>
<li>确定模块之间的接口，即模块之间传递的信息；</li>
<li>评价模块结构的质量。</li>
</ul>
<p>软件系统总体结构的设计是概要设计关键的一步，直接影响到下一个阶段详细设计与编码的工作。</p>
<p>软件系统的质量及一些整体特性都在软件系统总体结构的设计中决定。</p>
</li>
<li>
<p><strong>数据结构及数据库设计</strong>：</p>
<ol>
<li>
<p><strong>数据结构设计</strong>：逐步细化的方法也适用于数据结构的设计。</p>
<p>在需求分析阶段，己经通过数据字典对数据的组成、操作约束和数据之间的关系等方面进行了描述，确定了数据的结构特性。在概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。在概要设计阶段，宜使用抽象的数据类型。</p>
</li>
<li>
<p><strong>数据库设计</strong>：</p>
<p>数据库的设计是指数据存储文件的设计，主要进行以下几方面设计：</p>
<ol>
<li>
<p>概念设计：在数据分析的基础上，采用自底向上的方法从用户角度进行视图设计，一般用E-R模型来表述数据模型。</p>
<p>E-R模型既是设计数据库的基础，也是设计数据结构的基础。</p>
</li>
<li>
<p>逻辑设计：E-R模型是独立于数据库管理系统（DBMS）的，要结合具体的DBMS特征来建立数据库的逻辑结构。</p>
</li>
<li>
<p>物理设计：对于不同的DBMS，物理环境不同，提供的存储结构与存取方法各不相同。</p>
<p>物理设计就是设计数据模式的一些物理细节，如数据项存储要求、存取方法和索引的建立等。</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>编写概要设计文档</strong>：</p>
<p>文档主要有：</p>
<ul>
<li>概要设计说明书</li>
<li>数据库设计说明书</li>
<li>用户手册</li>
<li>修订测试计划</li>
</ul>
</li>
<li>
<p><strong>评审</strong>：</p>
<p>对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方法的可行性，关键的处理及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审。</p>
</li>
</ol>
<h2 id="详细设计">详细设计</h2>
<ol>
<li>
<p><strong>算法设计</strong>：<u>对每个模块进行详细的算法设计</u>，用某种图形、表格和语言等工具<u>将每个模块处理过程的详细算法描述出来</u>。</p>
</li>
<li>
<p><strong>数据结构设计</strong>：对模块内的数据结构进行设计。</p>
</li>
<li>
<p><strong>数据库设计</strong>：对数据库进行物理设计，即确定数据库的物理结构。</p>
</li>
<li>
<p>其他设计：</p>
<p>根据软件系统的类型，还可能要进行以下设计：</p>
<ul>
<li><strong>代码设计</strong>：为了提高数据的输入、分类、存储和检索等操作，节约内存空间，对数据库中某些数据项的值要进行代码设计。</li>
<li><strong>输入/输出格式设计</strong>。</li>
<li><strong>用户界面设计</strong>。</li>
</ul>
</li>
<li>
<p>编写<u>详细设计说明书</u>。</p>
</li>
<li>
<p><strong>评审</strong>：<u>对处理过程的算法和数据库的物理结构都要评审。</u></p>
</li>
</ol>
<p>系统设计的结果是一系列的系统设计文件，这些文件是物理实现一个信息系统（包括硬件设备和编制软件程序）的重要基础。</p>
<hr>
<h1 id="系统测试">系统测试</h1>
<p>系统测试是<u>为了发现错误而执行程序的过程</u>。</p>
<ul>
<li>成功的测试：发现了至今尚未发现的错误的测试。</li>
<li>测试的目的：希望能以最少的人力和时间发现潜在的各种错误和缺陷。</li>
</ul>
<p>信息系统测试应包括：</p>
<ul>
<li>软件测试</li>
<li>硬件测试</li>
<li>网络测试</li>
</ul>
<p>系统测试是保证系统质量和可靠性的关键步骤，是对系统开发过程的最后复查。</p>
<p>根据测试的概念和目的，在进行信息系统测试时应遵循以下基本原则：</p>
<ol>
<li>
<p>应尽早并不断地进行测试。测试应贯穿在开发的各个阶段，应尽早纠正错误，消除隐患。</p>
</li>
<li>
<p>测试工作应该避免由原开发软件的人或小组承担。</p>
<ul>
<li>开发人员往往不愿否认自己的工作，总认为自己开发的软件没有错误；</li>
<li>开发人员的错误很难由本人测试出来，很容易根据自己编程的思路来制定测试思路，具有局限性。</li>
</ul>
</li>
<li>
<p>在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。将实际输出结果与预期结果相比较就能发现测试对象是否正确。</p>
</li>
<li>
<p>在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。</p>
</li>
<li>
<p>在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。</p>
</li>
<li>
<p>严格按照测试计划来进行，避免测试的随意性。</p>
<p>测试计划应包括：</p>
<ul>
<li>测试内容</li>
<li>进度安排</li>
<li>人员安排</li>
<li>测试环境</li>
<li>测试工具</li>
<li>测试资料</li>
</ul>
</li>
<li>
<p>妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便。</p>
</li>
<li>
<p>测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便。</p>
</li>
</ol>
<p>系统测试阶段的<u>测试目标来自于需求分析阶段</u>。</p>
<p>测试过程：</p>
<ol>
<li>制定测试计划</li>
<li>编制测试大纲</li>
<li>根据测试大纲设计和生成测试用例</li>
<li>实施测试</li>
<li>生成测试报告</li>
</ol>
<h2 id="单元测试">单元测试</h2>
<p><strong>单元测试</strong>也称为<strong>模块测试</strong>，<u>在模块编写完成且无编译错误后就可以进行</u>。单元测试<u>侧重于模块中的内部处理逻辑和数据结构</u>。如果选用<u>机器测试</u>，一般用<u>白盒测试法</u>。这类测试<u>可以对多个模块同时进行</u>。</p>
<p>单元测试主要检查模块的以下5个特征：</p>
<ul>
<li>
<p>模块接口：模块的接口保证了测试模块的数据流可以正确地流入、流出。</p>
<p>在测试中应检查以下要点：</p>
<ul>
<li>测试模块的<u>输入参数</u>和<u>形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用其他模块时，所给出的<u>实际参数</u>和<u>被调用模块的形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用标准函数时，所用的<u>参数在属性、数目和顺序上是否正确</u>。</li>
<li><u>全局变量在各模块中的定义和用法是否一致。</u></li>
<li><u>输入是否仅改变了形式参数。</u></li>
<li><u>开/关的语句</u>是否正确。</li>
<li>规定的<u>I/O格式</u>是否与输入/输出语句一致。</li>
<li>在使用文件之前是否已经打开文件或使用文件之后是否己经关闭文件。</li>
</ul>
</li>
<li>
<p>局部数据结构</p>
</li>
<li>
<p>重要的执行路径</p>
</li>
<li>
<p>出错处理</p>
</li>
<li>
<p>边界条件</p>
</li>
</ul>
<p>模块间存在调用与被调关系，对每个模块进行测试时，需要开发两种模块：</p>
<ul>
<li>
<p>驱动模块：接收测试例子的数据，将这些数据送到测试模块，输出结果。</p>
<p>即模拟被测试模块的上一级模块，相当于被测模块的主程序。</p>
</li>
<li>
<p>桩模块（存根模块）：代替测试模块中所调用的子模块，其内部可进行少量的数据处理。目的是为了检验入口、输出调用和返回的信息。</p>
<p>即模拟被测模块的子模块（所调用的模块），但不是软件产品的组成部分。</p>
</li>
</ul>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683613415307.png"
	width="360"
	height="344"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683613415307_hu4c5b3d41c7734b9a664e78a78f6ec812_28357_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683613415307_hu4c5b3d41c7734b9a664e78a78f6ec812_28357_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="单元测试环境"
	
	
		class="gallery-image" 
		data-flex-grow="104"
		data-flex-basis="251px"
	
></p>
<p>提高模块的内聚度可以简化单元测试。</p>
<h2 id="集成测试">集成测试</h2>
<p>集成测试就是<u>把模块按系统设计说明书的要求组合起来进行测试</u>。即使所有的模块都通过了测试，在集成之后，仍然可能出现问题：</p>
<ul>
<li>穿过模块的数据丢失；</li>
<li>一个模块的功能对其他模块造成有害的影响；</li>
<li>各个模块集成起来没有达到预期的功能；</li>
<li>全局数据结构出现问题；</li>
<li>单个模块的误差可以接受，但模块组合后，可能会出现误差累积，最后累积到不能接受的程度。</li>
</ul>
<p>集成测试是进行一些旨在<u>发现与接口相关的错误</u>的测试，其目标是<u>利用已通过单元测试的构件建立设计中描述的程序结构</u>。</p>
<p>通常，集成测试有两种方法：</p>
<ul>
<li>
<p><strong>非增量集成</strong>：分别测试各个模块，再把这些模块组合起来进行整体测试。</p>
<ul>
<li>优点：可以对模块进行并行测试，能充分利用人力，并加快工程进度。</li>
<li>缺点：容易混乱，出现错误不容易查找和定位。</li>
</ul>
</li>
<li>
<p><strong>增量集成</strong>：以小增量的方式逐步进行构造和测试。</p>
<p>增量式测试的范围一步步扩大，错误容易定位，更易于对接口进行彻底测试，并且可以运用系统化的测试方法。</p>
</li>
</ul>
<p>增量集成策略有：</p>
<ul>
<li>
<p><strong>自项向下集成测试</strong>：一种构造软件体系结构的增量方法。</p>
<p>模块的集成顺序为从主控模块（主程序）开始，沿着控制层次逐步向下，以深度优先或广度优先的方式将从属于（或间接从属于）主控模块的模块集成到结构中。</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683617607121.png"
	width="500"
	height="393"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683617607121_hu713a5d010320841559d8f2583f0abebb_19456_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683617607121_hu713a5d010320841559d8f2583f0abebb_19456_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="自顶向下集成"
	
	
		class="gallery-image" 
		data-flex-grow="127"
		data-flex-basis="305px"
	
></p>
<p><strong>深度优先集成</strong>是<u>首先集成位于程序结构中主控路径上的所有构件</u>，也可以根据特定应用系统的特征进行选择。</p>
<p>例如上图中，选择最左边的路径：</p>
<ol>
<li>首先，集成构建$M_1$、$M_2$和$M_5$；</li>
<li>其次，集成$M_8$或$M_6$（若$M_2$的正常运行是必须的）；</li>
<li>然后，集成中间和右边控制路径上的构建。</li>
</ol>
<p>广度优先集成<u>首先沿着水平方向，将属于同一层的构建集成起来</u>。</p>
<p>例如上图中：</p>
<ol>
<li>首先，将构建$M_2$、$M_3$和$M_4$集成起来；</li>
<li>其次是$M_5$、$M_6$、$M_7$，依次类推。</li>
</ol>
<p>集成过程可以通过下列5个步骤完成：</p>
<ol>
<li><u>主控模块用作测试驱动模块</u>，用这些从属于主控模块的所有模块代替桩模块。</li>
<li>依靠所选择的集成方法（即深度优先或广度优先），每次用实际模块替换一个从属桩模块。</li>
<li>在集成每个模块后都进行测试。</li>
<li>在完成每个测试集之后，用实际模块替换另一个桩模块。</li>
<li>可以执行回归测试，以确保没有引入新的错误。</li>
</ol>
<p>回到第2步继续执行此过程，直到完成了整个程序结构的构造。</p>
<blockquote>
<p><u>自顶向下集成不需要驱动模块。</u></p>
</blockquote>
</li>
<li>
<p><strong>自底向上集成测试</strong>：自底向上集成测试就是从原子模块（程序结构的最底层构件）开始进行构造和测试。</p>
<p>由于构件是自底向上集成的，在处理时所需要的从属于给定层次的模块总是存在的，因此，没有必要使用桩模块。自底向上集成策略可以利用以下步骤来实现：</p>
<ol>
<li>连接低层构件以构成完成特定子功能的簇。</li>
<li>编写驱动模块（测试的控制程序）以协调测试用例的输入和输出。</li>
<li>测试簇。</li>
<li>去掉驱动程序，沿着程序结构向上逐步连接簇。</li>
</ol>
<blockquote>
<p>簇：一系列相关低层构建的集合。</p>
<p><u>自底向上集成不需要桩模块。</u></p>
</blockquote>
<p>例如：</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683619189037.png"
	width="762"
	height="534"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683619189037_hu05113d41e3a4f82669c36fba382f49e9_36425_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683619189037_hu05113d41e3a4f82669c36fba382f49e9_36425_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="自底向上"
	
	
		class="gallery-image" 
		data-flex-grow="142"
		data-flex-basis="342px"
	
></p>
<ol>
<li>连接相应的构建形成簇1、簇2和簇3；</li>
<li>编写驱动模块（图中虚线上方连接的框，即$D_1$、$D_2$和$D_3$）</li>
<li>利用驱动模块对每个簇进行测试。</li>
<li>簇1和簇2中的构建从属于模块$M_a$，去掉驱动模块$D_1$和$D_2$，将这两个簇直接与$M_a$相连；簇3去掉驱动模块$D_3$，然后与$M_b$相连。</li>
<li>最后将$M_a$和$M_b$与构建$M_c$连接在一起。</li>
</ol>
</li>
<li>
<p><strong>回归测试</strong>：重新执行己测试过的某些子集，以确保变更没有传播不期望的副作用。</p>
<p>每当加入一个新模块作为集成测试的一部分时，软件发生变更，建立了新的数据流路径，可能出现新的/O,以及调用新的控制逻辑。这些变更可能会使原来可以正常工作的功能产生问题。</p>
<p>回归测试有助于保证变更不引入无意识行为或额外的错误。回归测试的方法有：</p>
<ul>
<li>手工执行，重新执行所有测试用例的子集</li>
<li>利用捕捉/回放工具自动执行</li>
</ul>
<p>回归测试要执行的测试子集包含以下3种测试用例：</p>
<ul>
<li><u>能够测试软件所有功能</u>的具有代表性的<u>测试样本</u>。</li>
<li>额外测试，侧重于<u>可能会受变更影响的软件功能</u>。</li>
<li>侧重于<u>已发生变更的软件构件测试</u>。</li>
</ul>
<p>随着集成测试的进行，<u>回归测试的数量可能变得相当庞大</u>，因此，应将回归测试用例设计成<u>只包括每个主要程序功能的一个或多个错误类的测试</u>。</p>
</li>
<li>
<p><strong>冒烟测试</strong>：一种常用的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估。</p>
<p>冒烟测试方法包括下列活动：</p>
<ol>
<li>
<p>将已经转换为代码的软件构件集成到构建中。</p>
<p>一个构建包括所有的：</p>
<ul>
<li>数据文件</li>
<li>库</li>
<li>可复用的模块</li>
<li>实现一个或多个产品功能所需的工程化构件</li>
</ul>
</li>
<li>
<p>设计一系列测试以<u>暴露影响构建正确地完成它的功能的错误</u>，其<u>目的是为了发现极有可能造成项目延迟的业务阻塞错误</u>。</p>
</li>
<li>
<p>每天将该构建与其他构建及整个软件产品（以其当前形势）集成起来进行冒烟测试。</p>
<p>这种集成方法可以自顶向下，也可以自底向上。</p>
</li>
</ol>
</li>
</ul>
<h2 id="测试方法">测试方法</h2>
<p>测试方法分为：</p>
<ul>
<li>
<p><strong>静态测试</strong>：</p>
<p>指被测试程序不在机器上运行，而是采用以下手段对程序进行检测：</p>
<ul>
<li>
<p><strong>人工检测</strong>：不依靠计算机而是依靠人工审查程序或评审软件。</p>
<p>人工检测包括：</p>
<ul>
<li>代码检查</li>
<li>静态结构分析</li>
<li>代码质量度量</li>
</ul>
</li>
<li>
<p><strong>计算机辅助静态分析</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>动态测试</strong>：指通过运行程序发现错误。</p>
<p>在对软件产品进行动态测试时可以采用以下两种测试方法：</p>
<ul>
<li><strong>黑盒测试法</strong></li>
<li><strong>白盒测试法</strong></li>
</ul>
<p>测试用例由以下组成：</p>
<ul>
<li>测试输入数据</li>
<li>预期输出结果：与测试输入数据对应的预期输出结果</li>
</ul>
<p>在设计测试用例时，应当包括：</p>
<ul>
<li>合理的输入条件</li>
<li>不合理的输入条件</li>
</ul>
</li>
</ul>
<h3 id="黑盒测试">黑盒测试</h3>
<p><strong>黑盒测试</strong>也称为<strong>功能测试</strong>，在<u>完全不考虑软件的内部结构和特性</u>的情况下，测试软件的外部特性。</p>
<p>进行黑盒测试主要是为了发现以下几类错误：</p>
<ol>
<li>是否有错误的功能或遗漏的功能？</li>
<li>界面是否有误？输入是否正确接收？输出是否正确？</li>
<li>是否有数据结构或外部数据库访问错误？</li>
<li>性能是否能多接受？</li>
<li>是否有初始化或终止性错误？</li>
</ol>
<p>常用的黑盒测试技术有：</p>
<ul>
<li>
<p><strong>等价类划分</strong>：将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例。</p>
<p>每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以<u>用少量代表性的测试用例取得较好的测试效果</u>。</p>
<p>等价类划分有两种不同的情况：</p>
<ul>
<li>有效等价类</li>
<li>无效等价类</li>
</ul>
<p>在设计测试用例时，要同时考虑这两种等价类。</p>
<p>定义等价类的原则如下。</p>
<ol>
<li>在<u>输入条件规定了取值范围或值的个数</u>的情况下，<u>可以定义1个有效等价类和2个无效等价类</u>。</li>
<li>在<u>输入条件规定了输入值的集合或规定了“必须如何”</u>的条件的情况下，<u>可以定义1个有效等价类和一个无效等价类</u>。</li>
<li>在输入条件是一个<u>布尔量</u>的情况下，<u>可以定义一个有效等价类和一个无效等价类</u>。</li>
<li>在<u>规定了输入数据的一组值（假定$n$个）</u>，并且程序要<u>对每一个输入值分别处理</u>的情况下，<u>可以定义$n$个有效等价类和1个无效等价类</u>。</li>
<li>在<u>规定了输入数据必须遵守的规则</u>的情况下，<u>可以定义一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</u>。</li>
<li>在确知己划分的等价类中，各元素在程序处理中的方式不同的情况下，则应将该等价类进一步划分为更小的等价类。</li>
</ol>
<p>例如，输入$x$的取值范围是$0 \sim 10$，输入$y$的取值范围是$-10 \sim -1$，那么可以定义三个等价类：</p>
<ul>
<li>有效等价类1：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类2：$x$的取值范围是$x &lt; 0 \ \ OR \ \ x &gt; 10$，输入$y$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类3：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$x &lt; -10 \ \ OR \ \ x &gt; -1$。</li>
</ul>
<p>无效等价类的划分：每个无效等价类的测试用例，只违反一个输入的取值范围。如果违反了多个输入的取值范围，那便是不好的测试用例。</p>
</li>
<li>
<p><strong>边界值分析</strong>：输入的<u>边界比中间更加容易发生错误</u>，因此用边界值分析来<u>补充等价类划分的测试用例设计技术</u>。</p>
<p>边界值划分<u>选择等价类边界的测试用例</u>，既<u>注重于输入条件边界</u>，又<u>适用于输出域测试用例</u>。</p>
<p>对边界值设计测试用例应遵循的原则如下：</p>
<ol>
<li>如果<u>输入条件规定了值的范围</u>，则应取<u>刚达到这个范围的边界的值</u>，以及<u>刚刚超越这个范围边界的值</u>作为测试输入数据。</li>
<li>如果<u>输入条件规定了值的个数</u>，则用<u>最大个数、最小个数、比最小个数少1、比最大个数多1的数据</u>作为测试数据。</li>
<li>根据规格说明的每个输出条件使用上述两条原则。</li>
<li>如果程序的规格说明给出的<u>输入域或输出域是有序集合</u>，则应选取<u>集合的第一个元素和最后一个元素</u>作为测试用例。</li>
<li>如果程序中使用了一个<u>内部数据结构</u>，则应当选择这个<u>内部数据结构边界上的值</u>作为测试用例。</li>
<li>分析规格说明，找出其他可能的边界条件。</li>
</ol>
</li>
<li>
<p><strong>错误推测</strong></p>
</li>
<li>
<p><strong>因果图</strong></p>
</li>
</ul>
<h3 id="白盒测试">白盒测试</h3>
<p><strong>白盒测试</strong>也称为<strong>结构测试</strong>，<u>根据程序的内部结构和逻辑来设计测试用例</u>，对程序的路径和过程进行测试，检查是否满足设计的需要。</p>
<p>白盒测试常用的技术有：</p>
<ul>
<li>
<p><strong>逻辑覆盖</strong>：考察用测试数据运行被测程序时，对程序逻辑的覆盖程度。</p>
<p>主要的逻辑覆盖标准有6种，它们的覆盖程度从低到高为：</p>
<ol>
<li>
<p><strong>语句覆盖</strong>：指选择足够的测试数据，使<u>被测试程序中的每条语句至少执行一次</u>。</p>
<p>语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。</p>
</li>
<li>
<p><strong>判定覆盖</strong>（分支覆盖）：指设计足够的测试用例，使得<u>被测程序中的每个判定表达式至少获得一次“真”/“假”值</u>。</p>
<p>判定覆盖的判定表达式是指判定表达式整体。</p>
<p>判定覆盖要比语句覆盖更强一些。</p>
</li>
<li>
<p><strong>条件覆盖</strong>：指构造一组测试用例，使得<u>每一判定语句中每个逻辑条件的各种可能的值至少满足一次</u>。</p>
<p>条件覆盖的判定语句是指判定表达式下的判定语句（如果有），即用<code>AND</code>、<code>OR</code>等逻辑运算符连接起来的语句（不包含逻辑运算符的语句）。</p>
</li>
<li>
<p><strong>判定/条件覆盖</strong>：指设计足够的测试用例，<u>使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次</u>。</p>
<p>判定/条件覆盖同时满足：</p>
<ul>
<li>判定覆盖</li>
<li>条件覆盖</li>
</ul>
</li>
<li>
<p><strong>条件组合覆盖</strong>：指设计足够的测试用例，使得<u>每个判定中条件的各种可能值的组合都至少出现一次</u>。</p>
<p>满足条件组合覆盖的测试用例一定满足：</p>
<ul>
<li>判定覆盖</li>
<li>条件覆盖</li>
<li>判定/条件覆盖</li>
</ul>
</li>
<li>
<p><strong>路径覆盖</strong>：指<u>覆盖被测试程序中所有可能的路径</u>。</p>
</li>
</ol>
</li>
<li>
<p><strong>循环覆盖</strong></p>
</li>
<li>
<p><strong>基本路径测试</strong></p>
</li>
</ul>
<h3 id="总结-1">总结</h3>
<p>白盒测试逻辑覆盖技术总结（覆盖程度从低到高）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">逻辑覆盖</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语句覆盖</td>
<td style="text-align:left">每条语句执行一次</td>
</tr>
<tr>
<td style="text-align:center">分支（判定）覆盖</td>
<td style="text-align:left">每个分支获得一次True/False</td>
</tr>
<tr>
<td style="text-align:center">条件覆盖</td>
<td style="text-align:left">每个分支中的每个逻辑条件的所有可能取值满足一次</td>
</tr>
<tr>
<td style="text-align:center">判定/条件覆盖</td>
<td style="text-align:left">分支覆盖 + 条件覆盖</td>
</tr>
<tr>
<td style="text-align:center">条件组合覆盖</td>
<td style="text-align:left">每个判定中条件的各种可能值的组合都出现一次</td>
</tr>
<tr>
<td style="text-align:center">路径覆盖</td>
<td style="text-align:left">覆盖被测试程序中所有可能的路径</td>
</tr>
</tbody>
</table></div>
<hr>
<h1 id="运行和维护">运行和维护</h1>
<p>软件维护是软件生命周期中的最后一个阶段，处于系统投入生产性运行以后的时期中，因此<u>不属于系统开发过程</u>。<u>软件维护是在软件已经交付使用之后为了改正错误或满足新的需求而修改软件的过程</u>，即软件在交付使用后对软件所做的一切改动。</p>
<h2 id="系统可维护性">系统可维护性</h2>
<p>系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度。提高可维护性是开发软件系统所有步骤的关键目的。<u>系统的可维护性可以衡量系统是否能被很好地维护。</u></p>
<p>系统可维护性的评价指标：</p>
<ol>
<li>
<p><strong>可理解性</strong>：指别人能理解系统的结构、界面、功能和内部过程的难易程度。</p>
<p>模块化、详细设计文档、结构化设计和良好的高级程序设计语言等都有助于提高可理解性。</p>
</li>
<li>
<p><strong>可测试性</strong>：<u>诊断和测试的容易程度取决于易理解的程度。</u></p>
<p>好的文档资料有利于诊断和测试；程序的结构、高性能的测试工具以及周密计划的测试工序也是至关重要的。</p>
<p>在进行系统维护时，应该充分利用在系统测试阶段保存下来的测试用例。</p>
</li>
<li>
<p><strong>可修改性</strong>：诊断和测试的容易程度与系统设计所制定的设计原则有直接关系。</p>
<p>模块的耦合、内聚、作用范围与控制范围的关系等都对可修改性有影响。</p>
</li>
</ol>
<p><strong>软件文档与软件维护</strong>：</p>
<p><u>软件文档是软件可维护性的决定因素。</u>文档是软件产品的一部分，并且编写高质量的文档可以提高软件开发的质量。</p>
<p>软件系统的文档分为：</p>
<ul>
<li><strong>用户文档</strong>：主要描述<u>系统功能</u>和<u>使用方法</u>，并<u>不关心</u>这些<u>功能是怎样实现的</u>；</li>
<li><strong>系统文档</strong>：描述<u>系统设计、实现和测试</u>等各方面的内容。</li>
</ul>
<p>可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护的特点。在软件工程的每一个阶段都应考虑并提高软件的可维护性，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审（如将来要改进的部分和可能会修改的部分）。</p>
<p>维护应该针对整个软件配置，不应该只修改源程序代码。</p>
<h2 id="软件维护">软件维护</h2>
<p>软件维护主要是指<u>根据需求变化或硬件环境的变化对应用程序进行部分或全部修改</u>。修改时应充分利用源程序，<u>修改后要填写程序修改登记表</u>，并<u>在程序变更通知书上写明新旧程序的不同之处</u>。</p>
<p>软件维护的内容一般有以下几个方面：</p>
<ol>
<li>
<p><strong>正确性维护</strong>：指<u>改正在系统开发阶段已发生而系统测试阶段尚未发现的错误</u>。</p>
<p>所发现的错误有：</p>
<ul>
<li>不太重要、不影响系统正常运行的错误，其维护工作可随时进行；</li>
<li>非常重要的错误，甚至会影响整个系统的正常运行，其维护工作必须制定计划，进行修改，并且要进行复查和控制。</li>
</ul>
</li>
<li>
<p><strong>适应性维护</strong>：<u>使应用软件适应信息技术变化和管理需求变化而进行的修改。</u></p>
</li>
<li>
<p><strong>完善性维护</strong>：<u>为扩充功能和改善性能而进行的修改</u>。</p>
<ul>
<li>主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</li>
<li>还包括对处理效率和编写程序的改进，关系到系统开发质量的重要方面。</li>
</ul>
<p>这方面的维护还要注意将相关的文档资料加入到前面相应的文档中。</p>
</li>
<li>
<p><strong>预防性维护</strong>：<u>为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰。</u></p>
<p>例如将专用报表功能改成通用报表生成功能，以适应将来报表格式的变化。</p>
</li>
</ol>
<p>这4个维护内容中，正确性和完善性维护是针对来自系统内部的维护，适应性和预防性是针对来自系统外部的维护。</p>
<ul>
<li>
<p>正确性维护针对的是系统内部的错误。</p>
<p>来自系统内部的，与错误有关的都是属于正确性维护。</p>
</li>
<li>
<p>完善性维护针对的是系统内部与功能、性能等方面有关的维护。</p>
<p>来自系统内部的，与系统功能、性能等方面有关的改善都是完善性维护。完善性维护的需求可以来自外部，例如功能的扩展。</p>
</li>
<li>
<p>适应性维护是针对来自系统外部的技术、管理需求等方面的变化。</p>
<p>针对来自系统外部的变化，系统功能等方面没有缺失，仅仅只是适应当前环境变化所做的更改，都是属于适应性维护。</p>
</li>
<li>
<p>预防性维护针对的是未来的环境变化。</p>
</li>
</ul>
<hr>
<h1 id="项目管理">项目管理</h1>
<h2 id="沟通路径">沟通路径</h2>
<p>沟通图是指项目中人员或部门之间的沟通用一条无向边连接起来，所构成图即为沟通图。沟通图中的路径称为沟通路径。</p>
<p>软件项目中沟通路径$m$的计算公式：</p>
<ul>
<li>
<p>沟通图中无主程序员时：</p>
<p>$$
m = \sum_{i=1}^{n} i-1 = \cfrac{(n-1)n}{2}
$$</p>
</li>
<li>
<p>沟通图中有主程序员时：</p>
<p>$$
m = n - 1
$$</p>
</li>
</ul>
<h2 id="软件项目估算">软件项目估算</h2>
<p>软件项目估算涉及人、技术、环境等多种因素，很难在项目完成前准确地估算出开发软件所需的成本、持续时间和工作量。所以需要一些方法和技术来支持项目的估算，常用的估算方法有下列3种：</p>
<ol>
<li>
<p>基于已经完成的类似项目进行估算（常用）。</p>
</li>
<li>
<p>基于分解技术进行估算。</p>
</li>
<li>
<p>基于经验估算模型的估算。</p>
<p>典型的经验估算模型有：</p>
<ul>
<li>IBM估算模型</li>
<li>CoCoMo模型</li>
<li>Putnam模型</li>
</ul>
</li>
</ol>
<p>上述方法可以组合使用，以提高估算的精度。</p>
<h3 id="cocomo-估算模型">COCOMO 估算模型</h3>
<p>COCOMO模型是一种精确的、易于使用的成本估算模型。COCOMO模型按其详细程度分为：</p>
<ol>
<li>
<p><strong>基本COCOMO模型</strong>：是一个<u>静态单变量模型</u>，用于对整个软件系统进行估算。</p>
<p>公式如下：</p>
<p>$$
E = a(L)^b \\
D=cE^d
$$</p>
<ul>
<li>$E$：工作量，单位是人月；</li>
<li>$D$：开发时间，单位是月；</li>
<li>$L$：项目的源代码行估计值，不包括程序中的注释及文档，其单位是千行代码；</li>
<li>$a$、$b$、$c$、$d$：常数。</li>
</ul>
<p>基本COCOMO模型可通过估算代码行的值$L$，然后计算开发工作量$E$和开发时间$D$的估算值。</p>
</li>
<li>
<p><strong>中级COCOMO模型</strong>：是一个<u>静态多变量模型</u>，它<u>将软件系统模型分为系统和部件两个层次</u>，系统由部件构成，它把软件开发所需的人力（成本）看作是程序大小和一系列“成本驱动属性”的函数。</p>
<p>中级COCOMO模型以基本COCOMO模型为基础，并考虑了15种影响软件工作量的因素，通过工作量调节因子（EAF）修正对工作量的估算，从而使估算更合理。其公式如下：</p>
<p>$$
E = a(L)^b \cdot EAF
$$</p>
<ul>
<li>$L$：软件产品的目标代码行数，单位是千行代码数；</li>
<li>$EAF$：工作量调节因子；</li>
<li>$a$、$b$：常数。</li>
</ul>
</li>
<li>
<p><strong>详细COCOMO模型</strong>：<u>将软件系统模型分为系统、子系统和模块3个层次</u>，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响。</p>
</li>
</ol>
<h3 id="cocomoii模型">COCOMOII模型</h3>
<p>和其前身COCOMO一样，COCOMOII也是一种层次结构的估算模型，被分为3个阶段性模型，分别对应三种不同的规模估算选择：</p>
<ol>
<li>
<p><strong>应用组装模型</strong>：在软件工程的前期阶段使用，这时用户界面的原型开发、对软件和系统交互的考虑、性能的评估以及技术成熟度的评价是最重要的。</p>
<p>规模估算选择：<strong>对象点</strong>。</p>
</li>
<li>
<p><strong>早期设计阶段模型</strong>：在需求己经稳定并且基本的软件体系结构己经建立时使用。</p>
<p>规模估算选择：<strong>功能点</strong>。功能点可转换为代码行。</p>
</li>
<li>
<p><strong>体系结构阶段模型</strong>：在软件的构造过程中使用。</p>
<p>规模估算选择：<strong>代码行</strong>。</p>
</li>
</ol>
<h3 id="总结-2">总结</h3>
<p>COCOMO模型：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模型分类</th>
<th style="text-align:left">类型或说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本COCOMO模型</td>
<td style="text-align:left">静态单变量模型，对整个软件系统进行估算</td>
</tr>
<tr>
<td style="text-align:center">中级COCOMO模型</td>
<td style="text-align:left">静态多变量模型，将系统模型分为系统和部件2个层次</td>
</tr>
<tr>
<td style="text-align:center">详细COCOMO模型</td>
<td style="text-align:left">将系统模型分为系统、子系统和模块3个层次</td>
</tr>
<tr>
<td style="text-align:center">COCOMOII</td>
<td style="text-align:left">层次结构，分为应用组装模型、早期设计阶段模型和体系结构阶段模型</td>
</tr>
</tbody>
</table></div>
<p>COCOMOII的使用时期及规模估算选择：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">阶段性模型</th>
<th style="text-align:center">规模估算选择</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用组装模型</td>
<td style="text-align:center">对象点</td>
</tr>
<tr>
<td style="text-align:center">早期设计阶段模型</td>
<td style="text-align:center">功能点</td>
</tr>
<tr>
<td style="text-align:center">体系结构阶段模型</td>
<td style="text-align:center">代码行</td>
</tr>
</tbody>
</table></div>
<h2 id="进度管理">进度管理</h2>
<p>进度安排：</p>
<p>为监控软件项目的进度计划和工作的实际进展情况，表示各项任务之间进度的相互依赖关系，需要采用图示的方法。在图中明确标明如下内容：</p>
<ol>
<li>各个任务的<u>计划开始时间</u>和<u>计划完成时间</u>。</li>
<li>各个任务的<u>完成标志</u>。</li>
<li>各个任务与<u>参与工作的人数</u>，各个任务与<u>工作量之间的衔接情况</u>。</li>
<li>完成各个任务所需的<u>物理资源</u>和<u>数据资源</u>。</li>
</ol>
<p>进度安排的常用图形描述方法有：</p>
<ul>
<li>Gantt图（甘特图）；</li>
<li>项目计划评审技术（Program Evaluation&amp;Review Technique，PERT）图。</li>
</ul>
<h3 id="gantt图">Gantt图</h3>
<p>Gantt图：一种<u>简单的水平条形图</u>，它<u>以日历为基准</u>描述项目任务。</p>
<ul>
<li>
<p>垂直轴：表示<u>多个不同的任务</u>，每个任务按照左侧任务名称垂直排列。</p>
</li>
<li>
<p>水平轴：表示<u>日历时间线</u>（如时、天、周、月和年等）。</p>
<p>每个水平条表示一个任务：</p>
<ul>
<li>每一水平条的<u>起点</u>：表示该任务的<u>开始时间</u>；</li>
<li>每一水平条的<u>终点</u>：表示该任务的<u>结束时间</u>；</li>
<li>每一水平条的<u>长度</u>：表示<u>完成该任务的持续时间</u>。</li>
</ul>
<p>当日历中同一时段存在多个水平条时，表示任务之间的并发。</p>
</li>
</ul>
<p>如图：</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683683731050.png"
	width="795"
	height="282"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683683731050_hu977eb3a1b8bea533db1ac3601076cb83_32011_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683683731050_hu977eb3a1b8bea533db1ac3601076cb83_32011_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="Gantt图示例"
	
	
		class="gallery-image" 
		data-flex-grow="281"
		data-flex-basis="676px"
	
></p>
<ul>
<li>
<p>Gantt图优点：</p>
<p>能清晰地描述：</p>
<ul>
<li>每个任务的开始时间；</li>
<li>每个任务的结束时间；</li>
<li>任务的进展情况；</li>
<li>各个任务之间的并行性。</li>
</ul>
</li>
<li>
<p>Gantt图缺点：</p>
<ul>
<li>不能清晰地反映各任务之间的<u>依赖关系</u>；</li>
<li>难以确定<u>整个项目的关键所在</u>，即不能清晰地确定影响进度的<u>关键任务</u>；</li>
<li>不能反映<u>计划中有潜力的部分</u>。</li>
</ul>
</li>
</ul>
<h3 id="pert图">PERT图</h3>
<p>PERT图是一个<u>有向图</u>：</p>
<ul>
<li>
<p><strong>弧</strong>：表示<strong>任务</strong>。</p>
<p>任务包含以下成分：</p>
<ul>
<li>
<p><u>完成该任务所需的时间</u>（任务持续时间）。</p>
</li>
<li>
<p><u>松弛时间</u>（Slack Time）：表示在<u>不影响整个工期的前提下完成该任务有多少机动余地</u>。</p>
<p>即松弛时间指当前任务的工期可以推迟的时间。</p>
</li>
</ul>
<p>空任务：用虚线箭头表示，表示任务间的关系所添加。完成空任务的所需时间为0。</p>
</li>
<li>
<p><strong>结点</strong>：表示<strong>事件</strong>。</p>
<p>事件是流入结点的任务的结束，或流出结点的任务的开始。事件<u>表示某个时间点</u>，本身不消耗时间和资源。</p>
<p>事件包含以下成分：</p>
<ul>
<li>事件号。</li>
<li>出现该事件的<strong>最早时刻</strong>：表示在此时刻之前从该事件出发的任务不可能开始。</li>
<li>出现该事件的<strong>最迟时刻</strong>：表示从该事件出发的任务最迟在此时刻开始，否则整个工程就不能如期完成。</li>
</ul>
<p><u>只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始。</u></p>
<p>特殊的事件：</p>
<ul>
<li>开始事件：没有任何任务流向该事件；</li>
<li>结束事件：没有任务任务从该事件流出。</li>
</ul>
<p>一个项目是从开始事件开始到结束事件结束。</p>
</li>
</ul>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683684995281.png"
	width="850"
	height="490"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683684995281_hube9164e5138fcdde7e8eebfa04856a94_71059_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683684995281_hube9164e5138fcdde7e8eebfa04856a94_71059_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="PERT图示例"
	
	
		class="gallery-image" 
		data-flex-grow="173"
		data-flex-basis="416px"
	
></p>
<p>设：</p>
<ul>
<li>$T(e)$：完成任务$e$的所需时间；</li>
<li>$T_s(e)$：完成任务$e$的松弛时间；</li>
<li>$T_e(v)$：事件$v$的最早时刻；</li>
<li>$T_l(v)$：事件$v$的最迟时刻。</li>
</ul>
<p>PERT图各成分取值（不一定需要满足下面的关系，但是可以用下面的式子推出）：</p>
<ul>
<li>
<p>事件$V_{in}$的<u>最早时刻</u>$T_e(V_{in})$：</p>
<ul>
<li>
<p>只有一个任务流入时，设该任务的流出事件为$V_{out}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = T_e(V_{out}) + T(&lt;V_{out}, V_{in}&gt;)
$$</p>
<p>即：<u>该流入任务的流出事件的最早时刻</u> + <u>完成该流入任务的所需时间</u>。</p>
</li>
<li>
<p>多个任务流入时，设与每个任务相对应的流出事件为$V_{out}[ \ i \ ]$，则这些任务为$&lt;V_{out}[ \ i \ ], V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = Max(T_e(V_{out}[ \ i \ ]) + T(&lt;V_{out}[ \ i \ ], V_{in}&gt;))
$$</p>
<p>即<u>流入该事件的每个任务计算出的最早时刻的最大值</u>。</p>
</li>
<li>
<p>开始事件$V_{start}$：</p>
<p>$$
T_e(V_{start}) = 0
$$</p>
</li>
</ul>
</li>
<li>
<p>事件$V_{out}$的<u>最迟时刻</u>$T_l(V_{out})$：</p>
<ul>
<li>
<p>只有一个任务流出时，设该任务的流入事件为$V_{in}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - (T(&lt;V_{out}, V_{in}&gt;) + T_s(&lt;V_{out}, V_{in}&gt;))
$$</p>
<p>即：<u>该流出任务的流入事件的最迟时刻</u> -（<u>该流出任务的所需时间</u> + <u>松弛时间</u>）。</p>
<p>如果松弛时间未知或为0：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - T(&lt;V_{out}, V_{in}&gt;)
$$</p>
</li>
<li>
<p>多个任务流出时，设与每个任务相对应的流入事件为$V_{out}[ \ i \ ]$，则这些任务为$&lt;V_{out}[ \ i \ ], V_{in}&gt;$：</p>
<p>$$
Min(V_{out}[ \ i \ ]) = T_l(V_{in}) - (T(&lt;V_{out}[ \ i \ ], V_{in}&gt;) + T_s(&lt;V_{out}[ \ i \ ], V_{in}&gt;))
$$</p>
<p>即<u>流出该事件的每个任务计算出的最晚时刻的最大值</u>。</p>
<p>如果松弛时间未知：</p>
<p>$$
Min(V_{out}[ \ i \ ]) = T_l(V_{in}) - T(&lt;V_{out}[ \ i \ ], V_{in}&gt;)
$$</p>
</li>
<li>
<p>结束事件$V_{end}$：</p>
<p>$$
T_l(V_{end}) = T_e(V_{end})
$$</p>
<p>即<u>结束事件的最早时刻与最迟时刻相等</u>。</p>
</li>
</ul>
</li>
<li>
<p>设某任务的流入事件为$V_{in}$，流出事件为$V_{out}$，则该任务$&lt;V_{out}, V_{in}&gt;$的<u>松弛时间</u>$T_s(&lt;V_{out}, V_{in}&gt;)$。</p>
<p>$$
T_s(&lt;V_{out}, V_{in}&gt;) = T_l(V_{in}) - T(&lt;V_{out}, V_{in}&gt;) - T_e(V_{out})
$$</p>
<p>即，该任务的流入事件的最迟时刻 - 该任务的所需时间 - 该任务的流出事件的最早时刻</p>
</li>
</ul>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683719224977.png"
	width="931"
	height="341"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683719224977_hu89f160ee9e5081c0094ce31c4ac579dc_24904_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683719224977_hu89f160ee9e5081c0094ce31c4ac579dc_24904_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="PERT图公式参照图"
	
	
		class="gallery-image" 
		data-flex-grow="273"
		data-flex-basis="655px"
	
></p>
<p>PERT图的路径：从开始事件到结束事件的一条通路。</p>
<p>PERT图的<strong>关键路径</strong>：指<u>所有的任务的松弛时间都为0的路径</u>。</p>
<p>关键路径的长度：指结束事件的最早（或最晚）时刻。</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683706944555.png"
	width="785"
	height="457"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683706944555_hu5ed56fd45a79614d457188c6e9a3a0a9_48481_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683706944555_hu5ed56fd45a79614d457188c6e9a3a0a9_48481_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="PERT图的关键路径示例"
	
	
		class="gallery-image" 
		data-flex-grow="171"
		data-flex-basis="412px"
	
></p>
<p>关键路径的特点：</p>
<ul>
<li>
<p>所有任务的松弛时间都为0。</p>
</li>
<li>
<p>每个事件的最早时刻和最迟时刻都是相等的。</p>
</li>
<li>
<p>所有任务持续时间的和，是PERT图所有路径中最大的，并且与结束事件的最早时刻（或最晚时刻）相等。</p>
<p>设关键路径中所有事件为$V_i$（$i = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_j, V_{j+1}&gt;$（$1 \le j \le n-1$）（表示$V_1$是开始事件，$V_2$是$V_1$往下的一个事件，以此类推，$V_n$是结束事件），那么该关键路径结束事件的最早时刻（或最晚时刻）为：</p>
<p>$$
T_e(V_n) = \sum_{i = 1}^{n-1} T(&lt;V_i, V_{i+1}&gt;)
$$</p>
</li>
</ul>
<p>最迟时刻的另一种求法（PERT图存在关键路径的情况下）：</p>
<p>已知某PERT图结束事件的最晚时刻（最早时刻），该PERT图中某一条路径（假设该路径没有分支）中所有事件为$V_j$（$j = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_k, V_{k+1}&gt;$（$1 \le k \le n-1$），该路径下任务的持续时间$T(&lt;V_{k-1}, V_k&gt;)$已知，（即$V_1$是开始事件，按照次序往下，$V_n$是结束事件），计算某一事件的最迟时刻$T_l(V_i)$（$1 \le i &lt; n$）：</p>
<p>$$
T_l(V_i) = T_l(V_n) - \sum_{j = i}^{n - 1} T(&lt;V_j, V_{j + 1}&gt;)
$$</p>
<p>即：<u>结束事件的最晚时刻</u> - <u>该事件到结束事件之间所有的任务的持续时间总和</u>。</p>
<blockquote>
<p>注意：如果事件$V_i$到结束事件之间存在多条路径，应该选择那条任务持续时间总和最大的路径。</p>
</blockquote>
<p>PERT图的优点：</p>
<ul>
<li>给出了每个任务的开始时间、结束时间和完成该任务所需的时间；</li>
<li>给出了任务之间的关系（依赖关系）。即任务之间的执行顺序。</li>
</ul>
<p>PERT图不能清晰地描述任务之间的并行情况。</p>
<h3 id="项目活动图">项目活动图</h3>
<p>项目活动图是一种有向图（与PERT图十分类似）：</p>
<ul>
<li>
<p>弧：表示活动。弧的权值表示活动的持续时间。</p>
</li>
<li>
<p>顶点：表示项目里程碑。</p>
<p>特殊的里程碑：</p>
<ul>
<li>开始里程碑：没有任何活动指向该里程碑；</li>
<li>结束里程碑：没有任何活动从该里程碑指出。</li>
</ul>
</li>
</ul>
<p>项目活动图的关键路径：按照PERT图的方法求出松弛时间为0的、从开始里程碑到结束里程碑的路径。</p>
<p>关键路径的长度：为结束里程碑的最早时刻（或最晚时刻）。它可以用来表示项目完成的最少时间。</p>
<h2 id="软件配置管理">软件配置管理</h2>
<p>在软件开发过程中变更是不可避免的，而变更时由于没有进行变更控制，可能加剧了项目中的混乱。为了协调软件开发使得混乱减到最小，使用配置管理技术，使变更所产生的错误达到最小并最有效地提高生产率。</p>
<p>软件配置管理（Software Configure Management，SCM）用于整个软件工程过程，它是一组管理整个软件生存周期中各阶段变更的活动。</p>
<p>软件配置管理的主要目标包括：</p>
<ul>
<li>标识变更</li>
<li>控制变更</li>
<li>版本控制</li>
<li>确保变更正确地实现</li>
<li>报告有关变更</li>
</ul>
<p>主要内容有两种版本：</p>
<ol>
<li>
<ul>
<li>版本管理</li>
<li>配置支持</li>
<li>变更支持</li>
<li>过程支持</li>
<li>团队支持</li>
<li>变化报告</li>
<li>审计支持</li>
</ul>
</li>
<li>
<ul>
<li>软件配置标识</li>
<li>变更管理</li>
<li>版本控制</li>
<li>系统建立</li>
<li>配置审核</li>
<li>配置状态报告</li>
</ul>
</li>
</ol>
<h3 id="变更控制">变更控制</h3>
<p>变更控制是一项最重要的软件配置任务。为了有效地实现变更控制，需借助于配置数据库和基线的概念。</p>
<p>基线：是软件生存周期中各开发阶段的一个特定点，它的作用是使各开发阶段的工作划分更加明确，使本来连续的工作在这些点上断开，以便于检查与肯定阶段成果。</p>
<p>基线可以作为一个检查点。在开发过程中，当采用的基线发生错误时可以知道所处的位置，返回到最近和最恰当的基线上。</p>
<p>配置数据库可分为以下3类：</p>
<ul>
<li>
<p><strong>开发库</strong>：专供开发人员使用，其中的信息可能做频繁修改，对其控制相当宽松。</p>
</li>
<li>
<p><strong>受控库</strong>：在生存期某一阶段工作结束时发布的阶段产品，这些是与软件开发工作相关的计算机可读信息和人工可读信息。</p>
<p>软件配置管理正是对受控库中的各个软件项进行管理，受控库也称为<strong>软件配置库</strong>。</p>
</li>
<li>
<p><strong>产品库</strong>：在开发的软件产品完成系统测试后，作为最终产品存入产品库，等待交付用户或现场安装。</p>
</li>
</ul>
<h3 id="风险管理">风险管理</h3>
<p>一般认为软件风险包含两个特性：</p>
<ul>
<li><strong>不确定性</strong>：指风险可能发生也可能不发生；</li>
<li><strong>损失</strong>：指如果风险发生，就会产生恶性后果。</li>
</ul>
<p>在进行风险分析时，重要的是量化每个风险的：</p>
<ul>
<li>不确定程度</li>
<li>损失程度</li>
</ul>
<p>项目风险威胁到项目计划。项目风险是指以下各方面的潜在问题以及它们对软件项目的影响：</p>
<ul>
<li>预算</li>
<li>进度</li>
<li>人员：聘用职员及组织</li>
<li>资源</li>
<li>利益相关者</li>
<li>需求</li>
</ul>
<p>以下方面的不确定性也属于项目风险因素：</p>
<ul>
<li>项目复杂度</li>
<li>项目规模</li>
<li>项目结构</li>
</ul>
<p>技术风险威胁到要开发软件的质量及交付时间。技术风险是指以下方面的潜在问题：</p>
<ul>
<li>设计</li>
<li>实现</li>
<li>接口</li>
<li>验证</li>
<li>维护</li>
</ul>
<p>以下方面也属于技术风险因素：</p>
<ul>
<li>规格说明的歧义性</li>
<li>技术的不确定性</li>
<li>技术陈旧</li>
<li>“前沿”技术</li>
</ul>
<p>商业风险威肋到要开发软件的生存能力，且常常会危害到项目或产品。5个主要的商业风险如下：</p>
<ul>
<li><strong>市场风险</strong>：开发了一个没有人真正需要的优良产品或系统。</li>
<li><strong>策略风险</strong>：开发的产品不再符合公司的整体商业策略。</li>
<li><strong>销售风险</strong>：开发了一个销售部门不知道如何去销售的产品。</li>
<li><strong>管理风险</strong>：由于重点的转移或人员的变动而失去了高级管理层的支持。</li>
<li><strong>预算风险</strong>：没有得到预算或人员的保证。</li>
</ul>
<p>Charette提出的风险分类方式：</p>
<ul>
<li>
<p><strong>己知风险</strong>：</p>
<p>通过仔细<u>评估以下内容可以发现</u>的风险：</p>
<ul>
<li><u>项目计划</u></li>
<li><u>开发项目的商业和技术环境</u></li>
<li>其他可靠的信息来源，如：
<ul>
<li><u>不现实的交付时间</u></li>
<li><u>没有文档化需求或文档化软件范围</u></li>
<li><u>恶劣的开发环境</u></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>可预测风险</strong>：</p>
<p>能够<u>从过去项目的经验中推断出来</u>的风险，如：</p>
<ul>
<li>人员变动</li>
<li>与客户缺乏沟通</li>
<li>由于正在进行维护而使开发人员精力分散</li>
</ul>
</li>
<li>
<p><strong>不可预测风险</strong>：可能会真的出现，但<u>很难事先识别</u>。</p>
</li>
</ul>
<h4 id="风险识别">风险识别</h4>
<p><strong>风险识别</strong>试图<u>系统化地指出对项目计划（估算、进度、资源分配等）的威胁</u>。<u>识别出已知风险和可预测风险后，项目管理者</u>首先要做的是：</p>
<ul>
<li><u>在可能时回避这些风险</u>；</li>
<li><u>在必要时控制这些风险</u>。</li>
</ul>
<p>识别风险的一种方法是<u>建立风险条目检查表</u>，主要用来识别下列几种类型中的一些已知风险和可预测风险：</p>
<ul>
<li><strong>产品规模</strong>：与要开发或要修改的软件的总体规模相关的风险。</li>
<li><strong>商业影响</strong>：与管理者或市场所施加的约束相关的风险。</li>
<li><strong>客户特性</strong>：与客户的素质以及开发者和客户定期沟通的能力相关的风险。</li>
<li><strong>过程定义</strong>：与软件过程定义的程度以及该过程被开发组织遵守的程度相关的风险。</li>
<li><strong>开发环境</strong>：与用来开发产品的工具的可得性及质量相关的风险。</li>
<li><strong>开发技术</strong>：与待开发软件的复杂性及系统所包含技术的“新奇性”相关的风险。</li>
<li><strong>人员才干及经验</strong>：与软件工程师的总体技术水平及项目经验相关的风险。</li>
</ul>
<p>与上述每个主题相关的问题可以针对每一个软件项目来回答。根据这些问题的答案，项目管理者就可以估计风险产生的影响。</p>
<p>另一种风险条目检查表格式：仅仅列出与每一种类型有关的特性，最终给出<u>一组风险因素和驱动因子以及它们发生的概率</u>。</p>
<p>风险因素包括：</p>
<ul>
<li><strong>性能</strong>：性能风险是指产品能够满足需求且符合其使用目的的不确定程度。</li>
<li><strong>成本</strong>：成本风险是指能够维持项目预算的不确定程度。</li>
<li><strong>支持</strong>：支特风险是指开发出的软件易于纠错、修改及升级的不确定程度。</li>
<li><strong>进度</strong>：进度风险是指能够维持项目进度且按时交付产品的不确定程度。</li>
</ul>
<h4 id="风险预测">风险预测</h4>
<p><strong>风险预测</strong>又称<strong>风险估计</strong>，它试图从两个方面评估一个风险：</p>
<ul>
<li>风险发生的可能性或概率；</li>
<li>发生风险所产生的后果。</li>
</ul>
<p>通常，项日计划人员与管理人员、技术人员一起进行以下4步<u>风险预测活动</u>：</p>
<ol>
<li>建立一个尺度或标准，以反映风险发生的可能性。</li>
<li>描述风险产生的后果。</li>
<li>估算风险对项目和产品的影响。</li>
<li>标注风险预测的整体精确度，以免产生误解。</li>
</ol>
<p>一种简单的风险预测技术是建立风险表：</p>
<ul>
<li>
<p>第1列：列出所有的风险（由风险识别活动得到)；</p>
</li>
<li>
<p>第2~4列：列出每个风险的：</p>
<ul>
<li>种类</li>
<li>发生的概率</li>
<li>所产生的影响</li>
</ul>
<p>风险所产生的影响可用一个数字来表示：</p>
<ul>
<li>“1”：表示灾难性的；</li>
<li>“2”：表示严重的；</li>
<li>“3”：表示轻微的；</li>
<li>“4”：表示可忽略的。</li>
</ul>
</li>
</ul>
<p>评估风险影响：</p>
<p>发生风险时，有3个因素可能会影响风险所产生的后果：</p>
<ul>
<li>
<p>风险的<strong>本质</strong>：指当风险发生时可能带来的问题。</p>
</li>
<li>
<p>风险的<strong>范围</strong>：</p>
<p>包括：</p>
<ul>
<li>风险的严重性；</li>
<li>风险的整体分布情况：项目中有多少部分受到影响或有多少客户受到损害。</li>
</ul>
</li>
<li>
<p>风险的<strong>时间</strong>：</p>
<ul>
<li>何时能够感受到风险的影响；</li>
<li>风险的影响会持续多长时间。</li>
</ul>
</li>
</ul>
<h4 id="风险优先级">风险优先级</h4>
<p>在进行项目风险管理时，根据风险的优先级来确定风险控制策略。</p>
<ul>
<li><strong>风险优先级</strong>：<u>是根据风险暴露来确定的。</u></li>
<li><strong>风险暴露</strong>：是一种量化风险影响的指标。</li>
</ul>
<p>整体的风险显露度（Risk Exposure，RE）可由下面的关系确定：</p>
<p>$$
RE = P \times C
$$</p>
<ul>
<li>$P$：风险发生的概率；</li>
<li>$C$:风险发生时带来的项目成本。</li>
</ul>
<p>即风险暴露等于风险影响乘以风险概率。风险影响是指当风险发生时造成的损失。</p>
<h4 id="风险评估">风险评估</h4>
<p>在进行风险评估时，建立了如下形式的三元组：</p>
<p>$$
(r_i, l_i, x_i)
$$</p>
<ul>
<li>$r_i$：表示风险；</li>
<li>$l_i$：表示风险发生的概率；</li>
<li>$x_i$：表示风险产生的影响。</li>
</ul>
<p>一种对风险评估很有用的技术就是<u>定义风险参照水准</u>。对于大多数软件项目来说，有3种典型的风险参照水准</p>
<ul>
<li>成本：成本是否超支</li>
<li>进度：进程是否延期</li>
<li>性能：性能是否下降</li>
</ul>
<p>在风险评估过程中，需要执行以下4个步骤：</p>
<ol>
<li>定义项目的风险参考水平值。</li>
<li>建立每一组$(r_i, l_i, x_i)$与每一个参考水平值之间的关系。</li>
<li>预测一组临界点以定义项目终止区域，该区域由一条曲线或不确定区域所界定。</li>
<li>预测什么样的风险组合会影响参考水平值。</li>
</ol>
<h4 id="风险控制">风险控制</h4>
<p>风险控制的目的是<u>辅助项目组建立处理风险的策略</u>。一个有效的策略必须考虑以下3个问题：</p>
<ul>
<li>
<p><strong>风险避免</strong>：</p>
<p>应对风险的<u>最好办法是主动地避免风险</u>，即<u>在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生</u>。</p>
</li>
<li>
<p><strong>风险监控</strong>：</p>
<p>项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。</p>
</li>
<li>
<p>RMMM计划：</p>
<p>风险管理策略可以包含在软件项目计划中，或者风险管理步骤也可以组织成一个独立的风险缓解、监控和管理计划（RMMM计划）。</p>
<p>RMMM计划将所有风险分析工作文档化，并由项目管理者作为整个项目计划中的一部分来使用。</p>
<p>建立了RMMM计划，而且项目己经启动之后，风险缓解及监测步骤也就开始了：</p>
<ul>
<li>
<p>风险缓解：一种问题规避活动。</p>
</li>
<li>
<p>风险监测：一种项目跟踪活动。</p>
<p>这种监测活动有3个主要目的：</p>
<ul>
<li>评估所预测的风险是否真的发生了；</li>
<li>保证正确地实施了各风险的缓解步骤；</li>
<li>收集能够用于今后风险缝隙的信息。</li>
</ul>
</li>
</ul>
<p>风险监测的另一个任务就是试图找到“起源”（在整个项目中是哪些风险引起了哪些问题）。</p>
</li>
</ul>
<h4 id="总结-3">总结</h4>
<p>风险分类总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">项目风险</td>
<td style="text-align:left">威胁到项目计划。<p>风险因素：<br>预算、进度、人员、资源和利益相关者，项目复杂度、规模和结构的不确定性</p></td>
</tr>
<tr>
<td style="text-align:center">技术风险</td>
<td style="text-align:left">威胁到软件的质量及交付时间。<p>风险因素：<br>设计、实现、接口、验证和维护，规格说明的歧义性、技术的不确定性、技术陈旧和使用“前沿”技术</p></td>
</tr>
<tr>
<td style="text-align:center">市场风险</td>
<td style="text-align:left">开发了一个没有人真正需要的产品或系统。</td>
</tr>
<tr>
<td style="text-align:center">策略风险</td>
<td style="text-align:left">开发的产品不再符合公司的整体商业策略。</td>
</tr>
<tr>
<td style="text-align:center">销售风险</td>
<td style="text-align:left">开发了一个销售部门不知道如何去销售的产品。</td>
</tr>
<tr>
<td style="text-align:center">管理风险</td>
<td style="text-align:left">由于重点的转移或人员的变动而失去了高级管理层的支持。</td>
</tr>
<tr>
<td style="text-align:center">预算风险</td>
<td style="text-align:left">没有得到预算或人员的保证。</td>
</tr>
</tbody>
</table></div>
<p>风险管理总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">风险管理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">风险识别</td>
<td style="text-align:left">指出对项目计划的威胁。可通过建立风险条目检查表识别。</td>
</tr>
<tr>
<td style="text-align:center">风险预测</td>
<td style="text-align:left">从风险发生的可能性或概率、风险产生的后果评估可能发生的风险。</td>
</tr>
<tr>
<td style="text-align:center">风险评估</td>
<td style="text-align:left">从风险发生的概率和产生的影响评估风险。可用定义风险参照水准技术评估。</td>
</tr>
<tr>
<td style="text-align:center">风险控制</td>
<td style="text-align:left">目的是辅助项目建立处理风险的策略。策略是风险避免、风险监控和RMMM计划。</td>
</tr>
<tr>
<td style="text-align:center">风险避免</td>
<td style="text-align:left">应对风险的最好办法是主动地避免风险。</td>
</tr>
<tr>
<td style="text-align:center">风险监控</td>
<td style="text-align:left">项目管理者应监控某些可以提供风险高低变化指示的因素。</td>
</tr>
</tbody>
</table></div>
<hr>
<h1 id="软件质量">软件质量</h1>
<h2 id="软件质量特性的度量">软件质量特性的度量</h2>
<p>可靠性、可用性和可维护性是软件的质量属性，软件工程中，用$0 \sim 1$之间的数来度量。</p>
<ul>
<li>
<p>可靠性：指一个系统对于<u>给定的时间间隔内、在给定条件下无失效运作的概率</u>。</p>
<p>可以用$\cfrac{MTTF}{1+MTTF}$来度量。</p>
<p>$MTTF$为<u>平均无故障时间</u>。</p>
</li>
<li>
<p>可用性：指<u>在给定的时间点上</u>，一个<u>系统能够按照规格说明正确运作的概率</u>。</p>
<p>可以用$\cfrac{MTBF}{1+MTBF}$来度量。</p>
<p>$MTBF$为<u>平均失效间隔时间</u>。</p>
</li>
<li>
<p>可维护性：<u>在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率</u>。</p>
<p>可以用$\cfrac{1}{1+MTTR}$来度量。</p>
<p>$MTTR$为<u>平均修复时间</u>。</p>
</li>
</ul>
<p>总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">质量属性</th>
<th style="text-align:center">度量公式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center"><p>$\cfrac{MTTF}{1+MTTF}$</p><p>$MTTF$：平均无故障时间</p></td>
<td style="text-align:left">给定时间间隔内、给定条件下，无失效运作的概率</td>
</tr>
<tr>
<td style="text-align:center">可用性</td>
<td style="text-align:center"><p>$\cfrac{MTBF}{1+MTBF}$</p><p>$MTBF$：平均失效间隔时间</p></td>
<td style="text-align:left">给定时间点上、能按照规格说明正确运作的概率</td>
</tr>
<tr>
<td style="text-align:center">可维护性</td>
<td style="text-align:center"><p>$\cfrac{1}{1+MTTR}$</p><p>$MTTR$：平均修复时间</p></td>
<td style="text-align:left">给定使用条件下、规定时间间隔内，使用规定过程和资源完成维护的概率</td>
</tr>
</tbody>
</table></div>
<h2 id="软件质量模型">软件质量模型</h2>
<p>讨论软件质量首先要了解软件的质量特性，目前己经有多种软件质量模型来描述软件质量特性，如：</p>
<ul>
<li>ISO/IEC 9126 软件质量模型</li>
<li>Me Call 软件质量模型。</li>
</ul>
<h3 id="isoiec-9126-软件质量模型">ISO/IEC 9126 软件质量模型</h3>
<p>ISO/IEC 9126软件质量模型由3个层次组成：</p>
<ol>
<li>第一层：<strong>质量特性</strong></li>
<li>第二层：<strong>质量子特性</strong></li>
<li>第三层：<strong>度量指标</strong></li>
</ol>
<p>该模型的质量特性和质量子特性：</p>
<div class="table-wrapper"><table>
<tr>
    <th style="text-align: center;">
        质量特性
    </th>
    <th style="text-align: center;">
        质量子特性
    </th>
</tr>
<tr>
    <td style="text-align: center;" rowspan="6">
        <b>功能性</b>（Functionality）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适合性（Suitability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        准确性（Accurateness）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        互用性（Interoperability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        依从性（Compliance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        安全性（Security）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>可靠性</b>（Reliability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        成熟性（Maturity）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        容错性（Fault tolerance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易恢复性（Recoverability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>易使用性</b>（Usability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易理解性（Understandability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易学性（Learnability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易操作性（Operability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="3">
        <b>效率</b>（Efficiency）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        时间特性（Time behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        资源特性（Resource behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可维护性</b>（Maintainability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易分析性（Analyzability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易改变性（Changeability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        稳定性（Stability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易测试性（Testability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可移植性</b>（Portability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适应性（Adaptability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易安装性（Installability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        一致性（Conformance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易替换性（Replaceability）
    </td>
</tr>
</table></div>
<p>质量子特性的含义：</p>
<ul>
<li>功能性：
<ul>
<li><strong>适合性</strong>：与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性。</li>
<li><strong>准确性</strong>：与能够得到正确或相符的结果或效果有关的软件属性。</li>
<li><strong>互用性</strong>：<u>与其他指定系统进行交互操作</u>的能力相关的软件属性。</li>
<li><strong>依从性</strong>：<u>使软件服从有关的标准、约定、法规及类似规定</u>的软件属性。</li>
<li><strong>安全性</strong>：与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性。</li>
</ul>
</li>
<li>可靠性：
<ul>
<li><strong>成熟性</strong>：与由软件故障引起失效的频度有关的软件属性。</li>
<li><strong>容错性</strong>：与<u>在软件错误或违反指定接口的情况下维持指定的性能水平</u>的能力有关的软件属性。</li>
<li><strong>易恢复性</strong>：与<u>在故障发生后，重新建立其性能水平并恢复直接受影响数据</u>的能力，以及为达到此目的所需的时间和努力有关的软件属性。</li>
</ul>
</li>
<li>易使用性：
<ul>
<li><strong>易理解性</strong>：与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。</li>
<li><strong>易学性</strong>：与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。</li>
<li><strong>易操作性</strong>：与用户为进行操作和操作控制所付出的努力有关的软件属性。</li>
</ul>
</li>
<li>效率：
<ul>
<li><strong>时间特性</strong>：与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性。</li>
<li><strong>资源特性</strong>：与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。</li>
</ul>
</li>
<li>可维护性：
<ul>
<li><strong>易分析性</strong>：与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。</li>
<li><strong>易改变性</strong>：与进行修改、排错或适应环境变换所需努力有关的软件属性。</li>
<li><strong>稳定性</strong>：与修改造成未预料效果的风险有关的软件属性。</li>
<li><strong>易测试性</strong>：为确认经修改软件所需努力有关的软件属性。</li>
</ul>
</li>
<li>可移植性：
<ul>
<li><strong>适应性</strong>：与软件转移到不同环境时的处理或手段有关的软件属性。</li>
<li><strong>易安装性</strong>：与在指定环境下安装软件所需努力有关的软件属性。</li>
<li><strong>一致性</strong>：使软件服从与可移植性有关的标准或约定的软件属性。</li>
<li><strong>易替换性</strong>：与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。</li>
</ul>
</li>
</ul>
<h3 id="mc-call-软件质量模型">Mc Call 软件质量模型</h3>
<p>Mc Call软件质量模型从以下3个方面确定了11个质量特性：</p>
<ul>
<li>软件产品的<strong>运行</strong></li>
<li>软件产品的<strong>修正</strong></li>
<li>软件产品的<strong>转移</strong></li>
</ul>
<p>Mc Call也给出了一个三层模型框架：</p>
<ol>
<li>第一层：<strong>质量特性</strong></li>
<li>第二层：<strong>评价准则</strong></li>
<li>第三层：<strong>度量指标</strong></li>
</ol>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683794894507.png"
	width="533"
	height="379"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683794894507_hu9949eda818815c80ae75952e8d8a159a_51224_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683794894507_hu9949eda818815c80ae75952e8d8a159a_51224_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="Mc Call 软件质量模型"
	
	
		class="gallery-image" 
		data-flex-grow="140"
		data-flex-basis="337px"
	
></p>
<h2 id="软件质量保证">软件质量保证</h2>
<p>软件质量保证是指为保证软件系统或软件产品充分满足用户要求的质量而进行的有计划、有组织的活动，其目的是生产高质量的软件。</p>
<p>软件质量保证包括了与以下7个主要活动相关的各种任务：</p>
<ul>
<li>应用技术方法</li>
<li>进行正式的技术评审</li>
<li>测试软件</li>
<li>标准的实施</li>
<li>控制变更</li>
<li>度量（Metrics）</li>
<li>记录保存和报告</li>
</ul>
<h3 id="软件评审">软件评审</h3>
<p>通常，把“质量”理解为“用户满意程度”。为了使得用户满意，有以下两个必要条件：</p>
<ul>
<li>
<p><strong>设计质量</strong>：设计的规格说明书符合用户的要求。</p>
<p>设计质量的评审对象：</p>
<ul>
<li>软件需求规格说明</li>
<li>数据需求规格说明</li>
<li>软件概要设计说明</li>
</ul>
</li>
<li>
<p><strong>程序质量</strong>：程序按照设计规格说明所规定的情况正确执行。</p>
<p>程序质量的评审通常是从开发者的角度进行，与开发技术直接相关。程序质量的评审对象：</p>
<ul>
<li>软件结构：
<ul>
<li>功能结构：
<ul>
<li>数据结构</li>
<li>功能结构</li>
<li>数据结构和功能结构之间的对应关系</li>
</ul>
</li>
<li>功能的通用性</li>
<li>模块的层次</li>
<li>模块结构：
<ul>
<li>控制流结构</li>
<li>数据流结构</li>
<li>模块结构与功能结构之间的对应关系</li>
</ul>
</li>
<li>处理过程的结构</li>
</ul>
</li>
<li>与运行环境的接口：
<ul>
<li>与硬件的接口</li>
<li>与用户的接口</li>
</ul>
</li>
<li>变更带来的影响</li>
</ul>
</li>
</ul>
<p>软件的规格说明分为：</p>
<ul>
<li>
<p><strong>外部规格说明</strong>：从用户角度来看的规格，包括硬件/软件系统设计、功能设计；</p>
<p>设计质量是由外部规格说明决定的</p>
</li>
<li>
<p><strong>内部规格说明</strong>：为了实现外部规格的更详细的规格，即软件模块结构与模块处理过程的设计。</p>
<p>内部规格说明是从开发者角度来看的规格说明。</p>
<p>程序是由内部规格说明决定的。</p>
</li>
</ul>
<h3 id="软件容错技术">软件容错技术</h3>
<p>提高软件质量和可靠性的技术大致可分为两类：</p>
<ul>
<li>避开错误：在开发的过程中不让差错潜入软件的技术；</li>
<li>容错技术：对某些无法避开的差错，使其影响减至最小的技术。</li>
</ul>
<p>实现容错的<u>主要手段是<strong>冗余</strong></u>。冗余是指<u>对于实现系统规定功能是多余的那部分资源</u>，包括：</p>
<ul>
<li>硬件</li>
<li>软件</li>
<li>信息</li>
<li>时间</li>
</ul>
<p>由于加入了这些资源，有可能使系统的可靠性得到较大的提高。通常，冗余技术分为4类：</p>
<ul>
<li>
<p><strong>结构冗余</strong>：结构冗余是通常采用的冗余技术，按其工作方法可以分为：</p>
<ul>
<li>
<p><strong>静态冗余</strong>：</p>
<p>常用的有：</p>
<ul>
<li>三模冗余（Triple Module Redundancy，TR）</li>
<li>多模冗余</li>
</ul>
<p>静态冗余通过表决和比较来屏蔽系统中出现的错误。</p>
</li>
<li>
<p><strong>动态冗余</strong>：动态冗余的主要方式是多重模块待机储备。</p>
<p>当系统测试到某工作模块出现错误时，就用一个备用模块来顶替它并重新运行。这里包括以下过程：</p>
<ul>
<li>检测</li>
<li>切换</li>
<li>恢复</li>
</ul>
<p>动态冗余有以下两种方式：</p>
<ul>
<li>
<p>热备份系统：每当一个出错模块被其他备用模块顶替后，冗余系统相当于进行了一次重构。</p>
<p>在热备份系统中，备用模块在待机过程中的失效率为0。</p>
</li>
<li>
<p>冷备份系统：各备用模块在其待机时可与主模块一同工作，也可不工作。</p>
</li>
</ul>
</li>
<li>
<p><strong>混合冗余</strong>：兼有静态元余和动态冗余的长处。</p>
</li>
</ul>
</li>
<li>
<p><strong>信息冗余</strong>：指为检测或纠正信息在运算或传输中的错误需外附加的一部分信息。</p>
</li>
<li>
<p><strong>时间冗余</strong>：指以重复执行指令或程序来消除瞬时错误带来的影响。</p>
</li>
<li>
<p><strong>冗余附加技术</strong>：指为实现上述冗余技术所需的资源和技术，包括：</p>
<p>程序、指令、数据、存放和调动它们的空间和通道等。</p>
<p>在屏蔽硬件错误的容错技术中，冗余附加技术包括：</p>
<ol>
<li>关键程序和数据的冗余存储及调用。</li>
<li>检测、表决、切换、重构、纠错和复算的实现。</li>
</ol>
<p>在屏蔽软件错误的容错系统中，冗余附加技术的构成包括：</p>
<ol>
<li><u>冗余备份程序的存储及调用。</u></li>
<li><u>实现错误检测和错误恢复的程序。</u></li>
<li><u>实现容错软件所需的固化程序。</u></li>
</ol>
</li>
</ul>
<hr>
<h1 id="mccabe-软件复杂性度量法">McCabe 软件复杂性度量法</h1>
<p><strong>McCabe度量法</strong>又称<strong>环路度量法</strong>，是<u>通过定义环路复杂度，建立程序复杂性的度量，它是一种基于程序控制流的复杂性度量方法</u>，它反映了程序（或模块）的控制结构的复杂性。</p>
<p>MaCabe度量法认为<u>程序的复杂性在很大程度上取决于控制的复杂性</u>。单一的顺序程序结构最为简单，循环和选择构成的环路越多，程序就越复杂。</p>
<p>MaCabe度量法以图论为工具，先画出程序图，然后用该图的环路数作为程序复杂性的度量值。</p>
<p>程序图是退化的程序流程图。把程序流程图中的每个处理符号都退化成一个结点，原来连接不同处理符号的流线变成连接不同点的有向弧，这样得到的有向图称为程序图。</p>
<p><img src="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683629835683.png"
	width="447"
	height="416"
	srcset="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683629835683_hu0af7eb1a0943c79d25452239a70d1444_33322_480x0_resize_box_3.png 480w, /p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1683629835683_hu0af7eb1a0943c79d25452239a70d1444_33322_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="程序图示例"
	
	
		class="gallery-image" 
		data-flex-grow="107"
		data-flex-basis="257px"
	
></p>
<p>程序图仅描述程序内部的控制流程，完全不表现对数据的具体操作以及分支和循环的具体条件。</p>
<p>根据图论，在一个强连通的有向图$G$中，计算环的个数$V(G)$的公式为：</p>
<p>$$
V(G) = m - n + 2p
$$</p>
<ul>
<li>$V(G)$：$G$中的<u>环路个数</u>；</li>
<li>$m$：$G$中的<u>弧的个数</u>；</li>
<li>$n$：$G$中的<u>结点数</u>；</li>
<li>$p$：$G$中的<u>强连通分量个数</u>。</li>
</ul>
<p>在一个程序中，从程序图的入口点总能到达图中的任何一个结点，因此，程序总是连通的，但不是强连通的。</p>
<p>为了使程序图成为强连通图，<u>从图的入口点到出口点加一条用虚线表示的有向边</u>（如上图所示），使图成为强连通图（但虚线弧并不算入实际的弧数）。这样就可以使用上式计算环路复杂性了，也因此程序图的$p$通常为1。</p>
<p>即，计算有向图$G$的环路复杂性的公式为：</p>
<p>$$
V(G) = m - n + 2
$$</p>
<p>例如上图中，结点数$n=6$，弧数$m=9$，则：</p>
<p>$$
V(G) = 9 - 6 + 2 = 5
$$</p>
<p>即上图McCabe环路复杂的度量值为5。</p>
<blockquote>
<p>$V(G) = 10$是一个实际模块的上限。当$V(G) &gt; 10$时，很难充分测试这个模块。</p>
<p>在白盒测试中，计算环路复杂度可以简单地使用判定条件的数量 + 1。</p>
</blockquote>
<hr>
<h1 id="软件工具">软件工具</h1>
<h2 id="软件开发工具">软件开发工具</h2>
<p>对应于软件开发过程的各种活动，软件开发工具通常有：</p>
<ul>
<li>需求分析工具</li>
<li>设计工具</li>
<li>编码与排错工具</li>
<li>测试工具</li>
</ul>
<h2 id="软件维护工具">软件维护工具</h2>
<p>辅助软件维护过程中活动的软件称为软件维护工具，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：</p>
<ul>
<li><u>版本控制</u>工具</li>
<li><u>文档分析</u>工具</li>
<li><u>开发信息库</u>工具</li>
<li><u>逆向工程</u>工具</li>
<li><u>再工程</u>工具</li>
</ul>
<h2 id="软件管理和软件支持工具">软件管理和软件支持工具</h2>
<p>软件管理和软件支持工具用来辅助管理人员和软件支持人员的管理活动和支持活动，以确保软件高质量地完成。</p>
<p>常用的铺助软件管理和软件支持的工具有：</p>
<ul>
<li>项目管理工具</li>
<li>配置管理工具</li>
<li>软件评价工具</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E8%BD%AF%E8%80%83/">软考</a>
        
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a>
        
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a>
        
    </section>


    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
       
</article>


    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        计算机网络（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        结构化开发（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        数据库（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        面向对象（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        知识产权（软件设计师）</a>
</div>
</section>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 Linner&#39;s Blog

        <span style="padding-left: 5px;padding-right: 5px;">|</span>

        <a href="https://beian.miit.gov.cn/" target="_blank" >粤ICP备2022125602号-1</a>
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
