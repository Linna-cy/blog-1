<!DOCTYPE html>
<html lang="zh" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='计算机系统 跳转连接：软件设计师——计算机系统篇 基本单位 位（比特） 最小数据单位 bit、b 字节 最小存储单位 byte、B 1B = 8b 千字节 KB 1KB = 1024B 兆字节'>


<title>概念总结篇</title>

<link rel='canonical' href='https://blog.linner.asia/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/'>

<link rel="stylesheet" href="/scss/style.min.7a68e2beb371039eca9f5e8f87aa11bdb1fdc96a55744700a091f658cd1e66a7.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>

<meta property='og:title' content='概念总结篇'>
<meta property='og:description' content='计算机系统 跳转连接：软件设计师——计算机系统篇 基本单位 位（比特） 最小数据单位 bit、b 字节 最小存储单位 byte、B 1B = 8b 千字节 KB 1KB = 1024B 兆字节'>
<meta property='og:url' content='https://blog.linner.asia/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/'>
<meta property='og:site_name' content='Linner&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='软考' /><meta property='article:tag' content='软件设计师' /><meta property='article:published_time' content='2023-05-25T11:34:54&#43;08:00'/><meta property='article:modified_time' content='2023-05-25T11:34:54&#43;08:00'/>
<meta name="twitter:title" content="概念总结篇">
<meta name="twitter:description" content="计算机系统 跳转连接：软件设计师——计算机系统篇 基本单位 位（比特） 最小数据单位 bit、b 字节 最小存储单位 byte、B 1B = 8b 千字节 KB 1KB = 1024B 兆字节">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />

<style>
    .article-content {
        position: relative;
    }
    .article-content table, 
    .article-content tbody {
        white-space: normal;
        word-break: keep-all;
    }
    .article-content u {
        text-decoration-line: none;
        border-bottom: 1.5px solid;
        padding-bottom: 1.5px;
    }
    .article-content li {
        margin-top: 0.8em;
        margin-bottom: 0.8em;
    }
    .article-content ul:last-child, 
    .article-content ol:last-child {
        margin-bottom: 0;
    }
    .article-content td * {
         
    }
    .article-content td ol, 
    .article-content td ul {
        padding-left: 1.2em;
    }
    .article-content td {
        padding-top: 1em;
        padding-bottom: 1em;
        padding-left: 1em;
        padding-right: 1em;
    }
    .article-content td li:first-child,
    .article-content td ol:first-child, 
    .article-content td ul:first-child {
        margin-top: 0;
    }
    .article-content td ul:last-child,
    .article-content td ol:last-child,
    .article-content td ul:first-child {
        margin-bottom: 0;
    }
</style>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            localStorage.setItem(colorSchemeKey, "auto");
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu0c2331fe09320137a3bd1d4b5cc68791_142496_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Linner&#39;s Blog</a></h1>
            <h2 class="site-description">随便看看就行，副标题暂时还没想好</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/Linna-cy'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>

                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives" id="toc-list">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents"></nav>
            
        </div>
    </section>


            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/ruanshe/" >
                软件设计师
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/">概念总结篇</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">May 25, 2023</time>
                |
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 58 分钟
                </time>
                |
            </div>
        

        <div class="article-time--reading">共29049字</div>
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="计算机系统">计算机系统</h1>
<p>跳转连接：<a class="link" href="/p/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%af%87/" >软件设计师——计算机系统篇</a></p>
<h2 id="基本单位">基本单位</h2>
<div class="table-wrapper"><table>
<tr>
    <td>位（比特）<br>最小数据单位</td>
    <td><b>bit、b</b></td>
    <td></td>
</tr>
<tr>
    <td>字节<br>最小存储单位</td>
    <td>byte、B</td>
    <td>1B = 8b</td>
</tr>
<tr>
    <td>千字节</td>
    <td>KB</td>
    <td>1KB = 1024B</td>
</tr>
<tr>
    <td>兆字节</td>
    <td>MB</td>
    <td>1MB = 1024KB</td>
</tr>
<tr>
    <td>吉字节</td>
    <td>GB</td>
    <td>1GB = 1024MB</td>
</tr>
<tr>
    <td>太字节</td>
    <td>TB</td>
    <td>1TB = 1024GB</td>
</tr>
</table></div>
<h2 id="中央处理单元">中央处理单元</h2>
<p>CPU的功能：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">程序控制</td>
<td style="text-align:left">通过执行指令来控制程序的执行顺序。</td>
</tr>
<tr>
<td style="text-align:center">操作控制</td>
<td style="text-align:left">CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。</td>
</tr>
<tr>
<td style="text-align:center">时间控制</td>
<td style="text-align:left">对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。</td>
</tr>
<tr>
<td style="text-align:center">数据处理</td>
<td style="text-align:left">通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。</td>
</tr>
</tbody>
</table></div>
<p>CPU的组成：</p>
<ul>
<li>运算器：
<ul>
<li>算术逻辑单元（ALU）：处理数据，对数据进行算术运算和逻辑运算。</li>
<li>累加寄存器（AC，累加器）：通用寄存器，存放操作数或者结果。。</li>
<li>数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字。</li>
<li>状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态。</li>
</ul>
</li>
<li>控制器：
<ul>
<li>指令寄存器（IR）：暂存要执行的指令。</li>
<li>程序计数器（PC，指令计数器）：寄存信息和指令计数。</li>
<li>地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。</li>
<li>指令译码器（ID）。</li>
</ul>
</li>
<li>寄存器组</li>
<li>内部总线</li>
</ul>
<h2 id="数据编码">数据编码</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4.png"
	width="1174"
	height="273"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="带符号数的范围"
	
	
		class="gallery-image" 
		data-flex-grow="430"
		data-flex-basis="1032px"
	
></p>
<h2 id="寻址方式">寻址方式</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即寻址</td>
<td style="text-align:left">操作数就包含在指令中。</td>
</tr>
<tr>
<td style="text-align:center">直接寻址</td>
<td style="text-align:left">操作数在内存，指令给出操作数的地址。</td>
</tr>
<tr>
<td style="text-align:center">寄存器寻址</td>
<td style="text-align:left">操作数在寄存器，指令给出操作数的寄存器名（地址）。</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接寻址</td>
<td style="text-align:left">操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。</td>
</tr>
<tr>
<td style="text-align:center">间接寻址</td>
<td style="text-align:left">指令中给出操作数地址（操作数地址在内存中）的地址。</td>
</tr>
<tr>
<td style="text-align:center">相对寻址</td>
<td style="text-align:left">指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。</td>
</tr>
<tr>
<td style="text-align:center">变址寻址</td>
<td style="text-align:left">操作数地址等于变址寄存器的内容加偏移量。</td>
</tr>
</tbody>
</table></div>
<h2 id="校验码">校验码</h2>
<p>编码系统的码距：</p>
<ul>
<li>$\ge 2$：该编码系统具有<u>检错能力</u>；</li>
<li>$\ge 3$：该编码系统才<u>可能有纠错能力</u>。</li>
</ul>
<p>奇偶校验码：</p>
<ul>
<li>码距为2。</li>
<li>仅能检测奇数位数出错。</li>
</ul>
<p>海明码：</p>
<p>设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：</p>
<p>$$
2^k-1 \ge n+k
$$</p>
<p>循环冗余（n,k）码：</p>
<ul>
<li>信息码（数据），占k位；</li>
<li>校验码，占n-k位；</li>
<li>码距为2，可以检错不能纠错。</li>
</ul>
<h2 id="计算机指令集">计算机指令集</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">RISC<br>精简指令集（计算机）</th>
<th style="text-align:center">CISC<br>复杂指令集（计算机）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指令种类</td>
<td style="text-align:center">少、精简</td>
<td style="text-align:center">多、复杂</td>
</tr>
<tr>
<td style="text-align:center">指令复杂度</td>
<td style="text-align:center">低（简单）</td>
<td style="text-align:center">高（复杂）</td>
</tr>
<tr>
<td style="text-align:center">指令长度</td>
<td style="text-align:center">固定</td>
<td style="text-align:center">变化</td>
</tr>
<tr>
<td style="text-align:center">寻址方式</td>
<td style="text-align:center">少</td>
<td style="text-align:center">复杂多样</td>
</tr>
<tr>
<td style="text-align:center">实现（译码方式）</td>
<td style="text-align:center">硬布线控制逻辑（组合逻辑控制器）</td>
<td style="text-align:center">微程序控制技术</td>
</tr>
<tr>
<td style="text-align:center">通用寄存器数量</td>
<td style="text-align:center">多、大量</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">流水线技术</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table></div>
<h2 id="流水线技术">流水线技术</h2>
<p>执行$n$条指令：</p>
<ul>
<li>
<p>顺序执行总时间：</p>
<p>$$
顺序执行总时间=单条指令执行的时间\times n
$$</p>
</li>
<li>
<p>流水线执行总时间：</p>
<p>$$
流水线执行总时间=一条指令执行的时间+流水线周期 \times (n-1)
$$</p>
<p>流水线（操作）周期为执行时间最长的一段操作的时间。</p>
</li>
<li>
<p>连续输入$n$条指令的吞吐率：</p>
<p>$$
吞吐率=\cfrac {n}{总执行时间}
$$</p>
<p>如果是流水线的吞吐率，则总执行时间为流水线执行总时间。
流水线的吞吐率是最长流水段操作时间的倒数。即：</p>
<p>$$
最长流水段操作时间=\cfrac {流水线执行总时间}{n}
$$</p>
</li>
<li>
<p>加速比：</p>
<p>$$
加速比 = \cfrac{顺序执行总时间}{流水线执行总时间}
$$</p>
</li>
</ul>
<h2 id="存储器">存储器</h2>
<p>按存储器所处位置可分为：</p>
<ul>
<li>内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。</li>
<li>外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。</li>
</ul>
<p>按存储器工作方式：</p>
<ul>
<li>读/写存储器（RAM）。</li>
<li>只读存储器：ROM、PROM、EPROM、EEPROM等。
<ul>
<li>固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。</li>
<li>可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。</li>
</ul>
</li>
</ul>
<h2 id="缓存">缓存</h2>
<p>高速缓存中的地址映像方法：</p>
<ul>
<li>
<p>直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884025087.png"
	width="825"
	height="526"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="156"
		data-flex-basis="376px"
	
></p>
</li>
<li>
<p>全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884252415.png"
	width="730"
	height="538"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="135"
		data-flex-basis="325px"
	
></p>
</li>
<li>
<p>组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。</p>
</li>
</ul>
<blockquote>
<p>发生块冲突从多到少的顺序：直接映像 &gt; 组相联映像 &gt; 全相联映像。</p>
<p>地址映像都是由硬件自动完成。</p>
</blockquote>
<h2 id="中断">中断</h2>
<p>程序查询方式（程序直接控制方式）：</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888001780.png"
	width="754"
	height="1174"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="64"
		data-flex-basis="154px"
	
></p>
<ul>
<li>CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数放入内存。</li>
</ul>
<p>中断驱动方式：</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888578058.png"
	width="787"
	height="1134"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="69"
		data-flex-basis="166px"
	
></p>
<ul>
<li>I/O设备通过中断信号主动向CPU报告I/O操作已完成。</li>
<li>CPU和I/O可并行工作。</li>
<li>CPU利用率得到提升。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数据放入内存。</li>
</ul>
<p>DMA方式（直接存储器存储方式）：</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888972074.png"
	width="816"
	height="723"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="112"
		data-flex-basis="270px"
	
></p>
<ul>
<li>CPU和I/O可并行工作。</li>
<li>仅在传送数据块多开始和结束时才需要CPU的干预。</li>
<li>由外设直接将数据放入内存。</li>
<li>一次读写的单位为&quot;块&quot;而不是字。</li>
</ul>
<p>DMA传输数据比中断驱动方式传输数据要快一点。</p>
<h2 id="总线">总线</h2>
<p>微机中的总线分为：</p>
<ul>
<li>数据总线</li>
<li>地址总线</li>
<li>控制总线</li>
</ul>
<p>常见总线：</p>
<ul>
<li>ISA总线。</li>
<li>EISA总线。</li>
<li>PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。</li>
<li>PCI Express 总线。</li>
<li>前端总线。</li>
<li>RS-232C。</li>
<li>SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。</li>
<li>SATA。</li>
<li>USB。</li>
<li>IEEE-1394。</li>
<li>IEEE-488总线。</li>
</ul>
<h2 id="加密与认证技术">加密与认证技术</h2>
<p>加密技术用于防止第三方窃听：</p>
<ul>
<li>
<p>对称加密：只有一把密钥。加密和解密用同一把密钥。</p>
<ul>
<li>密钥分发有缺陷。</li>
<li>加密解密速度很快。</li>
<li>适合加量大量明文数据。</li>
</ul>
</li>
<li>
<p>非对称加密：</p>
<ul>
<li>加密和解密不是同一把密钥。</li>
<li>一共有两把密钥，分别是公钥和私钥。</li>
<li>用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。</li>
<li>不能通过一把密钥推出另一把密钥。</li>
<li>用接收方的公钥加密明文可以实现防止窃听的效果。</li>
<li>密钥分发没有缺陷。</li>
<li>加密解密速度很慢。</li>
</ul>
</li>
</ul>
<p>认证技术用于防止篡改、假冒和否认：</p>
<ul>
<li>摘要（防止篡改）：Hash算法加密，放在密文后。</li>
<li>数字签名（防止假冒和否认）：<u>发送方用私钥对摘要进行签名</u>（加密）。接收方用<u>发送方的公钥对数字签名进行验证</u>（解密）。</li>
</ul>
<p>数字证书：CA机构用私钥对用户的公钥签名（加密）。接收方用CA的公钥验证（解密），从而得到用户的公钥。</p>
<p>加密算法：</p>
<ul>
<li>对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：
<ul>
<li>DES</li>
<li>3DES</li>
<li>RC-5</li>
<li>IDEA</li>
<li>AES</li>
<li>RC4</li>
</ul>
</li>
<li>非对称密钥（公钥、公开密钥加密）算法：
<ul>
<li>RSA</li>
<li>ECC</li>
<li>DSA</li>
</ul>
</li>
<li>其他加密算法：
<ul>
<li>Hash函数</li>
<li>SHA-1安全散列算法</li>
<li>MD5摘要算法</li>
</ul>
</li>
</ul>
<hr>
<h1 id="程序设计语言">程序设计语言</h1>
<p>跳转连接：<a class="link" href="/p/%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%af%ad%e8%a8%80%e7%af%87/" >软件设计师——程序设计语言篇</a></p>
<h2 id="编译过程">编译过程</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680232196718.png"
	width="549"
	height="466"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="编译过程"
	
	
		class="gallery-image" 
		data-flex-grow="117"
		data-flex-basis="282px"
	
></p>
<p>必须的编译过程阶段：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>目标代码生成</li>
</ol>
<p>可省略的编译过程阶段：</p>
<ul>
<li>中间代码生成</li>
<li>（中间或目标）代码优化</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">词法分析</td>
<td style="text-align:left">对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号</td>
</tr>
<tr>
<td style="text-align:center">语法分析</td>
<td style="text-align:left">根据语言的语法规则将单词符号序列分解成各类语法单位</td>
</tr>
<tr>
<td style="text-align:center">语义分析</td>
<td style="text-align:left">检查源程序是否包含静态语义错误</td>
</tr>
<tr>
<td style="text-align:center">中间代码生成</td>
<td style="text-align:left">分水岭，上面是前端，下面是后端</td>
</tr>
<tr>
<td style="text-align:center">代码优化</td>
<td style="text-align:left">所做的优化一般与具体的机器无关</td>
</tr>
<tr>
<td style="text-align:center">目标代码生成</td>
<td style="text-align:left">把中间代码变换成机器指令</td>
</tr>
</tbody>
</table></div>
<h2 id="正规式">正规式</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">闭包</td>
<td style="text-align:left">表示其前面链接的符号或集合可以出现$[0, +\infty]$次。</td>
</tr>
<tr>
<td style="text-align:center"><code>·</code></td>
<td style="text-align:center">连接</td>
<td style="text-align:left">可省略，将多个符号或集合连接起来。表示逻辑与</td>
</tr>
<tr>
<td style="text-align:center"><code>|</code></td>
<td style="text-align:center">或</td>
<td style="text-align:left">表示逻辑或。</td>
</tr>
</tbody>
</table></div>
<p>Example：</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1680248469003.png"
	width="990"
	height="277"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="357"
		data-flex-basis="857px"
	
></p>
<p>设$U$、$V$和$W$均为正规式：</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680249034196.png"
	width="974"
	height="185"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="526"
		data-flex-basis="1263px"
	
></p>
<h2 id="有限自动机">有限自动机</h2>
<ul>
<li>
<p><strong>确定的有限自动机</strong>（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的<strong>状态是唯一的</strong>。</p>
<p>一个DFA是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$：</p>
<ul>
<li>
<p>$S$：包含<u>状态的有限集</u>（每个元素称为一个状态）。</p>
</li>
<li>
<p>$\Sigma$：有穷<u>字母表</u>，其每个元素称为一个<u>输入字符</u>。</p>
</li>
<li>
<p>$f$：$S \times \Sigma \to S$ 上的<u>单值部分映像</u>。</p>
<p>$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$</p>
<p>表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。</p>
</li>
<li>
<p>$s_0$：唯一的<u>开始状态</u>，$s_0 \in S$。</p>
</li>
<li>
<p>$Z$：非空的<u>终止状态集合</u>，$Z \subseteq S$。</p>
</li>
</ul>
<p>DFA可以用两种直观的方式表示：</p>
<ul>
<li>
<p><strong>状态转换图</strong>：简称为转换图，是一个有向图。</p>
<ul>
<li>
<p>DFA中的每个<strong>状态</strong>对应转换图中的一个<strong>结点</strong>。</p>
</li>
<li>
<p>DFA中的每个<strong>转换函数</strong>对应图中的一条<strong>有向弧</strong>。</p>
</li>
<li>
<p><strong>双圈表示的结点是终态结点。</strong></p>
<blockquote>
<p>终态也可以是初态。</p>
</blockquote>
</li>
</ul>
<p>若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。</p>
</li>
<li>
<p><strong>状态转换矩阵</strong>：用一个二位数组$M$表示。</p>
<p>矩阵元素$M[A,a]$：</p>
<ul>
<li><strong>行下标</strong>：表示状态。当前状态为$A$。</li>
<li><strong>列下标</strong>：表示输入的字符。当前输入为$a$。</li>
<li>$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。</li>
</ul>
</li>
</ul>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251834262.png"
	width="983"
	height="160"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="614"
		data-flex-basis="1474px"
	
></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251962756.png"
	width="982"
	height="585"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="167"
		data-flex-basis="402px"
	
></p>
</li>
<li>
<p><strong>不确定的有限自动机</strong>（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的<strong>状态是不唯一的</strong>。</p>
<p>NFA也是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：</p>
<ul>
<li>
<p>$f$是$S \times \Sigma \to 2^S$ 上的映像。</p>
<p>对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。</p>
</li>
<li>
<p>有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。</p>
</li>
</ul>
<blockquote>
<p>DFA是NFA的特例。</p>
</blockquote>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680252743732.png"
	width="918"
	height="407"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="225"
		data-flex-basis="541px"
	
></p>
</li>
</ul>
<p><u>有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。</u></p>
<h2 id="设计语言成分">设计语言成分</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">成分</th>
<th style="text-align:left">包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据成分</td>
<td style="text-align:left"><ul><li>标识符</li><li>关键字</li><li>常量</li><li>变量</li><li>全局量</li><li>局部量</li><li>数据类型</li></ul></td>
</tr>
<tr>
<td style="text-align:center">运算成分</td>
<td style="text-align:left"><ul><li>算数</li><li>关系</li><li>逻辑</li><li>位</li></ul></td>
</tr>
<tr>
<td style="text-align:center">控制结构</td>
<td style="text-align:left"><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul></td>
</tr>
<tr>
<td style="text-align:center">传输成分</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">函数</td>
<td></td>
</tr>
</tbody>
</table></div>
<hr>
<h1 id="数据结构">数据结构</h1>
<p>跳转连接：<a class="link" href="/p/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%af%87/" >软件设计师——数据结构篇</a></p>
<h2 id="线性表">线性表</h2>
<p><strong>顺序表：</strong></p>
<p>在表长为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：</p>
<ul>
<li>
<p>在第$i$个插入位置插入，需要移动$n+1-i$个元素。</p>
<ul>
<li>在第1个位置插入（$a_1$）需要移动$n$个元素；</li>
<li>在第$n+1$个位置插入（$a_n$后面）不需要移动元素。</li>
</ul>
</li>
<li>
<p>设在第$i$个插入位置插入的概率为$p_i$，<u>等概率下插入</u>一个新元素需要移动的元素个数的<u>期望值$E_{insert}$</u>为：</p>
<p>$$
E_{insert} = \cfrac{插入位置数-1}{2} = \cfrac{n+1}{2}
$$</p>
</li>
</ul>
<p>在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：</p>
<ul>
<li>
<p>删除第$i$个元素$a_i$需要移动$n-i$个元素。</p>
<ul>
<li>删除元素$a_1$需要移动$n-1$个元素；</li>
<li>删除元素$a_n$不需要移动元素。</li>
</ul>
</li>
<li>
<p>设$a_i$被删除的概率为$q_i$，<u>等概率下删除元素</u>时需要移动的元素个数的<u>期望值$E_{delete}$</u>为：</p>
<p>$$
E_{delete} = \cfrac{删除位置数}{2} = \cfrac{n-1}{2}
$$</p>
</li>
</ul>
<p><strong>插入操作时间复杂度：</strong></p>
<ul>
<li>最好情况（在第$n+1$个位置插入）：$O(1)$；</li>
<li>最坏情况（在第1个位置插入）：$O(n)$；</li>
<li>平均复杂度：$O(n)$。</li>
</ul>
<p><strong>链表插入和删除操作时间复杂度</strong>（带不带头节点的复杂度都一样）：</p>
<ul>
<li>最好情况（在$i=1$位置）：$O(1)$；</li>
<li>最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$</li>
<li>平均复杂度：$O(n)$</li>
</ul>
<h2 id="串的模式匹配">串的模式匹配</h2>
<p>朴素的模式匹配（布鲁特一福斯）算法：</p>
<p>设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：</p>
<ul>
<li>
<p>最好情况：$O(m)$，次数为$m$；</p>
</li>
<li>
<p>最坏情况：$O(n \times m)$，次数为$\cfrac{1}{2} m(n-m+2)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i\big( (i+1) \times m \big)} = \cfrac{m}{n-m+1} \sum_{i=0}^{n-m}{(i+1)} = \cfrac{1}{2} m(n-m+2)
$$</p>
</li>
<li>
<p>平均：$O(n+m)$，次数为$\cfrac{1}{2} (n+m)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i(i+m)} = \cfrac{1}{n-m+1} \sum_{i=0}^{n-m}{i+m} = \cfrac{1}{2} (n+m)
$$</p>
</li>
</ul>
<h2 id="数组">数组</h2>
<p>设：</p>
<ul>
<li>二维数组为$A[n,m]$，$n$为行数，$m$为列数；</li>
<li>数组元素$a_{i,j},\ 0 \le i \le n-1,\ 0 \le j \le m-1$；</li>
<li>$LOC(a_{i,j})$为元素$a_{i,j}$的地址；</li>
<li>$L$为单个元素的存储空间大小。</li>
</ul>
<p>则有：</p>
<ul>
<li>
<p>以行为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i \times n + j) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) \times n + (j-1) \big) \times L
$$</p>
</li>
<li>
<p>以列为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \times m) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) + (j-1) \times m \big) \times L
$$</p>
</li>
</ul>
<p><strong>对称矩阵：</strong></p>
<p>假设将$n$阶对称矩阵$A_{n \times n}$压缩存储到一维数组$B\left[ \cfrac{n(n+1)}{2} \right]$，则$B[k]\ (1 \le k \le \cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$之间存在一一对应关系（以行为主序）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i-1)}{2} + j, &amp; 当\ i \ge j \\
\cfrac{j(j-1)}{2} + i, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p>如果下标从0开始（第一个元素为$a_{00}$，$0 \le k \le \cfrac{n(n+1)}{2} - 1$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i+1)}{2} + j + 1, &amp; 当\ i \ge j \\
\cfrac{j(j+1)}{2} + i + 1, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p><strong>三对角矩阵：</strong></p>
<p>设有$n$阶三对角矩阵$A_{n \times n}$，将其非0元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$存储在一维数组$B[k](1 \le k \le 3 \times n - 2)$中，则元素位置之间的对应关系为：</p>
<p>$$
k = 3 \times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2
$$</p>
<p>如果下标从0开始（$0 \le k \le 3(n-1)$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k = 3 \times i - 1 + j - i + 1 + 1 = 2i + j + 1
$$</p>
<h2 id="树">树</h2>
<ul>
<li>
<p>设$n$个结点的树，$d_i \ (1 \le i \le n)$为该树中结点的度：</p>
<p>$$
n = (\sum_{i=1}^{n}{d_i})+1
$$</p>
<p><strong>度</strong>：结点拥有的子树数。</p>
</li>
<li>
<p>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \ge 1$）。</p>
</li>
<li>
<p>高度为$h$的$m$度树至多有$\cfrac{m^h-1}{m-1}$个结点。</p>
</li>
</ul>
<p><strong>二叉树：</strong></p>
<ul>
<li>
<p>第$i$层（$i \ge 1$）上<u>最多</u>有$2^{i-1}$个结点。</p>
</li>
<li>
<p>高度为$k$的二叉树最多有$2^k-1$个结点（$k \ge 1$）。</p>
</li>
<li>
<p>若二叉树终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。</p>
</li>
<li>
<p>具有$n$个结点的完全二叉树的深度（高度）为：</p>
<p>$$
\lfloor \log_2{n} \rfloor + 1;
$$</p>
<p>或：</p>
<p>$$
\lceil \log_2{(n+1)} \rceil
$$</p>
</li>
<li>
<p>二叉树形态总数（卡特兰数）：</p>
<p>$$
\cfrac{C^{n}_{2n}}{n+1}
$$</p>
</li>
</ul>
<p><strong>链式存储二叉树：</strong></p>
<p>设有$n$个结点的二叉树，则其<strong>空指针域数量</strong>：</p>
<ul>
<li>
<p>对于二叉链表：</p>
<ul>
<li>总指针域个数：$2n$；</li>
<li>分支数（子孙结点数，非空指针域个数）：$n-1$。</li>
</ul>
<p>可得：</p>
<p>$$
空指针域数=2n-(n-1)=n+1
$$</p>
</li>
<li>
<p>对于三叉链表：</p>
<ul>
<li>总指针域个数：$3n$；</li>
<li>分支数（子孙结点数）：$n-1$；</li>
<li>指向父结点且非空的指针域个数：$n-1$。</li>
</ul>
<p>即，非空指针域个数为：$2(n-1)$。</p>
<p>可得：</p>
<p>$$
空指针域数=3n-2(n-1)=n+2
$$</p>
</li>
</ul>
<p><strong>平衡二叉树：</strong></p>
<p>设一个二叉树的左右子树高度之差的绝对值为$d$，那么</p>
<ul>
<li>不平衡的二叉树：$d &gt; 1$；</li>
<li>平衡的二叉树：$d \le 1$。</li>
</ul>
<p><strong>哈夫曼树</strong>（最优二叉树）：带权路径长度最短。</p>
<p>设：</p>
<ul>
<li>带权叶子结点数：$n$；</li>
<li>叶子结点的权值：$w_k$；</li>
<li>叶子结点到根的路径长度：$l_k$。</li>
</ul>
<p>则树的带权路径长度为：</p>
<p>$$
WPL = \sum_{k=1}^{n}{w_kl_k}
$$</p>
<p>给定$n$个权值后，哈夫曼树的结点数$m$就确定了：</p>
<p>$$
m = 2 \times n - 1
$$</p>
<p><strong>哈夫曼压缩比：</strong></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680959771881.png"
	width="784"
	height="489"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="压缩比例题"
	
	
		class="gallery-image" 
		data-flex-grow="160"
		data-flex-basis="384px"
	
></p>
<ol>
<li>
<p>按照<u>出现频率</u>计算<u>加权平均长度</u>：</p>
<p>$$
加权平均长度 = \sum_{i=1}^{5}{字符i的位数 \times 字符i出现频率}
$$</p>
<p>即：</p>
<p>$$
1 \times 40% + 3 \times (10% + 20% + 16% + 14%) = 2.2
$$</p>
<p>压缩后平均长度为2.2。</p>
</li>
<li>
<p>计算压缩比：</p>
<p>$$
压缩比 = \cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度}
$$</p>
<p>即，</p>
<ul>
<li>
<p>编码5个字符至少需要3位：$2^2 &lt; 5 &lt; 2^3$，所以压缩前编码长度为3；</p>
</li>
<li>
<p>压缩比：</p>
<p>$$
\cfrac{3-2.2}{3} \approx 0.27
$$</p>
</li>
</ul>
</li>
</ol>
<h2 id="图">图</h2>
<p><strong>完全图</strong>：</p>
<ul>
<li>$n$个顶点的无向完全图共有$\cfrac{n(n-1)}{2}$条边。</li>
<li>$n$个顶点的有向完全图共有$n(n-1)$条边。</li>
</ul>
<p>对于所有的图，其所有顶点的度数之和 $= 2e$（$e$为边数）。</p>
<p>$n$个结点的连通图，它的边的取值范围是$[n-1,\cfrac{n(n-1)}{2}]$。</p>
<p>图的邻接矩阵：横$i$竖$j$，横出竖入。</p>
<p><strong>深度优先搜索：</strong></p>
<ol>
<li>设置搜索指针$p$，使$p$指向顶点$v$；</li>
<li>访问$p$所指顶点，并使$p$指向与其<u>相邻接的且尚未被访问过</u>的顶点。</li>
<li>若$p$所指顶点存在，则重复步骤2，否则执行步骤4。</li>
<li>沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。</li>
</ol>
<p><strong>广度优先搜索：</strong></p>
<ol>
<li>从图中的某个顶点$v$出发；</li>
<li>访问$v$后，依次访问$v$的各个未被访问过的邻接点；</li>
<li>分别从$v$的邻接点出发，依次访问它们的邻接点；</li>
<li>按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到；</li>
<li>若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。</li>
</ol>
<p>广度和深度优先搜索<strong>时间复杂度</strong>（一样）：</p>
<ul>
<li>邻接矩阵：$O(n^2)$；</li>
<li>邻接链表：$O(n+e)$。</li>
</ul>
<p><strong>AOV 网拓扑排序</strong>：如果所有顶点已输出，说明网中不存在回路，否则说明存在。</p>
<ol>
<li>在AOV网中选择一个入度为0的顶点且输出它。</li>
<li>从网中删除该顶点及与该顶点有关的所有弧。</li>
<li>重复上述两步，直到网中不存在入度为0的顶点为止。</li>
</ol>
<hr>
<h1 id="操作系统">操作系统</h1>
<p>跳转连接：<a class="link" href="/p/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%af%87/" >软件设计师——操作系统篇</a></p>
<h2 id="进程的三态">进程的三态</h2>
<ul>
<li><strong>运行</strong>：当一个进程在处理机上运行时。</li>
<li><strong>就绪</strong>：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行（还未得到）。</li>
<li><strong>阻塞</strong>（等待或睡眠）：一个进程正在等待某一事件发生而暂时停止运行，这时即使把处理机分配给进程也无法运行。</li>
</ul>
<h2 id="同步互斥">同步互斥</h2>
<ul>
<li>
<p><strong>同步</strong>：指在系统中一些需要相互合作，协同工作的进程。</p>
</li>
<li>
<p><strong>互斥</strong>：指系统中多个进程因争用临界资源而互斥执行。</p>
</li>
<li>
<p>临界资源（CR）：在多道程序系统环境中，那些一次只能供一个进程使用的资源。如打印机、共享变量和表格等。</p>
</li>
<li>
<p>临界区（CS）：是进程中对临界资源实施操作的那段程序。</p>
<p>互斥临界区管理的4条原则：有空即进、无空则等、有限等待和让权等待。</p>
</li>
</ul>
<h2 id="信号量">信号量</h2>
<ul>
<li>公用信号量：实现进程间的互斥，初值为<code>1</code>或资源的数目。</li>
<li>私用信号量：实现进程间的同步，初值为<code>0</code>或某个正整数。</li>
</ul>
<p>信号量$S$的物理意义：</p>
<ul>
<li>$S \ge 0$：表示某资源的可用数，此时<strong>有可用资源</strong>；</li>
<li>$S &lt; 0$：则其绝对值表示阻塞队列中等待该资源的进程数，此时无可用资源，并且有进程被阻塞。</li>
</ul>
<p>PV操作：P（申请）减V（释放）加。</p>
<ul>
<li>P操作$S &lt; 0$：无可用资源，置该进程为<strong>阻塞</strong>状态。</li>
<li>V操作$S \le 0$：表示释放前有程序被阻塞，从阻塞状态唤醒一个进程，并将其插入就绪队列。</li>
</ul>
<p>假定信号量S表示某条消息，进程可以：</p>
<ul>
<li>调用P操作：测试消息是否到达；</li>
<li>调用V操作：通知消息已经准备好。</li>
</ul>
<h2 id="死锁">死锁</h2>
<p>产生死锁的原因：</p>
<ul>
<li>进程间互相<u>竞争资源</u>。</li>
<li><u>进程推进顺序非法</u>。</li>
</ul>
<p>产生死锁的4个必要条件：</p>
<ul>
<li>互斥条件</li>
<li>请求保持条件</li>
<li>不可剥夺条件</li>
<li>环路条件</li>
</ul>
<p>发生死锁时，在进程资源有向图中必构成环路。</p>
<p>造成死锁的情况：</p>
<ul>
<li>进程推进顺序不当</li>
<li>同类资源分配不当</li>
<li>PV操作使用不当</li>
</ul>
<p>死锁的处理策略：</p>
<ul>
<li>鸵鸟策略（不理睬策略）</li>
<li>预防策略</li>
<li>避免策略</li>
<li>检测与解除死锁</li>
</ul>
<p>死锁预防：</p>
<ul>
<li>
<p>预先静态分配法：破坏了“不可剥夺条件”，<u>预先分配所需资源，保证不等待资源</u>。</p>
<p>该方法的问题是降低了对资源的利用率，降低进程的并发程度；有时可能无法预先知道所需资源。</p>
</li>
<li>
<p>资源有序分配法：破坏了“环路条件”，<u>把资源分类按顺序排列，保证不形成环路</u>。</p>
<p>该方法存在的问题是限制进程对资源的请求：由于资源的排序占用系统开销。</p>
</li>
</ul>
<p><img src="/p/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%af%87/#%e9%93%b6%e8%a1%8c%e5%ae%b6%e7%ae%97%e6%b3%95"
	
	
	
	loading="lazy"
	
		alt="银行家算法"
	
	
></p>
<h2 id="线程轻型进程">线程（轻型进程）</h2>
<ul>
<li>基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈）。</li>
<li>与其它同一进程的线程共享进程所拥有的全部资源。</li>
</ul>
<p>线程分为：</p>
<ul>
<li>用户级线程</li>
<li>内核支持线程</li>
</ul>
<h2 id="存储管理">存储管理</h2>
<p><strong>程序的局限性：</strong></p>
<ul>
<li>
<p><strong>时间局限性</strong>：</p>
<ul>
<li>如果程序中的某条<u>指令一旦执行</u>，则不久的将来该指令<u>可能再次被执行</u>；</li>
<li>如果某个<u>存储单元被访问</u>，则不久以后该存储单元<u>可能再次被访问</u>。</li>
</ul>
<p>产生时间局限性的典型原因是<u>在程序中存在着大量的循环操作</u>。</p>
</li>
<li>
<p><strong>空间局限性</strong>：指一旦<u>程序访问了某个存储单元</u>，则在不久的将来，<u>其附近的存储单元也最有可能被访问</u>。</p>
<p>即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为<u>程序是顺序执行的</u>。</p>
</li>
</ul>
<p><strong>段页式存储管理：</strong></p>
<ol>
<li>将整个主存划分成大小相等的存储块（页框）。</li>
<li>将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名。</li>
<li>将每个段划分成若干页，以页框为单位离散分配。</li>
</ol>
<h2 id="缓冲">缓冲</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189558038.png"
	width="1251"
	height="272"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189558038_huf41226c97da8111160feca89ef09c095_5839_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189558038_huf41226c97da8111160feca89ef09c095_5839_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="单缓冲并行工作示意图"
	
	
		class="gallery-image" 
		data-flex-grow="459"
		data-flex-basis="1103px"
	
></p>
<p>$n$个作业的单缓冲所花费的时间为：</p>
<p>$$
(Max(C, T) + M) \times n + Min(C, T)
$$</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189296831.png"
	width="1147"
	height="257"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189296831_hu582c92cd9e0fed45f58d15d99767bd10_23747_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189296831_hu582c92cd9e0fed45f58d15d99767bd10_23747_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="双缓冲并行工作示意图"
	
	
		class="gallery-image" 
		data-flex-grow="446"
		data-flex-basis="1071px"
	
></p>
<p>$n$个作业的双缓冲所花费的时间为：</p>
<p>$$
Max(T, M, C) \times n + T + M + C - Max(T, M, C)
$$</p>
<p>即，</p>
<p>$$
Max(T, M, C) \times (n - 1) + T + M + C
$$</p>
<h2 id="磁盘调度">磁盘调度</h2>
<ul>
<li>
<p><strong>先来先服务</strong>（First-Come First-Served，FCFS）：根据进程请求访问磁盘的先后次序进行调度。</p>
<ul>
<li>优点：公平、简单，且每个进程的请求都能依次得到处理，不会出现某进程的请求长期得不到满足的情况。</li>
<li>缺点：此算法由于未对寻道进行优化，致使平均寻道时间可能较长。</li>
</ul>
</li>
<li>
<p><strong>最短寻道时间优先</strong>（Shortest Seek Time First，SSTF，最短移臂算法）：该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，使得每次的寻道时间最短。</p>
<ul>
<li>优点：可能会出现饥饿现象。</li>
<li>缺点：不能保证平均寻道时间最短。</li>
</ul>
</li>
<li>
<p><strong>扫描算法</strong>（SCAN，电梯调度算法）：总是从磁头当前位置开始，沿磁头的移动方向去选择离当前磁头最近的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。</p>
<p>在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>
<ul>
<li>优点：避免了饥饿现象的出现。</li>
<li>缺点：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，再从外向里扫描完所有要访问的磁道后才处理该进程的请求，致使该进程的请求被严重地推迟。</li>
</ul>
</li>
<li>
<p><strong>单向扫描算法</strong>（CSCAN，循环扫描算法）：为了减少上述SCAN缺点中存在的这种延迟，算法规定磁头只做单向移动。</p>
<p>例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。</p>
</li>
</ul>
<h2 id="旋转调度算法">旋转调度算法</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683268410250.png"
	width="322"
	height="311"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683268410250_hua6d0da9a28446871d2f3485a4e0dfcf2_31100_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683268410250_hua6d0da9a28446871d2f3485a4e0dfcf2_31100_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="初始逻辑记录分布情况"
	
	
		class="gallery-image" 
		data-flex-grow="103"
		data-flex-basis="248px"
	
></p>
<p>设$n$个扇区的磁盘，经过一个扇区的时间为$t$，读取一个记录后处理的时间为$c$，那么：</p>
<ul>
<li>
<p>顺序处理完所有记录的总时间为：</p>
<p>$$
(t + nt) (n-1) + t + c
$$</p>
<p>即：</p>
<p>$$
t \times n^2 + c
$$</p>
</li>
<li>
<p>记录优化后的总时间：</p>
<p>$$
n(t + c)
$$</p>
</li>
</ul>
<h2 id="多级磁盘索引结构">多级磁盘索引结构</h2>
<ul>
<li>
<p><strong>直接索引</strong>：索引表中的地址项直接指向磁盘数据块。</p>
<p><img src="/uTools_1683271855209.png"
	
	
	
	loading="lazy"
	
		alt="直接索引"
	
	
></p>
</li>
<li>
<p><strong>一级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的记录是地址项，这些地址项直接指向磁盘数据块。</p>
<p>称这个磁盘索引块为<strong>一级索引块</strong>。</p>
<p><img src="/uTools_1683274982800.png"
	
	
	
	loading="lazy"
	
		alt="一级间接地址索引"
	
	
></p>
</li>
<li>
<p><strong>二级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的一个记录指向一个一级索引块。</p>
<p>称这个记录指向一级索引块的磁盘索引块为<strong>二级索引块</strong>。</p>
<p><img src="/uTools_1683275164015.png"
	
	
	
	loading="lazy"
	
		alt="二级间接地址索引"
	
	
></p>
</li>
</ul>
<hr>
<h1 id="面向对象">面向对象</h1>
<p>跳转连接：<a class="link" href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/" >软件设计师——面向对象篇</a></p>
<h2 id="设计原则">设计原则</h2>
<ul>
<li>
<p><strong>责任原则</strong>（Single Responsibility Principle，SRP）：当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</p>
</li>
<li>
<p><strong>开放封闭原则</strong>（Open &amp; Close Principle，OCP）：软件实体（类、模块、函数等）应
该可以扩展的，即<strong>开放的</strong>；但是不可修改的，即<strong>封闭的</strong>。</p>
</li>
<li>
<p><strong>里氏替换原则</strong>（Liskov Substitution Principle，LSP）：子类型必须能够替换掉他们的基
类型。</p>
<p>即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</p>
<p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。</p>
</li>
<li>
<p><strong>依赖倒置原则</strong>（Dependence Inversion Principle，DP）：抽象不应该依赖于细节，细
节应该依赖于抽象。即，<u>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</u>。</p>
</li>
<li>
<p><strong>接口分离原则</strong>（Interface Segregation Principle，ISP）：不应该强迫客户依赖于它们不
用的方法。接口属于客户，不属于它所在的类层次结构。</p>
<p>即：<u>依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。</u></p>
<p>这样做的好处就在于可以最大限度地应对可能的变化。</p>
</li>
</ul>
<p>Robert C. Martin提出的面向对象设计原则（重点的）：</p>
<ul>
<li><strong>共同封闭原则</strong>（Common Closure Principle，CCP）：包中的所有类对于同一类性质的变化应该是共同到闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</li>
<li><strong>共同重用原则</strong>（Common Reuse Principle，CRP）：一个包中的所有类应该是共同重用
的。如果重用了包中的一个类那么就要重用包中的所有类。</li>
</ul>
<h2 id="uml">UML</h2>
<p><a class="link" href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/#uml" >面向对象——UML</a></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">UML图</th>
<th style="text-align:center">静态建模</th>
<th style="text-align:center">动态建模</th>
<th style="text-align:center">物理建模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">构件图（组件图)</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">序列图（顺序图，时序图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">通信图（协作图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">状态图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
</tbody>
</table></div>
<p>活动图是一种特殊的状态图，它们的差异如下：</p>
<ul>
<li>相同点：状态中都有初态和终态。</li>
<li>主要差异：
<ul>
<li>活动图的转换称为流；</li>
<li>活动图有分支、并发分岔和并发汇合。</li>
</ul>
</li>
</ul>
<p>顺序图和通信图是同构的，它们之间可以相互转换。它们的差异如下：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:left"><center>序列图</center></th>
<th style="text-align:left"><center>通信图</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>强调</strong></td>
<td style="text-align:left"><center>消息时间顺序</center></td>
<td style="text-align:left"><center>收发消息的对象的结构组织</center></td>
</tr>
<tr>
<td style="text-align:center"><strong>不同的特性</strong></td>
<td style="text-align:left"><ul><li>有对象生命线：对象存在的时间段</li><li>有控制焦点：对象执行动作所经历的时间段</li></ul></td>
<td style="text-align:left"><ul><li>有路径：表示对象之间有交互</li><li>有序号：表示消息的时间顺序，可嵌套表示</li></ul></td>
</tr>
</tbody>
</table></div>
<p>以下是UML图的总结：</p>
<ul>
<li>
<p><strong>类图</strong>：展现一组<u>对象（类）</u>、<u>接口</u>、<u>协作</u>和它们之间的<u>关系</u></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061210921.png"
	width="619"
	height="467"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="类图示例"
	
	
		class="gallery-image" 
		data-flex-grow="132"
		data-flex-basis="318px"
	
></p>
</li>
<li>
<p><strong>对象图</strong>：展现某一时刻的一组<u>对象</u>以及它们之间的<u>关系</u>，描述了在类图中所建立事物的实例的静态快照</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061786263.png"
	width="713"
	height="312"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="对象图示例"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="548px"
	
></p>
</li>
<li>
<p><strong>用例图</strong>：展现了一组<u>用例</u>、<u>参与者</u>以及它们之间的<u>关系（包含、扩展、关联和泛化）</u></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682062071630.png"
	width="756"
	height="382"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="用例图示例"
	
	
		class="gallery-image" 
		data-flex-grow="197"
		data-flex-basis="474px"
	
></p>
</li>
<li>
<p><strong>序列图（顺序图，时序图）</strong>：描述了以<u>时间顺序</u>组织的<u>对象</u>之间的<u>交互活动</u>，强调<u>消息时间顺序</u></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682064874751.png"
	width="691"
	height="471"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="序列图示例"
	
	
		class="gallery-image" 
		data-flex-grow="146"
		data-flex-basis="352px"
	
></p>
</li>
<li>
<p><strong>通信图（协作图）</strong>：强调<u>收发消息的对象的结构组织</u></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682065157645.png"
	width="719"
	height="314"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="通信图"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="549px"
	
></p>
</li>
<li>
<p><strong>状态图（状态转换图）</strong>：展现了一个状态机，强调<u>对象行为的事件顺序</u></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682066287326.png"
	width="831"
	height="431"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="状态图示例"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="462px"
	
></p>
</li>
<li>
<p><strong>活动图</strong>：一种特殊的状态图，展现了在<u>系统内从一个活动到另一个活动的流程</u>，强调<u>对象间的控制流程</u></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1682067363114.png"
	width="654"
	height="744"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="活动图示例"
	
	
		class="gallery-image" 
		data-flex-grow="87"
		data-flex-basis="210px"
	
></p>
</li>
<li>
<p><strong>构件图（组件图)</strong>：展现了一组<u>构件之间的组织和依赖</u>，将构件映射为类、接口或协作</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682068370459.png"
	width="638"
	height="332"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682068370459_hue00d8420ae8e9d060383db5e372a8f97_47534_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682068370459_hue00d8420ae8e9d060383db5e372a8f97_47534_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="构件图示例"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="461px"
	
></p>
</li>
<li>
<p><strong>部署图</strong>：对物理建模，展现了<u>运行时处理结点以及其中构件（制品）的配置</u></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682073176388.png"
	width="491"
	height="327"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="部署图示例"
	
	
		class="gallery-image" 
		data-flex-grow="150"
		data-flex-basis="360px"
	
></p>
</li>
</ul>
<h2 id="设计模式">设计模式</h2>
<p><a class="link" href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" >面向对象——设计模式</a></p>
<p>设计模式代码仓库：<a class="link" href="https://gitee.com/linner_cheng/design-patterns"  target="_blank" rel="noopener"
    >https://gitee.com/linner_cheng/design-patterns</a></p>
<p>设计模式分类：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center"><br></th>
<th style="text-align:left">创建型</th>
<th style="text-align:left">结构型</th>
<th style="text-align:left">行为型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">说明</td>
<td style="text-align:left">与对象的创建有关</td>
<td style="text-align:left">处理类或对象的组合</td>
<td style="text-align:left">描述类或对象的交互和职责分配</td>
</tr>
<tr>
<td style="text-align:center">类模式</td>
<td style="text-align:left">Factory Method（工厂方法模式）</td>
<td style="text-align:left">Adapter（适配器模式）</td>
<td style="text-align:left">Interpreter（解释器模式）<br>Template Method（模板方法模式）</td>
</tr>
<tr>
<td style="text-align:center">对象模式</td>
<td style="text-align:left">Abstract Factory（抽象工厂模式）<br>Builder（生成器模式）<br>Prototype（原型模式）<br>Singleton（单例模式）</td>
<td style="text-align:left">Adapter（适配器模式）<br>Bridge（桥接模式）<br>Composite（组合模式）<br>Decorator（装饰器模式）<br>Facade（外观模式）<br>Flyweight（享元模式）<br>Proxy（代理模式）</td>
<td style="text-align:left">Chain of Responsibility（责任链模式）<br>Command（命令模式）<br>Iterator（迭代器模式）<br>Mediator（中介者模式）<br>Memento（备忘录模式）<br>Observer（观察者模式）<br>State（状态模式）<br>Strategy（策略模式）<br>Visitor（访问者模式）</td>
</tr>
</tbody>
</table></div>
<p>创建型设计模式（抽象了对象的实例化过程）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:center">动态生产对象</td>
<td style="text-align:left">定义创建对象的接口，由子类实例化对象。让类的实例化延迟到其子类。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:center">生成系列对象</td>
<td style="text-align:left">提供创建一系列对象的接口，无需指定具体的类。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:center">构造复杂对象</td>
<td style="text-align:left">将复杂对象的构建与表示分离。使得同样的构建可以创建不同的表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:center">克隆对象</td>
<td style="text-align:left">用原型实例指定创建对象的类型，通过复制原型来创建对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:center">一个实例</td>
<td style="text-align:left">保证一个类仅有一个实例，并提供一个全局访问点。</td>
</tr>
</tbody>
</table></div>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left"><ul><li>一个类不知道它所必须创建对象的类</li><li>由子类来指定创建的对象</li><li>将创建对象的职责委托给多个帮助子类中的某一个</li></ul></td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left"><ul><li>系统独立于它产品的创建、<u>组合</u>和表示</li><li>系统由多个产品系列中的一个来配置</li><li>强调一系列相关产品对象的设计，以便进行联合使用</li><li>提供一个产品类库，只显示它们的接口而不是实现</li></ul></td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left"><ul><li>创建复杂对象的算法，独立于该对象的组成部分以及它们的装配方式</li><li>构造过程必须允许被构造的对象有不同的表示</li></ul></td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left"><ul><li>系统独立于它产品创建、<u>构成</u>和表示</li><li>要实例化的类是在运行时刻指定，如动态装载</li><li>避免创建一个与产品类层次平行的工厂类层次</li></ul></td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left"><ul><li>类只能有一个实例，用户可从一个全局点访问</li><li>这个唯一实例是通过子类化可扩展的，客户无须更改代码就能使用扩展实例</li></ul></td>
</tr>
</tbody>
</table></div>
<p>结构型模式（组合类或对象获得新的结构）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器（类/对象）</td>
<td style="text-align:center">接口转换</td>
<td style="text-align:left">将类的接口转换成兼容其他类的接口。<br>使原本接口不兼容的类可以一起工作。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:center">抽象与实现分离</td>
<td style="text-align:left">将类的抽象与实现分离，使它们可以独立变化。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">组合对象</td>
<td style="text-align:left">将对象组合成树型结构以表示“部分——整体”的层次结构。<br>使得用户对单个对象和组合对象的使用具有一致性。</td>
</tr>
<tr>
<td style="text-align:center">装饰</td>
<td style="text-align:center">动态附加职责</td>
<td style="text-align:left">动态地给一个对象添加一些额外的职责，比用子类来扩展功能更灵活。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:center">对外统一接口</td>
<td style="text-align:left">为子系统定义和提供一个统一的对外高层接口（外观）。<br>简化了该子系统的使用。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:center">共享大量细粒度对象</td>
<td style="text-align:left">提供支持大量细粒度对象共享的有效方法。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:center">中介代理</td>
<td style="text-align:left">为其他对象提供一种代理以控制对这个对象的访问。</td>
</tr>
</tbody>
</table></div>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left"><ul><li>使用接口不符合要求的类</li><li>创建可复用、可与其它不相关类或不可预见类协同工作</li><li>（仅适用于对象适配器）想使用子类，但又不想对它们子类化来匹配接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left"><ul><li>在抽象和实现之间没有固定的绑定关系</li><li>抽象以及实现都可以通过生成子类的方法扩充</li><li>对抽象的实现部分的修改不会对用户产生影响</li><li>隐藏抽象的实现</li><li>在多个对象间共享实现，用户并不知道</li></ul></td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left"><ul><li>表示对象的部分——整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，并统一地使用它们</li></ul></td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left"><ul><li>不影响其他对象，而动态透明地添加职责</li><li>处理那些可以撤销的职责</li><li>不能采用子类进行扩充</li></ul></td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left"><ul><li>为一个复杂子系统提供一个简单接口</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性</li><li>需要构建一个层次结构的子系统时</li></ul></td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left"><ul><li>使用了大量的对象，造成很大开销</li><li>对象的大多数状态都可变为外部状态</li><li>删除对象的外部状态后，可以用相对较少的共享对象取代很多组对象</li></ul></td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left"><ul><li>在需要比较通用和复杂对象指针代替简单指针时</li></ul></td>
</tr>
</tbody>
</table></div>
<p>行为型模式：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:center">职责传递</td>
<td style="text-align:left">将处理请求的多个对象连成一条链，请求在链中传递，直到有对象处理。<br>给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:center">请求封装为对象</td>
<td style="text-align:left">将一个请求封装为一个对象，可用不同请求对客户进行参数化。<br>将请求排队或记录日志，支持撤销操作。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:center">语句解释</td>
<td style="text-align:left">给定一种语言，定义其文法和解释器，解释器根据文法解释语言中的句子。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:center">顺序访问数据集</td>
<td style="text-align:left">提供一个顺序访问聚合对象中元素的方法，不需要暴露对象的内部表示。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:center">不直接引用</td>
<td style="text-align:left">用对象封装一系列的对象交互。<br>使各对象不需显式地相互调用，达到低耦合。<br>可以独立改变对象间的交互。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:center">保存状态</td>
<td style="text-align:left">不破坏封装的前提下，捕获对象的内部状态，并在该对象之外保存。<br>可以在以后恢复保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:center">联动</td>
<td style="text-align:left">定义对象间的一种一对多依赖关系。<br>一个对象状态改变，所有依赖于它的对象都得到通知并被自动更新。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:center">状态封装成类</td>
<td style="text-align:left">把对象的行为封装在不同的状态对象中。<br>允许一个对象在其内部状态改变时改变它的行为。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:center">多方案切换</td>
<td style="text-align:left">定义并封装一系列算法，使它们可以在不影响客户端的情况下相互替换。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:center">框架</td>
<td style="text-align:left">定义一个操作中的算法骨架，让其子类来实现算法中的剩余逻辑。<br>可以不改变算法结构而重新定义其某些特定步骤。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:center">数据与操作分离</td>
<td style="text-align:left">封装作用与某对象结构中元素的操作。<br>可以在不改变元素类的前提下，定义或修改作用于这些元素的操作。</td>
</tr>
</tbody>
</table></div>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left"><ul><li>有多个对象处理请求，运行时刻自动确定由谁处理</li><li>不明指定接收者的情况下向多个对象中的一个提交请求</li><li>可处理请求的对象集合被动态指定</li></ul></td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left"><ul><li>抽象出待执行的动作以参数化某对象</li><li>不同的时刻指定、排列和执行请求</li><li>支持取消操作，支持修改日志</li></ul></td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left"><ul><li>文法简单</li><li>效率不是关键问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left"><ul><li>访问聚合对象的内容而不暴露其内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left"><ul><li>一组对象以复杂的方式进行通信</li><li>一个对象引用其他很多对象并且直接与这些对象通信</li><li>定制一个分布在多个类中的行为，而又不想生成太多的子类</li></ul></td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left"><ul><li>必须保存一个对象在某一个时刻的（部分）状态</li><li>如果用接口让其他对象直接得到这些状态，会暴露对象的实现细节并破坏对象的封装性</li></ul></td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left"><ul><li>当抽象模型有两个方面，其中一个方面依赖于另一个方面</li><li>当改变一个对象的同时需要改变其他对象，又不知道有多少对象待改变</li><li>当一个对象必须通知其他对象，又不能假定其他对象是谁（不能紧耦合）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left"><ul><li>对象的行为决定于它的状态，且在运行时刻根据状态改变行为</li><li>操作中含有庞大的多分支的条件语句</li></ul></td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left"><ul><li>许多相关的类仅仅是行为有异</li><li>需要使用一个算法的不同变体</li></ul></td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left"><ul><li>一次性实现算法中不变的部分，将可变的行为留给子类实现</li><li>各子类中公共行为被提取到公共父类中，避免代码重复</li></ul></td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left"><ul><li>对象结构包含很多类对象，用户想对这些对象实施操作</li><li>对对象结构中的对象进行很多不同且不相关的操作</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新操作</li></ul></td>
</tr>
</tbody>
</table></div>
<p>个人理解的方式：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">简述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left">具体工厂（工厂接口的实现）创建具体对象。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left">一个具体工厂（抽象工厂的子类）创建多个产品，不同工厂用不同方式创建这一系列产品。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left">复杂对象通过切换构建<code>construct(Builder)</code>来创建不同表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left">多个原型之间通过克隆<code>Prototype.clone()</code>来复制对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left">通过私有化无参构造方法、静态<code>Singleton instance</code>属性和静态<code>getInstance()</code>方法使对象保持单例。</td>
</tr>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left">适配器继承目标类，重写目标类的方法，方法将不兼容的接口包装成与目标类一致的接口。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left">将产品（抽象）与其某属性（实现）分开，通过桥接（组合）产品与其属性独立出来的类来制造不同产品。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left">用树形结构和一致的抽象类让部分和整体的操作一致。如文件树。</td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left">装饰器继承被装饰类，通过构造器传入被装饰对象，然后在与被装饰类一致的方法中添加新操作。多个装饰器嵌套可组成一条装饰链。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left">复杂子系统有很多操作，外观将其简化。跟适配器很像。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left">让一个对象假装成许多个对象。就是很多个对象之间可能有一部分属性的值是一样的，定义一个对象然后共享这部分属性。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left">代理就是给被代理对象加一些操作，跟适配器和外观不同的是代理的接口是与被代理对象一致的。</td>
</tr>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left">有多个接口一致的对象，将请求在这些对象间层层转发，请求可以被其中一个对象处理（JavaWeb里的过滤器）。和嵌套的装饰器很像。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left">就是一个命令一个对象，调用这些对象的方式一致（对象接口一致）。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left">解释语言的上下文。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left">在集合对象的外部，通过迭代器访问集合中的元素，对应的迭代器可由集合对象给出<code>iterator()</code>。跟Java里的迭代器一个样。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left">有多个类似对象，这些对象通过中介互相发送消息（就好像微信聊天一样，微信就是中介）。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left">捕获并保存对象的内部状态，并且可以恢复到原型保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left">在目标对象状态更新时，观察者们可以收到通知<code>update()</code>，然后更新自身状态，与目标对象的状态保持一致。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left">一个状态一个类，在状态中通过判断变换到其它状态。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left">就是动态切换算法。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left">模板实现算法操作中不变的部分，其余的交给子类去实现。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left">就是在<code>Visitor.visit(访问对象)</code>中定义对象的操作，然后在结构类中提供<code>accept(Visitor)</code>来访问这些对象。</td>
</tr>
</tbody>
</table></div>
<hr>
<h1 id="数据库">数据库</h1>
<p>跳转连接：<a class="link" href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/" >软件设计师——数据库篇</a></p>
<h2 id="三级模式两级映像">三级模式两级映像</h2>
<p><img src="/uTools_1681373319410.png"
	
	
	
	loading="lazy"
	
		alt="三级模式两级映像"
	
	
></p>
<p>三级结构有3类数据模型：</p>
<ul>
<li><strong>外模型</strong>：用户使用的<strong>数据视图</strong>，是一种局部的逻辑数据视图，表示用户所理解的实体、实体属性和实体关系。</li>
<li><strong>概念模型</strong>：全局的<strong>逻辑数据视图</strong>，是数据库管理员所看到的实体、实体属性和实体之间的联系。</li>
<li><strong>内模型</strong>：数据的物理<strong>存储模型</strong>。</li>
</ul>
<p>三个物理模型分别对应数据库系统的3层结构：</p>
<ul>
<li>
<p><strong>外模式（子模式、用户模式）</strong>：数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。</p>
</li>
<li>
<p><strong>概念模式（模式）</strong>：所有用户的公共数据视图，与具体的应用程序和应用程序开发工具无关。</p>
</li>
<li>
<p><strong>内模式（物理模式、存储模式）</strong>：是数据在数据库内部的表示方式。</p>
<p>定义<u>所有的<strong>内部记录类型</strong>、<strong>索引</strong>和<strong>文件</strong>的组织方式</u>。</p>
</li>
</ul>
<p>数据库系统在三级模式之间提供了两级映像：</p>
<ul>
<li>模式——内模式映像存在于<u>概念级和内部级</u>之间，实现<u>概念模式和内模式</u>间的相互转换。</li>
<li>外模式——模式映像：存在于<u>外部级和概念级</u>之间，实现了<u>外模式和概念模式</u>之间的相互转换。</li>
</ul>
<p>二级映像功能保证数据的独立性：</p>
<ul>
<li><strong>物理独立性</strong>：指当数据库的<u>内模式发生改变时，数据的逻辑结构不变</u>。</li>
<li><strong>逻辑独立性</strong>：指用户的<u>应用程序与数据库的逻辑结构是相互独立的</u>。</li>
</ul>
<h2 id="完整性约束">完整性约束</h2>
<ul>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义完整性</strong></li>
</ul>
<h2 id="关系代数运算符">关系代数运算符</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681431891302.png"
	width="735"
	height="301"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681431891302_hu474e5e1683bfce1832772e13dcf3cc90_42174_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681431891302_hu474e5e1683bfce1832772e13dcf3cc90_42174_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="关系代数运算符"
	
	
		class="gallery-image" 
		data-flex-grow="244"
		data-flex-basis="586px"
	
></p>
<ul>
<li>
<p><strong>广义笛卡儿积</strong>（Extended Cartesian Product）：两个元组分别为$n$目和$m$目的关系$R$和$S$的广义笛卡儿积是一个$(n+m)$列的元组的集合。</p>
<p>元组的前$n$列是关系$R$的一个元组，后$m$列是关系$S$的一个元组，记作$R \times S$，其形式定义如下：</p>
<p>$$
R \times S = \{ t| (t \ = \ &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \}
$$</p>
<p>如果$R$和$S$中有相同的属性名，可在属性名前加关系名作为限定，以示区别。若$R$有$K_1$,个元组，$S$有$K_2$个元组，则$R$和$S$的广义笛卡儿积有$K_1 \times K2$个元组。</p>
<blockquote>
<p>$&lt;t^n, t^m&gt;$是一个元组$t^n$和$t^m$拼接成的一个元组。</p>
</blockquote>
</li>
<li>
<p><strong>投影</strong>（Projection）：投影运算是从关系的<u>垂直方向</u>进行运算，在关系$R$中选出若干属性列$A$组成新的关系，记作$\pi_A (R)$，其形式定义如下：</p>
<p>$$
\pi_A (R) = \{ t[A]|t \in R \}
$$</p>
</li>
<li>
<p><strong>选择</strong>（Selection）：选择运算是从关系的<u>水平方向</u>进行运算，是从关系$R$中选择满足给定条件的诸元组，记作$\sigma_F (R)$其形式定义如下：</p>
<p>$$
\sigma_A (R) = \{ t| (t \in R) \wedge F(t) = True \}
$$</p>
<p>其中，$F(t)$中的运算对象可以是：</p>
<ul>
<li>属性名（或列的序号）；</li>
<li>常数；</li>
<li>运算符；</li>
<li>算术比较符（$&lt;, \le, &gt;, \ge, \neq$）；</li>
<li>逻辑运算符（$\wedge, \vee, \neg$）。</li>
</ul>
</li>
<li>
<p><strong>连接</strong>（Join）：连接运算是从两个关系$R$和$S$的笛卡儿积中选取满足条件的元组。</p>
<blockquote>
<p>可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。</p>
</blockquote>
<ul>
<li>
<p><strong>$\theta$连接</strong>：从$R$与$S$的笛卡儿积中选取属性间满足一定条件的元组。记作：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[X] \ \theta \ t^m[Y]) \}
$$</p>
<p>其中：</p>
<ul>
<li>$X \theta Y$：连接的条件；</li>
<li>$\theta$：比较运算符；</li>
<li>$X$和$Y$分别为$R$和$S$上度数相等且可比的属性组；</li>
<li>$t^n\left[ X \right]$表示$R$中$t^n$元组的对应于属性$X$的一个分量；</li>
<li>$t^m[Y]$表示$S$中$t^m$元组的对应于属性$Y$的一个分量。</li>
</ul>
<p>$\theta$连接也可以表示为：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] \ \theta \ t^m[j]) \}
$$</p>
<p>其中，</p>
<ul>
<li>
<p>$i=1,2,3,\cdots,n$；</p>
</li>
<li>
<p>$j=1,2,3,\cdots,m$；</p>
</li>
<li>
<p>$i \theta j$：</p>
<p>从两个关系$R$和$S$中选取$R$的第$i$列和$S$的第$j$列之间满足$\theta$运算的元组进行连接。</p>
</li>
</ul>
<p>$\theta$连接可以由基本的关系运算笛卡儿积和选取运算导出。因此，$\theta$连接可表示为：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \sigma_{X \theta Y}(R \times S)
$$</p>
<p>或：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \sigma_{i \theta j}(R \times S)
$$</p>
</li>
<li>
<p><strong>等值连接</strong>：当$\theta$为“=”时，称之为等值连接，记为$R \mathop{\Join}\limits_{i = j} S$，其形式定义如下：</p>
<p>$$
R \mathop{\Join}\limits_{i = j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] = t^m[j]) \}
$$</p>
</li>
<li>
<p>$F$连接：从关系$R$和$S$的笛卡尔积中选取属性值满足某一公式$F$的元组，记为$\mathop{\Join}\limits_{F}$。</p>
<p>$F$是形为$F_1 \wedge F_2 \wedge \cdots \wedge F_n$的公式，每个$F_p$是形为$i \theta j$的式子。</p>
</li>
<li>
<p><strong>自然连接</strong>：自然连接是一种特殊的等值连接，它要求两个关系中<u>进行比较的分量必须是相同的属性组</u>，并且在结果集中<u>将重复属性列去掉</u>。</p>
<p>若：</p>
<ul>
<li>
<p>$t^n \in R$，$t^m \in S$；</p>
</li>
<li>
<p>$R$和$S$具有相同的属性组$B$，且$B=(B_1,B_2,,B_k)$；</p>
</li>
<li>
<p>假定$R$关系的属性：</p>
<p>$$
A_1,A_2,\cdots,A_{n-k},B_1,B_2,\cdots,B_k
$$</p>
</li>
<li>
<p>$S$关系的属性：</p>
<p>$$
B_1,B2,\cdots,B_k,B_{k+1},B_{k+2},\cdots,B_m
$$</p>
</li>
</ul>
<p>自然连接可以记为$R \Join S$,其形式定义如下：</p>
<p>$$
R \Join S = \{ t| (t = &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (R.B_1 = S.B_1) \wedge (R.B_2 = S.B_2) \wedge \cdots \wedge (R.B_k = S.B_k) \}
$$</p>
</li>
</ul>
</li>
<li>
<p><strong>外连接</strong>（Outer Jion）：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。</p>
<p>外连接运算有3种：</p>
<ul>
<li>
<p><strong>左外连接</strong>（Left Outer Jion，⟕）：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值$null$充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>右外连接</strong>（Right Outer Jion，⟖）：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值$null$填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>全外连接</strong>（Full Outer Jion，⟗）。完成左外连接和右外连接的操作。</p>
</li>
</ul>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681454087063.png"
	width="762"
	height="575"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681454087063_hud13edc09469e2a4b2eff4fd4a8bf7c0a_99173_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681454087063_hud13edc09469e2a4b2eff4fd4a8bf7c0a_99173_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="132"
		data-flex-basis="318px"
	
></p>
</li>
</ul>
<h2 id="sql">SQL</h2>
<p><a class="link" href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#sql" >数据库篇——SQL</a></p>
<ol>
<li>
<p><strong>DDL</strong>（<strong>Data Definition Language</strong>，<strong>数据定义语言</strong>）：用来定义数据库对象：数据库，表，列等。</p>
<p>关键字：<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code> 等。</p>
</li>
<li>
<p><strong>DML</strong>（<strong>Data Manipulation Language</strong>，<strong>数据操作语言</strong>）：用来对数据库中表的数据进行增删改。</p>
<p>关键字：<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code> 等。</p>
</li>
<li>
<p><strong>DQL</strong>（<strong>Data Query Language</strong>，<strong>数据查询语言</strong>）：用来查询数据库中表的记录。</p>
<p>关键字：<code>SELECT</code>等。</p>
</li>
<li>
<p><strong>DCL</strong>（<strong>Data Control Language</strong>，<strong>数据控制语言</strong>）：用来定义数据库的访问权限和安全级别，及创建用户。</p>
</li>
</ol>
<p>授权语句格式（<code>GRANT</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">GRANT</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">权限</span><span style="color:#f92672">&gt;</span>[, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">权限</span><span style="color:#f92672">&gt;</span>] ...
[<span style="color:#66d9ef">ON</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">对象类型</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">对象名</span><span style="color:#f92672">&gt;</span>]
<span style="color:#66d9ef">TO</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">用户</span><span style="color:#f92672">&gt;</span>[, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">用户</span><span style="color:#f92672">&gt;</span>]...
[<span style="color:#66d9ef">WITH</span> <span style="color:#66d9ef">GRANT</span> <span style="color:#66d9ef">OPTION</span>];
</code></pre></div><p>常见的操作权限如下：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">对象类型</th>
<th style="text-align:left">操作权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">属性列</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">视图</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">基本表</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALTER</code>、<br><code>INDEX</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">数据库</td>
<td style="text-align:center"><code>DATABASE</code></td>
<td style="text-align:left"><code>CREATETAB</code></td>
</tr>
</tbody>
</table></div>
<ul>
<li>建立表的权限，可由DBA授予普通用户；</li>
<li><code>WITH GRANT OPTION</code>：表示获得了这些权限的用户还可以将权限赋给其他用户。</li>
</ul>
<p>收回权限语句格式（<code>REVOKE</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">REVOKE</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">权限</span><span style="color:#f92672">&gt;</span>[, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">权限</span><span style="color:#f92672">&gt;</span>]...
[<span style="color:#66d9ef">ON</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">对象类型</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">对象名</span><span style="color:#f92672">&gt;</span>]
<span style="color:#66d9ef">FROM</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">用户</span><span style="color:#f92672">&gt;</span>[, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">用户</span><span style="color:#f92672">&gt;</span>];
</code></pre></div><h2 id="函数依赖">函数依赖</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">结论</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">函数依赖</td>
<td style="text-align:left">元组在$X$上的属性值相等，那么在$Y$上的属性值也相等</td>
<td style="text-align:left">$X$函数决定$Y$或$Y$函数依赖于$X$，记作$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">非平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是非平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">完全函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$X' \subset X$，$X' \not\rightarrow Y$</td>
<td style="text-align:left">$Y$对$X$完全函数依赖，记作$X \stackrel{f}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">部分函数依赖（局部函数依赖）</td>
<td style="text-align:left">$X \rightarrow Y$，$X \stackrel{f}{\not\longrightarrow} Y$</td>
<td style="text-align:left">$Y$对$X$部分函数依赖，记作$X \stackrel{P}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">传递依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$，$Y \rightarrow Z$</td>
<td style="text-align:left">$Z$对$X$传递依赖</td>
</tr>
</tbody>
</table></div>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">码（候选码，候选关键字）</td>
<td style="text-align:left">若$K \stackrel{f}{\rightarrow} U$，则$K$为$R$的候选码</td>
</tr>
<tr>
<td style="text-align:center">主属性</td>
<td style="text-align:left">包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">非主属性</td>
<td style="text-align:left">不包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">外码</td>
<td style="text-align:left">$X$非$R$的码，但$X$是另一个关系的码，则称$X$为外码</td>
</tr>
</tbody>
</table></div>
<p>Armstrong公理系统：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">定律</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自反律</td>
<td style="text-align:left">$Y \subseteq X \subseteq U$</td>
<td style="text-align:left">$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">增广律</td>
<td style="text-align:left">$X \rightarrow Y$，$Z \subseteq U$</td>
<td style="text-align:left">$XZ \rightarrow XZ$</td>
</tr>
<tr>
<td style="text-align:center">传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ Y \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table></div>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">规则</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">合并规则</td>
<td style="text-align:left">$X \rightarrow Y,\ X \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow YZ$</td>
</tr>
<tr>
<td style="text-align:center">伪传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ WY \rightarrow Z$</td>
<td style="text-align:left">$XW \rightarrow Z$</td>
</tr>
<tr>
<td style="text-align:center">分解规则</td>
<td style="text-align:left">$X \rightarrow Y,\ Z \subseteq Y$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table></div>
<h2 id="关系模式的分解">关系模式的分解</h2>
<ul>
<li><a class="link" href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e6%97%a0%e6%8d%9f%e8%bf%9e%e6%8e%a5" >无损连接</a></li>
<li><a class="link" href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e4%bf%9d%e6%8c%81%e5%87%bd%e6%95%b0%e4%be%9d%e8%b5%96" >保持函数依赖</a></li>
</ul>
<h2 id="范式">范式</h2>
<p><a class="link" href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e8%8c%83%e5%bc%8f" >数据库篇——范式</a></p>
<ol>
<li>
<p>第一范式（1NF）：若关系模式R的<u>每一个分量是不可再分的数据项</u>，则关系模式R属于第一范式。</p>
<p>如，关系模式$R&lt;U,F&gt;$：</p>
<p>$$
U = \{ 学号,姓名,学院,院长,课程号,课程名,成绩 \} \\
F = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长,课程号 \rightarrow 课程名,(学号,课程号) \rightarrow 成绩 \}
$$</p>
</li>
<li>
<p>第二范式（2NF）：若关系模式$R \in 1NF$，且<u>每一个非主属性完全依赖于码</u>，则关系模式$R \in 2NF$。</p>
<p>即当<u>1NF消除了对主键的部分函数依赖后就能满足2NF</u>。</p>
<p>例如，$学号 \rightarrow 学院$，即$(学号,课程号) \stackrel{P}{\rightarrow} 学院$（部分依赖于码），所以$R \not\in 2NF$。</p>
<p><u>模式的分解需要保持函数依赖。</u>根据$F$，将$R$分解为：</p>
<ul>
<li>
<p>$R_1&lt;U_1,F_1&gt;$：</p>
<p>$$
U_1 = \{ 学号,姓名,学院,院长 \} \\
F_1 = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长 \}
$$</p>
</li>
<li>
<p>$R_2&lt;U_2,F_2&gt;$：</p>
<p>$$
U_2 = \{ 课程号,课程名 \} \\
F_2 = \{ 课程号 \rightarrow 课程名 \}
$$</p>
</li>
<li>
<p>$R_3&lt;U_3,F_3&gt;$：</p>
<p>$$
U_3 = \{ 学号,课程号,成绩 \} \\
F_3 = \{ (学号,课程号) \rightarrow 成绩 \}</p>
</li>
</ul>
<p>则，$R1 \in 2NF$，$R2 \in 2NF$，$R3 \in 2NF$。</p>
</li>
<li>
<p>第三范式（3NF）：若关系模式$R(R \in 2NF)$中<u>任何一个非主属性都不传递函数依赖于码</u>。</p>
<p>若关系模式$R&lt;U,F&gt;$（$U$为关系集，$F$为函数依赖集）中不存在这样的码$X$，使得：</p>
<ul>
<li>$X \rightarrow Y(Y \not\rightarrow X)$，</li>
<li>$Y \rightarrow Z$，</li>
</ul>
<p>则关系模式$R \in 3NF$，其中：</p>
<ul>
<li>$Y$为属性组，</li>
<li>$Z(Z \not\subseteq Y)$为非主属性。</li>
</ul>
<p>即当<u>2NF消除了非主属性对主键的传递函数依赖</u>，则称为3NF。</p>
<p>如，$R_1$中有$学号 \rightarrow 学院$，$学院 \rightarrow 院长$（非主属性&quot;院长&quot;传递依赖于主键&quot;学号&quot;）。可将$R_1$分解为：</p>
<ul>
<li>
<p>$R_{11}&lt;U_{11},F_{11}&gt;$：</p>
<p>$$
U_{11} = \{ 学号,姓名,学院 \} \\
F_{11} = \{ 学号 \rightarrow 姓名, 学号 \rightarrow 学院 \}
$$</p>
</li>
<li>
<p>$R_{12}&lt;U_{12},F_{12}&gt;$：</p>
<p>$$
U_{12} = \{ 学院,院长 \} \\
F_{12} = \{ 学院 \rightarrow 院长 \}
$$</p>
</li>
</ul>
</li>
</ol>
<p>范式之间的关系：</p>
<p>$$
5NF \sub 4NF \sub BCNF \sub 3NF \sub 2NF \sub 1NF
$$</p>
<p><img src="/uTools_1681894653450.png"
	
	
	
	loading="lazy"
	
		alt="规范化范式的包含关系"
	
	
></p>
<p>3NF和BCNE它们是进行规范化的主要目标。</p>
<p>1NF到4NF之间的转换关系：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">范式</th>
<th style="text-align:left">转换关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1NF</td>
<td style="text-align:left">每一个分量是不可再分的数据项</td>
</tr>
<tr>
<td style="text-align:center">2NF</td>
<td style="text-align:left">1NF消除了部分函数依赖后满足2NF</td>
</tr>
<tr>
<td style="text-align:center">3NF</td>
<td style="text-align:left">2NF消除了非主属性对码的传递函数依赖后满足3NF</td>
</tr>
<tr>
<td style="text-align:center">BCNF</td>
<td style="text-align:left">3NF消除了主属性对码的部分和传递函数依赖后满足BCNF</td>
</tr>
<tr>
<td style="text-align:center">4NF</td>
<td style="text-align:left">BCNF消除非平凡且非函数依赖的多值依赖后满足4NF</td>
</tr>
</tbody>
</table></div>
<p><img src="/uTools_1681988070233.png"
	
	
	
	loading="lazy"
	
		alt="规范化步骤"
	
	
></p>
<p>几种范式及其分解的性质：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">性质</th>
<th style="text-align:center">3NF</th>
<th style="text-align:center">BCNF</th>
<th style="text-align:center">4NF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">消除函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">消除多值函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">保持函数依赖</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left">保持多值函数依赖</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table></div>
<h2 id="数据库设计">数据库设计</h2>
<p><a class="link" href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1" >数据库篇——数据库设计</a></p>
<h2 id="分布式数据库">分布式数据库</h2>
<p>基本概念：</p>
<ul>
<li><strong>分片透明</strong></li>
<li><strong>复制透明</strong></li>
<li><strong>位置透明</strong></li>
<li><strong>逻辑透明</strong></li>
</ul>
<p>性质：</p>
<ul>
<li><strong>共享性</strong>：数据存储在不同的结点数据共享。</li>
<li><strong>自治性</strong>：指每结点对本地数据都能独立管理。</li>
<li><strong>可用性</strong>：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。</li>
<li><strong>分布性</strong></li>
</ul>
<hr>
<h1 id="结构化设计">结构化设计</h1>
<p>跳转连接：<a class="link" href="/p/%e7%bb%93%e6%9e%84%e5%8c%96%e8%ae%be%e8%ae%a1%e7%af%87/" >软件设计师——结构化设计篇</a></p>
<h2 id="模块化">模块化</h2>
<ul>
<li>
<p><strong>模块</strong>：是在程序中是数据说明、可执行语句等<u>程序对象的集合</u>，或者是单独命名和编址的元素，例如高级语言中的过程、函数和子程序等。</p>
<p>在软件的体系结构中，模块是可组合、分解和更换的单元。</p>
</li>
<li>
<p><strong>模块化</strong>：是指<u>将一个待开发的软件分解成若干个小的简单部分一模块</u>，<u>每个模块可独立地开发、测试，最后组装成完整的程序</u>。</p>
<p>这是一种<u>复杂问题“分而治之”的原则</u>。</p>
<p>模块化的<u>目的是使程序的结构清晰，容易阅读、理解、测试和修改。</u></p>
</li>
<li>
<p><strong>模块独立</strong>：是指<u>每个模块完成一个相对独立的特定子功能</u>，并且<u>与其他模块之间的联系简单</u>。</p>
<p>衡量模块独立程度的标准有（模块独立性的两个定性标准）：</p>
<ul>
<li><strong>耦合性</strong>；</li>
<li><strong>内聚性</strong>。</li>
</ul>
<p>在将软件系统划分模块时，应尽量做到<strong>高内聚</strong>、<strong>低耦合</strong>，提高模块的独立性。</p>
</li>
</ul>
<p>通常，可以按照在软件系统中的功能将模块分为四种类型：</p>
<ul>
<li>传入模块：取得数据或输入数据，经过某些处理，再将其传送给其他模块。</li>
<li>传出模块：输出数据，在输出前可能进行某些处理。数据可能被输出到系统的外部，或者会输出到其他模块进行进一步处理。</li>
<li>变换模块：从上级调用模块得到数据，进行特定的处理，转换成其他形式，再将加工结果返回给调用模块。</li>
<li>协调模块：一般不对数据进行加工，主要是通过调用、协调和管理其他模块来完成特定的功能。</li>
</ul>
<h2 id="耦合和内聚">耦合和内聚</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683443957893.png"
	width="874"
	height="133"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683443957893_hub7c8379d83566b7e880998eac437a73f_32408_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683443957893_hub7c8379d83566b7e880998eac437a73f_32408_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="耦合的种类"
	
	
		class="gallery-image" 
		data-flex-grow="657"
		data-flex-basis="1577px"
	
></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">耦合类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无直接耦合</td>
<td style="text-align:left">没有直接关系，不传递任何信息</td>
</tr>
<tr>
<td style="text-align:center">数据耦合</td>
<td style="text-align:left">调用关系，传递简单数据值</td>
</tr>
<tr>
<td style="text-align:center">标记耦合</td>
<td style="text-align:left">传递数据结构</td>
</tr>
<tr>
<td style="text-align:center">控制耦合</td>
<td style="text-align:left">调用关系，被调模块传递给主调模块控制变量</td>
</tr>
<tr>
<td style="text-align:center">外部耦合</td>
<td style="text-align:left">通过软件之外的环境联结</td>
</tr>
<tr>
<td style="text-align:center">公共耦合</td>
<td style="text-align:left">通过公共数据环境相互作用</td>
</tr>
<tr>
<td style="text-align:center">内容耦合</td>
<td style="text-align:left">直接使用另一个模块的内部数据<br>或通过非正常入口转入另一个模块内部</td>
</tr>
</tbody>
</table></div>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683460613634.png"
	width="852"
	height="150"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683460613634_hu1eaacf717e4a21f2e2077ba172b88635_37938_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683460613634_hu1eaacf717e4a21f2e2077ba172b88635_37938_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="内聚的种类"
	
	
		class="gallery-image" 
		data-flex-grow="568"
		data-flex-basis="1363px"
	
></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">内聚类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">偶然内聚<br>（巧合内聚）</td>
<td style="text-align:left">各处理之间没有任何联系</td>
</tr>
<tr>
<td style="text-align:center">逻辑内聚</td>
<td style="text-align:left">执行若干个逻辑上相似的功能，<br>通过参数确定该模块完成哪一个功能</td>
</tr>
<tr>
<td style="text-align:center">时间内聚</td>
<td style="text-align:left">把需要同时执行的动作组合在一起</td>
</tr>
<tr>
<td style="text-align:center">过程内聚</td>
<td style="text-align:left">完成多个任务，这些任务必须按指定的过程执行</td>
</tr>
<tr>
<td style="text-align:center">通信内聚</td>
<td style="text-align:left">所有处理都在同一个数据结构上操作，<br>或者各处理使用相同的输入数据或者产生相同的输出数据</td>
</tr>
<tr>
<td style="text-align:center">顺序内聚</td>
<td style="text-align:left">各处理都与同一功能密切相关且必须顺序执行，<br>前一功能元素的输出就是下一功能元素的输入</td>
</tr>
<tr>
<td style="text-align:center">功能内聚</td>
<td style="text-align:left">所有元素共同作用完成一个功能，缺一不可</td>
</tr>
</tbody>
</table></div>
<h2 id="系统结构设计原则">系统结构设计原则</h2>
<p>为保证总体结构设计顺利完成，应遵循以下几条原则：</p>
<ul>
<li>
<p><strong>分解——协调原则</strong>：</p>
<p>系统整体，具有其整体的目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。</p>
</li>
<li>
<p><strong>自顶向下的原则</strong>：从上往下，逐层分解；先确定上层模块的功能，再确定下层模块的功能。</p>
</li>
<li>
<p><strong>信息隐蔽、抽象的原则</strong>：<u>上层模块只规定下层模块做什么和所属模块间的协调关系，但不规定怎么做</u>。</p>
</li>
<li>
<p><strong>一致性原则</strong>：统一的规范、标准、文件模式……</p>
</li>
<li>
<p><strong>明确性原则</strong>：每个模块必须：</p>
<ul>
<li>功能明确、接口明确；</li>
<li>消除多重功能和无用接口。</li>
</ul>
</li>
<li>
<p><strong>高内聚、低耦合</strong></p>
</li>
<li>
<p><strong>模块的扇入系数和扇出系数要合理</strong>：</p>
<ul>
<li><strong>扇出系数</strong>：模块直接调用其他模块的个数。</li>
<li><strong>扇入系数</strong>：模块被其他模块调用时，直接调用它的模块个数。</li>
</ul>
<p><u>一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7</u>。</p>
</li>
<li>
<p><strong>模块的规模适当</strong>：</p>
<ul>
<li><u>过大的模块常常使系统分解得不充分；</u></li>
<li><u>过小的模块有可能降低模块的独立性，造成系统接口的复杂性。</u></li>
</ul>
</li>
<li>
<p><u>模块的作用范围应该在其控制范围之内。</u></p>
</li>
<li>
<p>避免或减少使用病态连接：病态连接是指从中部进入或访问一个模块。</p>
</li>
</ul>
<h2 id="系统文档">系统文档</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">人员</th>
<th style="text-align:center">阶段</th>
<th style="text-align:left">文档</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用户<br>系统分析人员</td>
<td style="text-align:center">系统规划<br>系统分析</td>
<td style="text-align:left">沟通文档，主要是<strong>规划报告</strong>、<strong>合同</strong>、<strong>方案</strong>：<br><ul><li>可行性研究报告</li><li>总体规划报告</li><li>系统开发合同</li><li>系统方案说明书</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>项目管理人员</td>
<td style="text-align:center">项目期内</td>
<td style="text-align:left">沟通文档（项目管理文件），主要是<strong>计划</strong>、<strong>报告</strong>类文档：<br><ul><li>系统开发计划<ul><li>工作任务分解表</li><li>PERT图</li><li>甘特图</li><li>预算分配表</li></ul></li><li>系统开发月报</li><li>系统开发总结报告</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统测试人员<br>系统开发人员</td>
<td style="text-align:center">测试</td>
<td style="text-align:left">系统测试人员根据以下文档对系统进行测试：<br><ul><li>系统方案说明书</li><li>系统开发合同</li><li>系统设计说明书</li><li>测试计划</li></ul>系统测试人员再将评估结果撰写成系统测试报告</td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>用户</td>
<td style="text-align:center">系统运行期间</td>
<td style="text-align:left">用户通过系统开发人员撰写的文档运行系统：<br><ul><li>用户手册</li><li>操作指南</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>系统维护人员</td>
<td style="text-align:center">维护</td>
<td style="text-align:left">沟通文档：<ul><li>系统设计说明书</li><li>系统开发总结报告<ul><li>研制报告</li><li>研制报告</li><li>技术手册</li></ul></li></ul></td>
</tr>
<tr>
<td style="text-align:center">用户<br>维修人员</td>
<td style="text-align:center">运维</td>
<td style="text-align:left">用户将运行过程中的问题进行记载：<ul><li>系统运行报告</li><li>维护修改建议</li></ul>系统维护人员根据以下文档对系统进行维护和升级：<ul><li>维护修改建议</li><li>系统开发人员留下的技术手册等文档</li></ul></td>
</tr>
</tbody>
</table></div>
<h2 id="数据流图和数据字典">数据流图和数据字典</h2>
<p><a class="link" href="/p/%e7%bb%93%e6%9e%84%e5%8c%96%e8%ae%be%e8%ae%a1%e7%af%87/#%e7%bb%93%e6%9e%84%e5%8c%96%e5%88%86%e6%9e%90%e6%96%b9%e6%b3%95" >结构化设计篇——结构化分析方法</a></p>
<hr>
<h1 id="软件工程">软件工程</h1>
<p>跳转连接：<a class="link" href="/p/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%af%87/" >软件设计师——软件工程篇</a></p>
<h2 id="软件过程模型">软件过程模型</h2>
<p>能力成熟度模型（从1开始）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">级别</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始级</td>
<td style="text-align:left">杂乱无章，几乎没有明确定义的步骤。</td>
</tr>
<tr>
<td style="text-align:center">可重复级</td>
<td style="text-align:left">建立基本的项目管理过程和实践来跟踪项目费用、进度和功能特性。</td>
</tr>
<tr>
<td style="text-align:center">已定义级</td>
<td style="text-align:left">将管理和工程文档化、标准化并综合成标准软件过程；<br>使用标准开发过程（或方法论）构建（或集成）系统。</td>
</tr>
<tr>
<td style="text-align:center">己管理级</td>
<td style="text-align:left">对软件过程和产品质量制定了的详细度量标准，且有定量的理解和控制。</td>
</tr>
<tr>
<td style="text-align:center">优化级</td>
<td style="text-align:left">加强了定量分析，通过过程质量和新观念、新技术使过程不断地改进。</td>
</tr>
</tbody>
</table></div>
<p>能力成熟度集成连续式模型（从0开始）：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">能力等级</th>
<th style="text-align:left">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未完成的</td>
<td style="text-align:left">未执行或未得到等级1中的所有目标。</td>
</tr>
<tr>
<td style="text-align:center">已执行的</td>
<td style="text-align:left">可标识的输入工作产品到输出工作产品的转换，实现特定目标。<p>关注：特定目标的完成。</p></td>
</tr>
<tr>
<td style="text-align:center">已管理的</td>
<td style="text-align:left">已管理的过程的制度化。<p>关注：针对单个过程实例的能力。</p></td>
</tr>
<tr>
<td style="text-align:center">已定义级的</td>
<td style="text-align:left">已定义的过程的制度化。<p>关注：过程的组织级标准化和部署。</p></td>
</tr>
<tr>
<td style="text-align:center">定量管理的</td>
<td style="text-align:left">可定量管理的过程的制度化。<p>说明：使用测量和质量保证来控制和改进。</p></td>
</tr>
<tr>
<td style="text-align:center">优化的</td>
<td style="text-align:left">优化的过程的制度化。<p>说明：使用量化手段改变和优化。</p></td>
</tr>
</tbody>
</table></div>
<p>各开发模型的适用范围：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瀑布模型</td>
<td style="text-align:left">将软件生存周期中的活动定为线性顺序链接的阶段模型</td>
<td style="text-align:left">需求明确、大致固定且变更少</td>
</tr>
<tr>
<td style="text-align:center">V模型</td>
<td style="text-align:left">瀑布模型的变体，强调测试贯穿项目的始终，是一种测试的开发模型</td>
<td style="text-align:left">需求明确、低风险</td>
</tr>
<tr>
<td style="text-align:center">增量模型</td>
<td style="text-align:left">融合瀑布模型和原型迭代，核心功能先完成，每轮迭代都会有新的增量，核心功能得到充分测试，强调每个增量均发布一个可操作的产品</td>
<td style="text-align:left">快速构造可运行的产品，产品升级，领域熟悉或已有原型</td>
</tr>
<tr>
<td style="text-align:center">演化模型</td>
<td style="text-align:left">迭代的过程模型，需求无法被完整定义，功能在使用过程中不断完善</td>
<td style="text-align:left">对软件需求缺乏准确认识的情况</td>
</tr>
<tr>
<td style="text-align:center">原型模型</td>
<td style="text-align:left">原型开发方法模型，目的是快速、低成本地构建原型系统</td>
<td style="text-align:left">需求不清或多变、领域陌生；不适合大规模系统</td>
</tr>
<tr>
<td style="text-align:center">螺旋模型</td>
<td style="text-align:left">结合瀑布和演化模型，强调引入风险分析，属于面向对象开发模型</td>
<td style="text-align:left">庞大、复杂、高风险的系统，开发人员有丰富的风险评估经验和知识</td>
</tr>
<tr>
<td style="text-align:center">喷泉模型</td>
<td style="text-align:left">面向对象模型，特点是迭代、无间隙和支持重用，各阶段无明显界限，可迭代交叉</td>
<td style="text-align:left">面向对象的开发过程</td>
</tr>
<tr>
<td style="text-align:center">统一过程</td>
<td style="text-align:left">用例驱动、以架构为中心、迭代和增量</td>
<td></td>
</tr>
</tbody>
</table></div>
<p>统一过程模型阶段里程碑和关注点总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">里程碑</th>
<th style="text-align:left">关注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始阶段</td>
<td style="text-align:left">生命周期目标</td>
<td style="text-align:left">项目的初创活动</td>
</tr>
<tr>
<td style="text-align:center">精化阶段</td>
<td style="text-align:left">生命周期架构</td>
<td style="text-align:left">需求分析和架构演进</td>
</tr>
<tr>
<td style="text-align:center">构建阶段</td>
<td style="text-align:left">初始运作功能</td>
<td style="text-align:left">系统的构建</td>
</tr>
<tr>
<td style="text-align:center">移交阶段</td>
<td style="text-align:left">产品发布</td>
<td style="text-align:left">软件提交方面的工作</td>
</tr>
</tbody>
</table></div>
<h2 id="软件需求">软件需求</h2>
<ul>
<li>
<p><strong>功能需求</strong>：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</p>
</li>
<li>
<p><strong>性能需求</strong>：考虑软件开发的技术性指标。</p>
<p>例如：</p>
<ul>
<li>存储容量限制；</li>
<li>执行速度；</li>
<li>响应时间；</li>
<li>吞吐量。</li>
</ul>
</li>
<li>
<p><strong>用户或人的因素</strong>：考虑用户的类型。</p>
<p>例如：</p>
<ul>
<li>各种用户对使用计算机的熟练程度，需要接受的训练；</li>
<li>用户理解、使用系统的难度；</li>
<li>用户错误操作系统的可能性。</li>
</ul>
</li>
<li>
<p><strong>环境需求</strong>：考虑未来软件应用的环境，包括硬件和软件。</p>
<ul>
<li>对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等；</li>
<li>对软件的需求包括：操作系统、网络、数据库等。</li>
</ul>
</li>
<li>
<p><strong>界面需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>来自其他系统的输入；</li>
<li>到其他系统的输出；</li>
<li>对数据格式的特殊规定；</li>
<li>对数据存储介质的规定。</li>
</ul>
</li>
<li>
<p><strong>文档需求</strong>：考虑需要哪些文档，文档针对哪些读者。</p>
</li>
<li>
<p><strong>数据需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>输入、输出数据的格式；</li>
<li>接收、发送数据的频率；</li>
<li>数据的准确性和精度；</li>
<li>数据流量；</li>
<li>数据需保持的时间。</li>
</ul>
</li>
<li>
<p><strong>资源使用需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>软件运行时所需要的数据、其他软件、内存空间等资源；</li>
<li>软件开发、维护时，所需的人力、支撑软件、开发设备。</li>
</ul>
</li>
<li>
<p><strong>安全保密要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>是否需要对访问系统或系统信息加以控制；</li>
<li>隔离用户数据的方法；</li>
<li>用户程序如何与其他程序和操作系统隔离</li>
<li>系统备份要求。</li>
</ul>
</li>
<li>
<p><strong>可靠性要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>系统的可靠性要求；</li>
<li>系统是否必须检测和隔离错误；</li>
<li>出错后，重启系统允许的时间。</li>
</ul>
</li>
<li>
<p><strong>软件成本消耗与开发进度需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>开发是否有规定的时间表；</li>
<li>软/硬件投资有无限制。</li>
</ul>
</li>
<li>
<p><strong>其他非功能性要求</strong>：</p>
<p>如采用某种开发模式，需要确定：</p>
<ul>
<li>质量控制标准；</li>
<li>里程碑和评审；</li>
<li>验收标准；</li>
<li>各种质量要求的优先级；</li>
<li>可维护性方面的要求。</li>
</ul>
</li>
</ul>
<h2 id="单元测试">单元测试</h2>
<p>在测试中应检查以下要点：</p>
<ul>
<li>
<p>模块接口：模块的接口保证了测试模块的数据流可以正确地流入、流出。</p>
<p>在测试中应检查以下要点：</p>
<ul>
<li>测试模块的<u>输入参数</u>和<u>形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用其他模块时，所给出的<u>实际参数</u>和<u>被调用模块的形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用标准函数时，所用的<u>参数在属性、数目和顺序上是否正确</u>。</li>
<li><u>全局变量在各模块中的定义和用法是否一致。</u></li>
<li><u>输入是否仅改变了形式参数。</u></li>
<li><u>开/关的语句</u>是否正确。</li>
<li>规定的<u>I/O格式</u>是否与输入/输出语句一致。</li>
<li>在使用文件之前是否已经打开文件或使用文件之后是否己经关闭文件。</li>
</ul>
</li>
<li>
<p>局部数据结构</p>
</li>
<li>
<p>重要的执行路径</p>
</li>
<li>
<p>出错处理</p>
</li>
<li>
<p>边界条件</p>
</li>
</ul>
<h2 id="集成测试">集成测试</h2>
<ul>
<li>
<p><strong>非增量集成</strong>：分别测试各个模块，再把这些模块组合起来进行整体测试。</p>
<ul>
<li>优点：可以对模块进行并行测试，能充分利用人力，并加快工程进度。</li>
<li>缺点：容易混乱，出现错误不容易查找和定位。</li>
</ul>
</li>
<li>
<p><strong>增量集成</strong>：以小增量的方式逐步进行构造和测试。</p>
<p>增量式测试的范围一步步扩大，错误容易定位，更易于对接口进行彻底测试，并且可以运用系统化的测试方法。</p>
</li>
</ul>
<p>增量集成策略：</p>
<ul>
<li>自项向下集成测试：从主控模块（主程序）开始，以深度优先或广度优先的方式。不需要驱动模块。</li>
<li>自底向上集成测试：从原子模块开始进行构造和测试。不需要桩模块。</li>
<li>回归测试</li>
<li>冒烟测试</li>
</ul>
<h2 id="测试方法">测试方法</h2>
<p>黑白盒测试法属于动态测试。设计测试用例时应包括合理的输入条件和不合理的输入条件。</p>
<h2 id="黑盒测试">黑盒测试</h2>
<p>等价类划分：从每个等价类中选取一个代表性数据作为测试用例。用少量代表性的测试用例取得较好的测试效果。</p>
<p>分为有效等价类和无效等价类。</p>
<p>定义等价类的原则如下。</p>
<ol>
<li>在<u>输入条件规定了取值范围或值的个数</u>的情况下，<u>可以定义1个有效等价类和2个无效等价类</u>。</li>
<li>在<u>输入条件规定了输入值的集合或规定了“必须如何”</u>的条件的情况下，<u>可以定义1个有效等价类和一个无效等价类</u>。</li>
<li>在输入条件是一个<u>布尔量</u>的情况下，<u>可以定义一个有效等价类和一个无效等价类</u>。</li>
<li>在<u>规定了输入数据的一组值（假定$n$个）</u>，并且程序要<u>对每一个输入值分别处理</u>的情况下，<u>可以定义$n$个有效等价类和1个无效等价类</u>。</li>
<li>在<u>规定了输入数据必须遵守的规则</u>的情况下，<u>可以定义一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</u>。</li>
<li>在确知己划分的等价类中，各元素在程序处理中的方式不同的情况下，则应将该等价类进一步划分为更小的等价类。</li>
</ol>
<p>无效等价类的划分：每个无效等价类的测试用例，<u>只违反一个输入的取值范围</u>。如果违反了多个输入的取值范围，那便是不好的测试用例。</p>
<p>例如，输入$x$的取值范围是$0 \sim 10$，输入$y$的取值范围是$-10 \sim -1$，那么可以定义三个等价类：</p>
<ul>
<li>有效等价类1：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类2：$x$的取值范围是$x &lt; 0 \ \ OR \ \ x &gt; 10$，输入$y$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类3：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$x &lt; -10 \ \ OR \ \ x &gt; -1$。</li>
</ul>
<p>除了等价类划分还有：</p>
<ul>
<li>边界值分析</li>
<li>错误推测</li>
<li>因果图</li>
</ul>
<h2 id="白盒测试">白盒测试</h2>
<p>逻辑覆盖：考察用测试数据运行被测程序时，对程序逻辑的覆盖程度。</p>
<p>主要的逻辑覆盖标准有6种，它们的覆盖程度从低到高为：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">逻辑覆盖</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语句覆盖</td>
<td style="text-align:left">每条语句执行一次</td>
</tr>
<tr>
<td style="text-align:center">分支（判定）覆盖</td>
<td style="text-align:left">每个分支获得一次True/False</td>
</tr>
<tr>
<td style="text-align:center">条件覆盖</td>
<td style="text-align:left">每个分支中的每个逻辑条件的所有可能取值满足一次</td>
</tr>
<tr>
<td style="text-align:center">判定/条件覆盖</td>
<td style="text-align:left">分支覆盖 + 条件覆盖</td>
</tr>
<tr>
<td style="text-align:center">条件组合覆盖</td>
<td style="text-align:left">每个判定中条件的各种可能值的组合都出现一次</td>
</tr>
<tr>
<td style="text-align:center">路径覆盖</td>
<td style="text-align:left">覆盖被测试程序中所有可能的路径</td>
</tr>
</tbody>
</table></div>
<p>除了逻辑覆盖还有：</p>
<ul>
<li>循环覆盖</li>
<li>基本路径测试</li>
</ul>
<h2 id="软件维护">软件维护</h2>
<p>正确性和完善性维护是针对来自系统内部的维护，适应性和预防性是针对来自系统外部的维护。</p>
<ul>
<li>
<p>正确性维护针对的是系统内部的错误。</p>
<p>来自系统内部的，与错误有关的都是属于正确性维护。</p>
</li>
<li>
<p>完善性维护针对的是系统内部与功能、性能等方面有关的维护。</p>
<p>来自系统内部的，与系统功能、性能等方面有关的改善都是完善性维护。完善性维护的需求可以来自外部，例如功能的扩展。</p>
</li>
<li>
<p>适应性维护是针对来自系统外部的技术、管理需求等方面的变化。</p>
<p>针对来自系统外部的变化，系统功能等方面没有缺失，仅仅只是适应当前环境变化所做的更改，都是属于适应性维护。</p>
</li>
<li>
<p>预防性维护针对的是未来的环境变化。</p>
</li>
</ul>
<h2 id="沟通路径">沟通路径</h2>
<p>软件项目中沟通路径$m$的计算公式（人数$n$）：</p>
<ul>
<li>
<p>沟通图中无主程序员时：</p>
<p>$$
m = \sum_{i=1}^{n} i-1 = \cfrac{(n-1)n}{2}
$$</p>
</li>
<li>
<p>沟通图中有主程序员时：</p>
<p>$$
m = n - 1
$$</p>
</li>
</ul>
<h2 id="估算模型">估算模型</h2>
<p>COCOMO模型：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">模型分类</th>
<th style="text-align:left">类型或说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本COCOMO模型</td>
<td style="text-align:left">静态单变量模型，对整个软件系统进行估算</td>
</tr>
<tr>
<td style="text-align:center">中级COCOMO模型</td>
<td style="text-align:left">静态多变量模型，将系统模型分为系统和部件2个层次</td>
</tr>
<tr>
<td style="text-align:center">详细COCOMO模型</td>
<td style="text-align:left">将系统模型分为系统、子系统和模块3个层次</td>
</tr>
<tr>
<td style="text-align:center">COCOMOII</td>
<td style="text-align:left">层次结构，分为应用组装模型、早期设计阶段模型和体系结构阶段模型</td>
</tr>
</tbody>
</table></div>
<p>COCOMOII的使用时期及规模估算选择：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">阶段性模型</th>
<th style="text-align:center">规模估算选择</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用组装模型</td>
<td style="text-align:center">对象点</td>
</tr>
<tr>
<td style="text-align:center">早期设计阶段模型</td>
<td style="text-align:center">功能点</td>
</tr>
<tr>
<td style="text-align:center">体系结构阶段模型</td>
<td style="text-align:center">代码行</td>
</tr>
</tbody>
</table></div>
<h2 id="甘特图和pert图">甘特图和PERT图</h2>
<p><a class="link" href="/p/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%af%87/#%e8%bf%9b%e5%ba%a6%e7%ae%a1%e7%90%86" >软件工程篇——项目进度管理</a></p>
<h2 id="风险分类">风险分类</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">项目风险</td>
<td style="text-align:left">威胁到项目计划。<p>风险因素：<br>预算、进度、人员、资源和利益相关者，项目复杂度、规模和结构的不确定性</p></td>
</tr>
<tr>
<td style="text-align:center">技术风险</td>
<td style="text-align:left">威胁到软件的质量及交付时间。<p>风险因素：<br>设计、实现、接口、验证和维护，规格说明的歧义性、技术的不确定性、技术陈旧和使用“前沿”技术</p></td>
</tr>
<tr>
<td style="text-align:center">市场风险</td>
<td style="text-align:left">开发了一个没有人真正需要的产品或系统。</td>
</tr>
<tr>
<td style="text-align:center">策略风险</td>
<td style="text-align:left">开发的产品不再符合公司的整体商业策略。</td>
</tr>
<tr>
<td style="text-align:center">销售风险</td>
<td style="text-align:left">开发了一个销售部门不知道如何去销售的产品。</td>
</tr>
<tr>
<td style="text-align:center">管理风险</td>
<td style="text-align:left">由于重点的转移或人员的变动而失去了高级管理层的支持。</td>
</tr>
<tr>
<td style="text-align:center">预算风险</td>
<td style="text-align:left">没有得到预算或人员的保证。</td>
</tr>
</tbody>
</table></div>
<p>风险管理总结：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">风险管理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">风险识别</td>
<td style="text-align:left">指出对项目计划的威胁。可通过建立风险条目检查表识别。</td>
</tr>
<tr>
<td style="text-align:center">风险预测</td>
<td style="text-align:left">从风险发生的可能性或概率、风险产生的后果评估可能发生的风险。</td>
</tr>
<tr>
<td style="text-align:center">风险评估</td>
<td style="text-align:left">从风险发生的概率和产生的影响评估风险。可用定义风险参照水准技术评估。</td>
</tr>
<tr>
<td style="text-align:center">风险控制</td>
<td style="text-align:left">目的是辅助项目建立处理风险的策略。策略是风险避免、风险监控和RMMM计划。</td>
</tr>
<tr>
<td style="text-align:center">风险避免</td>
<td style="text-align:left">应对风险的最好办法是主动地避免风险。</td>
</tr>
<tr>
<td style="text-align:center">风险监控</td>
<td style="text-align:left">项目管理者应监控某些可以提供风险高低变化指示的因素。</td>
</tr>
</tbody>
</table></div>
<h2 id="isoiec-9126-软件质量模型">ISO/IEC 9126 软件质量模型</h2>
<p>由3个层次组成：</p>
<ol>
<li>第一层：<strong>质量特性</strong></li>
<li>第二层：<strong>质量子特性</strong></li>
<li>第三层：<strong>度量指标</strong></li>
</ol>
<p>该模型的质量特性和质量子特性：</p>
<div class="table-wrapper"><table>
<tr>
    <th style="text-align: center;">
        质量特性
    </th>
    <th style="text-align: center;">
        质量子特性
    </th>
</tr>
<tr>
    <td style="text-align: center;" rowspan="6">
        <b>功能性</b>（Functionality）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适合性（Suitability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        准确性（Accurateness）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        互用性（Interoperability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        依从性（Compliance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        安全性（Security）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>可靠性</b>（Reliability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        成熟性（Maturity）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        容错性（Fault tolerance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易恢复性（Recoverability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>易使用性</b>（Usability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易理解性（Understandability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易学性（Learnability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易操作性（Operability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="3">
        <b>效率</b>（Efficiency）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        时间特性（Time behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        资源特性（Resource behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可维护性</b>（Maintainability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易分析性（Analyzability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易改变性（Changeability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        稳定性（Stability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易测试性（Testability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可移植性</b>（Portability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适应性（Adaptability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易安装性（Installability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        一致性（Conformance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易替换性（Replaceability）
    </td>
</tr>
</table></div>
<p>质量子特性的含义：</p>
<ul>
<li>功能性：
<ul>
<li><strong>适合性</strong>：与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性。</li>
<li><strong>准确性</strong>：与能够得到正确或相符的结果或效果有关的软件属性。</li>
<li><strong>互用性</strong>：<u>与其他指定系统进行交互操作</u>的能力相关的软件属性。</li>
<li><strong>依从性</strong>：<u>使软件服从有关的标准、约定、法规及类似规定</u>的软件属性。</li>
<li><strong>安全性</strong>：与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性。</li>
</ul>
</li>
<li>可靠性：
<ul>
<li><strong>成熟性</strong>：与由软件故障引起失效的频度有关的软件属性。</li>
<li><strong>容错性</strong>：与<u>在软件错误或违反指定接口的情况下维持指定的性能水平</u>的能力有关的软件属性。</li>
<li><strong>易恢复性</strong>：与<u>在故障发生后，重新建立其性能水平并恢复直接受影响数据</u>的能力，以及为达到此目的所需的时间和努力有关的软件属性。</li>
</ul>
</li>
<li>易使用性：
<ul>
<li><strong>易理解性</strong>：与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。</li>
<li><strong>易学性</strong>：与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。</li>
<li><strong>易操作性</strong>：与用户为进行操作和操作控制所付出的努力有关的软件属性。</li>
</ul>
</li>
<li>效率：
<ul>
<li><strong>时间特性</strong>：与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性。</li>
<li><strong>资源特性</strong>：与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。</li>
</ul>
</li>
<li>可维护性：
<ul>
<li><strong>易分析性</strong>：与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。</li>
<li><strong>易改变性</strong>：与进行修改、排错或适应环境变换所需努力有关的软件属性。</li>
<li><strong>稳定性</strong>：与修改造成未预料效果的风险有关的软件属性。</li>
<li><strong>易测试性</strong>：为确认经修改软件所需努力有关的软件属性。</li>
</ul>
</li>
<li>可移植性：
<ul>
<li><strong>适应性</strong>：与软件转移到不同环境时的处理或手段有关的软件属性。</li>
<li><strong>易安装性</strong>：与在指定环境下安装软件所需努力有关的软件属性。</li>
<li><strong>一致性</strong>：使软件服从与可移植性有关的标准或约定的软件属性。</li>
<li><strong>易替换性</strong>：与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="计算机网络">计算机网络</h2>
<h2 id="网络分类">网络分类</h2>
<p>按通信距离分类：</p>
<div class="table-wrapper"><table>
    <tr>
        <th style="text-align:center">
            网络分类
            </th>
        <th style="text-align:center">
            分布距离
        </th>
        <th style="text-align:center">
            计算机分布范围
        </th>
        <th style="text-align:center">
            传输速率
        </th>
    </tr>
    <tr>
        <td style="text-align:center" rowspan="4">
            <b>
                局域网
                <br>
                MAN
            </b>
        </td>
        <tr>
            <td>10m左右</td>
            <td>房间</td>
            <td rowspan="3">
                4Mbps ~ 1Gbps
            </td>
        </tr>
        <tr>
            <td>100m左右</td>
            <td>楼寓</td>
        </tr>
        <tr>
            <td>1000m左右</td>
            <td>校园</td>
        </tr>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                城域网
                <br>
                WAN
            </b>
        </td>
        <td>10km</td>
        <td>城市</td>
        <td>50Kbps ~ 100 Mbps</td>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                广域网
                <br>
                LAN
            </b>
        </td>
        <td>100km以上</td>
        <td>国家或全球</td>
        <td>9.6Kbps ~ 45Mbps</td>
    </tr>
</table></div>
<h2 id="isoosi-网络体系结构">ISO/OSI 网络体系结构</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875696461.png"
	width="390"
	height="339"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875696461_hu39205de4aab8f3d4638771bbe2a09e98_32206_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875696461_hu39205de4aab8f3d4638771bbe2a09e98_32206_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="OSI 参考模型"
	
	
		class="gallery-image" 
		data-flex-grow="115"
		data-flex-basis="276px"
	
></p>
<ul>
<li>通信子网对应于OSI中的低三层：
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
</ul>
</li>
<li>资源子网对应于OSI中的高三层：
<ul>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
</ul>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683877150679.png"
	width="724"
	height="404"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683877150679_hu64c4f9fea840087facedf4dd79f952ea_77141_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683877150679_hu64c4f9fea840087facedf4dd79f952ea_77141_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="ISO/OSI RM 内信息流动"
	
	
		class="gallery-image" 
		data-flex-grow="179"
		data-flex-basis="430px"
	
></p>
<h2 id="网络的拓扑结构">网络的拓扑结构</h2>
<ul>
<li>
<p>总线型结构：</p>
<p><img src="/uTools_1683875429976.png"
	
	
	
	loading="lazy"
	
		alt="总线型结构"
	
	
></p>
</li>
<li>
<p>星型结构：</p>
<p><img src="/uTools_1683875460651.png"
	
	
	
	loading="lazy"
	
		alt="星型结构"
	
	
></p>
</li>
<li>
<p>环型结构：</p>
<p><img src="/uTools_1683875485913.png"
	
	
	
	loading="lazy"
	
		alt="环型结构"
	
	
></p>
</li>
<li>
<p>树型结构：</p>
<p><img src="/uTools_1683875508387.png"
	
	
	
	loading="lazy"
	
		alt="树型结构"
	
	
></p>
</li>
<li>
<p>分布式结构：</p>
<p><img src="/uTools_1683875530047.png"
	
	
	
	loading="lazy"
	
		alt="分布式结构"
	
	
></p>
</li>
</ul>
<h2 id="网络设备">网络设备</h2>
<p>按照ISO/OSI的分层将互连设备分类：</p>
<ul>
<li>
<p>物理层设备：</p>
<ul>
<li>中继器（Repeater）</li>
<li>集线器（Hub）：一种多端口的中继器。集线器不能自动寻址，但可以检测发送冲突。</li>
</ul>
</li>
<li>
<p>数据链路层设备：</p>
<ul>
<li>
<p>网桥（Bridge）</p>
</li>
<li>
<p>交换机（Switch）：一种多端口的网桥。</p>
<p>交换技术：</p>
<ul>
<li>端口交换</li>
<li>帧交换</li>
<li>信元交换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络层设备：路由器（Router）</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683956321797.png"
	width="554"
	height="235"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683956321797_hu561f5310d4335c386da88596021542b0_86791_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683956321797_hu561f5310d4335c386da88596021542b0_86791_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="路由器类型"
	
	
		class="gallery-image" 
		data-flex-grow="235"
		data-flex-basis="565px"
	
></p>
</li>
<li>
<p>应用层设备：网关（Gateway）</p>
</li>
</ul>
<h2 id="网络传输介质">网络传输介质</h2>
<ul>
<li>有线介质：
<ul>
<li>双绞线（Twisted-Pair）</li>
<li>同轴电缆（Coaxial）</li>
<li>光纤（Fiber Optic）</li>
</ul>
</li>
<li>无线介质：
<ul>
<li>微波</li>
<li>红外线和激光</li>
<li>卫星通信</li>
</ul>
</li>
</ul>
<h2 id="lan-模型">LAN 模型</h2>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683879193227.png"
	width="397"
	height="252"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683879193227_hu88c8e8da15a4cc0b1b209d5e372c6435_32953_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683879193227_hu88c8e8da15a4cc0b1b209d5e372c6435_32953_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="LAN 层次与 ISO/OSI RM 的对应关系"
	
	
		class="gallery-image" 
		data-flex-grow="157"
		data-flex-basis="378px"
	
></p>
<h2 id="以太网">以太网</h2>
<ul>
<li>IEEE 802.3中定义的标准局域网，速度为10Mbps，传输介质为细同轴电缆；</li>
<li>IEEE 802.3u中定义的快速以太网，速度为100Mbps，传输介质为双绞线；</li>
<li>IEEE 802.3z中定义的千兆以太网，速度为1000Mbps，传输介质为光纤或双绞线。</li>
</ul>
<h2 id="tcpip-协议族">TCP/IP 协议族</h2>
<p>基本特性：</p>
<ul>
<li>逻辑编制：IP地址包括：
<ul>
<li>网络ID号：用来标识网络；</li>
<li>子网ID号：用来标识网络上的一个子网；</li>
<li>主机ID号：用来标识子网上的一台计算机。</li>
</ul>
</li>
<li>路由选择</li>
<li>域名（DNS）解析</li>
<li>错误检测</li>
<li>流量控制</li>
</ul>
<p>TCP/IP分层模型由4个层次构成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ol>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683880948768.png"
	width="697"
	height="339"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683880948768_huf85223c878afcabc7c687de01d9badd5_93199_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683880948768_huf85223c878afcabc7c687de01d9badd5_93199_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="TCP/IP 模型于 OSI 模型的对比"
	
	
		class="gallery-image" 
		data-flex-grow="205"
		data-flex-basis="493px"
	
></p>
<ul>
<li>
<p>TCP（传输控制协议）：在IP提供的不可靠数据服务的基础上为应用程序提供了<u>可靠的、面向连接的、全双工的</u>数据传输服务。</p>
<p>采用三次握手来确认建立和关闭连接是否成功。</p>
</li>
<li>
<p>UDP（用户数据报协议）：一种<u>不可靠的、无连接的</u>协议，可以保证应用程序进程间的通信。</p>
</li>
</ul>
<h2 id="地址解析协议">地址解析协议</h2>
<ul>
<li>ARP（地址解析协议）：将IP地址转换为MAC地址（物理地址）。</li>
<li>RARP（反地址解析协议）：将MAC地址转换为IP地址。</li>
</ul>
<h2 id="动态主机配置协议-dhcp">动态主机配置协议 DHCP</h2>
<p>DHCP客户端可以从DHCP服务器获得以下内容：</p>
<ul>
<li>本机IP地址</li>
<li>DNS服务器地址</li>
<li>DHCP服务器地址</li>
<li>默认网关的地址</li>
</ul>
<h2 id="无效地址">无效地址</h2>
<ul>
<li>
<p>Windows无效地址：169.254.X.X</p>
<p>169.254.X.X是Windows系统在DHCP信息租用失败时自动给客户机分配的IP地址。</p>
</li>
<li>
<p>Linux无效地址：0.0.0.0</p>
</li>
</ul>
<h2 id="域名和url">域名和URL</h2>
<pre tabindex="0"><code>主机名.本地名.组名.最高层域名
</code></pre><p>主机所在的网络级别较高：</p>
<pre tabindex="0"><code>本地名.组名.最高层域名
</code></pre><p>URL即统一资源定位器（统一资源定位符）：</p>
<pre tabindex="0"><code>协议名://主机名.域名.域名后缀.域名分类/目录/网页文件
</code></pre><h2 id="ip">IP</h2>
<p><strong>IPv4：</strong></p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683896541328.png"
	width="484"
	height="412"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683896541328_hu1b653364ebbdf1e76eb9cf18be092964_53037_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683896541328_hu1b653364ebbdf1e76eb9cf18be092964_53037_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="IPv4各类地址分配方案"
	
	
		class="gallery-image" 
		data-flex-grow="117"
		data-flex-basis="281px"
	
></p>
<p>全<code>0</code>代表的是网络，全<code>1</code>代表的是广播。</p>
<p>IPv4能表示的地址个数为：</p>
<p>$$
2^{32} \approx 40亿
$$</p>
<p><img src="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683897195900.png"
	width="912"
	height="144"
	srcset="/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683897195900_hue345962bd6503581635d067a0b6e714b_38818_480x0_resize_box_3.png 480w, /p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683897195900_hue345962bd6503581635d067a0b6e714b_38818_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="IP地址类默认的子网掩码"
	
	
		class="gallery-image" 
		data-flex-grow="633"
		data-flex-basis="1520px"
	
></p>
<p>**IPv6：**长达128位的地址空间，彻底解决IPv4地址不足的问题。</p>
<p>IPv6理论上能表示的地址个数：</p>
<p>$$
2^{128} = 3.4 \times 10^{38}
$$</p>
<h2 id="防火墙技术">防火墙技术</h2>
<p>防火墙技术是<u>建立在内外网络边界上的过滤封锁机制</u>，它认为：</p>
<ul>
<li><u>内部网络是安全和可信赖的</u>；</li>
<li><u>外部网络是不安全和不可信赖的</u>。</li>
</ul>
<p>防火墙的作用：<u>防止不希望的、未经授权地进出被保护的内部网络。</u></p>
<p>防火墙技术经历了三个发展阶段：</p>
<ol>
<li>包过滤防火墙</li>
<li>应用代理网关防火墙</li>
<li>状态检测技术防火墙</li>
</ol>
<h2 id="入侵检测">入侵检测</h2>
<p>入侵检测系统（DS）作为防火墙之后的第二道安全屏障。</p>
<p>入侵检测系统有效的弥补了防火墙系统对网络上的入侵行为无法识别和检测的不足。</p>
<p>入侵防御系统（IPS）是在入侵检测系统的基础上发展起来的，不仅能检测到网络中的攻击行为，同时主动对攻击行为发出响应，对攻击进行防御。</p>
<h2 id="网络攻击">网络攻击</h2>
<p>攻击目标对于攻击者是个黑盒子。</p>
<p>网络攻击手段有：</p>
<ul>
<li>拒绝服务攻击（Dos攻击）：使计算机或网络无法提供正常的服务通过不断向计算机发起请求来实现的。</li>
<li>重放攻击：攻击者发送一个目的主机已经接受过的报文来达到攻击目的。</li>
<li>口令入侵攻击。</li>
<li>特洛伊木马。</li>
<li>端口欺骗攻击。</li>
<li>网络监听。</li>
<li>IP欺骗攻击。</li>
<li>SQL注入攻击。</li>
</ul>
<h2 id="病毒">病毒</h2>
<p>病毒类型：</p>
<ul>
<li>
<p>Worm（蠕虫病毒）：</p>
<ul>
<li>欢乐时光，</li>
<li>熊猫烧香，</li>
<li>红色代码，</li>
<li>爱虫病毒，</li>
<li>震网。</li>
</ul>
</li>
<li>
<p>Trojan（特洛伊木马）：通过内部发起连接与外部主机建立联系，由外部主机控制并盗取用户信息。</p>
<p>计算机感染特洛伊木马后的典型线型是<u>有未知程序试图建立网络连接</u>。</p>
<p>常见的木马如冰河。</p>
</li>
<li>
<p>Backdoor（后门病毒）。</p>
</li>
<li>
<p>Macro（宏病毒）：</p>
<p>宏病毒感染的对象主要是<u>文本文档</u>、<u>电子表格</u>等。</p>
</li>
</ul>
<hr>
<h1 id="算法设计与分析">算法设计与分析</h1>
<p>跳转连接：<a class="link" href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/" >软件设计师——算法设计与分析篇</a></p>
<h2 id="算法设计方法">算法设计方法</h2>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">算法设计方法</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分治法</td>
<td style="text-align:left"><ol><li>将原问题<strong>分解</strong>成多个<u>与原问题相同的子问题</u></li><li><strong>递归地求解</strong>各子问题</li><li>将子问题的解<strong>合并</strong>成原问题的解</li></ol></td>
<td style="text-align:left">原问题规模大且能分解为多个与原问题相同的子问题</td>
<td style="text-align:left"><ul><li>归并排序</li><li>快速排序</li><li>最大字段和问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">动态规划法</td>
<td style="text-align:left"><ol><li>找出并刻画最优解的结构特征</li><li>递归地定义最优解的值</li><li>自底向上方式计算最优值或构造最优解</li></ol></td>
<td style="text-align:left">求解具有某种最优性质的问题</td>
<td style="text-align:left"><ul><li>0-1 背包问题</li><li>矩阵连乘</li><li>最长公共序列（LCS）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">贪心法</td>
<td style="text-align:left">与动态规划类似，但贪心法考虑的是局部最优解</td>
<td style="text-align:left">并不保证得到全局最优解，但通常能得到近似最优解</td>
<td style="text-align:left"><ul><li>活动选择问题</li><li>背包问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">回溯法</td>
<td style="text-align:left">在解空间树中，按<u>深度优先策略</u>，从根结点出发搜索解空间树</td>
<td style="text-align:left"><ul><li>可以搜索问题的所有解或任一解</li><li>适用于求解组合数较大的问题</li><li>通过限界函数减少问题的搜索空间</li></ul></td>
<td style="text-align:left"><ul><li>0-1背包问题</li><li>n皇后问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">分支限界法</td>
<td style="text-align:left">与回溯法类似，在解空间树种按<u>广度优先</u>或<u>最小耗费</u>优先方式，搜索满足约束条件的一个解</td>
<td style="text-align:left"><ul><li>可以给出<u>在某种意义下的最优解</u></li><li>分为队列式和优先队列式，优先队列式通过最大堆或最小堆实现</li></u></ul></td>
<td style="text-align:left"><ul><li>0-1 背包问题</li></ul></td>
</tr>
</tbody>
</table></div>
<h2 id="算法实例">算法实例</h2>
<p><a class="link" href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e7%ae%97%e6%b3%95%e5%ae%9e%e4%be%8b" >算法设计与分析篇——算法实例</a></p>
<h2 id="查找算法">查找算法</h2>
<p><a class="link" href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95" >算法设计与分析篇——查找算法</a></p>
<p>查找算法在查找成功时的<u>平均查找长度</u>关键字和给定值比较次数的期望值：</p>
<p>$$
ASL = \sum_{i=1}^{n}{P_iC_i}
$$</p>
<ul>
<li>
<p>$P_i$为对表中第$i$个记录进行查找的概率，</p>
<p>一般认为$P_i=\cfrac{1}{n}, 1 \le i \le n$，即$\sum_{i=1}^{n}{P_i}$；</p>
</li>
<li>
<p>$C_i$为查找成功时，已经进行过比较的关键字个数。</p>
</li>
</ul>
<p>静态查找表有以下查找方法：</p>
<ul>
<li>顺序查找；</li>
<li>折半查找；</li>
<li>分块查找。</li>
</ul>
<p>动态查找表有以下查找方法：</p>
<ul>
<li>二叉排序树；</li>
<li>平衡排序树；</li>
<li>B-树；</li>
<li>哈希表。</li>
</ul>
<p><strong>顺序查找</strong>中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：</p>
<p>$$
ASL_{ss} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i+1)} = \cfrac{n+1}{2}
$$</p>
<p><strong>折半查找</strong>的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：</p>
<p>$$
ASL_{bs} = \cfrac{1}{n} \sum_{i=1}^{n}{i \times 2^{i-1}} = \cfrac{n+1}{n} log_2{(n+1)} - 1
$$</p>
<p>当$n$值较大时，$ASL_{bs} \approx log_2{(n+1)} - 1$。</p>
<h2 id="哈希函数">哈希函数</h2>
<p><strong>哈希函数构造方法</strong>：</p>
<ul>
<li>直接定址法；</li>
<li>数字分析法；</li>
<li>平方取中法；</li>
<li>折叠法；</li>
<li>随机数法；</li>
<li>除留余数法</li>
</ul>
<p>哈希函数的构造要考虑到：</p>
<ul>
<li>压缩性：节省存储空间；</li>
<li>散列性：尽量减少冲突。</li>
</ul>
<p><strong>除留取余数法：</strong></p>
<p>$$
f(key)=key \enspace mod \enspace p\quad (p\le m),\ m为散列表长
$$</p>
<p><strong>冲突处理方法：</strong></p>
<ul>
<li>开放地址法；</li>
<li>多重散列法（再哈希法）；</li>
<li>链地址法；</li>
<li>公共溢出区法……</li>
</ul>
<p><strong>开放地址法</strong>（三种寻找空散列地址的方法）：</p>
<ul>
<li>
<p>线性探测法（线性探测再散列）：</p>
<p>$$
H_i=(H(key)+d) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$d$取$0,1,2,&hellip;,m-1$；</li>
<li>$m$为散列表的长度。</li>
</ul>
<p>$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。</p>
</li>
<li>
<p>二次探测法（二次探测再散列）：</p>
<p>$$
H_i=(H(key)+q^2) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$q$取$0,1,-1,2,-2,&hellip;,\pm k$，$k \le \cfrac{m}{2}$</li>
<li>$m$为散列表的长度</li>
</ul>
</li>
</ul>
<h2 id="排序算法">排序算法</h2>
<p><a class="link" href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" >算法设计与分析篇——排序算法</a></p>
<p>排序算法有稳定排序和不稳定排序两种。假设待排序序列中，$R_i$和$R_j$值相同，且$R_i$领先于$R_j$，排序后：</p>
<ul>
<li><strong>稳定排序</strong>：排序后$R_i$和$R_j$相对次序不变，$R_i$任领先于$R_j$；</li>
<li><strong>不稳定排序</strong>：排序后可能出现$R_j$领先于$R_i$的情况。</li>
</ul>
<p>根据记录存储的位置可分为：</p>
<ul>
<li><strong>内部排序</strong>：待排序记录存储在内存中进行排序的过程。</li>
<li><strong>外部排序</strong>：排序记录的数量很大，内存无法容纳全部记录，在排序过程需要对外存进行访问的排序过程。</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">最好时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">是否归位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(log_2{n})$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table></div>
<blockquote>
<p>是否归位：在排序过程中，能否确定某些元素的最终排序位置。</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E8%BD%AF%E8%80%83/">软考</a>
        
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a>
        
    </section>


    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
       
</article>


    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/">
        
        

        软考图类汇总篇</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AF%87/">
        
        

        算法设计与分析篇</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/">
        
        

        计算机网络篇</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AF%87/">
        
        

        软件工程篇</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E7%AF%87/">
        
        

        结构化开发篇</a>
</div>
</section>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 Linner&#39;s Blog

        <span style="padding-left: 5px;padding-right: 5px;">|</span>

        <a href="https://beian.miit.gov.cn/" target="_blank" >粤ICP备2022125602号-1</a>
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
