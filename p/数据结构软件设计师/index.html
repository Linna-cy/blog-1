<!DOCTYPE html>
<html lang="zh" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='复杂度 大O表示法 算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。
 加法规则：多项相加，保留最高阶项，并将系数化为1； 乘法规则：多项相乘都保留，并将系数化为1。  递归式的时间（空间）复杂度：
$$ 递归的次数 \times 每次递归的时间（空间）复杂度 $$
渐进符号 可以用渐进符号来表示渐进复杂度。
渐进符号包括：
  $O$：算法运行时间的渐进上界。
给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le f(n) \le cg(n) \}$。
即，当$n \ge n_0$时，$f(n) \le c \cdot g(n)$。
  $\Omega$：算法运行时间的渐进下界。
给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le cg(n) \le f(n) \}$。
即，当$n \ge n_0$时，$c \cdot g(n) \le f(n)$。'>


<title>数据结构（软件设计师）</title>

<link rel='canonical' href='https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/'>

<link rel="stylesheet" href="/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css">
<link rel="stylesheet" href="/css/katex.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<script src="/js/katex.min.js"></script><meta property='og:title' content='数据结构（软件设计师）'>
<meta property='og:description' content='复杂度 大O表示法 算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。
 加法规则：多项相加，保留最高阶项，并将系数化为1； 乘法规则：多项相乘都保留，并将系数化为1。  递归式的时间（空间）复杂度：
$$ 递归的次数 \times 每次递归的时间（空间）复杂度 $$
渐进符号 可以用渐进符号来表示渐进复杂度。
渐进符号包括：
  $O$：算法运行时间的渐进上界。
给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le f(n) \le cg(n) \}$。
即，当$n \ge n_0$时，$f(n) \le c \cdot g(n)$。
  $\Omega$：算法运行时间的渐进下界。
给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le cg(n) \le f(n) \}$。
即，当$n \ge n_0$时，$c \cdot g(n) \le f(n)$。'>
<meta property='og:url' content='https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/'>
<meta property='og:site_name' content='Linner&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='软考' /><meta property='article:tag' content='软件设计师' /><meta property='article:tag' content='数据结构' /><meta property='article:tag' content='算法' /><meta property='article:published_time' content='2023-04-04T17:17:20&#43;08:00'/><meta property='article:modified_time' content='2023-04-04T17:17:20&#43;08:00'/>
<meta name="twitter:title" content="数据结构（软件设计师）">
<meta name="twitter:description" content="复杂度 大O表示法 算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。
 加法规则：多项相加，保留最高阶项，并将系数化为1； 乘法规则：多项相乘都保留，并将系数化为1。  递归式的时间（空间）复杂度：
$$ 递归的次数 \times 每次递归的时间（空间）复杂度 $$
渐进符号 可以用渐进符号来表示渐进复杂度。
渐进符号包括：
  $O$：算法运行时间的渐进上界。
给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le f(n) \le cg(n) \}$。
即，当$n \ge n_0$时，$f(n) \le c \cdot g(n)$。
  $\Omega$：算法运行时间的渐进下界。
给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le cg(n) \le f(n) \}$。
即，当$n \ge n_0$时，$c \cdot g(n) \le f(n)$。">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu0c2331fe09320137a3bd1d4b5cc68791_142496_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Linner&#39;s Blog</a></h1>
            <h2 class="site-description">随便看看就行，副标题暂时还没想好</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/Linna-cy'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>

                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives" id="toc-list">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents" class="js-toc"></nav>
            
        </div>
    </section>


            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/" >
                软件设计师
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">数据结构（软件设计师）</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Apr 04, 2023</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="复杂度">复杂度</h1>
<h2 id="大o表示法">大O表示法</h2>
<p>算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1681099842666.png"
	width="1014"
	height="100"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1681099842666_hu8fb0d0a3c83abecf36c375990db2efe0_51379_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1681099842666_hu8fb0d0a3c83abecf36c375990db2efe0_51379_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="1014"
		data-flex-basis="2433px"
	
></p>
<ul>
<li>加法规则：多项相加，保留最高阶项，并将系数化为1；</li>
<li>乘法规则：多项相乘都保留，并将系数化为1。</li>
</ul>
<p>递归式的时间（空间）复杂度：</p>
<p>$$
递归的次数 \times 每次递归的时间（空间）复杂度
$$</p>
<h2 id="渐进符号">渐进符号</h2>
<p>可以用渐进符号来表示渐进复杂度。</p>
<p>渐进符号包括：</p>
<ul>
<li>
<p>$O$：算法运行时间的渐进上界。</p>
<p>给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le f(n) \le cg(n) \}$。</p>
<p>即，当$n \ge n_0$时，$f(n) \le c \cdot g(n)$。</p>
</li>
<li>
<p>$\Omega$：算法运行时间的渐进下界。</p>
<p>给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le cg(n) \le f(n) \}$。</p>
<p>即，当$n \ge n_0$时，$c \cdot g(n) \le f(n)$。</p>
</li>
<li>
<p>$\Theta$：算法运行时间的渐进上界和渐进下界，即渐进紧致界（又叫紧缺界）。</p>
<p>给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c_1、c_2和n_0,使得\forall n \ge n_0, 有 0 \le c_1g(n) \le f(n) \le c_2g(n) \}$。</p>
<p>即，当$n \ge n_0$时，$c_1g(n) \le f(n) \le c_2g(n)$。</p>
</li>
</ul>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681110832416.png"
	width="966"
	height="1204"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681110832416_hud8e84328d379d2eda520e5c710188239_380512_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681110832416_hud8e84328d379d2eda520e5c710188239_380512_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="递归式主方法"
	
	
		class="gallery-image" 
		data-flex-grow="80"
		data-flex-basis="192px"
	
></p>
<h1 id="逻辑结构分类">逻辑结构分类</h1>
<ul>
<li>线性结构
<ul>
<li>线性表（一般线性表）</li>
<li>特殊线性表
<ul>
<li>栈</li>
<li>队列</li>
<li>字符串</li>
</ul>
</li>
<li>线性表的推广
<ul>
<li>数组</li>
<li>广义表</li>
</ul>
</li>
</ul>
</li>
<li>非线性结构
<ul>
<li>树结构
<ul>
<li>二叉树</li>
<li>多叉树</li>
</ul>
</li>
<li>图结构
<ul>
<li>有向图</li>
<li>无向图</li>
</ul>
</li>
<li>集合结构</li>
</ul>
</li>
</ul>
<hr>
<h1 id="线性表">线性表</h1>
<p><u>由 $n(n\geq 0)$ 个<strong>数据特性相同</strong>的元素构成的<strong>有限序列</strong>称为<strong>线性表</strong></u>。$n=0$ 时，称为空表。非空表的特点如下：</p>
<ul>
<li>存在唯一一个“第一个”元素。</li>
<li>存在唯一一个“最后一个”元素。</li>
<li>相邻元素之间存在序偶关系：
<ul>
<li>除第一个之外，结构中的每个数据元素均只有一个<strong>前驱</strong>；</li>
<li>除最后一个之外，结构中的每个数据元素均只有一个<strong>后继</strong>。</li>
</ul>
</li>
</ul>
<p>线性表的存储结构分为：</p>
<ul>
<li>顺序存储；</li>
<li>链式存储</li>
</ul>
<h2 id="顺序存储结构">顺序存储结构</h2>
<p>线性表的<strong>顺序存储</strong>是指用一组<strong>地址连续的存储单元</strong>依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。在这种存储方式下，元素间的逻辑关系无须占用额外的空间来存储。</p>
<p>其存储结构如图所示：</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610120418.png"
	width="130"
	height="266"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610120418_hu2b33a584fc5a2d635ec65d6abeb2f0a4_3927_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610120418_hu2b33a584fc5a2d635ec65d6abeb2f0a4_3927_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="顺序表存储结构"
	
	
		class="gallery-image" 
		data-flex-grow="48"
		data-flex-basis="117px"
	
></p>
<p>假设线性表的每个元素占用的存储空间为$L$，$LOC(a_i)$为第$i$个元素的存储位置（$0 \le i \le n-1$，$n$为线性表的长度）：</p>
<ul>
<li>
<p>第$i+1$个元素和第$i$个元素的存储位置满足：</p>
<p>$$
LOC(a_{i+1})=LOC(a_i)+L
$$</p>
</li>
<li>
<p>第$i$个元素的存储位置：</p>
<p>$$
LOC(a_i)=LOC(a_0) + i \times L
$$</p>
<p>如果下标从1开始：</p>
<p>$$
LOC(a_i)=LOC(a_1) + (i-1) \times L
$$</p>
</li>
</ul>
<p>顺序存储结构的线性表的特点：</p>
<ul>
<li>优点：<strong>可以随机存取表中的元素</strong>，不需要额外的存储空间来表达元素之间的逻辑关系；</li>
<li>缺点：<strong>插入和删除操作不方便、效率低、比较耗时</strong>（<strong>插入和删除操作需要移动元素</strong>），顺序表的长度是固定的。</li>
</ul>
<p>在表厂为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：</p>
<ul>
<li>
<p>在第$i$个插入位置插入，需要移动$n+1-i$个元素。</p>
<ul>
<li>在第1个位置插入（$a_1$）需要移动$n$个元素；</li>
<li>在第$n+1$个位置插入（$a_n$后面）不需要移动元素。</li>
</ul>
</li>
<li>
<p>设在第$i$个插入位置插入的概率为$p_i$，<u>等概率下</u>（假如这$n+1$个插入位置插入的概率相同）<u>插入</u>一个新元素需要移动的元素个数的<u>期望值$E_{insert}$</u>为：</p>
<p>$$
E_{insert} = \sum_{i=1}^{n+1}{ \Big( p_i \times (n-i+1) \Big) } = \cfrac{1}{n+1} \sum_{i=1}^{n+1}{(n-i+1)} = \cfrac{n+1}{2}
$$</p>
<p>$$
p_i = \cfrac{1}{n+1}
$$</p>
<p>即，$E_{insert} = \cfrac{插入位置数-1}{2} = \cfrac{n+1}{2}$</p>
</li>
</ul>
<p>在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：</p>
<ul>
<li>
<p>删除第$i$个元素$a_i$需要移动$n-i$个元素。</p>
<ul>
<li>删除元素$a_1$需要移动$n-1$个元素；</li>
<li>删除元素$a_n$不需要移动元素。</li>
</ul>
</li>
<li>
<p>设$a_i$被删除的概率为$q_i$，<u>等概率下删除元素</u>时需要移动的元素个数的<u>期望值$E_{delete}$</u>为：</p>
<p>$$
E_{delete} = \sum_{i=1}^{n}{\Big( q_i \times (n-i) \Big)} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i)} = \cfrac{n-1}{2}
$$</p>
<p>$$
q_i = \cfrac{1}{n}
$$</p>
<p>即，$E_{delete} = \cfrac{删除位置数}{2} = \cfrac{n-1}{2}$</p>
</li>
</ul>
<p><strong>插入操作时间复杂度</strong>：</p>
<ul>
<li>最好情况（在第$n+1$个位置插入）：$O(1)$；</li>
<li>最坏情况（在第1个位置插入）：$O(n)$；</li>
<li>平均复杂度：$O(n)$。</li>
</ul>
<p><strong>查找元素时间复杂度</strong>（根据下标查找）：$O(1)$。</p>
<h2 id="链式存储结构">链式存储结构</h2>
<p>线性表的<strong>链式存储</strong>是指<strong>通过指针链接起来</strong>的结点来存储数据元素。</p>
<p>其存储结构如下所示：</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610469403.png"
	width="403"
	height="49"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610469403_hueeee19018a01756f2e48de06f8910c88_6757_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610469403_hueeee19018a01756f2e48de06f8910c88_6757_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="链式表存储结构"
	
	
		class="gallery-image" 
		data-flex-grow="822"
		data-flex-basis="1973px"
	
></p>
<ul>
<li>
<p><strong>数据域</strong>：用于存储数据元素的<strong>值</strong>；</p>
</li>
<li>
<p><strong>指针域</strong>：用于存储当前元素的直接前驱或直接后继的<strong>位置信息</strong>（直接前或后驱的<strong>指针</strong>，称其为指针或链）。</p>
<p>存储各数据元素的结点的<u>地址并不要求是连续的</u>，因此存储数据元素的同时必须存储元素之间的逻辑关系。</p>
</li>
</ul>
<p>链式表的特点：</p>
<ul>
<li><u>结点空间只有在需要的时候才申请</u>，无须事先分配；</li>
<li>长度不固定。</li>
</ul>
<p>链式表结点之间通过指针域构成一个链表，<u>若结点中只有一个指针域，则称为线性链表</u>。</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610514354.png"
	width="685"
	height="64"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610514354_hu9c9f9d7fee45544c6864faab3f820061_7122_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610514354_hu9c9f9d7fee45544c6864faab3f820061_7122_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="链式表存储结构"
	
	
		class="gallery-image" 
		data-flex-grow="1070"
		data-flex-basis="2568px"
	
></p>
<p>上图中的Head：一个指向链表第一个结点的针，称为头指针。使用它就可以顺序地访问到表中的任意一个元素。</p>
<p>插入和删除操作时间复杂度（带不带头节点的复杂度都一样）：</p>
<ul>
<li>最好情况（在$i=1$位置）：$O(1)$；</li>
<li>最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$</li>
<li>平均复杂度：$O(n)$</li>
</ul>
<p>链表操作的时间复杂度取决于指针遍历。</p>
<hr>
<h1 id="栈">栈</h1>
<p>栈是一种<strong>后入先出</strong>（Last In First Out，LIFO）的线性表。<u>栈只能通过访问它的一端来实现数据存储和检索。</u></p>
<p>栈的基本操作有：</p>
<ul>
<li><strong>入栈</strong>：将元素置入栈顶；</li>
<li><strong>出栈</strong>：将元素从栈顶中取出。</li>
<li>读取栈顶元素</li>
</ul>
<p>栈的出栈顺序一定和入栈顺序<strong>相反</strong>。</p>
<h2 id="顺序存储结构-1">顺序存储结构</h2>
<p>栈的顺序存储结构也称为<strong>顺序栈</strong>。</p>
<p>顺序栈使用一个栈顶指针标记栈顶元素的索引位置。每次出栈时都需要重置栈顶指针，将栈顶指针向下移动，标记到新的栈顶元素。</p>
<p>顺序栈的空间容量有限，所以每次入栈时都需要判断栈是否为满。</p>
<h2 id="链式存储结构-1">链式存储结构</h2>
<p>栈的链式存储结构称为<strong>链栈</strong>。链栈的头指针就是栈顶指针。</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680676944766.png"
	width="238"
	height="265"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680676944766_hu1bea4090283c9929deed80a707d4d0a3_11895_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680676944766_hu1bea4090283c9929deed80a707d4d0a3_11895_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="链栈的存储结构"
	
	
		class="gallery-image" 
		data-flex-grow="89"
		data-flex-basis="215px"
	
></p>
<h2 id="栈的应用">栈的应用</h2>
<p>栈的典型应用包括<strong>表达式求值、括号匹配</strong>等，在计算机语言的实现以及将递归过程转变为非递归过程的处理中，栈有重要的作用。</p>
<hr>
<h1 id="队列">队列</h1>
<p>队列是一种<strong>先入先出</strong>（First In First Out，FIFO）的线性表。</p>
<p><u>队列只允许在表的一端插入元素，在表的另一端删除元素。</u></p>
<ul>
<li><strong>队头</strong>（Front）：允许<strong>删除</strong>元素的一端；</li>
<li><strong>队尾</strong>（Rear）：允许<strong>插入</strong>元素的一端。</li>
</ul>
<p>队列的基本操作有：</p>
<ul>
<li><strong>入队</strong>：将元素加入到队尾；</li>
<li><strong>出队</strong>：将元素加入到对头。</li>
</ul>
<p>队列的入队顺序一定<strong>等于</strong>出队顺序。</p>
<blockquote>
<p>使用两个栈可以来模拟一个队列（从一个栈出栈后的元素入另一个栈后再出栈）。</p>
</blockquote>
<h2 id="顺序存储结构-2">顺序存储结构</h2>
<p>队列的顺序存储结构称为<strong>顺序队列</strong>。</p>
<p>顺序队列设置两个指针：</p>
<ul>
<li>队头指针：指向对头元素的下标；</li>
<li>队尾指针：指向队尾元素的下标。</li>
</ul>
<p>如果顺序队列只按照数组下标大小顺序来设置指针（对头指针的值永不大于队尾指针），那么在经过一段时间的操作后，对头指针有可能指向的并不是数组的第一个元素，此时队列的长度永远都到达不了数组的长度（空间无法被充分利用，实际使用的长度和逻辑长度不符）。</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680677900098.png"
	width="959"
	height="323"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680677900098_hua0e0c24049b10a1b1a22eff29a314663_53364_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680677900098_hua0e0c24049b10a1b1a22eff29a314663_53364_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="队列操作"
	
	
		class="gallery-image" 
		data-flex-grow="296"
		data-flex-basis="712px"
	
></p>
<p>为了解决这个问题，我们可以把数组想象为一个环型的结构（将最后一个元素和第一个元素连接起来，队头指针可以比队尾指针大）。如果此时队列的状态是上图中步骤$(e)$的状态，此时再插入元素，可以将元素放在数组索引0的位置，再让队尾指针始终保持在队列最后一个元素的索引之后即可。将这种队列称为<strong>循环队列</strong>，如：</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678225885.png"
	width="907"
	height="202"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678225885_hu78897751e6ca29164f26d83cde2f776e_48040_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678225885_hu78897751e6ca29164f26d83cde2f776e_48040_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="循环队列"
	
	
		class="gallery-image" 
		data-flex-grow="449"
		data-flex-basis="1077px"
	
></p>
<h2 id="链式存储结构-2">链式存储结构</h2>
<p>队列的链式存储也称为<strong>链队列</strong>（<strong>链队</strong>）。这里为了便于操作，可以给链队列添加一个头结点，并令头指针指向头结点。因此，队列为空的判定条件是头指针和尾指针的值相同，且
均指向头结点。</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678441791.png"
	width="278"
	height="340"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678441791_hud106655f2d3cb3393c4501ce0717f1de_16473_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678441791_hud106655f2d3cb3393c4501ce0717f1de_16473_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="81"
		data-flex-basis="196px"
	
></p>
<h2 id="队列的应用">队列的应用</h2>
<p>队列结构常用于处理需要排队的场合，例如操作系统中处理打印任务的打印队列、离散事件的计算机模拟等。</p>
<hr>
<h1 id="串">串</h1>
<p><strong>串</strong>（<strong>字符串</strong>）是一种<strong>特殊的线性表</strong>，其<strong>数据元素为字符</strong>。</p>
<p>串具有自身的特性，运算时常常把一个串作为一个整体来处理。</p>
<p>串的基本概念和操作：</p>
<ul>
<li>
<p><strong>空串</strong>：长度为0的串；</p>
</li>
<li>
<p><strong>子串</strong>：由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。子串在主串中的位置是指子串首次出现时，该子串的第一个字符在主串中的位置。空串是任意串的子串。</p>
</li>
<li>
<p><strong>串相等</strong>：指两个串长度相等且对应序号的字符也相同。</p>
</li>
<li>
<p><strong>串比较</strong>：两个串比较大小时以字符的ASCⅡ码值（或其他字符编码集合）作为依据。</p>
<p>实质上，比较操作从两个串的第一个字符开始进行，字符的码值大者所在的串为大；若其中一个串先结束，则以串长较大者为大。</p>
</li>
<li>
<p>赋值：</p>
<ul>
<li>拷贝赋值：将一个串的值赋给另一个串；</li>
<li>引用（地址）赋值：将一个串的引用（地址）赋给另一个串。那么这个串可以使用另一个串中的值，但是对这个串所做的操作，也会作用到另一个串。</li>
</ul>
</li>
<li>
<p><strong>连接串</strong>：将一个串插入到另一个串尾。</p>
</li>
<li>
<p><strong>插入串</strong>：将一个串插入到另一个串的任意位置中。</p>
</li>
</ul>
<h2 id="顺序存储结构-3">顺序存储结构</h2>
<p>串的顺序存储结构是一种定长的串（类似顺序表）。</p>
<h2 id="链式存储结构-3">链式存储结构</h2>
<p>串的链式存储结构可以方便地对串进行插入删除操作（类似链表）。</p>
<h2 id="串的模式匹配">串的模式匹配</h2>
<p>子串的定位操作通常称为串的模式匹配。子串也称为模式串。</p>
<p>有关串模式匹配算法的详细讲解可以查看：<a class="link" href="../%e7%bb%8f%e5%85%b8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d" >经典字符串匹配</a></p>
<h3 id="朴素的模式匹配算法">朴素的模式匹配算法</h3>
<p>朴素的模式匹配算法也称为布鲁特一福斯算法（即暴力匹配算法），其基本思想是从主串的第一个字符起与模式串的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串第二个字符起与模式串的第一个字符重新比较，直到模式串中每个字符依次和主串中一个连续的字符序列相等时为止，此时称为匹配成功。如果不能在主串中找到与模式串相同的子串，则匹配失败。</p>
<p>设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：</p>
<ul>
<li>
<p>最好情况：$O(m)$，次数为$m$；</p>
</li>
<li>
<p>最坏情况：$O(n \times m)$，次数为$\cfrac{1}{2} m(n-m+2)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i\big( (i+1) \times m \big)} = \cfrac{m}{n-m+1} \sum_{i=0}^{n-m}{(i+1)} = \cfrac{1}{2} m(n-m+2)
$$</p>
</li>
<li>
<p>平均：$O(n+m)$，次数为$\cfrac{1}{2} (n+m)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i(i+m)} = \cfrac{1}{n-m+1} \sum_{i=0}^{n-m}{i+m} = \cfrac{1}{2} (n+m)
$$</p>
</li>
</ul>
<h3 id="kmp-算法">KMP 算法</h3>
<p>KMP算法又称为改进的模式匹配算法。</p>
<ul>
<li>串的<strong>前缀</strong>：包含第一个字符，且不包含最后一个字符的子串；</li>
<li>串的<strong>后缀</strong>：包含最后一个字符，且不包含第一个字符的子串。</li>
<li>前缀集合：包含串的所有前缀的集合；</li>
<li>后缀集合：包含串的所有后缀的集合。</li>
</ul>
<p>KMP的重点是求模式串字符的next值（失配指针$Next[\ i\ ]$），假设$a_{i-1}$为当前要求next值的模式串字符：</p>
<ul>
<li>
<p>前缀集合：</p>
<p>$$
Prefix=\{p_0,p_0p_1,\cdots,p_0&hellip;p_{i-1}\}
$$</p>
</li>
<li>
<p>后缀集合：</p>
<p>$$
Postfix=\{p_{i-1},p_{i-2}p_{i-1},\cdots,p_1&hellip;p_{i-1}\}
$$</p>
</li>
<li>
<p>失配指针：</p>
<p>$$
Next[i] =
\begin{cases}
-1 &amp; 当\ i=0 时 \\
max &amp; \{ k|0&lt;k&lt;i 且 &ldquo;p_0\cdots p_{k-1}&rdquo; = &ldquo;p_{i-k}\cdots p_{i-1}&rdquo; \} \\
0 &amp; 其他情况
\end{cases}
$$</p>
<p>即：</p>
<ul>
<li>$Next[0] = -1$；</li>
<li>$Next[i] = maxLen(Prefix \cap Postfix)$</li>
</ul>
<p>可以解释为：</p>
<p>$$
Next[\ i\ ] = 前i个子串的最长相同前后缀的长度
$$</p>
<p>特殊情况：$Next[\ 1\ ] = 0$，因为其前缀集合和后缀集合都为空。</p>
</li>
</ul>
<blockquote>
<p>失配表是用来指示匹配失败后指针该如何移动的。</p>
<p>失配表的建立跟要匹配的串没有任何关系，仅跟模式串有关。</p>
</blockquote>
<hr>
<h1 id="多维数组">多维数组</h1>
<p>多维数组是定长线性表在维数上的扩展，即线性表中的元素又是一个线性表。多维数组是一种“同构”的数据结构，其每个数据元素类型相同、结构一致。</p>
<ul>
<li>
<p>一维数组：即线性表。</p>
</li>
<li>
<p>二维数组（仅讨论顺序存储结构）：</p>
<p>二维数组的存储结构（如下图），可以分为以行为主序（下图左边）和以列为主序（下图右边）两种。</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680693946560.png"
	width="451"
	height="448"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680693946560_hu1932cb3790ae3468aeeee7cc636c93c8_34859_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680693946560_hu1932cb3790ae3468aeeee7cc636c93c8_34859_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="100"
		data-flex-basis="241px"
	
></p>
<p>设：</p>
<ul>
<li>二维数组为$A[n,m]$，$n$为行数，$m$为列数；</li>
<li>数组元素$a_{i,j},\ 0 \le i \le n-1,\ 0 \le j \le m-1$；</li>
<li>$LOC(a_{i,j})$为元素$a_{i,j}$的地址；</li>
<li>$L$为单个元素的存储空间大小。</li>
</ul>
<p>则有：</p>
<ul>
<li>
<p>以行为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i \times n + j) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) \times n + (j-1) \big) \times L
$$</p>
</li>
<li>
<p>以列为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \times m) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) + (j-1) \times m \big) \times L
$$</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>优先存储说法问题：</p>
<p>以行为主序优先存储的意思应该是在内存中按行存储。以列为主序优先存储的意思应该是在内存中按列存储。</p>
<p>假设一个二维数组为：</p>
<p>$$
\begin{vmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \\
a_{51} &amp; a_{52} &amp; a_{53} &amp; a_{54}
\end{vmatrix}
$$</p>
<p>按照以行为主序优先存储的公式，它在内存中应该是分为了5个地址连续的数组来存储。即内存中，$[a_{11},a_{12},a_{13},a_{14}]$为一个数组，其后再接一个数组$[a_{12},a_{22},a_{23},a_{24}]$，以此类推，在内存中按照列的元素作为一个连续的一维数组单位，再按照第1行后接第2行作为整个连续的二维数组。它们在内存中的地址顺序是：</p>
<p>$$
a_{11},a_{12},&hellip;,a_{14},\\
a_{21},&hellip;,a_{24},\\
a_{31},&hellip;,a_{34},\\
a_{41},&hellip;,a_{44},\\
a_{51},&hellip;,a_{54}
$$</p>
<p>那么以列为主序优先存储的地址顺序就为：</p>
<p>$$
a_{11},a_{21},&hellip;,a_{51},\\
a_{12},&hellip;,a_{52},\\
a_{13},&hellip;,a_{53},\\
a_{14},&hellip;,a_{54}
$$</p>
</blockquote>
<p>一般矩阵都用二维数组来表示，但是对于一些特殊矩阵，如对称矩阵、三角矩阵和对角矩阵。它们的非0元素的分布存在一定规律，所以可以将其压缩存储在一维数组中，并且它们的多个值相同的元素（按照对应特殊矩阵定义上的值相同，并非简单的值相同）只分配一个存储单位。</p>
<h2 id="对称矩阵">对称矩阵</h2>
<p>若矩阵$A_{n \times n}$中的元素特点为$a_{ij}=a_{ji}\ (1 \le i,j \le n)$，则称之为$n$阶对称矩阵。</p>
<p>对称矩阵$A_{n \times n}$：</p>
<p>$$
\begin{vmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{vmatrix}
$$</p>
<p>其中以对角线划分为三个区域：</p>
<ul>
<li>
<p><strong>主对角线</strong>：$a{11},a_{22},\cdots,a_{nn}$，共有$n$个元素；</p>
</li>
<li>
<p><strong>上三角区</strong>：对角线以上的所有元素，即：</p>
<p>$$
\begin{vmatrix}
0 &amp; a_{12} &amp; a_{13} &amp; \cdots &amp; a_{1n} \\
0 &amp; 0 &amp; a_{23} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; a_{(n-1)n} \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0
\end{vmatrix}
$$</p>
</li>
<li>
<p><strong>下三角区</strong>：对角线以下的所有元素，和上三角区的个数相等并且重复。</p>
</li>
</ul>
<p>可以将对称矩阵中，$n^2$个元素压缩存储到$\cfrac{n(n+1)}{2}$个元素的存储空间中。一般是存储下三角区和对角线。</p>
<p>假设将$n$阶对称矩阵$A_{n \times n}$压缩存储到一维数组$B\left[ \cfrac{n(n+1)}{2} \right]$，则$B[k]\ (1 \le k \le \cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$之间存在一一对应关系（以行为主序）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i-1)}{2} + j, &amp; 当\ i \ge j \\
\cfrac{j(j-1)}{2} + i, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p>如果下标从0开始（第一个元素为$a_{00}$，$0 \le k \le \cfrac{n(n+1)}{2} - 1$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i+1)}{2} + j + 1, &amp; 当\ i \ge j \\
\cfrac{j(j+1)}{2} + i + 1, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<blockquote>
<p>为什么$length(B) = \cfrac{n(n+1)}{2}$（压缩存储的一维数组大小）：</p>
<p>主对角线的元素的大小为$n$，下三角区的对角线大小分别为$n-1,n-2,&hellip;,1$。即：
$$
length(B) = \sum_{i=1}^{n}{i} = \cfrac{n(n+1)}{2}
$$</p>
</blockquote>
<blockquote>
<p>PS：《软件设计师教程（第五版）》中一维数组的下标$k$的取值范围错了：</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680698007514.png"
	width="999"
	height="344"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680698007514_hud68653e5fe46341035cf0f04b58f1fb8_157083_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680698007514_hud68653e5fe46341035cf0f04b58f1fb8_157083_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="对称矩阵"
	
	
		class="gallery-image" 
		data-flex-grow="290"
		data-flex-basis="696px"
	
>
很明显不是$\left[ 1, \cfrac{n(n+1)}{2} \right)$，而应该是$\left[ 1, \cfrac{n(n+1)}{2} \right]$。</p>
</blockquote>
<h2 id="三对角矩阵">三对角矩阵</h2>
<p>对角矩阵是指矩阵中的<u>非0元素都集中在以主对角线为中心的带状区域中</u>，即除了主对角线上和直接在对角线上、下方若干条对角线上的元素外，其余的矩阵元素都为0。三对角矩阵是对角矩阵中的一种，包括主对角线和在主对角线上、下方的各一条对角为非0元素：</p>
<p>$$
\begin{vmatrix}
a_{11} &amp; a_{12} &amp; 0      &amp; \cdots &amp; 0              &amp; 0          \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; \cdots &amp; 0              &amp; 0          \\
0      &amp; a_{32} &amp; a_{33} &amp; \cdots &amp; 0              &amp; 0          \\
0      &amp; 0      &amp; a_{43} &amp; \cdots &amp; 0              &amp; 0          \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots         &amp; \vdots     \\
0      &amp; 0      &amp; 0      &amp; \cdots &amp; a_{(n-1)(n-1)} &amp; a_{(n-1)n} \\
0      &amp; 0      &amp; 0      &amp; \cdots &amp; a_{n(n-1)}     &amp; a_{nn}
\end{vmatrix}
$$</p>
<p>设有$n$阶三对角矩阵$A_{n \times n}$，将其非0元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$存储在一维数组$B[k](1 \le k \le 3 \times n - 2)$中，则元素位置之间的对应关系为：</p>
<p>$$
k = 3 \times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2
$$</p>
<p>如果下标从0开始（$0 \le k \le 3(n-1)$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k = 3 \times i - 1 + j - i + 1 + 1 = 2i + j + 1
$$</p>
<h2 id="稀疏矩阵">稀疏矩阵</h2>
<p>在一个矩阵中，若<u>非0元素的个数远远少于0元素的个数，且非0元素的分布<strong>没有规律</strong></u>，则称之为稀疏矩阵。</p>
<p>对于稀疏矩阵，存储非0元素时<strong>必须同时存储其位置</strong>（即行号和列号），用<u>三元组$(i,j,a_{ij})$可唯一确定矩阵$A$中的一个元素</u>。</p>
<p>可以用三元组表来存储这些三元组。稀疏矩阵的三元组表的顺序存储结构称为<strong>三元组顺序表</strong>，常用的三元组表的链式存储结构是<strong>十字链表</strong>。</p>
<hr>
<h1 id="树">树</h1>
<p><strong>树</strong>结构是一种<strong>非线性结构</strong>，该结构中的一个数据元素可以有<strong>两个或两个以上的直接后继</strong>元素。</p>
<p><strong>树</strong>（Tree）是 $n(n\ge0)$ 个结点的有限集。</p>
<ul>
<li><strong>空树</strong>：$n=0$；</li>
<li><strong>非空树</strong>：$n&gt;0$，
<ul>
<li>有且仅有一个<strong>根结点</strong>，</li>
<li>除根节点外的其余结点可分为 $m(m&gt;0)$ 个互不相交的集合，即<strong>子树</strong>（SubTree）$T_1,T_2,\cdots,T_m$。</li>
</ul>
</li>
</ul>
<p>树的定义是<strong>递归</strong>的：</p>
<ul>
<li>一棵树由若干棵子树构成；</li>
<li>子树又由更小的子树构成。</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<h3 id="术语">术语</h3>
<ul>
<li><strong>度</strong>：结点拥有的子树数。整个树的度是树内各结点度的最大值。</li>
<li><strong>叶结点</strong>：度为 0 的结点，也称<strong>终端结点</strong>。</li>
<li><strong>非终端结点</strong>：度不为 0 的结点，也称<strong>分支结点</strong>。</li>
<li><strong>内部结点</strong>：除根节点外的非终端结点。</li>
<li><strong>子节点</strong>：结点<u>子树的根结点</u>。</li>
<li><strong>父结点</strong>：与子结点相连的上一层的唯一一个结点。</li>
<li><strong>兄弟结点</strong>：同一个父节点的子节点之间互为兄弟。</li>
<li><strong>祖先结点</strong>：从根结点到该结点所经分支上的所有结点（包括其父节点，但不包括其本身）。</li>
<li><strong>子孙结点</strong>：以某结点为根的子树中的所有结点。</li>
<li><strong>堂兄弟结点</strong>：父节点在同一层（但不是同一个）的结点互为堂兄弟。</li>
<li><strong>层次</strong>：以根结点为第一层，根的子节点为第二层 …… 树中任意结点的层次等于其父节点的层次加 1。</li>
<li><strong>树的高度</strong>：树中结点的最大层次，也称<strong>树的深度</strong>。</li>
<li><strong>森林</strong>：是 $m(m\ge0)$ 棵互不相交的树的集合。树中每个结点的子树的集合即为森林。</li>
</ul>
<h3 id="树的类型">树的类型</h3>
<ul>
<li><strong>有序树</strong>：树中结点的各子树从左到右是有次序的，即不能互换。</li>
<li><strong>无序树</strong>：树中结点的各子树相互之间可以互换，没有次序。</li>
</ul>
<h3 id="树的性质">树的性质</h3>
<ul>
<li>
<p>设$n$个结点的树，$d_i \ (1 \le i \le n)$为该树中结点的度：</p>
<p>$$
n = (\sum_{i=1}^{n}{d_i})+1
$$</p>
</li>
<li>
<p>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \ge 1$）。</p>
</li>
<li>
<p>高度为$h$的$m$度树至多有$\cfrac{m^h-1}{m-1}$个结点。</p>
</li>
</ul>
<h2 id="树的逻辑结构">树的逻辑结构</h2>
<p>树可以用二元组 $Tree=(root,F)$ 表示。其中 $root$ 是根结点，$F$ 是 $m(m\ge0)$ 棵子树的森林，即 $F=(T_1,T_2,\cdots,T_m)$，其中 $T_i=(r_i,F_i)$ 为根 $root$ 的第 $i$ 棵子树。</p>
<p>树根与其子树森林之间的关系：
$$
RF = \{ &lt;root,r_i&gt;|i=1,2,4,m,\quad m&gt;0 \}
$$</p>
<hr>
<h1 id="二叉树">二叉树</h1>
<p>二叉树是（$n \ge 0$）个结点的有限集合：</p>
<ul>
<li>空树：$n=0$；</li>
<li>由一个根结点及两棵不相交的且分别称为左、右子树的二叉树所组成（两个子数顺序不可交换）。</li>
</ul>
<p>二叉树同样具有递归性质。</p>
<p>二叉树的性质：</p>
<ul>
<li>
<p>第$i$层（$i \ge 1$）上<u>最多</u>有$2^{i-1}$个结点。</p>
<p>因为二叉树每个结点至多有两个分支（结点）。</p>
</li>
<li>
<p>高度为$k$的二叉树最多有$2^k-1$个结点（$k \ge 1$）。</p>
<p>每层结点都取最大值后累加：</p>
<p>$$
\sum_{i=1}^{k}{2^{i-1}} = 2^k - 1
$$</p>
<p>将深度为$k$且有$2^k-1$个结点的二叉树称为<strong>满二叉树</strong>。</p>
<p>对满二叉树自上而下、从左至右进行编号（即层序遍历的顺序）。一个深度为$k$、有$n$个结点的二叉树，当且仅当其每一个结点都于深度为$k$的满二叉树中编号从1至$n$的结点一一对应时，称之为<strong>完全二叉树</strong>。</p>
<blockquote>
<p>完全二叉树有一个隐藏关系：$n &gt; 2^{k-1}-1$。即深度为$k$的完全二叉树，其结点数$n$必须要比深度为$k-1$的满二叉树至少多1个结点。</p>
</blockquote>
<blockquote>
<p>深度为$k$的满二叉树结点数$n$和其第$k$层结点数$m$的关系：</p>
<p>$$
n = 2m-1
$$</p>
</blockquote>
</li>
<li>
<p>任何一棵二叉树，若其终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。</p>
<p>即：</p>
<p>$$
终端结点数（度0结点数）=度2结点数+1
$$</p>
</li>
<li>
<p>具有$n$个结点的完全二叉树的深度（高度）为：</p>
<p>$$
\lfloor \log_2{n} \rfloor + 1;
$$</p>
<p>或：</p>
<p>$$
\lceil \log_2{(n+1)} \rceil
$$</p>
</li>
</ul>
<p>二叉树形态总数（卡特兰数）：</p>
<p>$$
\cfrac{C^{n}_{2n}}{n+1}
$$</p>
<blockquote>
<p>排列组合公式：</p>
<p>$$
A^n_m = m \times (m-1) \times \cdots \times (m-n+1)
$$</p>
<p>$m$是起点，$n$是次数。</p>
<p>$$
C^n_m = \cfrac{A^n_m}{A^n_n}
$$</p>
</blockquote>
<h2 id="顺序存储结构-4">顺序存储结构</h2>
<p>用一组地址连续的存储单元存储二叉树中的结点。</p>
<p>可以按照为完全二叉树编号的顺序（即层序遍历的顺序），将二叉树映射到顺序表中：</p>
<p>若编号为$i$的结点（$i \ge 1$），则：</p>
<ul>
<li>$i=1$：根结点，没有双亲（父结点）；</li>
<li>$i&gt;1$：双亲为$\left\lfloor \cfrac{i}{2} \right\rfloor$；</li>
<li>$i \le \cfrac{n}{2}$：左孩子编号为$2i$；</li>
<li>$i \le \cfrac{n-1}{2}$：右孩子编号为$2i+1$。</li>
</ul>
<p>完全二叉树适合采用顺序存储结构，而一般二叉树则不适合。</p>
<h2 id="链式存储结构-4">链式存储结构</h2>
<p>可以用<strong>三叉链表或二叉链表</strong>来存储二叉树（一个结点含有3个或2个指针，其中必须有两个指针来分别存储左子树和右子树的根结点）。链表的头指针指向二叉树根结点：</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680770614240.png"
	width="980"
	height="337"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680770614240_hu74a2d83457551f99334a785fee2a7f2b_53953_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680770614240_hu74a2d83457551f99334a785fee2a7f2b_53953_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="二叉树的链表存储结构"
	
	
		class="gallery-image" 
		data-flex-grow="290"
		data-flex-basis="697px"
	
></p>
<blockquote>
<p>三叉链表仅仅是多了一个指向父结点的链表。</p>
</blockquote>
<p>设有$n$个结点的二叉树，则其<strong>空指针域数量</strong>：</p>
<ul>
<li>
<p>对于二叉链表：</p>
<ul>
<li>总指针域个数：$2n$；</li>
<li>分支数（子孙结点数，非空指针域个数）：$n-1$。</li>
</ul>
<p>可得：</p>
<p>$$
空指针域数=2n-(n-1)=n+1
$$</p>
</li>
<li>
<p>对于三叉链表：</p>
<ul>
<li>总指针域个数：$3n$；</li>
<li>分支数（子孙结点数）：$n-1$；</li>
<li>指向父结点且非空的指针域个数：$n-1$。</li>
</ul>
<p>即，非空指针域个数为：$2(n-1)$。</p>
<p>可得：</p>
<p>$$
空指针域数=3n-2(n-1)=n+2
$$</p>
</li>
</ul>
<h2 id="遍历">遍历</h2>
<p>二叉树有以下遍历方法：</p>
<ul>
<li>
<p>先序遍历：根左右</p>
<ol>
<li>访问根结点；</li>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
</ol>
</li>
<li>
<p>中序遍历：左根右</p>
<ol>
<li>中序遍历左子树；</li>
<li>访问根结点；</li>
<li>中序遍历右子树。</li>
</ol>
</li>
<li>
<p>后序遍历：左右根</p>
<ol>
<li>后序遍历左子树；</li>
<li>后序遍历右子树；</li>
<li>访问根结点。</li>
</ol>
<p>后序遍历可以使用栈：</p>
<ol>
<li>根结点入栈；</li>
<li>右子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；</li>
<li>左子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；</li>
<li>将栈中所有元素出栈，出栈顺序即为后序遍历的顺序。</li>
</ol>
</li>
<li>
<p>层序遍历：根据层序从上至下，从左到右遍历</p>
<ol>
<li>
<p>访问根结点（第1层）；</p>
</li>
<li>
<p>从左到右访问第2层所有结点；</p>
</li>
<li>
<p>从左到右访问第3层所有结点；</p>
<p>&hellip;</p>
</li>
</ol>
<p>直至访问到最后一层的所有结点（从左到右）。</p>
<p>层序遍历可以使用队列：</p>
<ol>
<li>将根结点入队；</li>
<li>将对头元素出队，然后将其左右子结点（如果有的话）依序入队；</li>
<li>重复步骤2直至所有元素出队，出队顺序即为层序遍历顺序。</li>
</ol>
</li>
</ul>
<blockquote>
<p>二叉树的遍历实质上是对一个非线性结构进行线性化的过程，它使得每个结点（除第一个和最后一个）在这些线性序列中有且仅有一个直接前驱和直接后继。</p>
</blockquote>
<h2 id="平衡二叉树">平衡二叉树</h2>
<p>二叉树可以用于快速查找。例如比根结点小的在左子树，比根结点大的在右子树（二叉排序树）。那么每次查找，根据根结点就可以剔除一半的范围。</p>
<p>但是如果二叉树左右子树的结点数量差别很大，那么每次查找并不一定能剔除一半的范围，查询效率大打折扣。</p>
<p>设一个二叉树的左右子树高度之差的绝对值为$d$，那么</p>
<ul>
<li>不平衡的二叉树：$d &gt; 1$；</li>
<li>平衡的二叉树：$d \le 1$。</li>
</ul>
<blockquote>
<p>完全二叉树一定是平衡二叉树，平衡二叉树不一定是完全二叉树。</p>
</blockquote>
<h2 id="二叉排序树">二叉排序树</h2>
<p>二叉排序树的定义：</p>
<ul>
<li><strong>左子树</strong>所有结点的关键字都<strong>小于</strong>根结点；</li>
<li><strong>右子树</strong>所有根结点的关键字都<strong>大于</strong>根结点；</li>
<li>左右子树也都是二叉排序树。</li>
</ul>
<p>二叉排序树的<strong>中序遍历</strong>（左根右）得到的是该二叉树的<strong>有序序列</strong>。</p>
<h2 id="线索二叉树">线索二叉树</h2>
<p>线索二叉树是在二叉树结点中保存了结点的前驱和后继的信息。</p>
<p>如果使用指针来指向其前驱和后继，增加指针信息会降低存储空间的利用率。</p>
<p>可以采用增加两个标志（<code>leftTag</code>和<code>rightTag</code>）来区分指针域指向的是左或右子结点还是前驱或后继：</p>
<div class="table-wrapper"><table>
    <tr>
        <td>leftTag</td>
        <td>leftChild</td>
        <td>data</td>
        <td>rightChild</td>
        <td>rightTag</td>
    </tr>
</table></div>
<p>其中：</p>
<p>$$
leftTag =
\begin{cases}
True  &amp; leftChild指向结点左孩子 \\
False &amp; leftChild指向结点的直接前驱
\end{cases}
$$</p>
<p>$$
rightTag =
\begin{cases}
True  &amp; rightChild指向结点右孩子 \\
False &amp; rightChild指向结点的直接后继
\end{cases}
$$</p>
<p>若二叉树的二叉链表采用以上所示的结点结构，则相应的链表称为线索链表，其中指向结点前驱、后继的指针称为线索。</p>
<p>对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化。</p>
<h2 id="哈夫曼树">哈夫曼树</h2>
<p>哈夫曼树即最优二叉树，是一类<strong>带权路径长度最短</strong>的树。</p>
<ul>
<li>
<p><strong>路径</strong>：指从树中<strong>一个结点到另一个结点之间的通路</strong>；</p>
</li>
<li>
<p><strong>路径长度</strong>：路径上的<strong>分支数目</strong>；</p>
</li>
<li>
<p><strong>树的路径长度</strong>：指从树根到每一个叶子之间的路径长度之和；</p>
</li>
<li>
<p><strong>结点的带权路径长度</strong>：从该结点到树根之间的<strong>路径长度</strong>与该结点<strong>权值</strong>的乘积；</p>
</li>
<li>
<p><strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和。</p>
<p>设：</p>
<ul>
<li>带权叶子结点数：$n$；</li>
<li>叶子结点的权值：$w_k$；</li>
<li>叶子结点到根的路径长度：$l_k$。</li>
</ul>
<p>则树的带权路径长度为：</p>
<p>$$
WPL = \sum_{k=1}^{n}{w_kl_k}
$$</p>
</li>
</ul>
<p>哈夫曼树是指权值为$w_1,w_2,\cdots,w_n$的$n$个叶子结点的二叉树中，带权路径长度最小的二叉树。</p>
<p>构造最优二叉树的哈夫曼算法：</p>
<ol>
<li>根据给定的$n$个权值$\{ w_1,w_2,\cdots,w_n \}$，构成$n$棵二叉树集合$F=\{T_1,T_2,\cdots,T_n\}$，每棵树$T_i$有且仅有一个带权为$w_i$的根结点。</li>
<li>在$F$中选取2棵权值最小的树作为左、右子树，构造一棵新二叉树。新二叉树的根结点权值为其左右子树根结点权值之和。</li>
<li>从$F$中删除这2棵树，并将新树加入到$F$中。</li>
<li>重复步骤2、3直到$F$中仅含一棵树为止，这棵树便是哈夫曼树。</li>
</ol>
<p>哈夫曼算法并未规定哪棵树作为左或右子树，所以哈夫曼树并不唯一，但$WPL$值是唯一的。</p>
<p>给定$n$个权值后，哈夫曼树的结点数$m$就确定了：</p>
<p>$$
m = 2 \times n - 1
$$</p>
<p>所以可用一维数组存储哈夫曼树。</p>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<p>哈夫曼编码是一种不等长的编码，它用哈夫曼算法来构造出最优前缀码：</p>
<p>给定<strong>字符集</strong>$D=\{ d_1,d_2,\cdots,d_n \}$及<strong>字符的使用频率</strong>$W=\{w_1,w_2,\cdots,w_n\}$。</p>
<p>构造<strong>最优前缀码</strong>的方法为：</p>
<ol>
<li>以$d_1,d_2,\cdots,d_n$作为叶子结点，$w_1,w_2,\cdots,w_n$作为叶子结点的权值，构造出一棵最优二叉树。</li>
<li>将树中每个结点的左分支标上0，右分支标上1（左0右1）。</li>
<li>每个叶子结点代表字符的编码就是从根到叶子的路径上组成的0、1串。</li>
</ol>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680836524813.png"
	width="347"
	height="334"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680836524813_hu78baa79acc8330412526e447ee3074d0_24961_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680836524813_hu78baa79acc8330412526e447ee3074d0_24961_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="哈夫曼编码"
	
	
		class="gallery-image" 
		data-flex-grow="103"
		data-flex-basis="249px"
	
></p>
<p>其中，字符$a$字符$b$、$c$、$d$、$e$的编码分别为00、01、100、11、101。</p>
<h3 id="压缩比">压缩比</h3>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680959771881.png"
	width="784"
	height="489"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="压缩比例题"
	
	
		class="gallery-image" 
		data-flex-grow="160"
		data-flex-basis="384px"
	
></p>
<ol>
<li>
<p>按照<u>出现频率</u>计算<u>加权平均长度</u>：</p>
<p>$$
加权平均长度 = \sum_{i=1}^{5}{字符i的位数 \times 字符i出现频率}
$$</p>
<p>即：</p>
<p>$$
1 \times 40% + 3 \times (10% + 20% + 16% + 14%) = 2.2
$$</p>
<p>压缩后平均长度为2.2。</p>
</li>
<li>
<p>计算压缩比：</p>
<p>$$
压缩比 = \cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度}
$$</p>
<p>即，</p>
<ul>
<li>
<p>编码5个字符至少需要3位：$2^2 &lt; 5 &lt; 2^3$，所以压缩前编码长度为3；</p>
</li>
<li>
<p>压缩比：</p>
<p>$$
\cfrac{3-2.2}{3} \approx 0.27
$$</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>哈夫曼编码方案是基于贪心策略的。</p>
</blockquote>
<hr>
<h1 id="图">图</h1>
<p>在图中，任意两个结点之间都可能有直接的关系，所以图中<u>一个结点的前驱结点和后继结点的数目是没有限制的</u>。</p>
<p>图$G$是由集合$V$和$E$构成的二元组，记作$G=(V,E)$：</p>
<ul>
<li><strong>顶点</strong>：表示数据元素。$V$是图中顶点的非空有限集合。</li>
<li><strong>边</strong>：表示数据元素之间的关系。$E$是图中边的有限集合。</li>
</ul>
<p>图可分为两种类型：</p>
<ul>
<li><strong>有向图</strong>：有向图顶点之间的关系称为弧（或有向边），用$&lt;v_i,v_j&gt;$表示，$v_i$是<strong>弧尾</strong>（始点或起点），$v_j$是<strong>弧头</strong>（终点，箭头指向的顶点），即有向边是指<u>从弧尾指向弧头</u>的一条边。$&lt;v_i,v_j&gt;$和$&lt;v_j,v_i&gt;$分别表示的是两条边。</li>
<li><strong>无向图</strong>：无向图顶点之间的关系用$(v_i,v_j)$表示。$(v_i,v_j)$和$(v_j,v_i)$表示的是同一条边。</li>
</ul>
<h2 id="术语-1">术语</h2>
<h3 id="完全图">完全图</h3>
<p><strong>完全图</strong>：</p>
<ul>
<li>
<p><strong>无向完全图</strong>：指一个有$n$个顶点的无向图，其每一个顶点与其他$n-1$个顶点之间都有边。</p>
<p>$n$个顶点的无向完全图共有$\cfrac{n(n-1)}{2}$条边：</p>
<p>$$
\sum_{i=1}^{n}{i} = \cfrac{n(n-1)}{2}
$$</p>
<p>假设$n$个顶点的无向完全图，为他们编上1到$n$的编号，按照编号顺序计算边，第1个顶点跟其他$n-1$个顶点有$n$条边；第2个顶点跟其他$n-1$个顶点也有$n$条边，除去1条跟第1个顶点相连的边，有$n-1$条不一样的边；第3个顶点出去2条跟第1和第2个顶点相连的边，有$n-2$条不一样的边……以此类推，得出上方公式。</p>
</li>
<li>
<p><strong>有向完全图</strong>：指一个有$n$个顶点的有向图，以其每一个顶点为始点与其他$n-1$个顶点之间都有弧。</p>
<p>$n$个顶点的有向完全图共有$n(n-1)$条边：</p>
<p>$$
\prod_{i=1}^{n}{n-1} = n(n-1)
$$</p>
<p>有向完全图的$n$个顶点都有$n-1$条以其他顶点作为终点的弧（出度为$n-1$），并且这$n$个顶点的$n-1$条弧都是不同的弧，所以可推出上方公式。</p>
</li>
</ul>
<h3 id="度">度</h3>
<p><strong>度</strong>：顶点$v$的度是指关联于该顶点的边的数目，记作$D(v)$。</p>
<p>若为有向图：</p>
<ul>
<li><strong>入度</strong>：以该顶点为终点的有向边的数目，记为$ID(v)$；</li>
<li><strong>出度</strong>：以该顶点为起点的有向边的数目，记为$OD(v)$。</li>
</ul>
<p>有向图度与入度、出度的关系：</p>
<p>$$
D(v) = ID(v) + OD(v)
$$</p>
<p>对于所有的图，顶点数$n$、边数$e$与各顶点的度之间有：</p>
<p>$$
e = \cfrac{1}{2} \sum_{i=1}^{n}{D(v_i)}
$$</p>
<p>即，所有顶点的度数之和 $= 2e$。</p>
<h3 id="路径">路径</h3>
<p><strong>路径</strong>：</p>
<ul>
<li>
<p>无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$(v_p,v_{i1}),(v_{i1},v_{i2}),\cdots,(v_{in},v_q) \in E(G)$；</p>
</li>
<li>
<p>无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$&lt;v_p,v_{i1}&gt;,&lt;v_{i1},v_{i2}&gt;,\cdots,&lt;v_{in},v_q&gt; \in E(G)$。</p>
<p>无向图中的路径也是有方向的。</p>
</li>
</ul>
<h3 id="子图">子图</h3>
<p><strong>子图</strong>：若有两个图$G=(V,E)$和$G'=(V',E')$，如果$V' \sube V$且$E' \sube E$，则称$G'$为$G$的子图。</p>
<h3 id="连通图">连通图</h3>
<p>对于无向图：</p>
<ul>
<li><strong>连通</strong>：无向图中，若从顶点$v_i$到顶点$v_j$<u>有路径</u>，则称顶点$v_i$和顶点$v_j$是联通的。</li>
<li><strong>连通图</strong>：若无向图中<u>任意两个顶点都是联通的</u>，称其为连通图。</li>
<li><strong>连通分量</strong>：无向图$G$的<strong>极大连通子图</strong>称为$G$的连通分量。</li>
</ul>
<p>$n$个结点的连通图，它的边的取值范围是$[n-1,\cfrac{n(n-1)}{2}]$。</p>
<p>对于有向图：</p>
<ul>
<li><strong>强连通图</strong>：在有向图$G$中，如果对于每一对顶点，$v_i,v_j\in V$ 且 $v_i \neq v_j$，从顶点$v_i$到顶点$v_j$和从顶点$v_j$到顶点$v_i$都存在路径，则称图$G$为强连通图。</li>
<li><strong>强连通分量</strong>：有向图中的<strong>极大连通子图</strong>称为有向图的强连通分量。</li>
</ul>
<blockquote>
<p>连通图是无向图中的一种，所以一般也称为无向连通图。</p>
<p>强连通图是有向图的一种，一般也称为有向强连通图。</p>
</blockquote>
<h3 id="网">网</h3>
<p>边（或弧）带权值的图称为网。</p>
<h3 id="有向树">有向树</h3>
<p>如果一个有向图恰<u>有一个顶点的入度为0（作为root），其余顶点的入度均为1</u>，则是一棵有向树。</p>
<h2 id="基本存储结构">基本存储结构</h2>
<p>图的基本存储结构有：</p>
<ul>
<li>邻接矩阵表示法：使用矩阵存储顶点关系，适合存储边比较多的图；</li>
<li>邻接链表表示法：使用多个单链表存储顶点关系，适合存储边比较少的图。</li>
</ul>
<h3 id="邻接矩阵表示法">邻接矩阵表示法</h3>
<p>图的邻接矩阵表示法是指<u>用矩阵来表示图中顶点之间的关系</u>。</p>
<p>对于具有$n$个顶点的图$G=(V,E)$，其邻接矩阵是一个$n$阶方阵，且满足：</p>
<p>$$
A[i][j] =
\begin{cases}
1 &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt;是E中的边 \\
0 &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt;不是E中的边
\end{cases}
$$</p>
<blockquote>
<p>即，横$i$竖$j$，横出竖入。</p>
</blockquote>
<p>无向图的邻接矩阵是对称矩阵，有向图的邻接矩阵则不一定对称。</p>
<ul>
<li>无向图：顶点$v_i$的度是邻接矩阵第$i$行（或列）中值不为0的元素个数；</li>
<li>有向图：第$i$行的非0元素个数是顶点$v_i$的出度$OD(v_i)$；第$i$列的非0元素个数是顶点$v_i$的入度$ID(v_j)$。</li>
</ul>
<p>网（赋权图）的邻接矩阵定义（$W_{ij}$是边或弧上的权值）：</p>
<p>$$
A[i][j] =
\begin{cases}
W_{ij} &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt; \in E \\
\infin &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt; \notin E
\end{cases}
$$</p>
<p>邻接矩阵适合用于存储边比较多的图。</p>
<h3 id="邻接链表表示法">邻接链表表示法</h3>
<p>邻接链表表示法指的是<u>为图的每个顶点建立一个单链表</u>：</p>
<ul>
<li>
<p>边结点（表结点）：</p>
  <div class="table-wrapper"><table>
      <tr>
          <td>adjvex</td>
          <td>nextarc</td>
          <td>info</td>
      </tr>
  </table></div>
<ul>
<li><code>adjvex</code>：指示与顶点$v_i$邻接的顶点的序号；</li>
<li><code>nextarc</code>：指示下一条边或弧的结点；</li>
<li><code>info</code>：存储与边或弧有关的信息，如权值等。</li>
</ul>
</li>
<li>
<p>表头结点（顶点结点）：</p>
  <div class="table-wrapper"><table>
      <tr>
          <td>data</td>
          <td>firstarc</td>
      </tr>
  </table></div>
<ul>
<li><code>data</code>：存储顶点$v_i$的名或其他有关信息；</li>
<li><code>firstarc</code>：指示链表中的第一个结点（邻接顶点）。</li>
</ul>
<p>表头结点通常以顺序存储结构存储，以便随机访问。</p>
</li>
</ul>
<p>对于有向图，<strong>邻接链表</strong>存储的是以当前结点作为<strong>起点</strong>的弧；<strong>逆邻接链表</strong>存储的是以当前结点作为<strong>终点</strong>的弧。</p>
<p>邻接链表适合用于存储边比较少的图。</p>
<h2 id="遍历-1">遍历</h2>
<p>图的遍历是指<u>从某个项点出发，沿着某条搜索路径对图中的所有项点进行访问且只访问一次的过程</u>。</p>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>深度优先搜索（Depth First Search，DFS）类似于树的先序遍历。从图$G$中任一结点$v$出发按深度优先搜索法进行遍历的步骤：</p>
<ol>
<li>设置搜索指针$p$，使$p$指向顶点$v$；</li>
<li>访问$p$所指顶点，并使$p$指向与其<u>相邻接的且尚未被访问过</u>的顶点。</li>
<li>若$p$所指顶点存在，则重复步骤2，否则执行步骤4。</li>
<li>沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。</li>
</ol>
<p>时间复杂度（$n$为顶点数，$e$为边数）：</p>
<ul>
<li>邻接矩阵：$O(n^2)$；</li>
<li>邻接链表：$O(n+e)$。</li>
</ul>
<h3 id="广度优先搜索">广度优先搜索</h3>
<p>图的广度优先搜索（Breadth First Search，BFS）步骤为：</p>
<ol>
<li>从图中的某个顶点$v$出发；</li>
<li>访问$v$后，依次访问$v$的各个未被访问过的邻接点；</li>
<li>分别从$v$的邻接点出发，依次访问它们的邻接点；</li>
<li>按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到；</li>
<li>若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。</li>
</ol>
<p>广度优先搜索可以引入队列来保存已访问过的顶点序列。即，每当一个顶点被访问后，就将其放入队列中；当队头顶点出队时，就访问其未被访问的邻接点并令这些邻接顶点入队。每个顶点最多入队一次。</p>
<p>广度和深度优先搜索遍历图的<u>时间复杂度相同</u>（$n$为顶点数，$e$为边数）：</p>
<ul>
<li>邻接矩阵：$O(n^2)$；</li>
<li>邻接链表：$O(n+e)$。</li>
</ul>
<blockquote>
<p>广度和深度优先搜索遍历图的不同之处在于：<u>顶点访问的次序不同</u>。</p>
</blockquote>
<h2 id="生成树">生成树</h2>
<p>连通图的生成树是该图的极小连通子图（都是$n-1$条边）。</p>
<p>对于<strong>非连通图</strong>而言，每个连通分量中的顶点集和遍历时走过的边集一起构成若干棵生成树，把它们称为<strong>非连通图的生成树森林</strong>。</p>
<ul>
<li>
<p>在图的生成树中任一加一条边，则必然形成回路。</p>
<p>边数为$e$，$e \ge n$则必然形成回路。</p>
</li>
<li>
<p>图的生成树不是唯一的。</p>
<p>按深度和广度优先搜索进行遍历将得到不同的生成树，分别称为深度优先生成树和广度优先生成树。</p>
</li>
</ul>
<h3 id="最小生成树">最小生成树</h3>
<p>连通网的生成树的边也带权，把生成树各边的权值总和称为生成树的权。<u>权值最小的生成树称为最小生成树</u>。</p>
<h2 id="aov-网">AOV 网</h2>
<p>一个大工程项目可以分为许多较小子工程（称为活动）。有向图中，用顶点表示活动，弧表示活动之间的优先级关系（活动进行时的制约关系），称这样的有向图为<u>以顶点表示活动的网</u>（Activity On Vertex network，AOV网）。</p>
<p>在AOV网中：</p>
<ul>
<li>
<p>从顶点$v_i$到$v_j$有一条有向路径：</p>
<ul>
<li>$v_i$是$v_j$的前驱，</li>
<li>$v_j$是$v_i$的后继；</li>
</ul>
</li>
<li>
<p>$&lt;v_i,v_j&gt;$：</p>
<ul>
<li>$v_i$是$v_j$的直接前驱，</li>
<li>$v_j$是$v_i$的直接后继。</li>
</ul>
</li>
</ul>
<p>AOV网中不应出现有向环。检测工程是否可行，首先应检查对应AOV网是否存在回路。不存在回路的有向图称为有向无环图（DAG，Directed Acycline Graph）。</p>
<h2 id="拓扑排序">拓扑排序</h2>
<p>检测AOV网是否是DAG的方法是对AOV网构造其<u>顶点的拓扑有序序列</u>。</p>
<p>拓扑排序是将AOV网中的所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点$v_i$到$v_j$有一条路径，则在该线性序列中，$v_i$必在$v_j$之前。对AOV网进行拓扑排序的方法如下：</p>
<ol>
<li>在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。</li>
<li>从网中删除该顶点及与该顶点有关的所有弧。</li>
<li>重复上述两步，直到网中不存在入度为0的顶点为止。</li>
</ol>
<p>两种结果：</p>
<ul>
<li>所有顶点已输出，说明网中不存在回路。</li>
<li>尚有未输出的顶点，剩余顶点均有前驱顶点，表面网中存在回路。</li>
</ul>
<p>有向无环图的拓扑序列中，顶点$v_i$在$v_j$之前，则：</p>
<ul>
<li>可能存在弧$&lt;v_i,v_j&gt;$，一定不存在弧$&lt;v_j,v_i&gt;$；</li>
<li>可能存在$v_i$到$v_j$的路径，一定不存在$v_j$到$v_i$的路径。</li>
</ul>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681115534531.png"
	width="133"
	height="173"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681115534531_hu9a36ad2327d0139feeb1c8e76c812997_7356_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681115534531_hu9a36ad2327d0139feeb1c8e76c812997_7356_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="AOV网拓扑排序例子"
	
	
		class="gallery-image" 
		data-flex-grow="76"
		data-flex-basis="184px"
	
></p>
<p>上图拓扑排序的结果为：6,1,4,3,2,5（结果并不唯一）。</p>
<blockquote>
<p>当有向图中无环时，也可以利用深度优先遍历进行逆拓扑排序。</p>
</blockquote>
<hr>
<h1 id="查找">查找</h1>
<p>查找是一种常用的基本运算。查找表是指由同一类型的数据元素（或记录）构成的集合。</p>
<p>查找表经常要进行的操作：</p>
<ul>
<li>查询某个特定的数据元素是否在查找表中。</li>
<li>检索某个特定的数据元素的各种属性。</li>
</ul>
<p>通常将只进行这两种操作的查找表称为<strong>静态查找表</strong>。</p>
<p>查找表经常要进行的另外两种操作：</p>
<ul>
<li>在查找表中插入一个数据元素。</li>
<li>从查找表中删除一个数据元素。</li>
</ul>
<p>需要在查找表中插入或删除元素，称此类查找表为<strong>动态查找表</strong>。</p>
<p><strong>关键字</strong>是数据元素（或记录）的某个数据项的值，用它来识别（标识）这个数据元素。</p>
<ul>
<li><strong>主关键字</strong>：能唯一标识一个数据元素的关键字。</li>
<li><strong>次关键字</strong>：能标识多个数据元素的关键字。</li>
</ul>
<h2 id="平均查找长度">平均查找长度</h2>
<p>查找算法基本操作是<u>“将记录的关键字与给定值进行比较”</u>。因此，通常<u>以“其关键字和给定值进行过比较的记录个数的期望值”作为衡量查找算法好坏的依据</u>。</p>
<p>查找算法在查找成功时的<u>平均查找长度</u>关键字和给定值比较次数的期望值：</p>
<p>$$
ASL = \sum_{i=1}^{n}{P_iC_i}
$$</p>
<ul>
<li>
<p>$P_i$为对表中第$i$个记录进行查找的概率，</p>
<p>一般认为$P_i=\cfrac{1}{n}, 1 \le i \le n$，即$\sum_{i=1}^{n}{P_i}$；</p>
</li>
<li>
<p>$C_i$为查找成功时，已经进行过比较的关键字个数。</p>
</li>
</ul>
<h2 id="查找算法">查找算法</h2>
<p>静态查找表有以下查找方法：</p>
<ul>
<li>顺序查找；</li>
<li>折半查找；</li>
<li>分块查找。</li>
</ul>
<p>动态查找表有以下查找方法：</p>
<ul>
<li>二叉排序树；</li>
<li>平衡排序树；</li>
<li>B-树；</li>
<li>哈希表。</li>
</ul>
<h3 id="顺序查找">顺序查找</h3>
<p>顺序查找是从表的一端开始，按照顺序（从左往右或从右往左）逐一进行查找。顺序查找的方法<u>对于<strong>顺序存储方式</strong>和<strong>链式存储方式</strong>的查找表都适用</u>。</p>
<p>顺序查找中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：</p>
<p>$$
ASL_{ss} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i+1)} = \cfrac{n+1}{2}
$$</p>
<h3 id="二分查找">二分查找</h3>
<p>二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。步骤如下：</p>
<p>以升序数列$L[0&hellip;n-1]$为例，假设要查找的数为$x$：</p>
<p>让$x$与数列中间位置的元素$L\left[ \left\lfloor \cfrac{n}{2} \right\rfloor \right]$进行比较，如果相等则返回该元素下标，否则：</p>
<ul>
<li>如果$x$比中间元素小，递归地对中间元素左边的数列（比$x$小的元素）进行二分查找；</li>
<li>如果$x$比中间元素大，递归地对中间元素右边的数列（比$x$大的元素）进行二分查找。</li>
</ul>
<p>折半查找的过程可用二叉树描述。$n$个结点的二叉树深度为$\lfloor log_2{n} \rfloor + 1$，折半查找进行比较的关键字个数最多不超过树的深度。所以，折半查找在查找成功时和给定值<u>进行比较的关键字个数最多为$\lfloor log_2{n} \rfloor + 1$</u>。</p>
<p>折半查找的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：</p>
<p>$$
ASL_{bs} = \cfrac{1}{n} \sum_{i=1}^{n}{i \times 2^{i-1}} = \cfrac{n+1}{n} log_2{(n+1)} - 1
$$</p>
<p>当$n$值较大时，$ASL_{bs} \approx log_2{(n+1)} - 1$。</p>
<h1 id="哈希表">哈希表</h1>
<p>哈希表查找（又叫散列表查找）是通过散列技术，将存储位置和关键字构建一个确定的关系$H$，使得每个关键字$key$对应一个存储位置$H(key)$。其中，$H$称为哈希函数或者散列函数。</p>
<p>根据设定的<strong>哈希函数</strong>$H(key)$和<strong>处理冲突的方法</strong>，将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这块连续的空间称为哈希表或散列表，这一映射过程称为<strong>哈希造表</strong>或<strong>散列表</strong>，所得的存储位置称为<strong>哈希地址</strong>或<strong>散列地址</strong>。</p>
<p>对于哈希表，主要考虑两个问题：</p>
<ul>
<li>如何构造哈希函数；</li>
<li>如何解决冲突。</li>
</ul>
<h2 id="冲突">冲突</h2>
<p>对于某个哈希函数$H$和两个关键字$key_1$和$key_2$,如果$key_1 \neq key_2$，而$H(key_1)=H(key_2)$，则称为冲突。</p>
<p>具有相同哈希函数值的关键字对该哈希函数来说称为同义词。</p>
<p>一般情况下，冲突只能尽可能减少而不能完全避免。</p>
<h2 id="哈希函数的构造方法">哈希函数的构造方法</h2>
<p>常用的哈希函数构造方法有：</p>
<ul>
<li>直接定址法；</li>
<li>数字分析法；</li>
<li>平方取中法；</li>
<li>折叠法；</li>
<li>随机数法；</li>
<li>除留余数法……</li>
</ul>
<p>哈希函数的构造要考虑到：</p>
<ul>
<li>
<p>压缩性：节省存储空间；</p>
</li>
<li>
<p>散列性：尽量减少冲突。</p>
<p>要减少冲突，就要设法使哈希函数尽可能均匀地把关键字映射到存储区的各个存储单元。在构造哈希函数时，一般都要对关键字进行计算，且尽可能使关键字的所有组成部分都能起作用。</p>
</li>
</ul>
<h3 id="除留取余数法">除留取余数法</h3>
<p>除留取余数法是最常用的构造散列函数方法。</p>
<p>除留取余数法：</p>
<p>$$
f(key)=key \enspace mod \enspace p\quad (p\le m),\ m为散列表长
$$</p>
<blockquote>
<p>$mod$ 是取模运算。</p>
<p>根据经验，若散列表表长为$m$，通常$p$为小于或等于表长（最好接近$m$）的最小质数，可以更好的减小冲突。</p>
</blockquote>
<h2 id="冲突处理方法">冲突处理方法</h2>
<p>解决冲突就是为出现冲突的关键字找到另一个“空”的哈希地址。在处理冲突的过程中可能得到一个地址序列$H_i,(i=1,2,\dots,k)$。常见的处理冲突的方法有以下几种：</p>
<ul>
<li>开放地址法；</li>
<li>多重散列法（再哈希法）；</li>
<li>链地址法；</li>
<li>公共溢出区法……</li>
</ul>
<h3 id="开放地址法">开放地址法</h3>
<p>开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。</p>
<p>有三种寻找空散列地址的方法：</p>
<ul>
<li>
<p>线性探测法（线性探测再散列）：</p>
<p>$$
H_i=(H(key)+d) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$d$取$0,1,2,&hellip;,m-1$；</li>
<li>$m$为散列表的长度。</li>
</ul>
<p>$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。</p>
</li>
<li>
<p>二次探测法（二次探测再散列）：</p>
<p>$$
H_i=(H(key)+q^2) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$q$取$0,1,-1,2,-2,&hellip;,\pm k$，$k \le \cfrac{m}{2}$</li>
<li>$m$为散列表的长度</li>
</ul>
<p>二次探测法其实是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。</p>
</li>
</ul>
<p>线性探测法市能使第$i$个哈希地址的同义词存入第$i+1$个哈希地址，这样本应存入第$i+1$个哈希地址的元素变成了第$i+2$个哈希地址元素的同义词，……，因此，可能出现很多元素在相邻的哈希地址上“聚集”起来的现象，大大降低了查找效率。</p>
<hr>
<h1 id="排序">排序</h1>
<p>排序算法有稳定排序和不稳定排序两种。假设待排序序列中，$R_i$和$R_j$关键字相同，即$k_i=k_j$，且$R_i$领先与$R_j$排序后</p>
<ul>
<li><strong>稳定排序</strong>：排序后$R_i$和$R_j$相对次序不变，$R_i$任领先于$R_j$；</li>
<li><strong>不稳定排序</strong>：排序后可能出现$R_j$领先于$R_i$的情况。</li>
</ul>
<p>根据记录存储的位置可分为：</p>
<ul>
<li><strong>内部排序</strong>：待排序记录存储在内存中进行排序的过程。</li>
<li><strong>外部排序</strong>：排序记录的数量很大，内存无法容纳全部记录，在排序过程需要对外存进行访问的排序过程。</li>
</ul>
<p>排序过程需要进行的两种基本操作：</p>
<ol>
<li>
<p>比较两个关键字的大小。</p>
<p>这种操作对于大多数排序方法来说是必需的。</p>
</li>
<li>
<p>将记录从一个位置移动到另一个位置。</p>
<p>这种操作可以通过改变记录的存储方式来避免。</p>
</li>
</ol>
<p>排序算法及其时间、空间复杂度：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">最好时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">是否归位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(log_2{n})$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table></div>
<blockquote>
<p>是否归位：在排序过程中，能否确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="选择排序">选择排序</h2>
<p>选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去都是 $O(n²)$ 的时间复杂度。</p>
<p>算法步骤：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复步骤2，直到所有元素均排序完毕。</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectionSort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> len)
{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ; i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> i;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> len; j<span style="color:#f92672">++</span>)     <span style="color:#75715e">// 走访未排序的元素
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 找到最小值
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&lt;</span> arr[min])
                min <span style="color:#f92672">=</span> j;
        <span style="color:#75715e">// i 不是最小数时，将 i 和最小数进行交换
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> min)
        {
            <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr[i];
            arr[i] <span style="color:#f92672">=</span> arr[min];
            arr[min] <span style="color:#f92672">=</span> tmp; 
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { 
        <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">82</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">89</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">37</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">70</span> };
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)<span style="color:#66d9ef">sizeof</span>(arr) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>arr);
    selectionSort(arr, len);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>)
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, arr[i]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>算法步骤：</p>
<p>假设一个序列长度为n，m（m≤n）是已排序完成的在末尾的数。</p>
<ol>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。对比结束后，最后的元素会是最大的数。</p>
</li>
<li>
<p>对接下来n-m个未排序的数重复步骤1和2，直到没有任何一对数字需要比较。</p>
<p>第一趟对序列中所有n个数进行比对，第二趟对序列中n-1个未排序完成的数进行比对，以此类推。每次比对的数为n-m。</p>
</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bubbleSort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> len)
{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&gt;</span> arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
            {
                <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr[j];
                arr[j] <span style="color:#f92672">=</span> arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
                arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> tmp;
            }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { 
        <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">82</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">89</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">37</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">70</span> };
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)<span style="color:#66d9ef">sizeof</span>(arr) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>arr);
    bubbleSort(arr, len);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>)
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, arr[i]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="直接插入排序">直接插入排序</h2>
<p>直接插入排序的做法是：在插入第$i$个记录（$R_i$）时，序列中的前$i-1$个记录$R_1,R_2,\cdots,R_{i-1}$已排好序。将$R_i$与前面的有序序列做比较，找到应该插入的位置将$R_i$插入，并将插入位置后的记录依序向后移动。</p>
<blockquote>
<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p>
<p>对于基本有序的序列用直接插入排序效率是最高的。</p>
<p>不归位：在排序过程中，不能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="希尔排序">希尔排序</h2>
<p>希尔排序又称为“缩小增量排序”，它是对直接插入排序方法的改进。</p>
<p>希尔排序的基本思想是：先将整个待排记录序列分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。</p>
<p>步骤如下：</p>
<ol>
<li>
<p>选择一个增量序列$t_1,t_2,&hellip;,t_k$，其中$t_i &lt; t_{i-1}(1 \le i \le k),t_k = 1$；</p>
<p>一般来说，$t_1 \le \cfrac{n}{2}$。</p>
</li>
<li>
<p>按增量序列个数$k$，对序列进行$k$趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为$t_i$的子序列，分别对各子表进行直接插入排序。仅增量因子为$1$时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681209778321.png"
	width="649"
	height="460"
	srcset="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681209778321_hu3445f2349c32f6de565415fce2b1b7c8_87538_480x0_resize_box_3.png 480w, /p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681209778321_hu3445f2349c32f6de565415fce2b1b7c8_87538_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="141"
		data-flex-basis="338px"
	
></p>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="计数排序">计数排序</h2>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是$Θ(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<blockquote>
<p>计数排序是用来排序0到100之间的数字的最好的算法。</p>
</blockquote>
<p>算法步骤：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素。</li>
<li>统计数组中每个值为 <code>i</code>的元素出现的次数，存入数组 <code>C</code>的第 <code>i</code>项。</li>
<li>对所有的计数累加（从 <code>C</code>中的第一个元素开始，每一项和前一项相加）。</li>
<li>反向填充目标数组：将每个元素 <code>i</code>放在新数组的第 <code>C(i)</code> 项，每放一个元素就将 <code>C(i)</code> 减去 <code>1</code>。</li>
</ol>
<h2 id="堆排序">堆排序</h2>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p>
<p>堆积是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ol>
<p>算法步骤</p>
<ol>
<li>
<p>将待排序的数组构造出一个堆 <code>H[0……n-1]</code>；</p>
</li>
<li>
<p>把堆首（堆顶结点，即最大值）和堆尾（堆的最下层最右边的结点）互换；</p>
<p>此时不再对原堆顶（最大值）进行操作，即原堆顶已经被“移出”，堆的长度缩小1。</p>
</li>
<li>
<p>把新的数组顶端数据调整到相应位置；</p>
</li>
<li>
<p>重复步骤 2 到 3，直到堆的尺寸为 1。</p>
</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="快速排序">快速排序</h2>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>算法步骤</p>
<ol>
<li>从序列中选择一个元素作为“基准”（pivot）。</li>
<li>将所有比基准数小的放在基准左边，所有比基准数大的放在基准右边（相同的数可以在任一边）。这个称为分区（partition）操作。</li>
<li>分区完成后，该基准就会归到序列中的相应位置，该位置是排序完成后的位置。</li>
<li>分别递归地把小于基准数的子序列（左边）和大于基准数的子序列（右边）重复执行1到3操作。</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="归并排序">归并排序</h2>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ol>
<li>自上而下的递归；</li>
<li>自下而上的迭代。</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<blockquote>
<p>不归位：在排序过程中，不能确定某些元素的最终排序位置。</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E8%BD%AF%E8%80%83/">软考</a>
        
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        
            <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
        
    </section>


    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
       
</article>


    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        数据库（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        面向对象（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        知识产权（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        程序设计语言（软件设计师）</a>
</div>
</section>

            
                

<section class="tagCloud" style="margin-right: 10px;">
<div class="tagCloud-tags">
    <a href="/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">
        
        

        计算机系统（软件设计师）</a>
</div>
</section>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 Linner&#39;s Blog

        <span style="padding-left: 5px;padding-right: 5px;">|</span>

        <a href="https://beian.miit.gov.cn/" target="_blank" >粤ICP备2022125602号-1</a>
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
