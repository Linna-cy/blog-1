<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>编译原理 on Linner&#39;s Blog</title>
        <link>https://blog.linner.asia/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link>
        <description>Recent content in 编译原理 on Linner&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <lastBuildDate>Thu, 30 Mar 2023 19:58:41 +0800</lastBuildDate><atom:link href="https://blog.linner.asia/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>程序设计语言篇</title>
        <link>https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/</link>
        <pubDate>Thu, 30 Mar 2023 19:58:41 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/</guid>
        <description>&lt;h1 id=&#34;低级和高级语言&#34;&gt;低级和高级语言&lt;/h1&gt;
&lt;p&gt;程序设计语言根据硬件是否能识别区分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低级语言&lt;/strong&gt;：二进制机器指令、汇编语言。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级语言&lt;/strong&gt;：面向各类应用的程序设计语言，更加接近自然语言。需要通过编译器或解释器（翻译）来让机器执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;编译和解释&#34;&gt;编译和解释&lt;/h1&gt;
&lt;p&gt;程序设计语言按照翻译的方式可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;：需要通过&lt;strong&gt;编译器&lt;/strong&gt;（&lt;strong&gt;编译程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;编译为包含二进制指令的&lt;u&gt;可执行文件（目标程序）&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;真正在机器上运行的是与源程序（逻辑）等价的目标程序。&lt;/p&gt;
&lt;p&gt;源程序和编译器都不再参与目标程序的运行过程。&lt;/p&gt;
&lt;p&gt;汇编程序也是属于编译执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：需要通过&lt;strong&gt;解释器&lt;/strong&gt;（&lt;strong&gt;解释程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;中的指令解释为二进制指令后给机器执行。&lt;/p&gt;
&lt;p&gt;该过程不会产生独立的目标程序。&lt;/p&gt;
&lt;p&gt;并且解释器和源程序都会参与到程序的运行过程（运行控制）中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与编译方式相比，解释方式程序执行的速度慢，因为解释方式执行的程序，需要解释器在其中充当一个原程序与机器之前实时的翻译。&lt;/p&gt;
&lt;p&gt;脚本语言属于动态语言，其程序结构可以在运行中改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译过程&#34;&gt;编译过程&lt;/h2&gt;
&lt;p&gt;编译程序的功能是把某高级语言书写的&lt;u&gt;源程序翻译成与之等价的目标程序&lt;/u&gt;（汇编语言或机
器语言)。&lt;/p&gt;
&lt;p&gt;编译程序的工作过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680232196718.png&#34;
	width=&#34;549&#34;
	height=&#34;466&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;282px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其中，以下几个阶段对于编译过程来说是必须的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下两个阶段对于编译过程来说不是必须的（可省略）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;li&gt;（中间或目标）代码优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;词法分析&#34;&gt;词法分析&lt;/h3&gt;
&lt;p&gt;源程序可以简单地被看成是一个&lt;u&gt;多行的字符串&lt;/u&gt;。&lt;strong&gt;词法分析&lt;/strong&gt;阶段的任务是&lt;u&gt;对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号&lt;/u&gt;。&lt;strong&gt;“单词”符号&lt;/strong&gt;是程序设计语言的&lt;strong&gt;基本语法单位&lt;/strong&gt;，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。&lt;/p&gt;
&lt;p&gt;词法分析程序输出的“单词”&lt;u&gt;常以&lt;strong&gt;二元组&lt;/strong&gt;的方式输出&lt;/u&gt;，即单词种别和单词自身的值。&lt;/p&gt;
&lt;p&gt;词法分析过程依据的是语言的&lt;u&gt;词法规则&lt;/u&gt;，即描述“单词”结构的规则。&lt;/p&gt;
&lt;h4 id=&#34;词法规则&#34;&gt;词法规则&lt;/h4&gt;
&lt;p&gt;词法分析根据词法规则将构成源程序的字符串转换成单词符号序列。词法规则可用3型文法（正规文法）或正规表达式描述。&lt;/p&gt;
&lt;h5 id=&#34;正规表达式&#34;&gt;正规表达式&lt;/h5&gt;
&lt;p&gt;正规表达式（正规式）有以下符号：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;闭包&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示其前面链接的符号或集合可以出现$[0, +\infty]$次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;·&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;连接&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可省略，将多个符号或集合连接起来。表示逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;或&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示逻辑或。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/1680248469003.png&#34;
	width=&#34;990&#34;
	height=&#34;277&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;357&#34;
		data-flex-basis=&#34;857px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;设$U$、$V$和$W$均为正规式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680249034196.png&#34;
	width=&#34;974&#34;
	height=&#34;185&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;526&#34;
		data-flex-basis=&#34;1263px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;有限自动机&#34;&gt;有限自动机&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;有限自动机&lt;/strong&gt;是词法分析的一个工具（一种识别装置的抽象概念），它能正确地&lt;strong&gt;识别正规集&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定的有限自动机&lt;/strong&gt;（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个DFA是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$S$：包含&lt;u&gt;状态的有限集&lt;/u&gt;（每个元素称为一个状态）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Sigma$：有穷&lt;u&gt;字母表&lt;/u&gt;，其每个元素称为一个&lt;u&gt;输入字符&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f$：$S \times \Sigma \to S$ 上的&lt;u&gt;单值部分映像&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$&lt;/p&gt;
&lt;p&gt;表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$s_0$：唯一的&lt;u&gt;开始状态&lt;/u&gt;，$s_0 \in S$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Z$：非空的&lt;u&gt;终止状态集合&lt;/u&gt;，$Z \subseteq S$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFA可以用两种直观的方式表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换图&lt;/strong&gt;：简称为转换图，是一个有向图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;状态&lt;/strong&gt;对应转换图中的一个&lt;strong&gt;结点&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;转换函数&lt;/strong&gt;对应图中的一条&lt;strong&gt;有向弧&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双圈表示的结点是终态结点。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;终态也可以是初态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换矩阵&lt;/strong&gt;：用一个二位数组$M$表示。&lt;/p&gt;
&lt;p&gt;矩阵元素$M[A,a]$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行下标&lt;/strong&gt;：表示状态。当前状态为$A$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列下标&lt;/strong&gt;：表示输入的字符。当前输入为$a$。&lt;/li&gt;
&lt;li&gt;$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680251834262.png&#34;
	width=&#34;983&#34;
	height=&#34;160&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;614&#34;
		data-flex-basis=&#34;1474px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680251962756.png&#34;
	width=&#34;982&#34;
	height=&#34;585&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不确定的有限自动机&lt;/strong&gt;（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是不唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;NFA也是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$f$是$S \times \Sigma \to 2^S$ 上的映像。&lt;/p&gt;
&lt;p&gt;对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DFA是NFA的特例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680252743732.png&#34;
	width=&#34;918&#34;
	height=&#34;407&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;541px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有向弧中出现如 $a,b$，代表该有向弧输入的值可以为$a$&lt;strong&gt;或&lt;/strong&gt;$b$。即&lt;code&gt;,&lt;/code&gt;代表或。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;语法分析&#34;&gt;语法分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语法分析&lt;/strong&gt;的任务是在词法分析的基础上，&lt;u&gt;根据语言的语法规则将单词符号序列分解成各类语法单位&lt;/u&gt;，如“表达式”“语句”和“程序”等。&lt;/p&gt;
&lt;p&gt;如果源程序中没有语法错误，语法分析后就能正确地&lt;u&gt;构造出其语法树&lt;/u&gt;；否则&lt;u&gt;指出语法错误&lt;/u&gt;，并&lt;u&gt;给出相应的诊断信息&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;例如对&lt;code&gt;id1 := id2 + id3 * 60&lt;/code&gt;进行语法分析后形成的语法树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680233200526.png&#34;
	width=&#34;888&#34;
	height=&#34;266&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;333&#34;
		data-flex-basis=&#34;801px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;一般来说，根据表达式生成的语法树，运算符在表达式种优先级越高，它在语法树中的层次就越低，反之亦然。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;词法分析和语法分析在本质上都是对源程序的结构进行分析。&lt;/p&gt;
&lt;p&gt;到达语法分析阶段可以发现程序中所有的语法错误。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量的值是否正确；&lt;/li&gt;
&lt;li&gt;语句的形式是否正确；&lt;/li&gt;
&lt;li&gt;语句的结构是否合法；&lt;/li&gt;
&lt;li&gt;检查括号是否匹配；&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法分析方法有多种，根据产生语法树的方向，可分为&lt;strong&gt;自底向上&lt;/strong&gt;和&lt;strong&gt;自顶向下&lt;/strong&gt;两类。&lt;/p&gt;
&lt;h4 id=&#34;上下文无关文法&#34;&gt;上下文无关文法&lt;/h4&gt;
&lt;p&gt;程序设计语言的&lt;u&gt;绝大多数&lt;strong&gt;语法规则&lt;/strong&gt;可以采用&lt;strong&gt;上下文无关文法&lt;/strong&gt;进行描述&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;上下文无关文法属于乔姆斯基定义的2型文法。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法，$G[S] = (V_N, V_T, P, S)$，其产生式的形式都是 $A \to \beta$，其中 $A \in V_n$，$\beta \in (V_N \cup V_T)^*$。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V_N$：非终结符号集合，&lt;/li&gt;
&lt;li&gt;$V_T$：终结符号集合，&lt;/li&gt;
&lt;li&gt;$P$：产生式集合，&lt;/li&gt;
&lt;li&gt;$S$：开始符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680255073014.png&#34;
	width=&#34;990&#34;
	height=&#34;393&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;251&#34;
		data-flex-basis=&#34;604px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上下文无关文法的推导过程可用树型结构描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680255429332.png&#34;
	width=&#34;210&#34;
	height=&#34;346&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AF%87/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;60&#34;
		data-flex-basis=&#34;145px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由上下文无关文法的推导过程也可以看出它是自顶向下推导。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法中的集合，有以下对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$S \to P$&lt;/li&gt;
&lt;li&gt;$P \to V_N$&lt;/li&gt;
&lt;li&gt;$V_N \to V_T$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语义分析&#34;&gt;语义分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语义分析&lt;/strong&gt;阶段分析各语法结构的含义，&lt;u&gt;检查源程序是否包含静态语义错误&lt;/u&gt;，并&lt;u&gt;收集类型信息&lt;/u&gt;供后面的代码生成阶段使用。&lt;u&gt;只有语法和语义都正确的源程序才能翻译成正确的目标代码。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;语义分析的一个主要工作是&lt;u&gt;进行类型分析和检查&lt;/u&gt;。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。&lt;/p&gt;
&lt;p&gt;语义分析阶段的输入是上一个阶段（语法分析）所构造的语法树。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析后语法树中可能会出现一些语义处理结点。例如&lt;code&gt;inttoreal&lt;/code&gt;，表示将一个整型数转换为浮点数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析不能发现程序中所有的语义错误。语义分析只能发现静态语义错误，动态语义错误需要在生成目标程序后运行时才能发现。&lt;/p&gt;
&lt;p&gt;有语义错误是可以编译成功的。例如&lt;code&gt;a/0&lt;/code&gt;，符合语法，也符合静态语义，编译器检验不出来这个是错的，只有运行才会报错，也就是动态语义，动态语义错误常见的还有死循环。&lt;/p&gt;
&lt;p&gt;PS：现在有些IDE会对一些常见的动态语义错误进行检查，在程序编译前提示给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;中间代码生成&#34;&gt;中间代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;中间代码生成&lt;/strong&gt;阶段的工作是&lt;u&gt;根据语义分析的输出生成中间代码&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。最常用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。四元式的形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(运算符, 运算对象1, 运算对象2, 运算结果)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;语义分析和中间代码生成所依据的是语言的语义规则。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;中间代码生成阶段&lt;/u&gt;对于编译过程来说是&lt;u&gt;可省略的&lt;/u&gt;。但是&lt;u&gt;前面的三个阶段词法分析、语法分析和语义分析还有最后的目标代码生成是不可省略的&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;编译器前后端&#34;&gt;编译器前后端&lt;/h4&gt;
&lt;p&gt;对于编译过程的各个阶段，在逻辑上可以把它们划分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;中间代码优化&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以中间代码为分水岭（中间代码作为前端的输出，然后再作为后端的输入来连接前后端），把编译器分成了与机器有关的部分（后端）和与机器无关的部分（前端）。如此一来，对于同一种程序设计语言的编译器，开发出一个前端之后，就可以针对不同的机器开发相应的后端，前、后端有机结合后就形成了该语言的一个编译器。当语言有改动时，只会涉及前端部分的维护。&lt;/p&gt;
&lt;p&gt;对于不同的程序设计语言，分别设计出相应的前端，然后将各个语言的前端与同一个后端相结合，就可以得到各个语言在某种机器上的编译器。&lt;/p&gt;
&lt;p&gt;使用中间代码，将编译器分为前后端的好处是，有利于编译程序的可移植性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译程序的可移植性提高了，那么相应的源程序（源代码）的可移植也会提高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;中缀和后缀表达式&#34;&gt;中缀和后缀表达式&lt;/h4&gt;
&lt;p&gt;中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。&lt;/p&gt;
&lt;p&gt;根据生成的语法树，按照不同的方式遍历即可生成形式不同的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中缀表达式：中序遍历（左-根-右）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀表达式：后序便利（左-右-根）。&lt;/p&gt;
&lt;p&gt;后缀转中缀用到了栈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;逆波兰式其实就是后缀式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;代码优化&#34;&gt;代码优化&lt;/h3&gt;
&lt;p&gt;由于编译器将源程序翻译成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间上和空间上有较大的浪费。&lt;u&gt;当需要生成高效的目标代码时，必须进行优化。&lt;/u&gt;优化过程&lt;u&gt;可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;由于中间代码不依赖于具体机器，此时&lt;u&gt;所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关&lt;/u&gt;。优化所依据的原则是&lt;strong&gt;程序的等价变换规则&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;目标代码生成&#34;&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标代码&lt;/strong&gt;生成阶段的任务是&lt;u&gt;把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码&lt;/u&gt;，这个阶段的工作&lt;strong&gt;与具体的机器密切相关&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;寄存器的分配：寄存器访问速度快，但数量有限，所以如何分配及使用寄存器是目标代码生成时需要着重考虑的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译过程中为变量分配的存储单元所用的地址是&lt;strong&gt;逻辑地址&lt;/strong&gt;，程序运行时再将逻辑地址映射为物理地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;符号表管理&#34;&gt;符号表管理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;符号表&lt;/strong&gt;的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录源程序中各个符号的必要信息；&lt;/li&gt;
&lt;li&gt;辅助语义的正确性检查和代码生成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;符号表在前三个阶段构建&lt;/u&gt;：可以始于词法分析阶段，也可以放到语法分析和语义分析阶段&lt;/li&gt;
&lt;li&gt;符号表的使用有时会&lt;u&gt;延续到目标代码的运行阶段&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编译过程中翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需的信息正确地填入符号表；对可执行语句，则是将其翻译成中间代码或目标代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;出错处理&#34;&gt;出错处理&lt;/h3&gt;
&lt;p&gt;编写的源程序中出现的错误分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态错误&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;编译阶段发现的程序错误，又可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法错误：有关语言结构上的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态语义错误：运算符与运算对象类型不合法等错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态错误&lt;/strong&gt;（动态语义错误）：发生在程序运行时。&lt;/p&gt;
&lt;p&gt;常见的动态错误例如除数为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译时发现程序中的错误后，编译程序应采用适当的策略修复它们，使得分析过程能够继续下去，以便在一次编译过程中尽可能多地找出程序中的错误。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;程序设计语言的基本成分&#34;&gt;程序设计语言的基本成分&lt;/h1&gt;
&lt;p&gt;程序设计语言的基本成分包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;运算&lt;/li&gt;
&lt;li&gt;控制&lt;/li&gt;
&lt;li&gt;传输&lt;/li&gt;
&lt;li&gt;（函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据成分&#34;&gt;数据成分&lt;/h2&gt;
&lt;p&gt;数据成分包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识符&lt;/strong&gt;：标识符通常是由字母、数字和下划线&lt;code&gt;_&lt;/code&gt;组成，并且不能由数字开头。&lt;/p&gt;
&lt;p&gt;一般有如下种类标识符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字。&lt;/li&gt;
&lt;li&gt;变量名。&lt;/li&gt;
&lt;li&gt;函数名。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;现在，某些高级语言已经支持中文等字符来当作变量名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量&lt;/strong&gt;：一般有&lt;u&gt;字面量&lt;/u&gt;（例如&lt;code&gt;123&lt;/code&gt;、&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;）和&lt;u&gt;不可变变量（在某些语言中也称其为常量）&lt;/u&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常量也具有类型；&lt;/li&gt;
&lt;li&gt;常量也有对应的存储单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt;：用来存储数据或对象。有存储类别、类型、名称（变量名）、作用域和生存周期等属性（这些也是数据的属性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为整个文件或程序&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;局部量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为定义它的函数或语句块中&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;：按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型（C和C++）及其他类型等。&lt;/p&gt;
&lt;p&gt;许多程序设计语言都规定，程序中的数据都必须具有类型，其作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分配存储单元&lt;/strong&gt;：便于为数据合理分配存储单元；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;检查数据对象&lt;/strong&gt;：便于对参与表达式计算的数据对象进行（合法性）检查；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取值范围&lt;/strong&gt;：便于规定数据对象的取值范围及能够进行的运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;动态数据结构，其数据的结构会在程序运行过程中改变，例如链表、二叉树等。&lt;/p&gt;
&lt;p&gt;动态数据结构的数据空间必须采用&lt;strong&gt;堆存储&lt;/strong&gt;分配策略，数据存放在&lt;strong&gt;堆区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在C/C++中，全局变量的存储空间在静态数据区分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;运算成分&#34;&gt;运算成分&lt;/h2&gt;
&lt;p&gt;大多数高级程序设计语言的基本运算可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算。&lt;/li&gt;
&lt;li&gt;关系运算。&lt;/li&gt;
&lt;li&gt;逻辑运算。&lt;/li&gt;
&lt;li&gt;位运算。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;
&lt;p&gt;有以下三种结构来构造程序中的控制逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序结构。&lt;/li&gt;
&lt;li&gt;选择结构。&lt;/li&gt;
&lt;li&gt;循环结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数高级语言都针对循环结构提供了&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;等控制流跳转语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;传输成分&#34;&gt;传输成分&lt;/h2&gt;
&lt;p&gt;程序设计语言的传输成分指明语言允许的数据传输方式，如赋值处理、数据的输入和输出等。&lt;/p&gt;
&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数首部：
&lt;ul&gt;
&lt;li&gt;返回值类型&lt;/li&gt;
&lt;li&gt;函数名&lt;/li&gt;
&lt;li&gt;形参表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数体：定义函数所实现的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;：在C（C++）中，函数需要先声明后引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数调用&lt;/strong&gt;：在调用函数中使用被调函数实现的功能。函数调用的一般形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数名(实参表)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用函数与被调函数之间参数的传递有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;值调用&lt;/strong&gt;（Call by Value）：形参是实参的一份拷贝。即实参将值传递给形参，对形参值的更改并不会作用到实参上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;引用调用&lt;/strong&gt;（Call by Reference）：形参是实参的一个别名。即函数中对形参的访问和修改实际上是对其相应实参所做的访问和修改。&lt;/p&gt;
&lt;p&gt;引用调用下，可以实现形参和实参之间数据的双向传递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在进行函数调用和返回时，由系统使用栈区来进行控制和管理。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
