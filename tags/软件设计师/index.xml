<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>软件设计师 on Linner&#39;s Blog</title>
        <link>https://www.linner.asia/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <description>Recent content in 软件设计师 on Linner&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <lastBuildDate>Thu, 30 Mar 2023 19:58:41 +0800</lastBuildDate><atom:link href="https://www.linner.asia/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>软件设计师——程序设计语言</title>
        <link>https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</link>
        <pubDate>Thu, 30 Mar 2023 19:58:41 +0800</pubDate>
        
        <guid>https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</guid>
        <description>&lt;h1 id=&#34;低级和高级语言&#34;&gt;低级和高级语言&lt;/h1&gt;
&lt;p&gt;程序设计语言根据硬件是否能识别区分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低级语言&lt;/strong&gt;：二进制机器指令、汇编语言。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级语言&lt;/strong&gt;：面向各类应用的程序设计语言，更加接近自然语言。需要通过编译器或解释器（翻译）来让机器执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;编译和解释&#34;&gt;编译和解释&lt;/h1&gt;
&lt;p&gt;程序设计语言按照翻译的方式可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;：需要通过&lt;strong&gt;编译器&lt;/strong&gt;（&lt;strong&gt;编译程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;编译为包含二进制指令的&lt;u&gt;可执行文件（目标程序）&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;真正在机器上运行的是与源程序等价的目标程序。&lt;/p&gt;
&lt;p&gt;源程序和编译器都不再参与目标程序的运行过程。&lt;/p&gt;
&lt;p&gt;汇编程序也是属于编译执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：需要通过&lt;strong&gt;解释器&lt;/strong&gt;（&lt;strong&gt;解释程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;中的指令解释为二进制指令后给机器执行。&lt;/p&gt;
&lt;p&gt;该过程不会产生独立的目标程序。&lt;/p&gt;
&lt;p&gt;并且解释器和源程序都会参与到程序的运行过程中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译过程&#34;&gt;编译过程&lt;/h2&gt;
&lt;p&gt;编译程序的功能是把某高级语言书写的&lt;u&gt;源程序翻译成与之等价的目标程序&lt;/u&gt;（汇编语言或机
器语言)。&lt;/p&gt;
&lt;p&gt;编译程序的工作过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680232196718.png&#34;
	width=&#34;549&#34;
	height=&#34;466&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;282px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其中，以下几个阶段对于编译过程来说是必须的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下两个阶段对于编译过程来说不是必须的（可省略）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;li&gt;（中间或目标）代码优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于编译过程的各个阶段，在逻辑上可以把它们划分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;中间代码优化&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以中间代码为分水岭，把编译器分成了与机器有关的部分和与机器无关的部分。如此一来，对于同一种程序设计语言的编译器，开发出一个前端之后，就可以针对不同的机器开发相应的后端，前、后端有机结合后就形成了该语言的一个编译器。当语言有改动时，只会涉及前端部分的维护。&lt;/p&gt;
&lt;p&gt;对于不同的程序设计语言，分别设计出相应的前端，然后将各个语言的前端与同一个后端相结合，就可以得到各个语言在某种机器上的编译器。&lt;/p&gt;
&lt;h3 id=&#34;词法分析&#34;&gt;词法分析&lt;/h3&gt;
&lt;p&gt;源程序可以简单地被看成是一个&lt;u&gt;多行的字符串&lt;/u&gt;。&lt;strong&gt;词法分析&lt;/strong&gt;阶段的任务是&lt;u&gt;对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号&lt;/u&gt;。&lt;strong&gt;“单词”符号&lt;/strong&gt;是程序设计语言的&lt;strong&gt;基本语法单位&lt;/strong&gt;，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。&lt;/p&gt;
&lt;p&gt;词法分析程序输出的“单词”&lt;u&gt;常以&lt;strong&gt;二元组&lt;/strong&gt;的方式输出&lt;/u&gt;，即单词种别和单词自身的值。&lt;/p&gt;
&lt;p&gt;词法分析过程依据的是语言的&lt;u&gt;词法规则&lt;/u&gt;，即描述“单词”结构的规则。&lt;/p&gt;
&lt;h4 id=&#34;词法规则&#34;&gt;词法规则&lt;/h4&gt;
&lt;p&gt;词法分析根据词法规则将构成源程序的字符串转换成单词符号序列。词法规则可用3型文法（正规文法）或正规表达式描述。&lt;/p&gt;
&lt;h5 id=&#34;正规表达式&#34;&gt;正规表达式&lt;/h5&gt;
&lt;p&gt;正规表达式（正规式）有以下符号：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;闭包&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示其前面链接的符号或集合可以出现$[0, +\infty]$次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;·&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;连接&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可省略，将多个符号或集合连接起来。表示逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;或&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/1680248469003.png&#34;
	width=&#34;990&#34;
	height=&#34;277&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;357&#34;
		data-flex-basis=&#34;857px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;设$U$、$V$和$W$均为正规式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680249034196.png&#34;
	width=&#34;974&#34;
	height=&#34;185&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;526&#34;
		data-flex-basis=&#34;1263px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;有限自动机&#34;&gt;有限自动机&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;有限自动机&lt;/strong&gt;是词法分析的一个工具（一种识别装置的抽象概念），它能正确地&lt;strong&gt;识别正规集&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定的有限自动机&lt;/strong&gt;（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个DFA是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$S$：包含&lt;u&gt;状态的有限集&lt;/u&gt;（每个元素称为一个状态）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Sigma$：有穷&lt;u&gt;字母表&lt;/u&gt;，其每个元素称为一个&lt;u&gt;输入字符&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f$：$S \times \Sigma \to S$ 上的&lt;u&gt;单值部分映像&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$&lt;/p&gt;
&lt;p&gt;表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$s_0$：唯一的&lt;u&gt;开始状态&lt;/u&gt;，$s_0 \in S$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Z$：非空的&lt;u&gt;终止状态集合&lt;/u&gt;，$Z \subseteq S$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFA可以用两种直观的方式表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换图&lt;/strong&gt;：简称为转换图，是一个有向图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;状态&lt;/strong&gt;对应转换图中的一个&lt;strong&gt;结点&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;转换函数&lt;/strong&gt;对应图中的一条&lt;strong&gt;有向弧&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双圈表示的结点是终态结点。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;终态也可以是初态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换矩阵&lt;/strong&gt;：用一个二位数组$M$表示。&lt;/p&gt;
&lt;p&gt;矩阵元素$M[A,a]$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行下标&lt;/strong&gt;：表示状态。当前状态为$A$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列下标&lt;/strong&gt;：表示输入的字符。当前输入为$a$。&lt;/li&gt;
&lt;li&gt;$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251834262.png&#34;
	width=&#34;983&#34;
	height=&#34;160&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;614&#34;
		data-flex-basis=&#34;1474px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251962756.png&#34;
	width=&#34;982&#34;
	height=&#34;585&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不确定的有限自动机&lt;/strong&gt;（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是不唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;NFA也是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$f$是$S \times \Sigma \to 2^S$ 上的映像。&lt;/p&gt;
&lt;p&gt;对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DFA是NFA的特例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680252743732.png&#34;
	width=&#34;918&#34;
	height=&#34;407&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;541px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有向弧中出现如 $a,b$，代表该有向弧输入的值可以为$a$&lt;strong&gt;或&lt;/strong&gt;$b$。即&lt;code&gt;,&lt;/code&gt;代表或。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;语法分析&#34;&gt;语法分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语法分析&lt;/strong&gt;的任务是在词法分析的基础上，&lt;u&gt;根据语言的语法规则将单词符号序列分解成各类语法单位&lt;/u&gt;，如“表达式”“语句”和“程序”等。&lt;/p&gt;
&lt;p&gt;如果源程序中没有语法错误，语法分析后就能正确地&lt;u&gt;构造出其语法树&lt;/u&gt;；否则&lt;u&gt;指出语法错误&lt;/u&gt;，并&lt;u&gt;给出相应的诊断信息&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;例如对&lt;code&gt;id1 := id2 + id3 * 60&lt;/code&gt;进行语法分析后形成的语法树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680233200526.png&#34;
	width=&#34;888&#34;
	height=&#34;266&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;333&#34;
		data-flex-basis=&#34;801px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;词法分析和语法分析在本质上都是对源程序的结构进行分析。&lt;/p&gt;
&lt;p&gt;到达语法分析阶段可以发现程序中所有的语法错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法分析方法有多种，根据产生语法树的方向，可分为自底向上和自项向下两类。&lt;/p&gt;
&lt;h4 id=&#34;上下文无关文法&#34;&gt;上下文无关文法&lt;/h4&gt;
&lt;p&gt;程序设计语言的&lt;u&gt;绝大多数&lt;strong&gt;语法规则&lt;/strong&gt;可以采用&lt;strong&gt;上下文无关文法&lt;/strong&gt;进行描述&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;上下文无关文法属于乔姆斯基定义的2型文法。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法，$G[S] = (V_N, V_T, P, S)$，其产生式的形式都是 $A \to \beta$，其中 $A \in V_n$，$\beta \in (V_N \cup V_T)^*$。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V_N$：非终结符号集合，&lt;/li&gt;
&lt;li&gt;$V_T$：终结符号集合，&lt;/li&gt;
&lt;li&gt;$P$：产生式集合，&lt;/li&gt;
&lt;li&gt;$S$：开始符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255073014.png&#34;
	width=&#34;990&#34;
	height=&#34;393&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;251&#34;
		data-flex-basis=&#34;604px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上下文无关文法的推导过程可用树型结构描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255429332.png&#34;
	width=&#34;210&#34;
	height=&#34;346&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;60&#34;
		data-flex-basis=&#34;145px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由上下文无关文法的推导过程也可以看出它是自顶向下推导。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法中的集合，有以下对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$S \to P$&lt;/li&gt;
&lt;li&gt;$P \to V_N$&lt;/li&gt;
&lt;li&gt;$V_N \to V_T$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语义分析&#34;&gt;语义分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语义分析&lt;/strong&gt;阶段分析各语法结构的含义，&lt;u&gt;检查源程序是否包含静态语义错误&lt;/u&gt;，并收集类型信息供后面的代码生成阶段使用。&lt;u&gt;只有语法和语义都正确的源程序才能翻译成正确的目标代码。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;语义分析的一个主要工作是&lt;u&gt;进行类型分析和检查&lt;/u&gt;。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。&lt;/p&gt;
&lt;p&gt;语义分析阶段的输入是上一个阶段（语法分析）所构造的语法树。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析后语法树中可能会出现一些语义处理结点。例如&lt;code&gt;inttoreal&lt;/code&gt;，表示将一个整型数转换为浮点数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析不能发现程序中所有的语义错误。语义分析只能发现静态语义错误，动态语义错误需要在生成目标程序后运行时才能发现。&lt;/p&gt;
&lt;p&gt;有语义错误是可以编译成功的。例如&lt;code&gt;a/0&lt;/code&gt;，符合语法，也符合静态语义，编译器检验不出来这个是错的，只有运行才会报错，也就是动态语义，动态语义错误常见的还有死循环。&lt;/p&gt;
&lt;p&gt;PS：现在有些IDE会对一些常见的动态语义错误进行检查，在程序编译前提示给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;中间代码生成&#34;&gt;中间代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;中间代码生成&lt;/strong&gt;阶段的工作是&lt;u&gt;根据语义分析的输出生成中间代码&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。最常用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。四元式的形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(运算符, 运算对象1, 运算对象2, 运算结果)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;语义分析和中间代码生成所依据的是语言的语义规则。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;中间代码生成阶段&lt;/u&gt;对于编译过程来说是&lt;u&gt;可省略的&lt;/u&gt;。但是&lt;u&gt;前面的三个阶段词法分析、语法分析和语义分析还有最后的目标代码生成是不可省略的&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。&lt;/p&gt;
&lt;h4 id=&#34;中缀和后缀表达式&#34;&gt;中缀和后缀表达式&lt;/h4&gt;
&lt;p&gt;根据生成的语法树，按照不同的方式遍历即可生成形式不同的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中缀表达式：中序遍历（左-根-右）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀表达式：后序便利（左-右-根）。&lt;/p&gt;
&lt;p&gt;后缀转中缀用到了栈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;逆波兰式其实就是后缀式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;代码优化&#34;&gt;代码优化&lt;/h3&gt;
&lt;p&gt;由于编译器将源程序翻译成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间上和空间上有较大的浪费。&lt;u&gt;当需要生成高效的目标代码时，必须进行优化。&lt;/u&gt;优化过程&lt;u&gt;可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;由于中间代码不依赖于具体机器，此时&lt;u&gt;所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关&lt;/u&gt;。优化所依据的原则是&lt;strong&gt;程序的等价变换规则&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;目标代码生成&#34;&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标代码&lt;/strong&gt;生成阶段的任务是&lt;u&gt;把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码&lt;/u&gt;，这个阶段的工作&lt;strong&gt;与具体的机器密切相关&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;寄存器的分配：寄存器访问速度快，但数量有限，所以如何分配及使用寄存器是目标代码生成时需要着重考虑的。&lt;/p&gt;
&lt;h3 id=&#34;符号表管理&#34;&gt;符号表管理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;符号表&lt;/strong&gt;的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录源程序中各个符号的必要信息&lt;/li&gt;
&lt;li&gt;辅助语义的正确性检查和代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;符号表在前三个阶段构建&lt;/u&gt;：可以始于词法分析阶段，也可以放到语法分析和语义分析阶段&lt;/li&gt;
&lt;li&gt;符号表的使用有时会&lt;u&gt;延续到目标代码的运行阶段&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;出错处理&#34;&gt;出错处理&lt;/h3&gt;
&lt;p&gt;编写的源程序中出现的错误分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态错误&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;编译阶段发现的程序错误，又可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法错误：有关语言结构上的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态语义错误：运算符与运算对象类型不合法等错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态错误&lt;/strong&gt;（动态语义错误）：发生在程序运行时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译时发现程序中的错误后，编译程序应采用适当的策略修复它们，使得分析过程能够继续下去，以便在一次编译过程中尽可能多地找出程序中的错误。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;程序设计语言的基本成分&#34;&gt;程序设计语言的基本成分&lt;/h1&gt;
&lt;h2 id=&#34;数据成分&#34;&gt;数据成分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识符&lt;/strong&gt;：标识符通常是由字母、数字和下划线&lt;code&gt;_&lt;/code&gt;组成，并且不能由数字开头。&lt;/p&gt;
&lt;p&gt;一般有如下种类标识符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字。&lt;/li&gt;
&lt;li&gt;变量名。&lt;/li&gt;
&lt;li&gt;函数名。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;现在，某些高级语言已经支持中文等字符来当作变量名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量&lt;/strong&gt;：一般有&lt;u&gt;字面量&lt;/u&gt;（例如&lt;code&gt;123&lt;/code&gt;、&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;）和&lt;u&gt;不可变变量（在某些语言中也称其为常量）&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt;：用来存储数据或对象。有存储类别、类型、名称（变量名）、作用域和生存周期等属性（这些也是数据的属性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为整个文件或程序&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;局部量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为定义它的函数或语句块中&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;：按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型（C和C++）及其他类型等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运算成分&#34;&gt;运算成分&lt;/h2&gt;
&lt;p&gt;大多数高级程序设计语言的基本运算可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算。&lt;/li&gt;
&lt;li&gt;关系运算。&lt;/li&gt;
&lt;li&gt;逻辑运算。&lt;/li&gt;
&lt;li&gt;位运算。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;
&lt;p&gt;有以下三种结构来构造程序中的控制逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序结构。&lt;/li&gt;
&lt;li&gt;选择结构。&lt;/li&gt;
&lt;li&gt;循环结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数高级语言都针对循环结构提供了&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;等控制流跳转语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;传输成分&#34;&gt;传输成分&lt;/h2&gt;
&lt;p&gt;程序设计语言的传输成分指明语言允许的数据传输方式，如赋值处理、数据的输入和输出等。&lt;/p&gt;
&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数首部：
&lt;ul&gt;
&lt;li&gt;返回值类型&lt;/li&gt;
&lt;li&gt;函数名&lt;/li&gt;
&lt;li&gt;形参表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数体：定义函数所实现的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;：在C（C++）中，函数需要先声明后引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数调用&lt;/strong&gt;：在调用函数中使用被调函数实现的功能。函数调用的一般形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数名(实参表)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用函数与被调函数之间参数的传递有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;值调用&lt;/strong&gt;（Call by Value）：形参是实参的一份拷贝。即实参将值传递给形参，对形参值的更改并不会作用到实参上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用调用&lt;/strong&gt;（Call by Reference）：形参是实参的一个别名。即函数中对形参的访问和修改实际上是对其相应实参所做的访问和修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>软件设计师——计算机系统</title>
        <link>https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h1 id=&#34;计算机的基本单位&#34;&gt;计算机的基本单位&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;位（比特）&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;bit、b&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;最小数据单位/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;字节&lt;/td&gt;
    &lt;td&gt;byte、B&lt;/td&gt;
    &lt;td&gt;1B = 8b&lt;/td&gt;
    &lt;td&gt;最小存储单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;千字节&lt;/td&gt;
    &lt;td&gt;KB&lt;/td&gt;
    &lt;td&gt;1KB = 1024B&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;兆字节&lt;/td&gt;
    &lt;td&gt;MB&lt;/td&gt;
    &lt;td&gt;1MB = 1024KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;吉字节&lt;/td&gt;
    &lt;td&gt;GB&lt;/td&gt;
    &lt;td&gt;1GB = 1024MB&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;太字节&lt;/td&gt;
    &lt;td&gt;TB&lt;/td&gt;
    &lt;td&gt;1TB = 1024GB&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;计算机系统&#34;&gt;计算机系统&lt;/h1&gt;
&lt;p&gt;计算机系统由&lt;u&gt;硬件&lt;/u&gt;和&lt;u&gt;软件&lt;/u&gt;组成。&lt;/p&gt;
&lt;p&gt;计算机基本硬件系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;中央处理单元&#34;&gt;中央处理单元&lt;/h1&gt;
&lt;p&gt;运算器、控制器等部件被集成在一起统称中央处理单元（CPU）。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。&lt;/p&gt;
&lt;p&gt;中央处理单元（CPU）负责获取程序指令、对指令进行译码并加以执行。&lt;/p&gt;
&lt;p&gt;CPU的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序控制：通过执行指令来控制程序的执行顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作控制：CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间控制：对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据处理：通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。&lt;/p&gt;
&lt;p&gt;对数据的加工处理也是CPU最根本的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对系统内部和外部的中断（异常）做出响应，进行相应的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;寄存器组&lt;/li&gt;
&lt;li&gt;内部总线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运算器&#34;&gt;运算器&lt;/h2&gt;
&lt;p&gt;运算器组成部件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;算术逻辑单元（ALU）：重要组成部件。负责处理数据，实现对数据的算术运算和逻辑运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;累加寄存器（AC，累加器）：是一个通用寄存器。存放操作数或者结果。&lt;/p&gt;
&lt;p&gt;其功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。例如，在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。
运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字，将不同时间段内读/写的数据隔离开来。&lt;/p&gt;
&lt;p&gt;DR的主要作用为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为CPU和内存、外部设备之间数据传送的中转站；&lt;/li&gt;
&lt;li&gt;作为CPU和内存、外围设备之间在操作速度上的缓冲；&lt;/li&gt;
&lt;li&gt;在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态（标志通常分别由1位触发器保存）。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制器&#34;&gt;控制器&lt;/h2&gt;
&lt;p&gt;控制器用于控制整个CPU的工作，它决定了计算机运行过程的
自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。&lt;/p&gt;
&lt;p&gt;指令控制逻辑要完&lt;u&gt;取指令&lt;/u&gt;、&lt;u&gt;分析指令&lt;/u&gt;和&lt;u&gt;执行指令&lt;/u&gt;的操作，其过程分为&lt;u&gt;取指令&lt;/u&gt;、&lt;u&gt;指令译码&lt;/u&gt;、&lt;u&gt;按指令操作码执行&lt;/u&gt;、&lt;u&gt;形成下一条指令地址&lt;/u&gt;等步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令寄存器（IR）：暂存要执行的指令，该指令从内存中获取（通过缓冲寄存器）。&lt;/p&gt;
&lt;p&gt;当CPU执行一条指令时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把指令从内存储器取到缓冲寄存器中。&lt;/li&gt;
&lt;li&gt;送入IR暂存。&lt;/li&gt;
&lt;li&gt;指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序计数器（PC，指令计数器）：具有寄存信息和计数两种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在程序开始执行前，将程序的起始地址送入PC。
该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。&lt;/li&gt;
&lt;li&gt;执行指令时，CPU自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。&lt;/p&gt;
&lt;p&gt;执行转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令译码器(ID)。指令包含操作码和地址码两部分，而指令译码器就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据表示&#34;&gt;数据表示&lt;/h1&gt;
&lt;h2 id=&#34;原码&#34;&gt;原码&lt;/h2&gt;
&lt;p&gt;原码表示法又叫符号加绝对值表示法。最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。&lt;/p&gt;
&lt;p&gt;原码特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0的表示不唯一（有正负0）；&lt;/li&gt;
&lt;li&gt;加、减运算方式不统一；&lt;/li&gt;
&lt;li&gt;需额外对符号位进行处理，不利于硬件设计；&lt;/li&gt;
&lt;li&gt;当 $a &amp;lt; b$ 时，实现 $a-b$ 比较困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反码&#34;&gt;反码&lt;/h2&gt;
&lt;p&gt;最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。正数的反码与原码相同，负数的反码则是除符号位以外其余各位按位取反。&lt;/p&gt;
&lt;h2 id=&#34;补码&#34;&gt;补码&lt;/h2&gt;
&lt;p&gt;计算机中的补码是模2补码&lt;/p&gt;
&lt;p&gt;概念：在一个模运算（Moduler Arithmetic）系统中，同余（Congruence Modulo）的数等价。&lt;/p&gt;
&lt;p&gt;补码的定义：有 $n$ 位时，$[X]_补=(2^n+X)\mod{2^n}\quad (-2^{n-1}\leq X&amp;lt;2^{n-1})$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 $X&amp;lt;0$ 时，补码有两种求法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各位取反，末位加 1。&lt;/li&gt;
&lt;li&gt;从第 2 个 1 开始往右各位取反。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 $X&amp;gt;0$ 时，补码与原码相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码的减法：$Y-X=Y+[-X]_补$。&lt;/p&gt;
&lt;p&gt;特殊的补码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$[-2^{n-1}]_补=(2^n-2^{n-1})\mod{2^n}=(10\ldots0)_2\ (n-1 个0)$。&lt;/p&gt;
&lt;p&gt;这个数的最高位（符号位）即表示符号，又表示数值。如，-128。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$[-1]_补=2^n-1=(11\ldots1)_2\ (n个1)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$[+0]_补=[-0]_补=(00\ldots0)\ (n个0)$。
补码的0表示唯一。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;移码&#34;&gt;移码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;移码就是将每个数值加上一个偏置常数（Excess/Bias）。&lt;/li&gt;
&lt;li&gt;通常，当编码位数为 $n$ 时，bias 取 $2^{n-1}$ 或 $2^{n-1}-1$。&lt;/li&gt;
&lt;li&gt;移码可以方便地进行大小的比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移码可以看成是在其补码的基础上对符号位取反。移码的0表示唯一。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实（个人认为）根据补码和移码的定义，可以将补码当作特殊的移码。其bias为$2^n$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;各种码制带符号数的范围&#34;&gt;各种码制带符号数的范围&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4.png&#34;
	width=&#34;1174&#34;
	height=&#34;273&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;430&#34;
		data-flex-basis=&#34;1032px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数&lt;/h2&gt;
&lt;p&gt;浮点数使用两个定点数来分别表示实数的尾数（F）和阶码（E）。其一般形式为：$N=2^E \times F$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个数的浮点表示不是唯一的。小数点位置改变，阶码也随着相应改变。&lt;/li&gt;
&lt;li&gt;浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规格化浮点数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尾数$M \ge 0$，其规格化尾数形式为$M=0.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[0.5,1]$。&lt;/li&gt;
&lt;li&gt;尾数$M \le 0$，其规格化尾数形式为$M=1.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[-1,-0.5]$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般浮点数阶码用R位的移码表示，尾数用M位的补码表示。这种表示的数值范围为：&lt;/p&gt;
&lt;p&gt;$$
-1 \times 2^{(2^{R-1}-1)} \sim +(1-2^{-M+1}) \times 2^{(2^{R-1}-1)}
$$&lt;/p&gt;
&lt;p&gt;现在所有通用计算机都采用 IEEE 754 来表示浮点数。IEEE 754 的尾数用原码表示，阶码还是用移码表示。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;寻址方式&#34;&gt;寻址方式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;立即寻址：操作数就包含在指令中。&lt;/li&gt;
&lt;li&gt;直接寻址：操作数在内存，指令给出操作数的地址。&lt;/li&gt;
&lt;li&gt;寄存器寻址：操作数在寄存器，指令给出操作数的寄存器名（地址）。&lt;/li&gt;
&lt;li&gt;寄存器间接寻址：操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。&lt;/li&gt;
&lt;li&gt;间接寻址：指令中给出操作数地址（操作数地址在内存中）的地址。&lt;/li&gt;
&lt;li&gt;相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。&lt;/li&gt;
&lt;li&gt;变址寻址：操作数地址等于变址寄存器的内容加偏移量。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;校验码&#34;&gt;校验码&lt;/h1&gt;
&lt;p&gt;码距，是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。码距为n的编码方案，在该编码方案中任意两个合法编码之间至少有n个二进制位不同。例如值1和2的编码分别为&lt;code&gt;0000 0001&lt;/code&gt;和&lt;code&gt;0000 0010&lt;/code&gt;他们最后两位不同，所以，码距为2。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个编码系统的码距$\ge 2$时，该编码系统具有&lt;u&gt;检错能力&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;一个编码系统的码距$\ge 3$时，该编码系统才&lt;u&gt;可能有纠错能力&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，一个校验码要想能够检错和纠错那么它的码距至少是3。&lt;/p&gt;
&lt;h2 id=&#34;奇偶校验码&#34;&gt;奇偶校验码&lt;/h2&gt;
&lt;p&gt;奇偶校验（Parity Codes）是通过在编码中增加一位校验位来&lt;u&gt;使编码中1的个数为奇数（奇校验）或者为偶数（偶校验）&lt;/u&gt;。但该编码只能检错，但不能纠错。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇偶校验码码距为2。&lt;/li&gt;
&lt;li&gt;奇校验：仅检测出代码中奇数位数（奇数个0或1发生错误），不能发现偶数位数出错。偶校验反之。&lt;/li&gt;
&lt;li&gt;常用的奇偶校验码有3种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;海明码&#34;&gt;海明码&lt;/h2&gt;
&lt;p&gt;海明码（Hamming Code）是一种利用奇偶性来&lt;u&gt;检错和纠错&lt;/u&gt;的校验方法。海明码是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：&lt;/p&gt;
&lt;p&gt;$$
2^k-1 \ge n+k
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该公式的字面意思为，$k$个校验位的最大值（$k$个校验位都为1），要比海明码的位数（$n+k$）要大。
海明码的码距为3。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;海明码的编码规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$k$个校验位：$P_k, P_{k-1}, \cdots, P_1$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n$个数据位：$D_{n-1}, D_{n-2}, \cdots, D_1, D_0$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的海明码：$H_{n+k}, H_{n+k-1}, \cdots, H_1$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$H_j = P_i, j=2^{i-1}$。&lt;/li&gt;
&lt;li&gt;数据位依序插入到海明码中剩下的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;海明码中任一位都是由若干个校验位来检验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;校验数据位时：被校验的海明位的下标等于所有参与校验该位的校验位的下标之和。&lt;/li&gt;
&lt;li&gt;校验位由自身校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679983905932.png&#34;
	width=&#34;1023&#34;
	height=&#34;1049&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679983905932_hu8233f94300cd2978c7262586b5e1abdc_350868_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679983905932_hu8233f94300cd2978c7262586b5e1abdc_350868_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;97&#34;
		data-flex-basis=&#34;234px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;偶校验：$G_4G_3G_2G_1={(0000)}_{2}$则表示数据无错误，否则表示接收到的数据有错误。&lt;/p&gt;
&lt;p&gt;若出错，$G_4G_3G_2G_1$的十进制值指出来出错位置。如$G_4G_3G_2G_1=1010$，说明$H_{10}(D_5)$出错，将其取反即可纠错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;奇校验：$G_4G_3G_2G_1=(1111)_2$则表示数据无错误，否则表示接收到的数据有错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环冗余码&#34;&gt;循环冗余码&lt;/h2&gt;
&lt;p&gt;循环冗余校验码（Cyclic Redundancy Check，CRC）广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生个校验位来进行编码，其编码长度为k+r。CRC的代码格式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679825785079.png&#34;
	width=&#34;613&#34;
	height=&#34;92&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679825785079_hue59488e391052e21a77b5920f121b7a3_12188_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679825785079_hue59488e391052e21a77b5920f121b7a3_12188_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;666&#34;
		data-flex-basis=&#34;1599px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;若CRC码的字长为n，又可称其为（n,k）码，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;左边为信息码（数据），占k位；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右边为校验码，占n-k位。&lt;/p&gt;
&lt;p&gt;校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。&lt;/p&gt;
&lt;p&gt;CRC码距为2，可以检错不能纠错。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;计算机指令集&#34;&gt;计算机指令集&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;RISC&lt;br&gt;精简指令集（计算机）&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CISC&lt;br&gt;复杂指令集（计算机）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令种类&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;少、精简&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多、复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令复杂度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低（简单）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高（复杂）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令长度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;寻址方式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;复杂多样&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实现（译码方式）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬布线控制逻辑（组合逻辑控制器）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;微程序控制技术&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通用寄存器数量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多、大量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流水线技术&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;流水线技术&#34;&gt;流水线技术&lt;/h1&gt;
&lt;p&gt;计算机中的流水线技术（Pipelining）是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。&lt;/p&gt;
&lt;p&gt;若要执行$n$条指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顺序执行总时间：&lt;/p&gt;
&lt;p&gt;$$
顺序执行总时间=单条指令执行的时间\times n
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线执行总时间：&lt;/p&gt;
&lt;p&gt;$$
流水线执行总时间=一条指令执行的时间+流水线周期 \times (n-1)
$$&lt;/p&gt;
&lt;p&gt;流水线（操作）周期为执行时间最长的一段操作的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连续输入$n$条指令的吞吐率：&lt;/p&gt;
&lt;p&gt;$$
吞吐率=\cfrac {n}{总执行时间}
$$&lt;/p&gt;
&lt;p&gt;如果是流水线的吞吐率，则总执行时间为流水线执行总时间。
流水线的吞吐率是最长流水段操作时间的倒数。即：&lt;/p&gt;
&lt;p&gt;$$
最长流水段操作时间=\cfrac {流水线执行总时间}{n}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加速比：&lt;/p&gt;
&lt;p&gt;$$
加速比 = \cfrac{顺序执行总时间}{流水线执行总时间}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;存储器&#34;&gt;存储器&lt;/h1&gt;
&lt;p&gt;按存储器所处位置可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。&lt;/li&gt;
&lt;li&gt;外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按存储器的构成材料分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁存储器&lt;/li&gt;
&lt;li&gt;半导体存储器&lt;/li&gt;
&lt;li&gt;光存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按存储器工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读/写存储器（RAM）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读存储器：ROM、PROM、EPROM、EEPROM等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。&lt;/li&gt;
&lt;li&gt;可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按访问方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按地址访问：&lt;/p&gt;
&lt;p&gt;可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机存储器&lt;/li&gt;
&lt;li&gt;顺序存储器&lt;/li&gt;
&lt;li&gt;直接存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按内容访问：例如相联存储器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟存储器由主存与辅存组成。&lt;/p&gt;
&lt;p&gt;DRAM（动态随机存储器）构成主存 DRAM需要周期性地刷新保持信息。&lt;/p&gt;
&lt;p&gt;SRAM（静态随机存储器）构成Cache（缓存）。&lt;/p&gt;
&lt;p&gt;闪存类似U盘，掉电后信息不会丢失。以块为单位进行删除。闪存是EPROM的一种类型，可以代替ROM存储器。闪存不可以代替主存。&lt;/p&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;p&gt;高速缓存用来存放当前最活跃的程序和数据，其特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于CPU与主存之间；容量一般在几千字节到几兆字节之间；&lt;/li&gt;
&lt;li&gt;速度一般比主存快5~10倍，由快速半导体存储器构成；&lt;/li&gt;
&lt;li&gt;其内容是主存局部域的副本，对程序员来说是透明的（看不到或可以忽略）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。&lt;/p&gt;
&lt;h2 id=&#34;缓存地址映射&#34;&gt;缓存地址映射&lt;/h2&gt;
&lt;p&gt;CPU工作时，送出的是主存单元的地址。为从Cache存储器中读/写信息，就需要将主存地址转成Cache存储器的地址，这种地址转换即为地址映像。&lt;/p&gt;
&lt;p&gt;高速缓存中的地址映像方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884025087.png&#34;
	width=&#34;825&#34;
	height=&#34;526&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;376px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884252415.png&#34;
	width=&#34;730&#34;
	height=&#34;538&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;325px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;发生块冲突从多到少的顺序：直接映像 &amp;gt; 组相联映像 &amp;gt; 全相联映像。
地址映像都是由硬件自动完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;中断&#34;&gt;中断&lt;/h1&gt;
&lt;p&gt;计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回源程序，这个过程称为中断。&lt;/p&gt;
&lt;p&gt;中断是一种非常重要的技术，&lt;u&gt;输入输出&lt;/u&gt;设备和&lt;u&gt;主机交换数据&lt;/u&gt;、&lt;u&gt;分时操作&lt;/u&gt;、&lt;u&gt;实时系统&lt;/u&gt;、&lt;u&gt;计算机网络&lt;/u&gt;和&lt;u&gt;分布式计算机系统&lt;/u&gt;中都要用到这种技术。为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。&lt;/p&gt;
&lt;h2 id=&#34;输入输出控制方式&#34;&gt;输入输出控制方式&lt;/h2&gt;
&lt;p&gt;程序查询方式（程序直接控制方式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888001780.png&#34;
	width=&#34;754&#34;
	height=&#34;1174&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;64&#34;
		data-flex-basis=&#34;154px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。&lt;/li&gt;
&lt;li&gt;一次只能读/写一个字。&lt;/li&gt;
&lt;li&gt;由CPU将数放入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断驱动方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888578058.png&#34;
	width=&#34;787&#34;
	height=&#34;1134&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;69&#34;
		data-flex-basis=&#34;166px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O设备通过中断信号主动向CPU报告I/O操作已完成。&lt;/li&gt;
&lt;li&gt;CPU和I/O可并行工作。&lt;/li&gt;
&lt;li&gt;CPU利用率得到提升。&lt;/li&gt;
&lt;li&gt;一次只能读/写一个字。&lt;/li&gt;
&lt;li&gt;由CPU将数据放入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA方式（直接存储器存储方式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888972074.png&#34;
	width=&#34;816&#34;
	height=&#34;723&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;112&#34;
		data-flex-basis=&#34;270px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU和I/O可并行工作。&lt;/li&gt;
&lt;li&gt;仅在传送数据块多开始和结束时才需要CPU的干预。&lt;/li&gt;
&lt;li&gt;由外设直接将数据放入内存。&lt;/li&gt;
&lt;li&gt;一次读写的单位为&amp;quot;块&amp;quot;而不是字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA传输数据比中断驱动方式传输数据要快一点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;总线&#34;&gt;总线&lt;/h1&gt;
&lt;p&gt;总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。&lt;/p&gt;
&lt;p&gt;采用总线结构主要有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化系统结构，便于系统设计制造；&lt;/li&gt;
&lt;li&gt;大大减少了连线数目，便于布线，减小体积，提高系统的可靠性；&lt;/li&gt;
&lt;li&gt;便于接口设计，所有与总线连接的设备均采用类似的接口；&lt;/li&gt;
&lt;li&gt;便于系统的扩充、更新与灵活配置，易于实现系统的模块化；&lt;/li&gt;
&lt;li&gt;便于设备的软件设计；&lt;/li&gt;
&lt;li&gt;便于故障诊断和维修，同时也降低了成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以减少信息传输线的数量。&lt;/p&gt;
&lt;p&gt;微机中的总线分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据总线&lt;/li&gt;
&lt;li&gt;地址总线&lt;/li&gt;
&lt;li&gt;控制总线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见总线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISA总线。&lt;/li&gt;
&lt;li&gt;EISA总线。&lt;/li&gt;
&lt;li&gt;PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。&lt;/li&gt;
&lt;li&gt;PCI Express 总线。&lt;/li&gt;
&lt;li&gt;前端总线。&lt;/li&gt;
&lt;li&gt;RS-232C。&lt;/li&gt;
&lt;li&gt;SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。&lt;/li&gt;
&lt;li&gt;SATA。&lt;/li&gt;
&lt;li&gt;USB。&lt;/li&gt;
&lt;li&gt;IEEE-1394。&lt;/li&gt;
&lt;li&gt;IEEE-488总线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址总线宽度：例如，内存容量4GB，$4GB=2^{2+10+10+10}B=2^32B$。所以内存单元的地址宽度为32位，即地址总线宽度为32位。&lt;/p&gt;
&lt;p&gt;数据总线宽度：例如字长为32的机器，那么其数据总线的宽度要为32。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;加密技术与认证技术&#34;&gt;加密技术与认证技术&lt;/h1&gt;
&lt;h2 id=&#34;加密技术&#34;&gt;加密技术&lt;/h2&gt;
&lt;p&gt;加密技术用于防止第三方窃听。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密：只有一把密钥。加密和解密用同一把密钥。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥分发有缺陷。&lt;/li&gt;
&lt;li&gt;加密解密速度很快。&lt;/li&gt;
&lt;li&gt;适合加量大量明文数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非对称加密：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密和解密不是同一把密钥。&lt;/li&gt;
&lt;li&gt;一共有两把密钥，分别是公钥和私钥。&lt;/li&gt;
&lt;li&gt;用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。&lt;/li&gt;
&lt;li&gt;不能通过一把密钥推出另一把密钥。&lt;/li&gt;
&lt;li&gt;用接收方的公钥加密明文可以实现防止窃听的效果。&lt;/li&gt;
&lt;li&gt;密钥分发没有缺陷。&lt;/li&gt;
&lt;li&gt;加密解密速度很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;认证技术&#34;&gt;认证技术&lt;/h2&gt;
&lt;p&gt;认证技术用于防止篡改、假冒和否认。&lt;/p&gt;
&lt;p&gt;摘要（防止篡改）：将发送的明文进行Hash算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比如果一致，侧没有篡改，否则有篡改。&lt;/p&gt;
&lt;p&gt;数字签名（防止假冒和否认）：&lt;/p&gt;
&lt;p&gt;发送方用自己的&lt;u&gt;私钥对摘要进行签名&lt;/u&gt;（加密）。得到数字签名放在密文后一起发送过去。&lt;/p&gt;
&lt;p&gt;接收方用发送方的&lt;u&gt;公钥对数字签名进行验证&lt;/u&gt;（解密）。如果验证成功则该消息没有被假冒且不能否认，否则该消息的真实性为假冒发送。&lt;/p&gt;
&lt;h2 id=&#34;数字证书&#34;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;数字证书是用第三方CA机构使用自己的私钥对用户的公钥签名（加密），来保证这个公钥不被篡改。然后接收方用CA的公钥验证（解密），从而得到用户的公钥。&lt;/p&gt;
&lt;h2 id=&#34;加密算法&#34;&gt;加密算法&lt;/h2&gt;
&lt;p&gt;对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DES&lt;/li&gt;
&lt;li&gt;3DES&lt;/li&gt;
&lt;li&gt;RC-5&lt;/li&gt;
&lt;li&gt;IDEA&lt;/li&gt;
&lt;li&gt;AES&lt;/li&gt;
&lt;li&gt;RC4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非对称密钥（公钥、公开密钥加密）算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSA&lt;/li&gt;
&lt;li&gt;ECC&lt;/li&gt;
&lt;li&gt;DSA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他加密算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hash函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SHA-1安全散列算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MD5摘要算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出结果为128位&lt;/li&gt;
&lt;li&gt;摘要算法防止发送的报文被篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加密可以阻止被动攻击，认证可以阻止主动攻击（不可以处理被动攻击）。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;系统可靠度&#34;&gt;系统可靠度&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F.png&#34;
	width=&#34;1157&#34;
	height=&#34;400&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F_huc533c9ebe7073a641e0c4f0ca26fe76d_129377_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F_huc533c9ebe7073a641e0c4f0ca26fe76d_129377_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;289&#34;
		data-flex-basis=&#34;694px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F.png&#34;
	width=&#34;1133&#34;
	height=&#34;376&#34;
	srcset=&#34;https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F_hu0151f1bd7a524d241456bee3273c718e_125234_480x0_resize_box_3.png 480w, https://www.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F_hu0151f1bd7a524d241456bee3273c718e_125234_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;301&#34;
		data-flex-basis=&#34;723px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
