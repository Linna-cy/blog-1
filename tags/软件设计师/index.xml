<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>软件设计师 on Linner&#39;s Blog</title>
        <link>https://blog.linner.asia/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <description>Recent content in 软件设计师 on Linner&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <lastBuildDate>Wed, 12 Apr 2023 16:28:00 +0800</lastBuildDate><atom:link href="https://blog.linner.asia/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>数据库（软件设计师）</title>
        <link>https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <pubDate>Wed, 12 Apr 2023 16:28:00 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</guid>
        <description>&lt;h1 id=&#34;数据库体系结构&#34;&gt;数据库体系结构&lt;/h1&gt;
&lt;p&gt;数据描述有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑描述：指程序员或用户用以操作的数据形式，是抽象的概念化数据。&lt;/li&gt;
&lt;li&gt;物理描述：指数据在存储设备上的存储方式，物理数据是实际存放在存储设备上的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三级模式结构&#34;&gt;三级模式结构&lt;/h2&gt;
&lt;p&gt;实际上有许多不同的数据库产品，但它们的体系结构基本上都具有相同的特征，采用“三级模式和两级映像”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681373319410.png&#34;
	width=&#34;486&#34;
	height=&#34;377&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681373319410_hu9b9f67605df5247fa6ccd5bd0d000f11_51804_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681373319410_hu9b9f67605df5247fa6ccd5bd0d000f11_51804_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;128&#34;
		data-flex-basis=&#34;309px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;三级结构有3类数据模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;外模型&lt;/strong&gt;：用户使用的&lt;strong&gt;数据视图&lt;/strong&gt;，是一种局部的逻辑数据视图，表示用户所理解的实体、实体属性和实体关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;概念模型&lt;/strong&gt;：全局的&lt;strong&gt;逻辑数据视图&lt;/strong&gt;，是数据库管理员所看到的实体、实体属性和实体之间的联系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内模型&lt;/strong&gt;：数据的物理&lt;strong&gt;存储模型&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三个物理模型分别对应数据库系统的3层结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外模式（子模式、用户模式）&lt;/strong&gt;：数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。&lt;/p&gt;
&lt;p&gt;外模式用DBMS的外模式描述语言（外模式DDL)来定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;概念模式（模式）&lt;/strong&gt;：所有用户的公共数据视图，与具体的应用程序和应用程序开发工具无关。&lt;/p&gt;
&lt;p&gt;概念模式用DBMS的模式描述语言（模式DDL)来定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内模式（物理模式、存储模式）&lt;/strong&gt;：是数据在数据库内部的表示方式。&lt;/p&gt;
&lt;p&gt;内模式由DBMS的内模式描述语言（内模式DDL)来描述，由设备介质语言来定义。&lt;/p&gt;
&lt;p&gt;定义&lt;u&gt;所有的&lt;strong&gt;内部记录类型&lt;/strong&gt;、&lt;strong&gt;索引&lt;/strong&gt;和&lt;strong&gt;文件&lt;/strong&gt;的组织方式&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;两级模式映象&#34;&gt;两级模式映象&lt;/h2&gt;
&lt;p&gt;数据库系统在三级模式之间提供了两级映像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模式——内模式映像存在于&lt;u&gt;概念级和内部级&lt;/u&gt;之间，实现&lt;u&gt;概念模式和内模式&lt;/u&gt;间的相互转换。&lt;/li&gt;
&lt;li&gt;外模式——模式映像：存在于&lt;u&gt;外部级和概念级&lt;/u&gt;之间，实现了&lt;u&gt;外模式和概念模式&lt;/u&gt;之间的相互转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据的独立性（指数据与程序独立）是由DBMS的二级映像功能来保证的。数据的独立性包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;物理独立性&lt;/strong&gt;：指当数据库的&lt;u&gt;内模式发生改变时，数据的逻辑结构不变&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;物理独立性可以保证，当数据的物理结构改变时，应用程序不用改变。&lt;/p&gt;
&lt;p&gt;但是，为了保证应用程序能够正确执行，&lt;u&gt;需要修改概念模式和内模式之间的映像&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;逻辑独立性&lt;/strong&gt;：指用户的&lt;u&gt;应用程序与数据库的逻辑结构是相互独立的&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;数据的逻辑结构发生变化后，用户程序也可以不修改。&lt;/p&gt;
&lt;p&gt;但是，为了保证应用程序能够正确执行，&lt;u&gt;需要修改外模式和概念模式之间的映像&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据模型&#34;&gt;数据模型&lt;/h1&gt;
&lt;p&gt;在数据库技术中，表示实体类型及实体类型间联系的模型称为数据模型。&lt;/p&gt;
&lt;p&gt;数据模型有以下类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念数据模型：从信息世界中抽象的数据模型；&lt;/li&gt;
&lt;li&gt;结构数据模型：从计算机世界中抽象出的DBMS支持的数据模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;概念数据模型&#34;&gt;概念数据模型&lt;/h2&gt;
&lt;p&gt;概念数据模型用于信息世界建模，一般采用实体-联系方法（E-R方法）。概念数据模型的常用术语有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实体&lt;/strong&gt;：客观存在并可以相互区别的事物称为实体。&lt;/p&gt;
&lt;p&gt;如一个单位、一个职工、一个部门或一个项目等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;：描述实体的特性称为属性，一个实体可以由若干个属性来刻画。&lt;/p&gt;
&lt;p&gt;属性的具体取值称为属性值，用以表示一个具体实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;码&lt;/strong&gt;：&lt;u&gt;唯一标识&lt;/u&gt;实体的属性集称为码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;域&lt;/strong&gt;：属性的&lt;u&gt;取值范围&lt;/u&gt;称为该属性的域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实体型&lt;/strong&gt;：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。&lt;/p&gt;
&lt;p&gt;例如，学生（学号，姓名，性别，班号）就是一个实体型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实体集&lt;/strong&gt;：同型实体的集合称为实体集。&lt;/p&gt;
&lt;p&gt;例如，全体学生就是一个实体集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;联系&lt;/strong&gt;：实体（型）之间的对应关系称为联系。联系分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体内部各属性之间的联系；&lt;/li&gt;
&lt;li&gt;实体之间的联系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个实体型之间的联系有3种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一对一联系(1:1)；&lt;/li&gt;
&lt;li&gt;一对多联系(1:n)；&lt;/li&gt;
&lt;li&gt;多对多联系(m:n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实体-联系方法表示的概念数据模型称为E-R图。E-R图是抽象和描述现实世界的有力工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实体型&lt;/strong&gt;：用&lt;strong&gt;矩形&lt;/strong&gt;表示，矩形框内写明实体名；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性&lt;/strong&gt;：用&lt;strong&gt;椭圆形&lt;/strong&gt;表示，并用无向边将其与相应的实体连接起来；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;联系&lt;/strong&gt;：用&lt;strong&gt;菱形&lt;/strong&gt;表示，菱形框内写明联系名，并用无向边将其分别与有关实体连接起来，同时在无向边旁标上联系的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681289395117.png&#34;
	width=&#34;240&#34;
	height=&#34;242&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681289395117_hube981d9754c37a567c83a04aad71de33_18088_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681289395117_hube981d9754c37a567c83a04aad71de33_18088_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;E-R图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;99&#34;
		data-flex-basis=&#34;238px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;结构数据模型&#34;&gt;结构数据模型&lt;/h2&gt;
&lt;p&gt;结构数据模型是直接面向数据库的逻辑结构。这类模型涉及到计算机系统和数据库管理系统，所以称为结构数据模型。任何一个DBMS都以某个结构数据模型为基础，或者说支持某个结构数据模型。&lt;/p&gt;
&lt;p&gt;常用术语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据项&lt;/strong&gt;：又称&lt;strong&gt;字段&lt;/strong&gt;，是数据库中可以命名的最小逻辑数据单位。可以是一个数或个字符串，用它描述属性的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;记录&lt;/strong&gt;：是数据项的有序集，即一个记录是由若干个数据项或字段组成，用它描述实体。&lt;/p&gt;
&lt;p&gt;一般来说，数据只有被组成记录的形式才有实际意义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;文件&lt;/strong&gt;：文件是一个具有符号名的一组同类记录的集合。文件包含记录的结构和记录的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结构数据模型主要包括：层次、网状、关系和面向对象模型。&lt;/p&gt;
&lt;p&gt;关系模型是一种用二维表格结构快表示实体以及实体之间联系的数据模型。每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述。因此可以说，关系模型是由关系模式组成的集合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前大多数数据库管理系统都是关系型的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;关系模型&#34;&gt;关系模型&lt;/h1&gt;
&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;
&lt;p&gt;有关关系模型的术语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关系&lt;/strong&gt;：一个关系就是一张&lt;strong&gt;二维表&lt;/strong&gt;，每个关系有一个关系名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;元组&lt;/strong&gt;：表中的一行即为一个&lt;strong&gt;元组&lt;/strong&gt;，对应存储文件中的一个&lt;strong&gt;记录值&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;：表中的&lt;strong&gt;列&lt;/strong&gt;称为属性，每一列有一个属性名。&lt;/p&gt;
&lt;p&gt;属性值相当于记录中的数据项或者字段值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;域&lt;/strong&gt;：属性的&lt;strong&gt;取值范围&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关系模式&lt;/strong&gt;：对关系的&lt;strong&gt;描述&lt;/strong&gt;称为关系模式，由关系名和其属性集合构成，关系模式的格式为：关系名（属性名1，属性名2，…，属性名n）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;候选码&lt;/strong&gt;（候选健）：属性或属性组合其值能够&lt;strong&gt;唯一地标识&lt;/strong&gt;一个元组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主码&lt;/strong&gt;（主键）：在一个关系中可能有&lt;u&gt;多个候选码，从中选择一个&lt;/u&gt;作为主码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主属性&lt;/strong&gt;：所有候选键都称为主属性，其他的属性都称为&lt;strong&gt;非码属性&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外码&lt;/strong&gt;（或外键）：如果一个关系中的属性或属性组并非该关系（二维表）的码，但它们是&lt;u&gt;另外一个关系（二维表）的码&lt;/u&gt;，则称其为该关系的外码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全码&lt;/strong&gt;：关系模式的&lt;u&gt;所有属性组是这个关系模式的候选码&lt;/u&gt;，称为全码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;超码&lt;/strong&gt;（超键）：一个&lt;u&gt;包含码的属性集称为超码&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;例如学号是码，则（学号，姓名）就是一个超码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整性约束&#34;&gt;完整性约束&lt;/h2&gt;
&lt;p&gt;完整性规则保证用户对数据库做修改时不会破坏数据的一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实体完整性&lt;/strong&gt;（Entity Integrity，引用完整性）：规定基本关系R的主属性A不能取空值。&lt;/p&gt;
&lt;p&gt;即&lt;u&gt;主属性不能为空&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参照完整性&lt;/strong&gt;（Referential Integrity）：若F是基本关系R的外码，它与基本关系S的主码K&lt;sub&gt;s&lt;/sub&gt;相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值可以取：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空值（F的每个属性值均为空值）；&lt;/li&gt;
&lt;li&gt;S中某个元组的主码值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即实体之间的关联可以变现为：关系R用外码F与关系S关联，外码F的值可以为空也可以为关系S中某个元组（记录）的主码值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户定义完整性&lt;/strong&gt;（User Defined Integrity）：针对某一具体的关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求，由应用的环境决定。&lt;/p&gt;
&lt;p&gt;例如，银行的用户账户规定必须大于等于100000、小于999999。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关系代数运算符&#34;&gt;关系代数运算符&lt;/h2&gt;
&lt;p&gt;关系操作的特点是操作对象和操作结果都是集合，而非关系数据模型的数据操作方式则为一次一个记录的方式。&lt;/p&gt;
&lt;p&gt;关系数据语言分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系代数语言；&lt;/li&gt;
&lt;li&gt;关系演算语言；&lt;/li&gt;
&lt;li&gt;具有关系代数和关系演算双重特点的语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系演算语言包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元组关系演算语言；&lt;/li&gt;
&lt;li&gt;域关系演算语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系代数运算符有4类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681431891302.png&#34;
	width=&#34;735&#34;
	height=&#34;301&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681431891302_hu474e5e1683bfce1832772e13dcf3cc90_42174_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681431891302_hu474e5e1683bfce1832772e13dcf3cc90_42174_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;关系代数运算符&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;244&#34;
		data-flex-basis=&#34;586px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;基本关系代数运算是对两个具有&lt;u&gt;相同的关系模式&lt;/u&gt;的关系进行运算。关系$R$与$S$具有&lt;u&gt;相同的关系模式&lt;/u&gt;，即$R$与$S$的元数相同（结构相同）。&lt;/p&gt;
&lt;p&gt;基本关系代数运算包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并&lt;/strong&gt;（Union）：关系$R$与$S$的并是由属于$R$或属于$S$的元组构成的集合，记作$R \cup S$，其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
R \cup S = \{ t | (t \in R) \vee (t \in S) \}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;式中$t$为元组变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;差&lt;/strong&gt;（Difference）：关系$R$与$S$的差是由&lt;u&gt;属于$R$但不属于$S$&lt;/u&gt;的元组构成的集合，记作$R-S$，其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
R-S = \{ t| (t \in R) \wedge (t \not\in S) \}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交&lt;/strong&gt;（Intersection）：关系$R$与$S$的交是由属于$R$同时又属于$S$的元组构成的集合，记作$R \cap S$,其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
R \cap S = \{ t| (t \in R) \wedge (t \in S) \}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$R \cap S = R-(R-S)$，或者$R \cap S = S-(S-R)$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扩展的关系代数运算可以从基本的关系运算中导出，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;广义笛卡儿积&lt;/strong&gt;（Extended Cartesian Product）：两个元组分别为$n$目和$m$目的关系$R$和$S$的广义笛卡儿积是一个$(n+m)$列的元组的集合。&lt;/p&gt;
&lt;p&gt;元组的前$n$列是关系$R$的一个元组，后$m$列是关系$S$的一个元组，记作$R \times S$，其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
R \times S = \{ t| (t \ = \ &amp;lt;t^n, t^m&amp;gt;) \wedge (t^n \in R) \wedge (t^m \in S) \}
$$&lt;/p&gt;
&lt;p&gt;如果$R$和$S$中有相同的属性名，可在属性名前加关系名作为限定，以示区别。若$R$有$K_1$,个元组，$S$有$K_2$个元组，则$R$和$S$的广义笛卡儿积有$K_1 \times K2$个元组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&amp;lt;t^n, t^m&amp;gt;$是一个元组$t^n$和$t^m$拼接成的一个元组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;投影&lt;/strong&gt;（Projection）：投影运算是从关系的&lt;u&gt;垂直方向&lt;/u&gt;进行运算，在关系$R$中选出若干属性列$A$组成新的关系，记作$\pi_A (R)$，其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
\pi_A (R) = \{ t[A]|t \in R \}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt;（Selection）：选择运算是从关系的&lt;u&gt;水平方向&lt;/u&gt;进行运算，是从关系$R$中选择满足给定条件的诸元组，记作$\sigma_F (R)$其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
\sigma_A (R) = \{ t| (t \in R) \wedge F(t) = True \}
$$&lt;/p&gt;
&lt;p&gt;其中，$F(t)$中的运算对象可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性名（或列的序号）；&lt;/li&gt;
&lt;li&gt;常数；&lt;/li&gt;
&lt;li&gt;运算符；&lt;/li&gt;
&lt;li&gt;算术比较符（$&amp;lt;, \le, &amp;gt;, \ge, \neq$）；&lt;/li&gt;
&lt;li&gt;逻辑运算符（$\wedge, \vee, \neg$）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接&lt;/strong&gt;（Join）：连接运算是从两个关系$R$和$S$的笛卡儿积中选取满足条件的元组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$\theta$连接&lt;/strong&gt;：从$R$与$S$的笛卡儿积中选取属性间满足一定条件的元组。记作：&lt;/p&gt;
&lt;p&gt;$$
R \mathop{\Join}\limits_{X \theta Y} S = \{ t| (t=&amp;lt;t^n,t^m&amp;gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[X] \ \theta \ t^m[Y]) \}
$$&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X \theta Y$：连接的条件；&lt;/li&gt;
&lt;li&gt;$\theta$：比较运算符；&lt;/li&gt;
&lt;li&gt;$X$和$Y$分别为$R$和$S$上度数相等且可比的属性组；&lt;/li&gt;
&lt;li&gt;$t^n\left[ X \right]$表示$R$中$t^n$元组的对应于属性$X$的一个分量；&lt;/li&gt;
&lt;li&gt;$t^m[Y]$表示$S$中$t^m$元组的对应于属性$Y$的一个分量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$\theta$连接也可以表示为：&lt;/p&gt;
&lt;p&gt;$$
R \mathop{\Join}\limits_{i \theta j} S = \{ t| (t=&amp;lt;t^n,t^m&amp;gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] \ \theta \ t^m[j]) \}
$$&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$i=1,2,3,\cdots,n$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$j=1,2,3,\cdots,m$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$i \theta j$：&lt;/p&gt;
&lt;p&gt;从两个关系$R$和$S$中选取$R$的第$i$列和$S$的第$j$列之间满足$\theta$运算的元组进行连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$\theta$连接可以由基本的关系运算笛卡儿积和选取运算导出。因此，$\theta$连接可表示为：&lt;/p&gt;
&lt;p&gt;$$
R \mathop{\Join}\limits_{X \theta Y} S = \sigma_{X \theta Y}(R \times S)
$$&lt;/p&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;p&gt;$$
R \mathop{\Join}\limits_{i \theta j} S = \sigma_{i \theta j}(R \times S)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;等值连接&lt;/strong&gt;：当$\theta$为“=”时，称之为等值连接，记为$R \mathop{\Join}\limits_{i = j} S$，其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
R \mathop{\Join}\limits_{i = j} S = \{ t| (t=&amp;lt;t^n,t^m&amp;gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] = t^m[j]) \}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$F$连接：从关系$R$和$S$的笛卡尔积中选取属性值满足某一公式$F$的元组，记为$\mathop{\Join}\limits_{F}$。&lt;/p&gt;
&lt;p&gt;$F$是形为$F_1 \wedge F_2 \wedge \cdots \wedge F_n$的公式，每个$F_p$是形为$i \theta j$的式子。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自然连接&lt;/strong&gt;：自然连接是一种特殊的等值连接，它要求两个关系中&lt;u&gt;进行比较的分量必须是相同的属性组&lt;/u&gt;，并且在结果集中&lt;u&gt;将重复属性列去掉&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;若：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$t^n \in R$，$t^m \in S$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$R$和$S$具有相同的属性组$B$，且$B=(B_1,B_2,,B_k)$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假定$R$关系的属性：&lt;/p&gt;
&lt;p&gt;$$
A_1,A_2,\cdots,A_{n-k},B_1,B_2,\cdots,B_k
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$S$关系的属性：&lt;/p&gt;
&lt;p&gt;$$
B_1,B2,\cdots,B_k,B_{k+1},B_{k+2},\cdots,B_m
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自然连接可以记为$R \Join S$,其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
R \Join S = \{ t| (t = &amp;lt;t^n, t^m&amp;gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (R.B_1 = S.B_1) \wedge (R.B_2 = S.B_2) \wedge \cdots \wedge (R.B_k = S.B_k) \}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般连接是从关系的水平方向运算，而自然连接&lt;u&gt;不仅要从关系的水平方向运算，而且要从关系的垂直方向运算&lt;/u&gt;（去掉重复属性）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外连接&lt;/strong&gt;（Outer Jion）：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。&lt;/p&gt;
&lt;p&gt;外连接运算有3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;左外连接&lt;/strong&gt;（Left Outer Jion，⟕）：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值$null$充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;右外连接&lt;/strong&gt;（Right Outer Jion，⟖）：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值$null$填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全外连接&lt;/strong&gt;（Full Outer Jion，⟗）。完成左外连接和右外连接的操作。即填充左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，将产生的新元组加入自然连接的结果中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681454087063.png&#34;
	width=&#34;762&#34;
	height=&#34;575&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681454087063_hud13edc09469e2a4b2eff4fd4a8bf7c0a_99173_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681454087063_hud13edc09469e2a4b2eff4fd4a8bf7c0a_99173_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;318px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;除&lt;/strong&gt;（Division）：给定关系$R(X,Y)$和$S(Y,Z)$，$X、Y、Z$为属性组。$R \div S$应当满足元组在$X$上的分量值$x$的象集$Y_x$包含关系$S$在属性组$Y$上投影的集合。其形式定义如下：&lt;/p&gt;
&lt;p&gt;$$
R \div S = \{ t^n[X] | (t^n \in R) \wedge (\pi_y (S) \subseteq Y_x) \}
$$&lt;/p&gt;
&lt;p&gt;其中，$Y_x$为$x$在$R$中的象集，$x=t^n[X]$，且$R \div S$的结果集的属性组为$X$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除运算是同时从关系的水平方向和垂直方向进行运算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sql-语句&#34;&gt;SQL 语句&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;SQL&lt;/strong&gt;（&lt;strong&gt;Structured Query Language&lt;/strong&gt;，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进行各种操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSISQL。&lt;/p&gt;
&lt;p&gt;查看更多 &lt;a class=&#34;link&#34; href=&#34;../sql-%e8%af%ad%e5%8f%a5&#34; &gt;SQL语句&lt;/a&gt; 相关内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DDL&lt;/strong&gt;（&lt;strong&gt;Data Definition Language&lt;/strong&gt;，&lt;strong&gt;数据定义语言&lt;/strong&gt;）：用来定义数据库对象：数据库，表，列等。&lt;/p&gt;
&lt;p&gt;关键字：&lt;code&gt;CREATE&lt;/code&gt;、&lt;code&gt;DROP&lt;/code&gt;、&lt;code&gt;ALTER&lt;/code&gt; 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DML&lt;/strong&gt;（&lt;strong&gt;Data Manipulation Language&lt;/strong&gt;，&lt;strong&gt;数据操作语言&lt;/strong&gt;）：用来对数据库中表的数据进行增删改。&lt;/p&gt;
&lt;p&gt;关键字：&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt; 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DQL&lt;/strong&gt;（&lt;strong&gt;Data Query Language&lt;/strong&gt;，&lt;strong&gt;数据查询语言&lt;/strong&gt;）：用来查询数据库中表的记录。&lt;/p&gt;
&lt;p&gt;关键字：&lt;code&gt;SELECT&lt;/code&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DCL&lt;/strong&gt;（&lt;strong&gt;Data Control Language&lt;/strong&gt;，&lt;strong&gt;数据控制语言&lt;/strong&gt;）：用来定义数据库的访问权限和安全级别，及创建用户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据定义语言ddl&#34;&gt;数据定义语言（DDL）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CREATE&lt;/code&gt;——创建：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立数据库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DATABASE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;数据库名&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立基本表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; tab_name
(
    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;数据类型&lt;/span&gt; [&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列级完整性约束条件&lt;/span&gt;],
    ...
    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表级完整性约束条件&lt;/span&gt;,
    ...
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完整性约束有3种子句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PRIMARY KEY&lt;/code&gt;：主键约束；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CHECK&lt;/code&gt;：检查约束；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FOREIGN KEY&lt;/code&gt;：外键约束；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOT NULL&lt;/code&gt;：非空约束；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UNIQUE&lt;/code&gt;：唯一约束；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEFAULT&lt;/code&gt;：默认约束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义列时使用的基本数据类型如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NTEGER&lt;/code&gt;：整数（也可写成&lt;code&gt;INT&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FLOAT(n)&lt;/code&gt;：浮点数，精度至少为n位数字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NUMERIC(p,d)&lt;/code&gt;：定点数，由p位数字（不包括符号、小数点）组成，小数点后面有d位数字（也可写成&lt;code&gt;DECIMAL(p,d)&lt;/code&gt;或&lt;code&gt;DEC(p,d)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CHAR(n)&lt;/code&gt;：长度为n的定长字符串。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DATETIME&lt;/code&gt;：日期时间型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE&lt;/code&gt;——修改表结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增加新列：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改列的定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;COLUMN&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;新类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除列：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;COLUMN&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;DROP TABLE&lt;/code&gt;——删除基本表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;数据操纵语言dml&#34;&gt;数据操纵语言（DML）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;INSERT INTO&lt;/code&gt;——插入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接插入元组值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名（列名序列）&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;元组值&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;序列&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;元组值&lt;/span&gt;), (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;元组值&lt;/span&gt;), ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入一个查询的结果值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名序列&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;查询语句&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;DELETE FROM&lt;/code&gt;——删除：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt; [&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;条件表达式&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;UPDATE&lt;/code&gt;——修改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;表名&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;值表达式&lt;/span&gt;[, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;值表达式&lt;/span&gt;...]
[WHERE条件表达式]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;数据查询语言dql&#34;&gt;数据查询语言（DQL）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SELECT&lt;/code&gt;——查询：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;目标表的列名或列表达式序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;关系名表序列&lt;/span&gt;
[&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;行条件表达式&lt;/span&gt;]
[&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名序列&lt;/span&gt;
[&lt;span style=&#34;color:#66d9ef&#34;&gt;HAVING&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;组条件表达式&lt;/span&gt;]]
[&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;ASC&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;]...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;where-条件查询&#34;&gt;WHERE 条件查询&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;目标表的列名或列表达式序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;关系名表序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;行条件表达式&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运算符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;运算符&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;运算符&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;td&gt;&lt;code&gt;BETWEEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;范围在指定的两个值之间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不小于&lt;/td&gt;
&lt;td&gt;&lt;code&gt;IS NULL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为 NULL 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;IS NOT NULL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不为 NULL 的值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;OR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逻辑或&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NOT&lt;/code&gt;逻辑非&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;IN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配包含在集合中的值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NOT IN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定不包含在集合中的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LIKE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符模糊配对&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;LIKE&lt;/code&gt;字符模糊配对包含以下通配符：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;目标表的列名或列表达式序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;关系名表序列&lt;/span&gt;
WHRER &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_ABC%&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;：表示任何字符出现任意次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt;：表示匹配单个任意字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;order-by-排序数据&#34;&gt;ORDER BY 排序数据&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ORDER BY&lt;/code&gt;可以指定多个列来排序，排序规则有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;关键字&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;规则说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;ASC&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;升序排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;DESC&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;降序排序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;目标表的列名或列表达式序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;关系名表序列&lt;/span&gt;
[...]
[&lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名&lt;/span&gt; [&lt;span style=&#34;color:#66d9ef&#34;&gt;ASC&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DESC&lt;/span&gt;] ...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;ORDER BY子句必须是SELECT命令中的最后一个子句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;group-by-分组数据&#34;&gt;GROUP BY 分组数据&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;目标表的列名或列表达式序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;关系名表序列&lt;/span&gt;
[&lt;span style=&#34;color:#66d9ef&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列名序列&lt;/span&gt;
[&lt;span style=&#34;color:#66d9ef&#34;&gt;HAVING&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;组条件表达式&lt;/span&gt;]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HAVING&lt;/code&gt;是&lt;code&gt;GROUP BY&lt;/code&gt;的分组条件控制语句。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HAVING&lt;/code&gt;的操作符和&lt;code&gt;WHERE&lt;/code&gt;相同。&lt;/li&gt;
&lt;li&gt;被&lt;code&gt;WHERE&lt;/code&gt;过滤掉的记录并不会出现在分组中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;聚合函数&#34;&gt;聚合函数&lt;/h3&gt;
&lt;p&gt;聚合函数实现数据统计等功能。&lt;/p&gt;
&lt;p&gt;函数名|功能
&lt;code&gt;AVG&lt;/code&gt;|计算一个数值型表达式的平均值
&lt;code&gt;COUNT&lt;/code&gt;|计算指定表达式中选择的项数，&lt;code&gt;COUNT(*)&lt;/code&gt;统计查询输出的行数
&lt;code&gt;MIN&lt;/code&gt;|计算指定表达式中的最小值
&lt;code&gt;MAX&lt;/code&gt;|计算指定表达式中的最大值
&lt;code&gt;SUM&lt;/code&gt;|计算指定表达式中的数值总和
&lt;code&gt;STDEV&lt;/code&gt;|计算指定表达式中所有数据的标准差
&lt;code&gt;STDEVP&lt;/code&gt;|计算总体标准差&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;目标表的列名或列表达式序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;关系名表序列&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;使用了聚合函数的条件判断&lt;/span&gt;
[ ... ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;聚合函数&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;关系名表序列&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;聚合函数可以使用算数运算符。&lt;/p&gt;
&lt;p&gt;聚合函数常与&lt;code&gt;GROUP BY&lt;/code&gt;子句一起使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;连接&#34;&gt;连接&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;连接符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;INNER JOIN&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;内连接（默认）。&lt;br&gt;内连接又包括等值连接、非等值连接和自连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;OUTER JOIN&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;外连接。&lt;br&gt;又包括：&lt;br&gt;&lt;code&gt;LEFT OUTER JOIN&lt;/code&gt;（左外连接）；&lt;br&gt;&lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt;（右外连接）；&lt;br&gt;&lt;code&gt;FULL OUTER JOIN&lt;/code&gt;（全外连接）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;子查询&#34;&gt;子查询&lt;/h3&gt;
&lt;p&gt;子查询是指将&lt;code&gt;SELECT&lt;/code&gt;作为其它语句的子句使用。例如在&lt;code&gt;WHERE&lt;/code&gt;、&lt;code&gt;FROM&lt;/code&gt;中使用&lt;code&gt;SELECT&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;数据控制语言dcl&#34;&gt;数据控制语言（DCL）&lt;/h2&gt;
&lt;p&gt;数据控制控制的是&lt;strong&gt;用户对数据的存储访问权力&lt;/strong&gt;，是由DBA决定的。但是，某个用户对某类数据具有何种权利，是个&lt;strong&gt;政策问题&lt;/strong&gt;而不是技术问题。&lt;/p&gt;
&lt;p&gt;授权语句格式（&lt;code&gt;GRANT&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;GRANT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;权限&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;[, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;权限&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;] ...
[&lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对象类型&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对象名&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;]
&lt;span style=&#34;color:#66d9ef&#34;&gt;TO&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;用户&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;[, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;用户&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;]...
[&lt;span style=&#34;color:#66d9ef&#34;&gt;WITH&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;GRANT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;OPTION&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不同类型的操作对象有不同的操作权限，常见的操作权限如下：&lt;/p&gt;
&lt;p&gt;对象|对象类型|操作权限
属性列|&lt;code&gt;TABLE&lt;/code&gt;|&lt;code&gt;SELECT&lt;/code&gt;、&lt;br&gt;&lt;code&gt;INSERT&lt;/code&gt;、&lt;br&gt;&lt;code&gt;UPDATE&lt;/code&gt;、&lt;br&gt;&lt;code&gt;DELETE&lt;/code&gt;、&lt;br&gt;&lt;code&gt;ALL PRIVILEGES&lt;/code&gt;
视图|&lt;code&gt;TABLE&lt;/code&gt;|&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;ALL PRIVILEGES&lt;/code&gt;
基本表|&lt;code&gt;TABLE&lt;/code&gt;|&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;ALTER&lt;/code&gt;、&lt;code&gt;INDEX&lt;/code&gt;、&lt;code&gt;ALL PRIVILEGES&lt;/code&gt;
数据库|&lt;code&gt;DATABASE&lt;/code&gt;|&lt;code&gt;CREATETAB&lt;/code&gt;建立表的权限，可由DBA授予普通用户&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WITH GRANT OPTION&lt;/code&gt;：表示获得了这些权限的用户还可以将权限赋给其他用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;收回权限语句格式（&lt;code&gt;REVOKE&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;REVOKE&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;权限&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;[, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;权限&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;]...
[&lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对象类型&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对象名&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;]
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;用户&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;[, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;用户&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;视图&#34;&gt;视图&lt;/h2&gt;
&lt;p&gt;视图是从一个或者多个基本表或视图中导出的虚拟表。&lt;/p&gt;
&lt;p&gt;创建视图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;VIEW&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;视图名&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;列表名&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;查询子句&lt;/span&gt;
[&lt;span style=&#34;color:#66d9ef&#34;&gt;WITH&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CHECK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;OPTION&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;子查询可以是任意复杂的&lt;code&gt;SELECT&lt;/code&gt;语句，但通常不允许含有&lt;code&gt;ORDER BY&lt;/code&gt;子句和&lt;code&gt;DISTINCT&lt;/code&gt;短语。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WITH CHECK OPTION&lt;/code&gt;：表示对&lt;code&gt;UPDATE&lt;/code&gt;、&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;操作时保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。&lt;/li&gt;
&lt;li&gt;组成视图的属性列名或者全部省略或者全部指定。如果省略属性列名，则隐含该视图由&lt;code&gt;SELECT&lt;/code&gt;子查询目标列的主属性组成。&lt;/li&gt;
&lt;li&gt;对视图进行的增改操作实际上是对基本表进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删除视图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;VIEW&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;视图名&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;
&lt;p&gt;数据库中的索引是&lt;u&gt;某个表中一列或者若干列值的集合&lt;/u&gt;和&lt;u&gt;相应的指向表中物理标识这些值的数据页的逻辑指针清单&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;索引分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聚集索引：指索引表中索引项的顺序与表中记录的物理顺序一致的索引；&lt;/li&gt;
&lt;li&gt;非聚集索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对数据库表创建和删除索引，修改的是数据库的内模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;关系数据库的规范化&#34;&gt;关系数据库的规范化&lt;/h1&gt;
&lt;h2 id=&#34;关系模式&#34;&gt;关系模式&lt;/h2&gt;
&lt;p&gt;一个关系模式应当是一个五元组（含关系名）：$R&amp;lt;U,D,dom,F&amp;gt;$。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$R$：&lt;u&gt;关系名，是符号化的元祖语义；&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;$U$：&lt;u&gt;一组属性名；&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;$D$：属性组$U$中的属性来自域$D$；&lt;/li&gt;
&lt;li&gt;$dom$：属性到域的映射；&lt;/li&gt;
&lt;li&gt;$F$：&lt;u&gt;属性组$U$上的一组数据依赖（函数依赖）。&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$D$和$dom$对模式设计关系不大，通常将关系模式看作是一个三元组：$R&amp;lt;U,F&amp;gt;$。&lt;/p&gt;
&lt;p&gt;当且仅当$U$上的一个关系$r$满足$F$时，称$r$为关系模式$R&amp;lt;U,F&amp;gt;$的一个关系。&lt;/p&gt;
&lt;h2 id=&#34;函数依赖&#34;&gt;函数依赖&lt;/h2&gt;
&lt;p&gt;数据依赖是&lt;u&gt;通过一个关系中属性间值的相等与否&lt;/u&gt;体现出来的&lt;u&gt;数据间的相互关系&lt;/u&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数依赖&lt;/strong&gt;：设$R(U)$是属性集U上的关系模式，&lt;u&gt;$X$、$Y$是$U$的子集&lt;/u&gt;。若对$R(U)$的任何一个可能的关系$r$，$r$中不可能存在两个元组在$X$上的属性值相等，而在$Y$上的属性值不等（即，&lt;u&gt;在关系$r$中，元组在$X$上的属性值相等，那么在$Y$上的属性值也相等&lt;/u&gt;），则称&lt;strong&gt;X函数决定Y&lt;/strong&gt;或&lt;strong&gt;Y函数依赖于X&lt;/strong&gt;，记作$X \rightarrow Y$。&lt;/p&gt;
&lt;p&gt;如，学生表中，$学号 \rightarrow 姓名$。&lt;/p&gt;
&lt;p&gt;属性之间有3种关系，但并不是每一种都存在函数依赖。如果$X$和$Y$之间的对应关系是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$1-1$：存在函数依赖$X \rightarrow Y$和$Y \rightarrow Y$；&lt;/li&gt;
&lt;li&gt;$n:1$：存在函数依赖$X \rightarrow Y$；&lt;/li&gt;
&lt;li&gt;$n:m$：不存在函数依赖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非平凡的函数依赖&lt;/strong&gt;：$X \rightarrow Y$，但$Y \not\subseteq X$，则称$X \rightarrow Y$是非平凡的函数依赖。&lt;/p&gt;
&lt;p&gt;例如，$姓名 \not\subseteq 学号$，则$学号 \rightarrow 姓名$是一个非平凡的函数依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;平凡的函数依赖&lt;/strong&gt;：如果$X \rightarrow Y$，但$Y \subseteq X$，则称$X \rightarrow Y$是平凡的函数依赖。&lt;/p&gt;
&lt;p&gt;例如，$学号 \subset (学号,课程号)$，则$(学号,课程号) \rightarrow 学号$是一个平凡的函数依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;完全函数依赖&lt;/strong&gt;：在R(U)中，如果$X \rightarrow Y$，并且对于X的任何一个真子集X&amp;rsquo;都有&lt;strong&gt;X&amp;rsquo;不能决定Y&lt;/strong&gt;，则称Y对X完全函数依赖，记作$X \stackrel{f}{\longrightarrow} Y$。&lt;/p&gt;
&lt;p&gt;即需要由$X$的所有属性才能决定$Y$的，才能称为完全函数依赖。&lt;/p&gt;
&lt;p&gt;如，$(学号,课程号) \rightarrow 成绩$。&lt;/p&gt;
&lt;p&gt;如果$X$仅包含一个属性，那么此时必为完全函数依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;部分函数依赖&lt;/strong&gt;：如果$X \rightarrow Y$，但&lt;strong&gt;Y不完全函数依赖于X&lt;/strong&gt;，则称Y对X部分函数依赖，记作$X \stackrel{P}{\longrightarrow} Y$。部分函数依赖也称为局部函数依赖。&lt;/p&gt;
&lt;p&gt;如，（学号，班级代号） $\rightarrow$ 姓名，因为学号 $\rightarrow$ 姓名，所以（学号，班级代号） $\stackrel{P}{\longrightarrow}$ 姓名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传递依赖&lt;/strong&gt;：在$R(U,F)$中（F是U上的一组函数依赖），如果$X \rightarrow Y,\ Y \not\subseteq X,\ Y \rightarrow Z$，则称&lt;strong&gt;Z对X传递依赖&lt;/strong&gt;（$X \rightarrow Z$）。&lt;/p&gt;
&lt;p&gt;即$X \stackrel{f}{\longrightarrow} Y$，且$Y \rightarrow Z$，则$X \rightarrow Z$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;码&lt;/strong&gt;：设$K$为$R(U,F)$中属性的组合，若$K \rightarrow U$，且对于$K$的任何一个真子集$K&#39;$都有$K&#39;$不能决定$U$，则$K$为$R$的候选码。&lt;/p&gt;
&lt;p&gt;即$K \stackrel{f}{\rightarrow} U$，那么K是R的候选码。&lt;/p&gt;
&lt;p&gt;若有多个候选码，则选一个作为主码（主键，主关键字）。候选码通常也称为&lt;strong&gt;候选关键字&lt;/strong&gt;（候选键，键）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主属性&lt;/strong&gt;和&lt;strong&gt;非主属性&lt;/strong&gt;：&lt;strong&gt;包含在任何一个候选码中&lt;/strong&gt;的属性称为主属性，否则称为非主属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外码&lt;/strong&gt;：若R(U)中的属性或属性组&lt;u&gt;X非R的码，但X是另一个关系的码&lt;/u&gt;，则称X为外码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数依赖的公理系统&lt;/strong&gt;（Armstrong公理系统）：&lt;/p&gt;
&lt;p&gt;设关系模式$R(U,F)$，其中$U$为属性集，$F是$U$上的一组函数依赖，那么有以下推理规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自反律&lt;/strong&gt;（A1）：若$Y \subseteq X \subseteq U$，则$X \rightarrow Y$为$F$所蕴涵（蕴含）。&lt;/p&gt;
&lt;p&gt;如，（学号，姓名） $\rightarrow$ 姓名是函数依赖所蕴涵的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;增广律&lt;/strong&gt;（A2）：若$X \rightarrow Y$为F所蕴涵，且$Z \subseteq U$,则$XZ \rightarrow YZ$为$F$所蕴涵。&lt;/p&gt;
&lt;p&gt;如，学号 $\rightarrow$ 姓名，班级 $\subseteq$ 学生表，那么（学号，班级） $\rightarrow$ （姓名，班级）是函数依赖所蕴涵的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传递律&lt;/strong&gt;（A3）：若$X \rightarrow Y,\ Y \rightarrow Z$为$F$所蕴涵，则$X \rightarrow Z$为$F$所蕴涵。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述3条推理规则又可推出下述3条推理规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;合并规则&lt;/strong&gt;：若$X \rightarrow Y,\ X \rightarrow Z$，则$X \rightarrow YZ$为F所蕴涵。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伪传递律&lt;/strong&gt;：若$X \rightarrow Y,\ WY \rightarrow Z$，则$XW \rightarrow Z$为F所蕴涵。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分解规则&lt;/strong&gt;：若$X \rightarrow Y,\ Z \subseteq Y$，则$X \rightarrow Z$为F所蕴涵。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;合并规则和分解规则是两个互逆的规则。即$X \rightarrow Y,\ X \rightarrow Z$，可得$X \rightarrow YZ$；那么$X \rightarrow YZ$，也可得$X \rightarrow Y,\ X \rightarrow Z$（因为$Y,Z \sub YZ$）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;条件&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;结论&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;函数依赖&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;元组在$X$上的属性值相等，那么在$Y$上的属性值也相等&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X$函数决定$Y$或$Y$函数依赖于$X$，记作$X \rightarrow Y$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;非平凡的函数依赖&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$，$Y \not\subseteq X$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$是非平凡的函数依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;平凡的函数依赖&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$，$Y \subseteq X$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$是平凡的函数依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;完全函数依赖&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$，$X&#39; \subset X$，$X&#39; \not\rightarrow Y$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Y$对$X$完全函数依赖，记作$X \stackrel{f}{\longrightarrow} Y$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;部分函数依赖（局部函数依赖）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$，$X \stackrel{f}{\not\longrightarrow} Y$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Y$对$X$部分函数依赖，记作$X \stackrel{P}{\longrightarrow} Y$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传递依赖&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$，$Y \not\subseteq X$，$Y \rightarrow Z$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Z$对$X$传递依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;码（候选码，候选关键字）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;若$K \stackrel{f}{\rightarrow} U$，则$K$为$R$的候选码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;主属性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包含在任何一个候选码中的属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;非主属性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不包含在任何一个候选码中的属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;外码&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X$非$R$的码，但$X$是另一个关系的码，则称$X$为外码&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Armstrong公理系统：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;定律&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;条件&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;F蕴含&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;自反律&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$Y \subseteq X \subseteq U$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;增广律&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y$，$Z \subseteq U$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$XZ \rightarrow XZ$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传递律&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y,\ Y \rightarrow Z$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Z$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;规则&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;条件&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;F蕴含&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;合并规则&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y,\ X \rightarrow Z$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow YZ$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;伪传递律&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y,\ WY \rightarrow Z$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$XW \rightarrow Z$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;分解规则&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Y,\ Z \subseteq Y$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$X \rightarrow Z$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;闭包计算&#34;&gt;闭包计算&lt;/h2&gt;
&lt;p&gt;设关系模式$R&amp;lt;U,F&amp;gt;$，其中$U$为属性集，$F$是$U$上的一组函数依赖。称所有用Armstrong公理从F推出的函数依赖$X \rightarrow A_i$中，$A_i(X,A_i \subseteq U)$的属性集合为$X$的属性闭包，记为$X^{+}_{F}$或$X^{+}$。&lt;/p&gt;
&lt;p&gt;定理：&lt;/p&gt;
&lt;p&gt;设关系模式$R&amp;lt;U,F&amp;gt;$，其中$F$为函数依赖集，$X,Y \subseteq U$，则从$F$推出$X \rightarrow Y$的充要条件是$Y \subseteq X^{+}$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;属性的闭包计算用于求主键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如，给定关系$R(U,F)$，其中$U={A,B,C,D,E,H}$，$F={A \rightarrow B, B \rightarrow DH, A \rightarrow H, C \rightarrow E }$。&lt;/p&gt;
&lt;p&gt;先根据$F$选取仅在$\rightarrow$左边出现的属性集（例如，$A$、$C$和$AC$）。根据选取的属性集进行闭包运算（先对$A$进行运算）：&lt;/p&gt;
&lt;p&gt;$$
(A)^{+} \rightarrow (A \ BH)^{+} \rightarrow (AB \ D \ H)^{+} \rightarrow (ABDH)
$$&lt;/p&gt;
&lt;p&gt;此时，$(ABDH)^{+}$无论再怎么推，结果都是$(ABDH)$，说明对$A$的闭包计算已经结束了，结果就是$(ABDH)$。&lt;/p&gt;
&lt;p&gt;而$(ABDH) \neq U$，说明$A$并不是关系$R$的主键。&lt;/p&gt;
&lt;p&gt;而对于$C$的函数依赖仅有$C \rightarrow E$，所以此时应该对$(AC)$进行闭包运算：&lt;/p&gt;
&lt;p&gt;$$
(AC)^{+} \rightarrow (ABDH \ CE)^{+} \rightarrow (ABCDEH)
$$&lt;/p&gt;
&lt;p&gt;此时对$(AC)$的闭包计算结果$(ABCDEH) = U$，说明$(AC)$是关系$R$的主键。&lt;/p&gt;
&lt;h2 id=&#34;关系模式的分解&#34;&gt;关系模式的分解&lt;/h2&gt;
&lt;p&gt;对存在&lt;strong&gt;数据冗余&lt;/strong&gt;、&lt;strong&gt;插入异常&lt;/strong&gt;、&lt;strong&gt;删除异常&lt;/strong&gt;问题的关系模式，应采取&lt;u&gt;将一个关系模式分解为多个关系模式的方法进行处理&lt;/u&gt;（原来存储在一个二维表内的数据就要分散到多个二维表中）。要求是分解后的二维表不能丢失分解前二维表的信息。&lt;/p&gt;
&lt;p&gt;为使分解后的模式保持原模式所满足的特性，其基本要求是模式分解具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无损连接性；&lt;/li&gt;
&lt;li&gt;保持函数依赖性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;无损连接&#34;&gt;无损连接&lt;/h3&gt;
&lt;p&gt;无损连接性指的是对关系模式分解时，原关系模式下，任一合法的关系实例，在分解之后应能通过自然连接运算恢复起来。&lt;/p&gt;
&lt;p&gt;设$\rho = \{ R_1&amp;lt;U_1,F_1&amp;gt;,\ R_2&amp;lt;U_2,F_2&amp;gt;,\ \cdots,\ R_k&amp;lt;U_k,F_k&amp;gt; \}$是关系模式$R&amp;lt;U,F&amp;gt;$的一个分解，如果对于$R$的任一满足$F$的关系$r$都有：&lt;/p&gt;
&lt;p&gt;$$
r = \pi_{R1}(r) \Join \pi_{R2}(r) \Join \cdots \Join \pi_{Rk}(r)
$$&lt;/p&gt;
&lt;p&gt;则称这个分解$\rho$是满足依赖集$F$的无损连接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\pi()$运算是投影运算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如$\pi_{R1}(r)$，表示关系$r$在$R_1$上的投影。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Join$运算是自然连接运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人理解：&lt;/p&gt;
&lt;p&gt;无损连接性就是指，关系模式拆分后（分成若干个小的关系模式，即$\rho$），$\rho$中的关系模式从总体上看，保持着与$R$一致的连接。$\rho$中的关系模式通过自然连接保持着原本的关系模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;验证无损连接的充要条件：&lt;/p&gt;
&lt;p&gt;如果$R$的分解为$\rho = \{R_1,R_2\}$，$F$为$R$所满足的函数依赖集合，则分解$\pho$具有无损连接性的充分必要条件为：&lt;/p&gt;
&lt;p&gt;$$
R_1 \cap R_2 \rightarrow (R_1 - R_2) \\
或 \\
R_1 \cap R_2 \rightarrow (R_2 - R_1)
$$&lt;/p&gt;
&lt;h3 id=&#34;保持函数依赖&#34;&gt;保持函数依赖&lt;/h3&gt;
&lt;p&gt;设有关系模式$R$，$F$是$R$的函数依赖集，$Z$是$R$的一个属性集合，则称$Z$所涉及到的$F^+$中所有函数依赖为$F$在$Z$上的投影，即为$\pi_Z(F)$，有：&lt;/p&gt;
&lt;p&gt;$$
\pi_Z(F) = \{ x \rightarrow y | (x \rightarrow y) \in F^+ 且 xy \subseteq z \}
$$&lt;/p&gt;
&lt;p&gt;设关系模式$R$的一个分解$\rho = \{ R_1&amp;lt;U_1,F_1&amp;gt;,\ R_2&amp;lt;U_2,F_2&amp;gt;,\ \cdots,\ R_k&amp;lt;U_k,F_k&amp;gt; \}$，$F$是$R$的依赖集，如果$F$等价于$\pi_{R1}(F) \cup \pi_{R2}(F) \cup \cdots \cup \pi_{Rk}(F)$，则称分解$\rho$具有依赖保持性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该定义中的&amp;quot;等价&amp;quot;并不代表相等，而是$F$中所包含的函数依赖在分解的函数依赖中也被包含，或者在分解的函数依赖中能被推出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个无损连接分解不一定具有依赖保持性；一个依赖保持性分解不一定具有无损连接性。&lt;/p&gt;
&lt;h2 id=&#34;范式&#34;&gt;范式&lt;/h2&gt;
&lt;p&gt;关系数据库中的&lt;u&gt;关系必须满足一定的规范化要求&lt;/u&gt;，对于不同的规范化程度可用范式来衡量。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;范式是符合某一种级别的关系模式的集合&lt;/u&gt;，是衡量关系模式规范化程度的标准，达到范式的关系才是规范化的。&lt;/p&gt;
&lt;p&gt;一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化。&lt;/p&gt;
&lt;p&gt;主要有6种范式，高一级范式是在低一级范式的基础上进一步满足一些要求，按要求从低到高分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一范式（1NF）：若关系模式R的&lt;u&gt;每一个分量是不可再分的数据项&lt;/u&gt;，则关系模式R属于第一范式。&lt;/p&gt;
&lt;p&gt;如，关系模式$R&amp;lt;U,F&amp;gt;$：&lt;/p&gt;
&lt;p&gt;$$
U = \{ 学号,姓名,学院,院长,课程号,课程名,成绩 \} \\
F = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长,课程号 \rightarrow 课程名,(学号,课程号) \rightarrow 成绩 \}
$$&lt;/p&gt;
&lt;p&gt;1NF可能存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据冗余&lt;/strong&gt;：数据的冗余度大，R中可能出现多个元组在多个属性集中值相同；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改异常&lt;/strong&gt;：引起修改操作的不一致性，修改一条记录可能需要修改其他多条记录才能保持数据一致性（由数据冗余引起）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插入异常&lt;/strong&gt;：主码不能取空值或部分空值，会出现插入异常；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;删除异常&lt;/strong&gt;：本该删除但又客观存在的元组，会出现删除异常。&lt;/p&gt;
&lt;p&gt;即，删除掉的数据可能包含着其他本不该被删除的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题的原因是1NF中可能存在&lt;u&gt;部分函数依赖&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二范式（2NF）：若关系模式$R \in 1NF$，且&lt;u&gt;每一个非主属性完全依赖于码&lt;/u&gt;，则关系模式$R \in 2NF$。&lt;/p&gt;
&lt;p&gt;即当&lt;u&gt;1NF消除了对主键的部分函数依赖后就能满足2NF&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;例如，$学号 \rightarrow 学院$，即$(学号,课程号) \stackrel{P}{\rightarrow} 学院$（部分依赖于码），所以$R \not\in 2NF$。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;模式的分解需要保持函数依赖。&lt;/u&gt;根据$F$，将$R$分解为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$R_1&amp;lt;U_1,F_1&amp;gt;$：&lt;/p&gt;
&lt;p&gt;$$
U_1 = \{ 学号,姓名,学院,院长 \} \\
F_1 = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长 \}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$R_2&amp;lt;U_2,F_2&amp;gt;$：&lt;/p&gt;
&lt;p&gt;$$
U_2 = \{ 课程号,课程名 \} \\
F_2 = \{ 课程号 \rightarrow 课程名 \}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$R_3&amp;lt;U_3,F_3&amp;gt;$：&lt;/p&gt;
&lt;p&gt;$$
U_3 = \{ 学号,课程号,成绩 \} \\
F_3 = \{ (学号,课程号) \rightarrow 成绩 \}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则，$R1 \in 2NF$，$R2 \in 2NF$，$R3 \in 2NF$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2NF可能依然会存在数据冗余、修改异常、插入异常删除异常等问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三范式（3NF）：若关系模式$R(R \in 2NF)$中&lt;u&gt;任何一个非主属性都不传递函数依赖于码&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;若关系模式$R&amp;lt;U,F&amp;gt;$（$U$为关系集，$F$为函数依赖集）中不存在这样的码$X$，使得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X \rightarrow Y(Y \not\rightarrow X)$，&lt;/li&gt;
&lt;li&gt;$Y \rightarrow Z$，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则关系模式$R \in 3NF$，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$Y$为属性组，&lt;/li&gt;
&lt;li&gt;$Z(Z \not\subseteq Y)$为非主属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即当&lt;u&gt;2NF消除了非主属性对主键的传递函数依赖&lt;/u&gt;，则称为3NF。&lt;/p&gt;
&lt;p&gt;如，$R_1$中有$学号 \rightarrow 学院$，$学院 \rightarrow 院长$（非主属性&amp;quot;院长&amp;quot;传递依赖于主键&amp;quot;学号&amp;quot;）。可将$R_1$分解为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$R_{11}&amp;lt;U_{11},F_{11}&amp;gt;$：&lt;/p&gt;
&lt;p&gt;$$
U_{11} = \{ 学号,姓名,学院 \} \\
F_{11} = \{ 学号 \rightarrow 姓名, 学号 \rightarrow 学院 \}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$R_{12}&amp;lt;U_{12},F_{12}&amp;gt;$：&lt;/p&gt;
&lt;p&gt;$$
U_{12} = \{ 学院,院长 \} \\
F_{12} = \{ 学院 \rightarrow 院长 \}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BC范式（BCNF）：关系模式$R&amp;lt;U,F&amp;gt;$属于BCNF（$R$首先得满足3NF），当且仅当其$F$中&lt;u&gt;每个依赖的决定因素必定包含R的某个候选码&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;满足3NF。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有&lt;u&gt;非主属性&lt;/u&gt;对每一个&lt;u&gt;码&lt;/u&gt;都是&lt;u&gt;完全函数依赖&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;$$
码 \stackrel{f}{\longrightarrow} 非主属性
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的&lt;u&gt;主属性对每一个&lt;/u&gt;不包含它的码&lt;/u&gt;，也是&lt;u&gt;完全函数依赖&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有任何属性完全函数依赖于非码的任何一组属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个满足BCNF的关系模式R己&lt;u&gt;消除了&lt;strong&gt;插入&lt;/strong&gt;和&lt;strong&gt;删除异常&lt;/strong&gt;&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四范式（4NF）：&lt;/p&gt;
&lt;p&gt;多值依赖：&lt;/p&gt;
&lt;p&gt;给定的关系模式$R(U,F)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X,Y,Z \subseteq U$，&lt;/li&gt;
&lt;li&gt;$Z=U-X-Y$（$Z$是$X \cup Y$的差集）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当且仅当对$R$的任一关系$r$，给定的一对$(x,z)$值，有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关。则关系模式$R$中的多值依赖$X \rightarrow\rightarrow Y$成立。&lt;/p&gt;
&lt;p&gt;平凡的多值依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X \rightarrow\rightarrow Y$成立，&lt;/li&gt;
&lt;li&gt;$Z = \Phi$，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则$X \rightarrow\rightarrow Y$为平凡的多值依赖。&lt;/p&gt;
&lt;p&gt;例如，课程$\rightarrow\rightarrow$任课老师，课程$\rightarrow\rightarrow$参考书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681986736869.png&#34;
	width=&#34;401&#34;
	height=&#34;168&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681986736869_hub94b74037a183c6a89e4bcd8421bb42f_31992_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681986736869_hub94b74037a183c6a89e4bcd8421bb42f_31992_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;多值依赖表示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;238&#34;
		data-flex-basis=&#34;572px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;4NF定义：&lt;/p&gt;
&lt;p&gt;设有一关系模式$R(U,F)$是1NF，如果对于$R$的每个&lt;u&gt;非平凡多值依赖&lt;/u&gt;$X \rightarrow\rightarrow Y(Y \not\subseteq X)$，&lt;u&gt;$X$都包含了$R$的一个候选码&lt;/u&gt;，则称$R$是第四范式，记为4NF。&lt;/p&gt;
&lt;p&gt;例如，课程$\rightarrow\rightarrow$任课老师，课程$\rightarrow\rightarrow$参考书都是非平凡多值依赖，而课程不是码，所以不属于4NF。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第五范式（5NF）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;范式之间的关系：&lt;/p&gt;
&lt;p&gt;$$
5NF \sub 4NF \sub BCNF \sub 3NF \sub 2NF \sub 1NF
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681894653450.png&#34;
	width=&#34;564&#34;
	height=&#34;309&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681894653450_hufd0c331a204cb2191b602cbf89c9254e_19807_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681894653450_hufd0c331a204cb2191b602cbf89c9254e_19807_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;规范化范式的包含关系&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;182&#34;
		data-flex-basis=&#34;438px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;3NF和BCNE它们是进行规范化的主要目标。&lt;/p&gt;
&lt;p&gt;1NF到4NF之间的转换关系：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;范式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;转换关系&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1NF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;所有的范式都满足1NF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2NF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1NF消除了部分函数依赖后满足2NF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3NF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2NF消除了非主属性对码的传递函数依赖后满足3NF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BCNF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3NF消除了主属性对码的部分和传递函数依赖后满足BCNF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4NF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;BCNF消除非平凡且非函数依赖的多值依赖后满足4NF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681988070233.png&#34;
	width=&#34;288&#34;
	height=&#34;303&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681988070233_huc82f8c088bb0c067181a613d8b65e62c_36441_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681988070233_huc82f8c088bb0c067181a613d8b65e62c_36441_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;规范化步骤&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;几种范式及其分解的性质：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;性质&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;3NF&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;BCNF&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4NF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;消除函数依赖带来冗余&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;消除多值函数依赖带来冗余&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保持函数依赖&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保持多值函数依赖&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据库设计&#34;&gt;数据库设计&lt;/h1&gt;
&lt;p&gt;新奥尔良（New Orleans）法式目前公认的数据库设计方法，它将数据库设计分为以下几个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户需求分析&lt;/li&gt;
&lt;li&gt;概念结构设计&lt;/li&gt;
&lt;li&gt;逻辑结构设计&lt;/li&gt;
&lt;li&gt;物理结构设计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几个阶段之后是与数据库建立和运行有关的阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库实施&lt;/li&gt;
&lt;li&gt;数据库运行和维护&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682505975157.png&#34;
	width=&#34;382&#34;
	height=&#34;711&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682505975157_hu7950d0a7bbf6248186699719c01d30ad_79693_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682505975157_hu7950d0a7bbf6248186699719c01d30ad_79693_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;数据库设计步骤&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;53&#34;
		data-flex-basis=&#34;128px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;需求分析&#34;&gt;需求分析&lt;/h2&gt;
&lt;p&gt;需求分析是项目确定后，对数据库应用系统所要设计的&lt;u&gt;内容（数据）&lt;/u&gt;和&lt;u&gt;功能（行为）&lt;/u&gt;的整理和描述，是以用户的角度来认识系统。&lt;/p&gt;
&lt;p&gt;需求分析是后面几个阶段，&lt;u&gt;逻辑结构设计&lt;/u&gt;、&lt;u&gt;物理结构设计&lt;/u&gt;以及&lt;u&gt;应用程序设计&lt;/u&gt;的依据。&lt;/p&gt;
&lt;p&gt;需求分析将收集到的零碎的、局部的数据分析整理后，建立&lt;u&gt;需求说明文档&lt;/u&gt;、&lt;u&gt;数据字典&lt;/u&gt;和&lt;u&gt;数据流程图&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;需求分析还包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据流分析：是对事务处理所需的原始数据的收集，及经过处理后所得数据及其流向。&lt;/p&gt;
&lt;p&gt;使用数据流图（DFD）表示。DFD能指出数据的流向和需要进行的事物处理（不涉及如何处理）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据字典：是关于数据库中数据的描述，即元数据（不是数据本身）。&lt;/p&gt;
&lt;p&gt;数据字典包括5个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据项；&lt;/li&gt;
&lt;li&gt;数据结构；&lt;/li&gt;
&lt;li&gt;数据流；&lt;/li&gt;
&lt;li&gt;数据存储；&lt;/li&gt;
&lt;li&gt;加工。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;系统需求说明书是需求分析阶段的成果&lt;/u&gt;，主要包括&lt;u&gt;数据流图&lt;/u&gt;、&lt;u&gt;数据字典&lt;/u&gt;、&lt;u&gt;各种说明性表格&lt;/u&gt;、&lt;u&gt;统计输出表和系统功能结构图&lt;/u&gt;等。&lt;/p&gt;
&lt;p&gt;需求分析阶段的工作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682560887456.png&#34;
	width=&#34;646&#34;
	height=&#34;291&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682560887456_hub24d924f6ecdb59b0c05cde9f6a94c8c_58795_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682560887456_hub24d924f6ecdb59b0c05cde9f6a94c8c_58795_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;需求分析阶段的工作步骤&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;221&#34;
		data-flex-basis=&#34;532px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;概念结构设计&#34;&gt;概念结构设计&lt;/h2&gt;
&lt;p&gt;概念设计阶段的目标是产生整体数据库概念结构，即概念模型，它是与DBMS无关的。&lt;/p&gt;
&lt;p&gt;概念结构设计的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下&lt;/li&gt;
&lt;li&gt;自底向上&lt;/li&gt;
&lt;li&gt;逐步扩张&lt;/li&gt;
&lt;li&gt;混合策略（自顶向下和自底向上相结合）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概念结构是对现实世界的一种抽象，从数据库设计角度看，主要是数据抽象，一般有如下3种数据抽象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类&lt;/li&gt;
&lt;li&gt;聚集&lt;/li&gt;
&lt;li&gt;概括&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;局部视图设计就是对某个局部应用设计其分一R图，也称局部E-R图。其基本步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682560993863.png&#34;
	width=&#34;717&#34;
	height=&#34;341&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682560993863_huf62446c235f8abd7d4a5d741b96b438b_65906_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682560993863_huf62446c235f8abd7d4a5d741b96b438b_65906_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;概念结构设计的工作步骤&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;210&#34;
		data-flex-basis=&#34;504px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定局部结构范围；&lt;/li&gt;
&lt;li&gt;定义实体；&lt;/li&gt;
&lt;li&gt;联系定义；&lt;/li&gt;
&lt;li&gt;属性分配。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;概念模型的建立采用E-R模型。&lt;/p&gt;
&lt;h3 id=&#34;e-r-模型&#34;&gt;E-R 模型&lt;/h3&gt;
&lt;p&gt;E-R模型用E-R图表示，E-R图有以下几个成分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实体&lt;/strong&gt;：用&lt;strong&gt;矩形&lt;/strong&gt;表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;联系&lt;/strong&gt;：用&lt;strong&gt;棱形&lt;/strong&gt;表示，并用无向边分别与有关实体连接起来，同时在无向边标注联系的类型（$1:1$，$1:n$ 或 $m:n$）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;：用&lt;strong&gt;椭圆形&lt;/strong&gt;表示，并用无向边将其与相应的实体连接起来&lt;/p&gt;
&lt;p&gt;E-R模型中的属性有以下分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单属性和复合属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单属性是原子的、不可再分的；&lt;/li&gt;
&lt;li&gt;复合属性可以细分为更小的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单值属性和多值属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单值属性是一个属性对应一个值；&lt;/li&gt;
&lt;li&gt;多值属性是一个属性对应一组值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NULL属性：实体在某个属性上没有值或属性值未知时，使用NULL值表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;派生属性：派生属性可以从其他属性得来（通过运算等方式求出）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扩充的E-R模型（用来表达更多具有特殊语义的成分）有以下成分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;弱实体&lt;/strong&gt;：使用&lt;strong&gt;双线矩形框&lt;/strong&gt;表示。将需要依赖其他实体存在的实体。&lt;/p&gt;
&lt;p&gt;实体间的所有（Ownership，拥有）关系代表一个实体对另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提。&lt;/p&gt;
&lt;p&gt;例如职工与家属的联系，家属总是属于某职工的（在关系模式中需要依赖职工而存在），所以家属是弱实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊化：将一个实体集按照某些特性区分为几个子实体。这种从普遍到特殊的过程即为特殊化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E-R图中的主要构件（包含扩充的E-R模型成分）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682508598814.png&#34;
	width=&#34;1035&#34;
	height=&#34;391&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682508598814_hub0bc3034b48557bb84109435ab8e458e_191424_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682508598814_hub0bc3034b48557bb84109435ab8e458e_191424_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;E-R图中的主要构件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;264&#34;
		data-flex-basis=&#34;635px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;建立概念结构模型&#34;&gt;建立概念结构模型&lt;/h3&gt;
&lt;p&gt;建立概念结构模型的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择局部应用：&lt;/p&gt;
&lt;p&gt;需求分析阶段得到的大量数据分散杂乱，许多数据会应用于不同的处理，数据与数据之间关联关系也较为复杂。要最终&lt;u&gt;确定实体、属性和联系，必须根据数据流图这一线索理清数据&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;数据流图是对业务处理过程从高层到底层的一级抽象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高层抽象流图一般反映系统的概貌，对数据的引用较为笼统；&lt;/li&gt;
&lt;li&gt;底层又可能过于细致，不能体现数据的关联关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此要&lt;u&gt;选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能。从这一层入手，就能很好地设计&lt;strong&gt;分E-R图&lt;/strong&gt;&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逐一设计分E-R图。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;E-R图合并：&lt;/p&gt;
&lt;p&gt;根据局部应用设计好各局部E-R图之后，就可以对各分E-R图进行合并。&lt;/p&gt;
&lt;p&gt;合并的目的在于，在合并过程中解决分E-R图中相互存在的冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分E-R图之间的冲突主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;属性冲突&lt;/strong&gt;：同一属性在不同的分E-R图上的属性类型、取值范围和数据单位等可能会不一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名冲突&lt;/strong&gt;：相同意义的属性在不同的分E-R图上可能会有不同的命名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结构冲突&lt;/strong&gt;：同一实体在不同的分E-R图中可能会有不同的属性；同一对象在某一分E-R图中被抽象为实体，而在另一分E-R图中又可能被抽象为属性，反之亦然。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;逻辑结构设计&#34;&gt;逻辑结构设计&lt;/h2&gt;
&lt;p&gt;逻辑结构设计就是在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型和关系模型。&lt;/p&gt;
&lt;p&gt;通常是把概念模型转换成为&lt;u&gt;某个具体的数据库管理系统所支持的结构数据模型&lt;/u&gt;（与DBMS有关）。即，将概念结构设计所得的E-R模型转换成关系模式。&lt;/p&gt;
&lt;p&gt;逻辑结构设计的工作步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682577339219.png&#34;
	width=&#34;581&#34;
	height=&#34;296&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682577339219_hu0e28af6a5a7453a0a5eb6666d48c94c7_44563_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682577339219_hu0e28af6a5a7453a0a5eb6666d48c94c7_44563_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;逻辑结构设计的工作步骤&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;196&#34;
		data-flex-basis=&#34;471px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;e-r-模型转换关系模式&#34;&gt;E-R 模型转换关系模式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;实体向关系模式的转换：&lt;/p&gt;
&lt;p&gt;将E-R图中的实体逐一转换成为一个关系模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体名：对应关系模式的名称；&lt;/li&gt;
&lt;li&gt;实体的属性：转换成关系模式的属性；&lt;/li&gt;
&lt;li&gt;实体标识符：关系的码（键）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联系向关系模式的转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一对一联系的转换：&lt;/p&gt;
&lt;p&gt;有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性包括该联系所关联的两个实体的码及联系的属性，关系的码取自任一方实体的码。&lt;/p&gt;
&lt;p&gt;那么一个一对一联系需要转换成三个关系模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式2（一般使用该方式）：将联系归并到关联的两个实体的任一方，给待归并的一方实体属性集中增加另一方实体的码和该联系的属性即可，归并后的实体码保持不变。&lt;/p&gt;
&lt;p&gt;一个一对一联系仅需转换成两个关系模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682562445900.png&#34;
	width=&#34;304&#34;
	height=&#34;358&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682562445900_hu39b33fe28157809884f3b45df834a34e_28041_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682562445900_hu39b33fe28157809884f3b45df834a34e_28041_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;联系向关系模式的转换示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;84&#34;
		data-flex-basis=&#34;203px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式1：&lt;/p&gt;
&lt;p&gt;厂长（&lt;strong&gt;姓名&lt;/strong&gt;，性别，年龄）&lt;/p&gt;
&lt;p&gt;工厂（&lt;strong&gt;厂号&lt;/strong&gt;，厂名，地点）&lt;/p&gt;
&lt;p&gt;管理（（厂长）&lt;strong&gt;姓名&lt;/strong&gt;，厂号，任期）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;粗体代表该关系模式的码。管理的码可以为姓名或厂号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式2：&lt;/p&gt;
&lt;p&gt;厂长（姓名，性别，年龄）&lt;/p&gt;
&lt;p&gt;工厂（厂号，厂名，地点，（厂长）姓名，任期）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一对多联系的转换：&lt;/p&gt;
&lt;p&gt;两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个实体的码及联系的属性，&lt;u&gt;关系的码是多方实体的码&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;方式2（一般使用该方式）：将联系&lt;u&gt;归并到关联的两个实体的多方&lt;/u&gt;，给待归并的多方实体属性集中增加一方实体的码和该联系的属性即可，归并后的多方实体码保持不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682563544291.png&#34;
	width=&#34;315&#34;
	height=&#34;361&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682563544291_hue1cce8af0395e2bd704f6df0a3e3321e_30915_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682563544291_hue1cce8af0395e2bd704f6df0a3e3321e_30915_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;一对多联系转换的例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;87&#34;
		data-flex-basis=&#34;209px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式1:&lt;/p&gt;
&lt;p&gt;仓库（&lt;strong&gt;仓库号&lt;/strong&gt;，地点，面积）&lt;/p&gt;
&lt;p&gt;商品（&lt;strong&gt;货号&lt;/strong&gt;，商品名，价格）&lt;/p&gt;
&lt;p&gt;仓储（&lt;strong&gt;货号&lt;/strong&gt;，仓库号，数量）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式2：&lt;/p&gt;
&lt;p&gt;仓库（&lt;strong&gt;仓库号&lt;/strong&gt;，地点，面积）&lt;/p&gt;
&lt;p&gt;商品（&lt;strong&gt;货号&lt;/strong&gt;，商品名，价格，仓库号，数量）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多对多联系的转换：&lt;/p&gt;
&lt;p&gt;多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682564018777.png&#34;
	width=&#34;327&#34;
	height=&#34;373&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682564018777_hu8cf40dc2a076405a9cb5ca4646519d5e_36334_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682564018777_hu8cf40dc2a076405a9cb5ca4646519d5e_36334_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;多对多联系转换的示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;87&#34;
		data-flex-basis=&#34;210px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;转换成：&lt;/p&gt;
&lt;p&gt;学生（&lt;strong&gt;学号&lt;/strong&gt;，姓名，性别，年龄）&lt;/p&gt;
&lt;p&gt;课程（&lt;strong&gt;课程号&lt;/strong&gt;，课程名，学时）&lt;/p&gt;
&lt;p&gt;选修（&lt;strong&gt;（学号，课程号）&lt;/strong&gt;，成绩）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;关系模式的规范化&#34;&gt;关系模式的规范化&lt;/h3&gt;
&lt;p&gt;转换后的关系模式可能存在数据冗余、更新异常等问题，所以需要进一步的规范化处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据语义确定各关系模式的数据依赖（函数依赖）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据数据依赖确定关系模式的范式。判定关系模式是否达到了3NF或4NF。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果关系模式不符合要求，要根据关系模式的分解算法对其进行分解，达到3NF、BCNF或4NF。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系模式的评价及修正。&lt;/p&gt;
&lt;p&gt;根据规范化理论对关系模式分解之后，就可以在理论上消除冗余和更新异常。但根据处理要求，可能还需要增加部分冗余以满足处理要求，这就需要做部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;事务管理&#34;&gt;事务管理&lt;/h1&gt;
&lt;p&gt;事务是一个操作序列，这些操作“要么都做，要么都不做”。&lt;/p&gt;
&lt;p&gt;事务和程序是两个不同的概念，一般一个程序可包含多个事务。&lt;/p&gt;
&lt;p&gt;在SQL语言中，事务定义的语句有以下三条。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BEGIN TRANSACTION&lt;/code&gt;：事务开始。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;COMMIT&lt;/code&gt;：事务提交。&lt;/p&gt;
&lt;p&gt;该操作表示事务成功地结束，它将通知事务管理器该事务的&lt;u&gt;所有更新操作现在可以被提交或永久地保留&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ROLLBACK&lt;/code&gt;：事务回滚。&lt;/p&gt;
&lt;p&gt;该操作表示事务非成功地结束，它将通知事务管理器&lt;u&gt;出故障&lt;/u&gt;了，数据库可能处于不一致状态，该事务的&lt;u&gt;所有更新操作必须回滚或撤销&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务的ACID性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;（Atomicity）：事务是原子的，要么都做，要么都不做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;（Consistency）：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态。&lt;/p&gt;
&lt;p&gt;因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;（Isolation）：事务相互隔离。&lt;/p&gt;
&lt;p&gt;当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;（Durability）：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据库故障&#34;&gt;数据库故障&lt;/h1&gt;
&lt;p&gt;在数据库的运行过程中，难免会出现计算机系统的软、硬件故障，这些故障会影响数据库中数据的正确性，甚至破坏数据库，使数据库中的全部或部分数据丢失。因此，数据库的关键技术在于建立冗余数据，即备份数据。如何在系统出现故障后能够及时地使数据库恢复到故障前的正确状态，就是数据库恢复技术。&lt;/p&gt;
&lt;p&gt;故障类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;事务内部故障&lt;/strong&gt;：有的可以通过事务程序本身发现；有的是非预期的，不能由事务程序处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统故障&lt;/strong&gt;（软故障）：是指造成系统停止运行的任何事件，使得系统要重新启动，例如CPU故障、操作系统故障和突然停电等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;介质故障&lt;/strong&gt;（硬故障）：如磁盘损坏、磁头碰撞和瞬时强磁干扰。此类故障发生的几率小，但破坏性最大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算机病毒&lt;/strong&gt;：计算机病毒是一种人为的故障和破坏，是在计算机程序中插入的破坏，计算机功能或者数据可以繁殖和传播的一组计算机指令或程序代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;备份方法&#34;&gt;备份方法&lt;/h2&gt;
&lt;p&gt;恢复的基本原理是“建立数据冗余”（重复存储）。建立冗余数据的方法是进行&lt;u&gt;数据转储&lt;/u&gt;和&lt;u&gt;登记日志文件&lt;/u&gt;，分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态转储和动态转储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态转储&lt;/strong&gt;：在转储期间不允许对数据库进行任何存取、修改操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态转储&lt;/strong&gt;：在转储期间允许对数据库进行存取、修改操作。&lt;/p&gt;
&lt;p&gt;动态转储和用户事务可并发执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;海量转储和增量转储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;海量转储&lt;/strong&gt;：指每次转储全部数据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增量转储&lt;/strong&gt;：指每次只转储上次转储后更新过的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;日志文件&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在事务处理的过程中，DBMS把以下操作写入日志文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务开始、事务结束；&lt;/li&gt;
&lt;li&gt;对数据库的插入、删除和修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦发生故障，DBMS的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。因此，DBMS利用日志文件来进行事务故障恢复和系统故障恢复，并可协助后备副本进行介质故障恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;恢复&#34;&gt;恢复&lt;/h2&gt;
&lt;p&gt;事务恢复有以下3个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。&lt;/li&gt;
&lt;li&gt;对事务的更新操作执行逆操作。&lt;/li&gt;
&lt;li&gt;继续反向扫描日志文件，查找该事务的其他更新操作，并做同样的处理，直到事务的开始标志。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;并发控制&#34;&gt;并发控制&lt;/h1&gt;
&lt;p&gt;所谓并发操作，是指在多用户共享的系统中许多用户可能同时对同一数据进行操作。并发操作带来的问题是数据的不一致性，主要有三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;丢失更新&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读脏数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其主要原因是事务的并发操作破坏了事务的隔离性。DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据。&lt;/p&gt;
&lt;h2 id=&#34;封锁&#34;&gt;封锁&lt;/h2&gt;
&lt;p&gt;并发控制的主要技术是封锁。基本封锁的类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;排它锁（X锁或写锁）：若事务T对数据对象A加上X锁，则&lt;u&gt;只允许T读取和修改A，其他事务都不能再对A加任何类型的锁&lt;/u&gt;，直到T释放A上的锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享锁（S锁或读锁）：若事务T对数据对象A加上S锁，则&lt;u&gt;只允许T读取A，但不能修改A，其他事务只能再对A加S锁&lt;/u&gt;，直到T释放A上的S锁。&lt;/p&gt;
&lt;p&gt;这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A进行任何修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;分布式数据库&#34;&gt;分布式数据库&lt;/h1&gt;
&lt;p&gt;分布式数据库系统是指数据存放在计算机网络的不同场地的计算机中，每一场地都有自治处理能力并能完成局部应用；而每一场地也参与（至少一种）全局应用程序的执行，全局应用程序可通过网络通信访问系统中多个场地的数据。其定义强调分布性和逻辑整体性两点。&lt;/p&gt;
&lt;p&gt;分布式数据库中有以下基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分片透明&lt;/strong&gt;：指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复制透明&lt;/strong&gt;：指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位置透明&lt;/strong&gt;：指用户无须知道数据存放的物理位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑透明&lt;/strong&gt;：指用户或应用程序无需知道局部场地使用的是哪种数据模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具有以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享性&lt;/strong&gt;：数据存储在不同的结点数据共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自治性&lt;/strong&gt;：指每结点对本地数据都能独立管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt;：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布性&lt;/strong&gt;：指数据在不同场地上的存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;存储过程&#34;&gt;存储过程&lt;/h1&gt;
&lt;p&gt;存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。&lt;/p&gt;
&lt;p&gt;存储过程是数据库所提供的一种数据库对象，通过存储过程定义一段代码，提供给应用程序调用来执行。从安全性的角度考虑，更新数据时，通过提供存储过程正第三方调用，将需要更新的数据传入存储过程，而在存储过程内部用代码分别对需要的多个表进行更新，从而避免了向第三方提供系统的表结构，保证了系统的数据安全。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>面向对象（软件设计师）</title>
        <link>https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <pubDate>Wed, 12 Apr 2023 16:28:00 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</guid>
        <description>&lt;h1 id=&#34;面向对象基本概念&#34;&gt;面向对象基本概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;面向对象&lt;/strong&gt;（Object-Oriented，00） = &lt;strong&gt;对象&lt;/strong&gt;（Object）+ &lt;strong&gt;分类&lt;/strong&gt;（Classification）+ &lt;strong&gt;继承&lt;/strong&gt;（Inheritance）+ &lt;strong&gt;通过消息的通信&lt;/strong&gt;（Communication with Messages）&lt;/p&gt;
&lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;
&lt;p&gt;在面向对象的系统中，对象是基本的运行时的实体，它包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;属性&lt;/strong&gt;：数据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行为&lt;/strong&gt;：作用于数据的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个对象把属性和行为封装为一个整体。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。&lt;/p&gt;
&lt;p&gt;对象可以看作是一个程序模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个对象通常由以下成分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象名；&lt;/li&gt;
&lt;li&gt;属性；&lt;/li&gt;
&lt;li&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息&#34;&gt;消息&lt;/h2&gt;
&lt;p&gt;对象之间进行通信的一种构造叫件消息。&lt;/p&gt;
&lt;h2 id=&#34;类&#34;&gt;类&lt;/h2&gt;
&lt;p&gt;类可以分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实体类&lt;/strong&gt;：实体类的对象表示现实世界中真实的实体；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;接口类&lt;/strong&gt;：接口类的对象为用户提供一种与系统合作交互的方式，分
为人和系统两大类（边界类）；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人的接口可以是显示屏、窗口、Wb窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。&lt;/li&gt;
&lt;li&gt;系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制类&lt;/strong&gt;：控制类的对象用来控制活动流，充当协调者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;继承是&lt;u&gt;父类&lt;/u&gt;和&lt;u&gt;子类&lt;/u&gt;之间&lt;u&gt;共享数据&lt;/u&gt;和&lt;u&gt;方法&lt;/u&gt;的机制。这是&lt;u&gt;类之间的一种关系&lt;/u&gt;，在定义和实现一个类的时候，可以在一个已经存在的类的基础上进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。&lt;/p&gt;
&lt;p&gt;一个父类可以有多个子类。所以继承又分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单重继承：只从一个父类得到继承；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多重继承：一个子类有两个或更多个父类。&lt;/p&gt;
&lt;p&gt;多重继承中可能导致子类存在二义性的成员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多态&#34;&gt;多态&lt;/h2&gt;
&lt;p&gt;多态（Polymorphism）：不同的对象收到同一消息可以产生完全不同的结果。&lt;/p&gt;
&lt;p&gt;同一消息就可以调用不同的方法。多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应。&lt;/p&gt;
&lt;p&gt;多态有不同的形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通用&lt;/strong&gt;的多态：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;多态：应用比较广泛，被称为最纯的多态；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包含&lt;/strong&gt;多态：在许多语言中都存在，最常见的例子就是子类型化。即一个类型是另一个类型的子类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定&lt;/strong&gt;的多态：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;过载&lt;/strong&gt;（Overloading）多态：同一个名字在不同的上下文中所代表的含义不同；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强制&lt;/strong&gt;多态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绑定&#34;&gt;绑定&lt;/h2&gt;
&lt;p&gt;绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。&lt;/p&gt;
&lt;p&gt;绑定分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态绑定&lt;/strong&gt;：在编译时进行的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;：在运行时进行的。&lt;/p&gt;
&lt;p&gt;一个给定的过程调用和代码的结合直到调用发生时才进行。&lt;/p&gt;
&lt;p&gt;动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类对象可以出现的地方，子类对象也可以出现。&lt;/p&gt;
&lt;p&gt;在运行过程中，当一个对象发送消息请求服务时，要根据匿收对象的其体情况将请求的操作与实现的方法进行连接，即动态绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;面向对象分析&#34;&gt;面向对象分析&lt;/h1&gt;
&lt;p&gt;同其他分析方法一样，面向对象分析（Object-Oriented Analysis，OOA）的目的是为了获得对应用问题的理解。&lt;/p&gt;
&lt;p&gt;面向对象分析包含5个活动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;认定对象；&lt;/li&gt;
&lt;li&gt;组织对象；&lt;/li&gt;
&lt;li&gt;描述对象间的相互作用；&lt;/li&gt;
&lt;li&gt;确定对象的操作&lt;/li&gt;
&lt;li&gt;定义对象的内部信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;认定对象&#34;&gt;认定对象&lt;/h2&gt;
&lt;p&gt;在应用领域中，按自然存在的实体确立对象。&lt;/p&gt;
&lt;p&gt;在定义域中，首先将自然存在的“名词”作为一个对象，这通常是研究问题、定义域实体的良好开始。&lt;/p&gt;
&lt;h2 id=&#34;组织对象&#34;&gt;组织对象&lt;/h2&gt;
&lt;p&gt;分析对象间的关系，将相关对象抽象成类，其目的是为了简化关联对象，利用类的继承性建立具有继承性层次的类结构。&lt;/p&gt;
&lt;p&gt;抽象类时可从以下方面考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象间的操作；&lt;/li&gt;
&lt;li&gt;一个对象是另一个对象的一部分，如房子是由门和窗构成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;面向对象设计&#34;&gt;面向对象设计&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;程序设计范型&lt;/strong&gt;（Programming Paradigm）是人们在&lt;u&gt;程序设计时所采用的基本方式模型&lt;/u&gt;，决定了程序设计时采用的&lt;u&gt;思维方式&lt;/u&gt;、&lt;u&gt;使用的工具&lt;/u&gt;，同时又&lt;u&gt;有一定的应用范畴&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;程序设计范型的发展经历了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程程序设计；&lt;/li&gt;
&lt;li&gt;模块化程序设计；&lt;/li&gt;
&lt;li&gt;函数程序设计；&lt;/li&gt;
&lt;li&gt;逻辑程序设计；&lt;/li&gt;
&lt;li&gt;面向对象程序设计范型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;面向对象程序设计&lt;/strong&gt;（Object-Oriented Programming，&lt;strong&gt;OOP&lt;/strong&gt;）的&lt;u&gt;实质是选用一种&lt;strong&gt;面向对象程序设计语言&lt;/strong&gt;（Object-Oriented Programming Language，&lt;strong&gt;OOPL&lt;/strong&gt;）&lt;/u&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用对象、类及其相关概念所进行的程序设计；&lt;/li&gt;
&lt;li&gt;关键在于加入了类和继承性，从而进一步提高了抽象程度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特定的OOP概念一般是通过OOPL中特定的语言机制来体现的。&lt;/p&gt;
&lt;p&gt;OOP现在已经扩展到系统分析和软件设计的范畴，出现了面向对象分析和面向对象设计的概念。&lt;/p&gt;
&lt;h2 id=&#34;设计原则&#34;&gt;设计原则&lt;/h2&gt;
&lt;p&gt;面向对象方法中的五大原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;责任原则&lt;/strong&gt;（Single Responsibility Principle，SRP）：当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开放封闭原则&lt;/strong&gt;（Open &amp;amp; Close Principle，OCP）：软件实体（类、模块、函数等）应
该可以扩展的，即&lt;strong&gt;开放的&lt;/strong&gt;；但是不可修改的，即&lt;strong&gt;封闭的&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;里氏替换原则&lt;/strong&gt;（Liskov Substitution Principle，LSP）：子类型必须能够替换掉他们的基
类型。&lt;/p&gt;
&lt;p&gt;即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。&lt;/p&gt;
&lt;p&gt;当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;依赖倒置原则&lt;/strong&gt;（Dependence Inversion Principle，DP）：抽象不应该依赖于细节，细
节应该依赖于抽象。即，&lt;u&gt;高层模块不应该依赖于低层模块，二者都应该依赖于抽象&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;接口分离原则&lt;/strong&gt;（Interface Segregation Principle，ISP）：不应该强迫客户依赖于它们不
用的方法。接口属于客户，不属于它所在的类层次结构。&lt;/p&gt;
&lt;p&gt;即：&lt;u&gt;依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;这样做的好处就在于可以最大限度地应对可能的变化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Robert C. Martin提出的面向对象设计原则还包括以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重用发布等价原则（Release Reuse Equivalency Principle，REP）：重用的粒度就是发布的粒度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共同封闭原则&lt;/strong&gt;（Common Closure Principle，CCP）：包中的所有类对于同一类性质的变化应该是共同到闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共同重用原则&lt;/strong&gt;（Common Reuse Principle，CRP）：一个包中的所有类应该是共同重用
的。如果重用了包中的一个类那么就要重用包中的所有类。&lt;/li&gt;
&lt;li&gt;无环依赖原则（Acyclic Dependencies Principle，ADP）：在包的依赖关系图中不允许存
在环，即包之间的结构必须是一个直接的五环图形。&lt;/li&gt;
&lt;li&gt;稳定依赖原则（Stable Dependencies Principle,SDP）：朝着稳定的方向进行依赖。&lt;/li&gt;
&lt;li&gt;稳定抽象原则（Stable Abstractions Principle，SAP）：包的抽象程度应该和其稳定程
度一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;uml&#34;&gt;UML&lt;/h1&gt;
&lt;p&gt;面向对象分析强调的是对一个系统中对象的特征和行为的定义。目前，国际上已经出现了多种面向对象的方法，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Peter Coad和Edward Yourdon的OOA和OOD方法（又称Coad/Yourdon方法或Coad方法）；&lt;/li&gt;
&lt;li&gt;Booch的OOD方法（又称Booch方法）；&lt;/li&gt;
&lt;li&gt;OMT（Object Modeling Technique，面向对象建模技术）方法；&lt;/li&gt;
&lt;li&gt;UML（Unified Modeling Language，统一建模语言）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UML是面向对象软件的标准化建模语言。由于其简单、统一，又能够表达软件设计中的动态和静态信息，目前己经成为可视化建模语言事实上的工业标准。&lt;/p&gt;
&lt;h2 id=&#34;事物&#34;&gt;事物&lt;/h2&gt;
&lt;p&gt;UML中有4种事物：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结构事物&lt;/strong&gt;（Structural Thing）：是UML模型中的名词。它们&lt;u&gt;通常是模型的&lt;strong&gt;静态部分&lt;/strong&gt;，描述概念或物理元素&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;结构事物包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类（Class）；&lt;/li&gt;
&lt;li&gt;接口（Interface）；&lt;/li&gt;
&lt;li&gt;协作（Collaboration）；&lt;/li&gt;
&lt;li&gt;用例（Use Case）；&lt;/li&gt;
&lt;li&gt;主动类（Active Class）；&lt;/li&gt;
&lt;li&gt;构件（Component）；&lt;/li&gt;
&lt;li&gt;制品（Artifact）；&lt;/li&gt;
&lt;li&gt;结点（Node）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055522161.png&#34;
	width=&#34;708&#34;
	height=&#34;294&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055522161_hu872254ba18803fa50bd84092332d0d27_39442_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055522161_hu872254ba18803fa50bd84092332d0d27_39442_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;结构事物多图形表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;240&#34;
		data-flex-basis=&#34;577px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行为事物&lt;/strong&gt;（Behavior Thing）：&lt;u&gt;是UML模型的&lt;strong&gt;动态部分&lt;/strong&gt;&lt;/u&gt;。它们是模型中的动词，描述了跨越时间和空间的行为。&lt;/p&gt;
&lt;p&gt;行为事物包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交互（Interaction）；&lt;/li&gt;
&lt;li&gt;状态机（State Machine）；&lt;/li&gt;
&lt;li&gt;活动（Activity）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055712246.png&#34;
	width=&#34;621&#34;
	height=&#34;133&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055712246_hu926c842303194b37bd3d84d241da7490_18166_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055712246_hu926c842303194b37bd3d84d241da7490_18166_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;行为事物的图形表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;466&#34;
		data-flex-basis=&#34;1120px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分组事物&lt;/strong&gt;（Grouping Thing）：分组事物是UML模型的&lt;strong&gt;组织部分&lt;/strong&gt;，是一些由模型分解成的“盒子”。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;在所有的分组事物中，最主要的分组事物是包（Package）&lt;/u&gt;。包是把元素组织成组的机制，这种机制具有多种用途。结构事物、行为事物甚至其他分组事物都可以放进包内。&lt;/p&gt;
&lt;p&gt;包与构件（仅在运行时存在）不同，它纯粹是概念上的（即它仅在开发时存在）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055987585.png&#34;
	width=&#34;224&#34;
	height=&#34;157&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055987585_hude1f550d1c91183afc794d1e3aa09c46_4122_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682055987585_hude1f550d1c91183afc794d1e3aa09c46_4122_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;包的图形化表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;342px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注释事物&lt;/strong&gt;（Annotational Thing）：注释事物是UML模型的&lt;strong&gt;解释部分&lt;/strong&gt;。这些注释事物用来描述、说明和标注模型的任何元素。&lt;/p&gt;
&lt;p&gt;注解（Note）是一种主要的注释事物。注解是一个依附于一个元素或者一组元素之上，对它进行约束或解释的简单符号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关系&#34;&gt;关系&lt;/h2&gt;
&lt;p&gt;UML中有4种关系，这4种关系是UML模型中可以包含的基本关系事物：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依赖（Dependency）：是&lt;u&gt;两个事物间的语义关系，其中一个事物（&lt;strong&gt;独立事物&lt;/strong&gt;）发
生变化会影响另一个事物（&lt;strong&gt;依赖事物&lt;/strong&gt;）的语义&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;在图形上，把一个依赖画成一条可能有方向的虚线，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089.png&#34;
	width=&#34;200&#34;
	height=&#34;48&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057108089_hufef657bed6e876bd373e5f4bb9f34af6_1059_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;依赖的图形表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;416&#34;
		data-flex-basis=&#34;1000px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;依赖的变体有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精化；&lt;/li&gt;
&lt;li&gt;跟踪；&lt;/li&gt;
&lt;li&gt;包含；&lt;/li&gt;
&lt;li&gt;延伸。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关联（Association）：是一种&lt;u&gt;结构关系&lt;/u&gt;，它描述了一组链，&lt;u&gt;链是对象之间的连接&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聚集&lt;/strong&gt;（Aggregation）是一种&lt;u&gt;特殊类型的关联&lt;/u&gt;，它&lt;u&gt;描述了整体和部分间的结构关系&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;关联和聚集的图形化表示如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153.png&#34;
	width=&#34;408&#34;
	height=&#34;101&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682057458153_hu37f2bf65b423a501f386d9709f6e6bc4_8075_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;关联和聚集的图形化表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;403&#34;
		data-flex-basis=&#34;969px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在关联上可以标注重复度（Multiplicity）和角色（Role）。&lt;/p&gt;
&lt;p&gt;实心菱形表示组合，空心菱形表示聚合；菱形右边表示整体，左边表示部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛化（Generalization）：是一种特殊/一般关系，&lt;u&gt;特殊元素（子元素）的对象可替代一般元素（父元素）的对象&lt;/u&gt;。用这种方法，&lt;u&gt;子元素共享了父元素的结构和行为&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;在图形上，把一个泛化关系画成一条带有空心箭头的实线，它指向父元素：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410.png&#34;
	width=&#34;162&#34;
	height=&#34;53&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682057764410_huaf9267ff556daac18150e46c6cbbde24_1023_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;泛化的图形表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;305&#34;
		data-flex-basis=&#34;733px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现（Realization）：是&lt;u&gt;类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;在两种情况下会使用实现关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在接口和实现它们的类或构件之间：&lt;/li&gt;
&lt;li&gt;在用例和实现它们的协作之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在图形上，把一个实现关系画成一条带有空心箭头的虚线，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682058026631.png&#34;
	width=&#34;167&#34;
	height=&#34;61&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682058026631_hu09469114d42fa29e39948f21a9a04633_1340_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682058026631_hu09469114d42fa29e39948f21a9a04633_1340_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;实现的图形化表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;273&#34;
		data-flex-basis=&#34;657px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;uml中的图&#34;&gt;UML中的图&lt;/h1&gt;
&lt;p&gt;UML2.0提供了13种图，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类图&lt;/li&gt;
&lt;li&gt;对象图&lt;/li&gt;
&lt;li&gt;用例图&lt;/li&gt;
&lt;li&gt;状态图&lt;/li&gt;
&lt;li&gt;活动图&lt;/li&gt;
&lt;li&gt;构件图&lt;/li&gt;
&lt;li&gt;组合结构图&lt;/li&gt;
&lt;li&gt;部署图&lt;/li&gt;
&lt;li&gt;包图&lt;/li&gt;
&lt;li&gt;交互图：
&lt;ul&gt;
&lt;li&gt;序列图&lt;/li&gt;
&lt;li&gt;通信图&lt;/li&gt;
&lt;li&gt;交互概览图&lt;/li&gt;
&lt;li&gt;计时图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UML中关联的多重度：&lt;/p&gt;
&lt;p&gt;进行面向对象设计时，类图中可以展现类之间的关联关系，还可以在类图中图示&lt;u&gt;关联中的数量关系&lt;/u&gt;，即多重度。表示数量关系时，&lt;u&gt;用多重度说明数量或数量范围&lt;/u&gt;，&lt;u&gt;表示有多少个实例（对象）能被连接起来&lt;/u&gt;，即&lt;u&gt;一个类的实例能够与另一个类的多少个实例相关联&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&#34;类图&#34;&gt;类图&lt;/h2&gt;
&lt;p&gt;&lt;u&gt;类图&lt;/u&gt;（Class Diagram）&lt;u&gt;展现了一组对象、接口、协作和它们之间的关系&lt;/u&gt;。在面向对象系统的建模中所建立的&lt;u&gt;最常见的图就是类图&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;类图中通常包括下述内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类；&lt;/li&gt;
&lt;li&gt;接口；&lt;/li&gt;
&lt;li&gt;协作；&lt;/li&gt;
&lt;li&gt;依赖、泛化和关联关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921.png&#34;
	width=&#34;619&#34;
	height=&#34;467&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061210921_hub4b131b7f109e06635ca875a61e12a0b_45450_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;类图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;318px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;类图中也可以包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注解和约束；&lt;/li&gt;
&lt;li&gt;包或子系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类图用于对系统的静态设计视图建模，通常以下述3种方式之一使用类图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对系统的词汇建模：&lt;/p&gt;
&lt;p&gt;涉及做出这样的决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些抽象是考虑中的系统的一部分，&lt;/li&gt;
&lt;li&gt;哪些抽象处于系统边界之外。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用类图详细描述这些抽象和它们的职责。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对简单的协作建模：协作是一些共同工作的类、接口和其他元素的群体，该群体提供的一些合作行为强于所有这些元素的行为之和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对逻辑数据库模式建模：将模式看作为数据库的概念设计的蓝图。在很多领域中，要在关系数据库或面向对象数据库中存储永久信息，可以用类图对这些数据库的模式建模。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对象图&#34;&gt;对象图&lt;/h2&gt;
&lt;p&gt;对象图（Object Diagram）展现了某一时刻一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的静态快照。&lt;/p&gt;
&lt;p&gt;对象图一般包括对象和链，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263.png&#34;
	width=&#34;713&#34;
	height=&#34;312&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682061786263_hua46f494b700cf1a0ac17d6d1520c7d36_50579_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;对象图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;228&#34;
		data-flex-basis=&#34;548px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;和类图一样，对象图给出系统的静态设计视图或静态进程视图，但它们是从真实的或原型实例的角度建立的。&lt;/p&gt;
&lt;h2 id=&#34;用例图&#34;&gt;用例图&lt;/h2&gt;
&lt;p&gt;用例图（Use Case Diagram）展现了一组用例、参与者（Actor）以及它们之间的关系。&lt;/p&gt;
&lt;p&gt;用例图通常包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用例：是从&lt;strong&gt;用户角度&lt;/strong&gt;描述&lt;strong&gt;系统的行为&lt;/strong&gt;，它将&lt;strong&gt;系统的一个功能&lt;/strong&gt;描述成一系列的事件，这些事件最终对操作者产生有价值的观测结果。&lt;/p&gt;
&lt;p&gt;用例是一个类，它代表&lt;strong&gt;一类功能&lt;/strong&gt;而不是使用该功能的某一具体实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参与者：是与系统交互的&lt;strong&gt;外部实体&lt;/strong&gt;，可能是&lt;strong&gt;使用者&lt;/strong&gt;，也可能是与系统交互的&lt;strong&gt;外部系统&lt;/strong&gt;、&lt;strong&gt;基础设备&lt;/strong&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例之间的扩展关系（&lt;code&gt;&amp;lt;&amp;lt;extend&amp;gt;&amp;gt;&lt;/code&gt;）和包含关系（&lt;code&gt;&amp;lt;&amp;lt;include&amp;gt;&amp;gt;&lt;/code&gt;），&lt;/li&gt;
&lt;li&gt;参与者和用例之间的关联关系，&lt;/li&gt;
&lt;li&gt;用例与用例以及参与者与参与者之间的泛化关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630.png&#34;
	width=&#34;756&#34;
	height=&#34;382&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682062071630_hue8ceb70c383d5b84d539f99bc1fa6287_66549_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;用例图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;197&#34;
		data-flex-basis=&#34;474px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;交互图&#34;&gt;交互图&lt;/h2&gt;
&lt;p&gt;交互图用于对系统的动态方面进行建模。一张交互图表现的是一个交互，由一组对象和它们之间的关系组成，包含它们之间可能传递的消息。&lt;/p&gt;
&lt;p&gt;每种交互图针对不同的目的，能适用于不同的情况。交互图表现为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;序列图&lt;/strong&gt;：强调&lt;strong&gt;消息时间顺序&lt;/strong&gt;的交互图；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信图&lt;/strong&gt;：强调&lt;strong&gt;接收和发送消息的对象的结构组织&lt;/strong&gt;的交互图；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交互概览图&lt;/strong&gt;：强调&lt;strong&gt;控制流&lt;/strong&gt;的交互图；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计时图&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在多数情况下，交互图包括对以下内容的具体的或原型化的实例以及它们之间传递的消息进行建模：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类；&lt;/li&gt;
&lt;li&gt;接口；&lt;/li&gt;
&lt;li&gt;构件；&lt;/li&gt;
&lt;li&gt;结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些都位于一个表达行为的脚本的语境中。&lt;/p&gt;
&lt;p&gt;交互图一般包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象；&lt;/li&gt;
&lt;li&gt;链：&lt;/li&gt;
&lt;li&gt;消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;序列图&#34;&gt;序列图&lt;/h3&gt;
&lt;p&gt;序列图（Sequence Diagram，又称顺序图）是场景（Scenario）的图形化表示，&lt;u&gt;描述了以时间顺序组织的对象之间的交互活动&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;形成序列图时，首先把参加交互的对象放在图的上方，沿水平方向排列。通常把发起交互的对象放在左边，下级对象依次放在右边。然后，把这些对象发送和接收的消息沿垂直方向按时间顺序从上到下放置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751.png&#34;
	width=&#34;691&#34;
	height=&#34;471&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682064874751_hu9f8f021651236d17904ea27f843ab916_52872_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;序列图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;146&#34;
		data-flex-basis=&#34;352px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;序列图有两个不同于通信图的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列图有对象生命线；&lt;/li&gt;
&lt;li&gt;序列图有控制焦点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通信图&#34;&gt;通信图&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;通信图&lt;/u&gt;（Communication Diagram，又称协作图）&lt;u&gt;强调收发消息的对象的结构组织&lt;/u&gt;。通信图强调参加交互的对象的组织。&lt;/p&gt;
&lt;p&gt;产生一张通信图，首先要将参加交互的对象作为图的顶点，然后把连接这些对象的链表示为图的弧，最后用对象发送和接收的消息来修饰这些链。这就提供了在协作对象的结构组织的语境中观察控制流的一个清晰的可视化轨迹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645.png&#34;
	width=&#34;719&#34;
	height=&#34;314&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682065157645_hu479fbd97a58f555006937d3c577e3006_30791_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;通信图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;228&#34;
		data-flex-basis=&#34;549px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通信图有两个不同于序列图的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通信图有路径；&lt;/li&gt;
&lt;li&gt;通信图有序号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;状态图&#34;&gt;状态图&lt;/h2&gt;
&lt;p&gt;状态图（State Diagram）展现了一个状态机。状态图关注系统的动态视图，对于接口、类和协作的行为建模尤为重要，&lt;u&gt;强调对象行为的事件顺序&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;状态图由以下组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;：指对象的生命周期中某个条件或者状态，是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。&lt;/p&gt;
&lt;p&gt;子状态：嵌套在另外一个状态中的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单状态。&lt;/li&gt;
&lt;li&gt;组合状态：含有子状态的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;转换&lt;/strong&gt;（事件和动作）：是两个状态之间的一种关系，表示对象将在源状态中执行一定的动作，并在某个特定事件发生而且某个特定的警界（监护）条件满足时进入目标状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转换动作：是一个可执行的原子操作，是不可中断的，其执行时间是可忽略不计的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事件&lt;/strong&gt;：是在某个特定时刻发生的事情，它是对引起系统做动作或（和）从一个状态转换到另个状态的外界事件的抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;活动&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326.png&#34;
	width=&#34;831&#34;
	height=&#34;431&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682066287326_hu94ea09022f5bcd63fe669c1e18a4beb2_47522_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;状态图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;462px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以用状态图对系统的动态方面建模。这些动态方面可以包括出现在系统体系结构的任何视图中的任何一种对象的按事件排序的行为，这些对象包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类（各主动类）；&lt;/li&gt;
&lt;li&gt;接口；&lt;/li&gt;
&lt;li&gt;构件；&lt;/li&gt;
&lt;li&gt;结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当对系统、类或用例的动态方面建模时，通常是对反应型对象建模。&lt;/p&gt;
&lt;h2 id=&#34;活动图&#34;&gt;活动图&lt;/h2&gt;
&lt;p&gt;活动图（Activity Diagram）是一种特殊的状态图，它&lt;u&gt;展现了在系统内从一个活动到另一个活动的流程&lt;/u&gt;。活动图专注于系统的动态视图，它对于系统的功能建模特别重要，并&lt;u&gt;强调对象间的控制流程&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114.png&#34;
	width=&#34;654&#34;
	height=&#34;744&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1682067363114_hua57a5009862c06a77af06a14b99cf391_95291_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;活动图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;87&#34;
		data-flex-basis=&#34;210px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;活动图一般包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;活动状态；&lt;/li&gt;
&lt;li&gt;动作状态；&lt;/li&gt;
&lt;li&gt;转换；&lt;/li&gt;
&lt;li&gt;对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;活动图可以表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支；&lt;/li&gt;
&lt;li&gt;合并；&lt;/li&gt;
&lt;li&gt;分岔；&lt;/li&gt;
&lt;li&gt;汇合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当对一个系统的动态方面建模时，通常有两种使用活动图的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对工作流建模；&lt;/li&gt;
&lt;li&gt;对操作建模。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;构建图&#34;&gt;构建图&lt;/h2&gt;
&lt;p&gt;构件图（Component Diagram，又称组件图）展现了&lt;u&gt;一组构件之间的组织和依赖&lt;/u&gt;。构件图专注于系统的静态实现视图。它&lt;u&gt;与类图相关，通常把构件映射为一个或多个类、接口或协作&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459.png&#34;
	width=&#34;638&#34;
	height=&#34;332&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459_hub55b12b010797b943f2ecf558036ffb6_42642_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682068370459_hub55b12b010797b943f2ecf558036ffb6_42642_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;构建图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;461px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;部署图&#34;&gt;部署图&lt;/h2&gt;
&lt;p&gt;部署图（Deployment Diagram）是用来对面向对象系统的物理方面建模的方法，&lt;u&gt;展现了运行时处理结点以及其中构件（制品）的配置&lt;/u&gt;。部署图对系统的静态部署视图进行建模，它与构件图相关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388.png&#34;
	width=&#34;491&#34;
	height=&#34;327&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682073176388_hu28a5a922204a8226fa8f8a21e50bdfbf_36398_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;部署图示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;360px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;artifact&amp;gt;&amp;gt;&lt;/code&gt;表示制品。&lt;/p&gt;
&lt;p&gt;部署图展现了系统的软件和硬件之间的关系在实施阶段使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态建模：
&lt;ul&gt;
&lt;li&gt;类图&lt;/li&gt;
&lt;li&gt;对象图&lt;/li&gt;
&lt;li&gt;用例图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态建模：
&lt;ul&gt;
&lt;li&gt;序列图（顺序图，时序图）&lt;/li&gt;
&lt;li&gt;通信图（协作图）&lt;/li&gt;
&lt;li&gt;状态图&lt;/li&gt;
&lt;li&gt;活动图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物理建模：
&lt;ul&gt;
&lt;li&gt;构件图（组件图)&lt;/li&gt;
&lt;li&gt;部署图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交互图：
&lt;ul&gt;
&lt;li&gt;序列图（顺序图，时序图）&lt;/li&gt;
&lt;li&gt;通信图（协作图）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;设计模式&#34;&gt;设计模式&lt;/h1&gt;
&lt;p&gt;设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便地复用成功的设计和体系结构。&lt;/p&gt;
&lt;p&gt;设计模式分类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;br&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;创建型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;结构型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;行为型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;类&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Factory Method（工厂方法模式）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Adapter（适配器模式，类）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Interpreter（解释器模式）&lt;br&gt;Template Method（模板方法模式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对象&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Abstract Factory（抽象工厂模式）&lt;br&gt;Builder（生成器模式）&lt;br&gt;Prototype（原型模式）&lt;br&gt;Singleton（单例模式）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Adapter（适配器模式，对象）&lt;br&gt;Bridge（桥接模式）&lt;br&gt;Composite（组合模式）&lt;br&gt;Decorator（装饰器模式）&lt;br&gt;Facade（外观模式）&lt;br&gt;Flyweight（享元模式）&lt;br&gt;Proxy（代理模式）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Chain of Responsibility（责任链模式）&lt;br&gt;Command（命令模式）&lt;br&gt;Iterator（迭代器模式）&lt;br&gt;Mediator（中介者模式）&lt;br&gt;Memento（备忘录模式）&lt;br&gt;Observer（观察者模式）&lt;br&gt;State（状态模式）&lt;br&gt;Strategy（策略模式）&lt;br&gt;Visitor（访问者模式）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;创新型设计模式&#34;&gt;创新型设计模式&lt;/h2&gt;
&lt;p&gt;创建型模式&lt;u&gt;抽象了实例化过程&lt;/u&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类创建型模式：使用继承改变被实例化的类；&lt;/li&gt;
&lt;li&gt;对象创建型模式：将实例化委托给另一个对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h3&gt;
&lt;p&gt;工厂模式（Factory Method）定义一个用于&lt;u&gt;创建对象的接口&lt;/u&gt;，让&lt;u&gt;子类决定实例化哪一个类&lt;/u&gt;。工厂模式使一个类的实例化延迟到其子类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即接口不创建具体的对象，交由子类来决定实例化哪个类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工厂模式结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682232330534.png&#34;
	width=&#34;725&#34;
	height=&#34;268&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682232330534_huc77d54806485b83d5b01369d9c023787_25091_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682232330534_huc77d54806485b83d5b01369d9c023787_25091_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;工厂模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;270&#34;
		data-flex-basis=&#34;649px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Product&lt;/code&gt;：定义工厂方法所创建的对象的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt;：实现&lt;code&gt;Product&lt;/code&gt;接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Creator&lt;/code&gt;：声明工厂方法，该方法返回一个&lt;code&gt;Product&lt;/code&gt;类型的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Creator&lt;/code&gt;也可以定义一个工厂方法的默认实现，它返回一个默认的&lt;code&gt;ConcreteProduct&lt;/code&gt;对象，可以调用工厂方法以创建一个&lt;code&gt;Product&lt;/code&gt;对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteCreator&lt;/code&gt;：重定义工厂方法以返回一个&lt;code&gt;ConcreteProduct&lt;/code&gt;实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Factory Method模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个类&lt;u&gt;不知道它所必须创建的对象的类&lt;/u&gt;的时候。&lt;/li&gt;
&lt;li&gt;当一个类&lt;u&gt;希望由它的子类来指定它所创建的对象&lt;/u&gt;的时候。&lt;/li&gt;
&lt;li&gt;当类&lt;u&gt;将创建对象的职责委托给多个帮助子类中的某一个&lt;/u&gt;，并且你希望将哪一个&lt;u&gt;帮助子类是代理者&lt;/u&gt;这一信息局部化的时候。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关键词：&lt;u&gt;子类指定创建对象&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;抽象工厂模式&#34;&gt;抽象工厂模式&lt;/h3&gt;
&lt;p&gt;抽象工厂（Abstract Factory）提供一个&lt;u&gt;创建一系列相关或相互依赖对象的接口&lt;/u&gt;，而&lt;u&gt;无须指定它们具体的类&lt;/u&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即提供对象的接口，用户无需考虑实现类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象工厂模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682230457950.png&#34;
	width=&#34;704&#34;
	height=&#34;330&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682230457950_hu9c89e6a2ba3c7411a12e6de71f8df7cf_36899_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682230457950_hu9c89e6a2ba3c7411a12e6de71f8df7cf_36899_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;抽象工厂模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;213&#34;
		data-flex-basis=&#34;512px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;：声明一个创建抽象产品对象的操作接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteFactory&lt;/code&gt;：实现创建具体产品对象的操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstractProduct&lt;/code&gt;：为一类产品对象声明一个接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt;：定义一个将被相应的具体工厂创建的产品对象，实现&lt;code&gt;AbstractProduct&lt;/code&gt;接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;：仅使用由&lt;code&gt;AbstractFactory&lt;/code&gt;和&lt;code&gt;AbstractProduct&lt;/code&gt;类声明的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Abstract Factory模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个系统要&lt;strong&gt;独立&lt;/strong&gt;于它的&lt;strong&gt;产品的创建&lt;/strong&gt;、&lt;strong&gt;组合&lt;/strong&gt;和&lt;strong&gt;表示&lt;/strong&gt;时。&lt;/li&gt;
&lt;li&gt;一个系统要由&lt;u&gt;多个产品系列中的一个来配置&lt;/u&gt;时。&lt;/li&gt;
&lt;li&gt;当要强调&lt;u&gt;一系列相关的产品&lt;/u&gt;对象的设计以便进行&lt;u&gt;联合使用&lt;/u&gt;时。&lt;/li&gt;
&lt;li&gt;当提供一个&lt;u&gt;产品类库&lt;/u&gt;，只想&lt;u&gt;显示它们的接口而不是实现&lt;/u&gt;时。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当一个系统应该独立于它的产品创建、构成和表示时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当要强调一系列相关的产品对象的设计以便进行联合使用时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个系统要由多个产品系列中的一个来配置时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为图形用户界面（GUI）组件定义不同平台的并行类层次结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;不同平台的GUI组件，使用同样的接口，根据平台使用不同的实现。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键词：&lt;u&gt;系列&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;生成器模式&#34;&gt;生成器模式&lt;/h3&gt;
&lt;p&gt;生成器（Builder，建造者）模式将一个&lt;u&gt;复杂对象的&lt;strong&gt;构建&lt;/strong&gt;与它的&lt;strong&gt;表示&lt;/strong&gt;分离&lt;/u&gt;，使得&lt;u&gt;同样的构建过程可以创建不同的表示&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;生成器模式结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682231345251.png&#34;
	width=&#34;729&#34;
	height=&#34;261&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682231345251_hu690497866a39e8a8fdd5b4c1f3b39af4_22986_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682231345251_hu690497866a39e8a8fdd5b4c1f3b39af4_22986_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;生成器模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;279&#34;
		data-flex-basis=&#34;670px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Product&lt;/code&gt;：表示被构造的复杂对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Builder&lt;/code&gt;：为创建一个&lt;code&gt;Product&lt;/code&gt;对象的各个部件指定抽象接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteBuilder&lt;/code&gt;：实现&lt;code&gt;Builder&lt;/code&gt;的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcreteBuilder&lt;/code&gt;创建&lt;code&gt;Product&lt;/code&gt;对象产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Director&lt;/code&gt;：构造一个使用&lt;code&gt;Builder&lt;/code&gt;接口的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Builder模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当&lt;u&gt;创建复杂对象的算法&lt;/u&gt;应该&lt;u&gt;独立于该对象的组成部分以及它们的装配方式时&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;当&lt;u&gt;构造过程必须允许被构造的对象有不同的表示时&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时。&lt;/li&gt;
&lt;li&gt;当构造过程必须允许被构造的对象有不同的表示时。&lt;/li&gt;
&lt;li&gt;将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。&lt;/li&gt;
&lt;li&gt;适用于抽象复杂对象的构建步骤和基于构建过程的具体实现构建复杂对象的不同表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键词：&lt;u&gt;复杂对象、不同表示&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;原型模式&#34;&gt;原型模式&lt;/h3&gt;
&lt;p&gt;原型（Prototype）模式用&lt;u&gt;原型实例指定创建对象的种类&lt;/u&gt;，并且&lt;u&gt;通过复制这些原型创建新的对象&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;原型模式结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233376386.png&#34;
	width=&#34;638&#34;
	height=&#34;298&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233376386_hu1813704620029f1adb77611772cb6330_23912_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233376386_hu1813704620029f1adb77611772cb6330_23912_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;原型模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;214&#34;
		data-flex-basis=&#34;513px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Prototype&lt;/code&gt;：声明一个复制自身的接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcretePrototype&lt;/code&gt;：实现一个复制自身的操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;：让一个原型复制自身从而创建一个新的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Prototype模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个系统应该独立于它的产品创建、构成和表示时。&lt;/li&gt;
&lt;li&gt;当要实例化的类是在运行时刻指定时，例如，通过动态装载。&lt;/li&gt;
&lt;li&gt;为了避免创建一个与产品类层次平行的工厂类层次时。&lt;/li&gt;
&lt;li&gt;当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单例模式&#34;&gt;单例模式&lt;/h3&gt;
&lt;p&gt;单例（Singleton）模式保证&lt;u&gt;一个类仅有一个实例&lt;/u&gt;，并&lt;u&gt;提供一个访问它的全局访问点&lt;/u&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就好像Spring中的Bean，每个Bean有且仅有一个实例，通过&lt;code&gt;@Autowired&lt;/code&gt;自动装配（来访问）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例模式结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233866165.png&#34;
	width=&#34;464&#34;
	height=&#34;169&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233866165_huef95807dda454cba71e939a884d0b18a_14126_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682233866165_huef95807dda454cba71e939a884d0b18a_14126_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;单例模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;274&#34;
		data-flex-basis=&#34;658px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Singleton&lt;/code&gt;：指定一个&lt;code&gt;Instance&lt;/code&gt;操作，允许客户访问它的唯一实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Instance&lt;/code&gt;：是一个类操作；可能负责创建它自己的唯一实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Singleton模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当类&lt;u&gt;只能有一个实例&lt;/u&gt;而且客户可以从一个众所周知的访问点访问它时。&lt;/li&gt;
&lt;li&gt;当这个&lt;u&gt;唯一实例&lt;/u&gt;应该是通过子类化可扩展的，并且&lt;u&gt;客户无须更改代码就能使用一个扩展的实例&lt;/u&gt;时。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关键词：&lt;u&gt;唯一实例、一个实例&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;结构型设计模式&#34;&gt;结构型设计模式&lt;/h2&gt;
&lt;p&gt;结构型设计模式涉及&lt;u&gt;如何组合类和对象以获得更大的结构&lt;/u&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构型类模式：&lt;u&gt;采用继承机制来组合接口或实现&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;一个简单的例子是&lt;u&gt;采用多重继承方法将两个以上的类组合成一个类&lt;/u&gt;，结果这个类包含了所有父类的性质。&lt;/p&gt;
&lt;p&gt;这一模式尤其有助于多个独立开发的类库协同工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构型对象模式：描述了&lt;u&gt;如何对一些对象进行组合，从而实现新功能的一些方法&lt;/u&gt;（不是对接口和实现进行组合）。&lt;/p&gt;
&lt;p&gt;因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h3&gt;
&lt;p&gt;适配器（Adapter）模式&lt;u&gt;将一个类的接口转换成客户希望的另外一个接口&lt;/u&gt;。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;
&lt;p&gt;类适配器使用多重继承对一个接口与另一个接口进行匹配：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299306295.png&#34;
	width=&#34;885&#34;
	height=&#34;674&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299306295_hu274e97e19deac790c686089605963483_65147_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299306295_hu274e97e19deac790c686089605963483_65147_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;适配器模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;131&#34;
		data-flex-basis=&#34;315px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Adapter模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想使用一个已经存在的类，而它的&lt;u&gt;接口不符合要求&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;想创建一个可以服用的类，该类可以&lt;u&gt;与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;（仅适用于对象Adapter）想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。&lt;u&gt;对象适配器可以适配它的父类接口。&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个对象加以包装以给客户提供其希望的另外一个接口。&lt;/li&gt;
&lt;li&gt;想使用一个已经存在的类，而其接口不符合要求。&lt;/li&gt;
&lt;li&gt;使所有接口不兼容类可以一起工作。&lt;/li&gt;
&lt;li&gt;将一个类的接口转换成客户希望的另一个接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键词：&lt;u&gt;另一个接口、接口不符合要求、接口兼容、接口转换&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;桥接模式&#34;&gt;桥接模式&lt;/h3&gt;
&lt;p&gt;桥接（Bridge）模式将&lt;strong&gt;抽象&lt;/strong&gt;部分与其&lt;strong&gt;实现&lt;/strong&gt;部分&lt;strong&gt;分离&lt;/strong&gt;，使它们都可以&lt;strong&gt;独立地变化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;桥接模式结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299992836.png&#34;
	width=&#34;932&#34;
	height=&#34;387&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299992836_hudb1c01aa99ecdd687550b15293eda98a_45309_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682299992836_hudb1c01aa99ecdd687550b15293eda98a_45309_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;桥接模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;240&#34;
		data-flex-basis=&#34;577px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Abstraction&lt;/code&gt;：定义&lt;u&gt;抽象类的接口&lt;/u&gt;，维护一个指向&lt;code&gt;Implementor&lt;/code&gt;类型对象的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RefinedAbstraction&lt;/code&gt;：扩充由&lt;code&gt;Abstraction&lt;/code&gt;定义的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Implementor&lt;/code&gt;：定义&lt;u&gt;实现类的接口&lt;/u&gt;，该接口不一定要与&lt;code&gt;Abstraction&lt;/code&gt;的接口完全一致；事实上这两个接口可以完全不同。&lt;/p&gt;
&lt;p&gt;一般来说，&lt;code&gt;Implementor&lt;/code&gt;接口仅提供基本操作，而&lt;code&gt;Abstraction&lt;/code&gt;：定义了基于这些基本操作的较高层次的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteImplementor&lt;/code&gt;：实现&lt;code&gt;Implementor&lt;/code&gt;接口并定义它的具体实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bridge模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;u&gt;不希望在抽象和它的实现部分之间有一个固定的绑定关系。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的&lt;u&gt;抽象&lt;/u&gt;以及它的&lt;u&gt;实现都&lt;/u&gt;应该&lt;u&gt;可以通过生成子类的方法加以扩充&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;这是Bridge模式使得开发者&lt;u&gt;可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对一个&lt;u&gt;抽象的实现部分的修改&lt;/u&gt;应对客户不产生影响，即&lt;u&gt;客户代码不必重新编译&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（C++）想对客户完全&lt;u&gt;隐藏抽象的实现部分&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有许多类要生成的类层次结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想在&lt;u&gt;多个对象间共享实现&lt;/u&gt;（可能使用引用计数），但同时要求&lt;u&gt;客户并不知道这一点&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类的抽象和其实现之间不希望有一个固定的绑定关系。&lt;/li&gt;
&lt;li&gt;不希望在抽象和它的实现部分之间有一个固定的绑定关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键词：&lt;u&gt;固定的绑定关系&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;组合模式&#34;&gt;组合模式&lt;/h3&gt;
&lt;p&gt;组合（Composite）模式将对象&lt;u&gt;组合成树型结构&lt;/u&gt;以&lt;u&gt;表示“部分——整体”&lt;/u&gt;的层次结构。Composite使得用户&lt;u&gt;对单个对象和组合对象的使用具有一致性&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;组合模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682300973563.png&#34;
	width=&#34;940&#34;
	height=&#34;440&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682300973563_hu29c872695ca6ff6ded5279e7e927bfc7_52033_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682300973563_hu29c872695ca6ff6ded5279e7e927bfc7_52033_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;组合模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;213&#34;
		data-flex-basis=&#34;512px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Component&lt;/code&gt;：为组合中的对象&lt;u&gt;声明接口&lt;/u&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在适当情况下&lt;u&gt;实现所有类共有接口的默认行为&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;声明一个接口用于访问和管理&lt;code&gt;Component&lt;/code&gt;的子组件；&lt;/li&gt;
&lt;li&gt;（可选）&lt;u&gt;在递归结构中定义一个接口，用于访问一个父组件&lt;/u&gt;，并在合适的情况下&lt;u&gt;实现&lt;/u&gt;它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Leaf&lt;/code&gt;：在组合中表示&lt;u&gt;叶结点对象&lt;/u&gt;，叶结点没有子结点；在组合中&lt;u&gt;定义图元对象的行为&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Composite&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义有子组件的那些组件的行为；&lt;/li&gt;
&lt;li&gt;存储子组件；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Component&lt;/code&gt;接口中实现与子组件有关的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;：通过&lt;code&gt;Component&lt;/code&gt;接口操纵组合组件的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Composite模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想表示对象的&lt;u&gt;部分——整体层次结构&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;希望用户&lt;u&gt;忽略组合对象与单个对象的不同&lt;/u&gt;，用户将&lt;u&gt;统一地使用组合结构中的所有对象&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;p&gt;表示对象的部分——整体层次结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;装饰器模式&#34;&gt;装饰器模式&lt;/h3&gt;
&lt;p&gt;装饰器（Decorator）模式&lt;u&gt;动态&lt;/u&gt;地给一个对象&lt;u&gt;添加一些额外的职责&lt;/u&gt;。就增加功能而言，&lt;u&gt;Decorator模式比生成子类更加灵活&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;装饰器模式结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302304911.png&#34;
	width=&#34;862&#34;
	height=&#34;392&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302304911_hu87036585f545fff625bfcce0389726df_55394_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302304911_hu87036585f545fff625bfcce0389726df_55394_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;装饰器模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;219&#34;
		data-flex-basis=&#34;527px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt;：定义一个&lt;u&gt;对象接口&lt;/u&gt;，可以给这些对象&lt;u&gt;动态地添加职责&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteComponent&lt;/code&gt;：定义一个对象，可以&lt;u&gt;给这个对象添加一些职责&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Decorator&lt;/code&gt;：&lt;u&gt;维持一个指向&lt;code&gt;Component&lt;/code&gt;对象的指针&lt;/u&gt;，并&lt;u&gt;定义一个与&lt;code&gt;Component&lt;/code&gt;接口一致的接口&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteDecorator&lt;/code&gt;：&lt;u&gt;向组件添加职责。&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Decorator模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/li&gt;
&lt;li&gt;处理那些可以撤销的职责。&lt;/li&gt;
&lt;li&gt;当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个对象加以包装以提供一些额外的行为。&lt;/li&gt;
&lt;li&gt;在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/li&gt;
&lt;li&gt;动态地给一个对象添加一些额外的职责。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键词：&lt;u&gt;提供、添加、额外行为、指责&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;外观模式&#34;&gt;外观模式&lt;/h3&gt;
&lt;p&gt;外观（Facade）模式&lt;u&gt;为子系统中的一组接口提供一个一致的界面&lt;/u&gt;，Facade模式&lt;u&gt;定义了&lt;/u&gt;一个&lt;u&gt;高层接口&lt;/u&gt;，这个接口&lt;u&gt;使得这一子系统更加容易使用&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;外观模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302810965.png&#34;
	width=&#34;950&#34;
	height=&#34;376&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302810965_hu0169411cc8d389f824aec2bd1bd88e86_24708_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682302810965_hu0169411cc8d389f824aec2bd1bd88e86_24708_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;外观模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;252&#34;
		data-flex-basis=&#34;606px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Facade&lt;/code&gt;：知道哪些子系统类负责处理请求；&lt;u&gt;将客户的请求代理给适当的子系统对象&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Subsystem classes&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现子系统的功能；&lt;/li&gt;
&lt;li&gt;处理有&lt;code&gt;Facade&lt;/code&gt;对象指派的任务；&lt;/li&gt;
&lt;li&gt;没有&lt;code&gt;Facade&lt;/code&gt;的任何相关信息，即没有指向&lt;code&gt;Facade&lt;/code&gt;的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Facade模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Facade可以提供一个简单的默认视图，供大多数用户使用。&lt;/p&gt;
&lt;p&gt;要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。&lt;/p&gt;
&lt;p&gt;Facade提供的简单默认视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;u&gt;客户程序&lt;/u&gt;与&lt;u&gt;抽象类的实现&lt;/u&gt;部分之间&lt;u&gt;存在着很大的依赖性&lt;/u&gt;。&lt;u&gt;引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当需要&lt;u&gt;构建一个层次结构的子系统&lt;/u&gt;时，使用&lt;u&gt;Facade模式定义子系统中每层的入口点&lt;/u&gt;。如果&lt;u&gt;子系统之间是相互依赖的&lt;/u&gt;，则可以&lt;u&gt;让它们仅通过Facade进行通信，从而简化了它们之间的依赖关系&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一系列对象加以包装以简化其接口。&lt;/li&gt;
&lt;li&gt;需要为一个复杂子系统提供一个简单接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键词：&lt;u&gt;简化接口、复杂子系统&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;享元模式&#34;&gt;享元模式&lt;/h3&gt;
&lt;p&gt;享元（Flyweight）模式运用共亨技术有效地支持大量细粒度的对象。&lt;/p&gt;
&lt;p&gt;享元模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682305434953.png&#34;
	width=&#34;870&#34;
	height=&#34;561&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682305434953_hu5d09b2ef7c809ea7781b9cd3cc8a6bd3_70263_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682305434953_hu5d09b2ef7c809ea7781b9cd3cc8a6bd3_70263_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;享元模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;155&#34;
		data-flex-basis=&#34;372px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Flyweight&lt;/code&gt;：描述一个接口，通过这个接口&lt;code&gt;Flyweight&lt;/code&gt;可以&lt;u&gt;接受并作用于外部状态&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteFlyweight&lt;/code&gt;：&lt;u&gt;实现&lt;code&gt;Flyweight&lt;/code&gt;接口，并为内部状态（如果有）增加存储空间。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcreteFlyweight&lt;/code&gt;对象必须是可共享的。它所存储的状态必须是内部的，即它必须独立于&lt;code&gt;ConcreteFlyweight&lt;/code&gt;对象的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并非所有的&lt;code&gt;Flyweight&lt;/code&gt;子类都需要被共享。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flyweight&lt;/code&gt;接口使共享成为可能，但它并不强制共享。在&lt;code&gt;Flyweight&lt;/code&gt;对象结构的某些层次，&lt;code&gt;UnsharedConcreteFlyweight&lt;/code&gt;对象通常将&lt;code&gt;ConcreteFlyweight&lt;/code&gt;对象作为子结点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FlyweightFactory&lt;/code&gt;：&lt;u&gt;创建并管理&lt;code&gt;Flyweight&lt;/code&gt;对象&lt;/u&gt;；确保合理地共享&lt;code&gt;Flyweight&lt;/code&gt;，当用户请求一个&lt;code&gt;Flyweight&lt;/code&gt;时，&lt;code&gt;FlyweightFactory&lt;/code&gt;对象提供一个已创建的实例或者在不存在时创建一个实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;：维持一个对&lt;code&gt;Flyweight&lt;/code&gt;的引用；计算或存储一个或多个&lt;code&gt;Flyweight&lt;/code&gt;的外部状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flyweight模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个应用程序&lt;u&gt;使用了大量的对象&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;完全由于&lt;u&gt;使用大量的对象，造成很大的存储开销&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;对象的&lt;u&gt;大多数状态都可变为外部状态&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;u&gt;删除对象的外部状态&lt;/u&gt;，那么&lt;u&gt;可以用相对较少的共享对象取代很多组对象&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代理模式&#34;&gt;代理模式&lt;/h3&gt;
&lt;p&gt;代理（Proxy）模式为其他对象&lt;u&gt;提供一种代理以控制对这个对象的访问&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;代理模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682306107287.png&#34;
	width=&#34;807&#34;
	height=&#34;348&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682306107287_hu0d398b0509b4d48f9b3205627bb8971a_28885_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682306107287_hu0d398b0509b4d48f9b3205627bb8971a_28885_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;代理模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;231&#34;
		data-flex-basis=&#34;556px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;：保存一个引用使得&lt;u&gt;代理可以访问实体&lt;/u&gt;；提供一个与&lt;code&gt;Subject&lt;/code&gt;的接口相同的接口，使&lt;u&gt;代理可以用来代替实体&lt;/u&gt;；&lt;u&gt;控制对实体的存取&lt;/u&gt;，并可能负责创建和删除它。&lt;/p&gt;
&lt;p&gt;其他功能依赖于代理的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Remote Proxy&lt;/code&gt;：负责对请求及其参数进行编码，并向不同地址空间中的实体发送己编码的请求；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Virtual Proxy&lt;/code&gt;：可以缓存实体的附加信息，以便延迟对它的访问；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Protection Proxy&lt;/code&gt;：检查调用者是否具有实现一个请求所必需的访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Subject&lt;/code&gt;：定义&lt;code&gt;RealSubject&lt;/code&gt;和&lt;code&gt;Proxy&lt;/code&gt;的共用接口，这样就在任何使用&lt;code&gt;RealSubject&lt;/code&gt;的地方都可以使用&lt;code&gt;Proxy&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RealSubject&lt;/code&gt;：定义&lt;code&gt;Proxy&lt;/code&gt;所代表的实体。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Proxy模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见情况有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;远程代理（Remote Proxy）：为一个对象在不同地址空间提供局部代表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚代理(Virtual Proxy）：根据需要创建开销很大的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保护代理（Protection Proxy）：控制对原始对象的访问，用于对象应该有不同的访问权限的时候。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;智能引用（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作。&lt;/p&gt;
&lt;p&gt;典型用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放；&lt;/li&gt;
&lt;li&gt;当第一次引用一个持久对象时，将它装入内存；&lt;/li&gt;
&lt;li&gt;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;行为型设计模式&#34;&gt;行为型设计模式&lt;/h2&gt;
&lt;p&gt;行为模式涉及&lt;u&gt;算法和对象间职责的分配&lt;/u&gt;。行为模式不仅&lt;u&gt;描述对象或类的模式&lt;/u&gt;，还&lt;u&gt;描述它们之间的通信模式&lt;/u&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行为类模式：使用&lt;u&gt;继承机制&lt;/u&gt;在类间分派行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行为对象模式：使用&lt;u&gt;对象复合&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;一些行为对象模式&lt;u&gt;描述了一组&lt;strong&gt;对等&lt;/strong&gt;的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;责任链模式&#34;&gt;责任链模式&lt;/h3&gt;
&lt;p&gt;责任链（Chain of Responsibility）模式&lt;u&gt;使多个对象都有机会处理请求&lt;/u&gt;，从而避免请求的发送者和接收者之间的耦合关系。&lt;u&gt;将这些对象连成一条链&lt;/u&gt;，并&lt;u&gt;沿着这条链传递该请求，直到有一个对象处理它为止&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;责任链模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682307471896.png&#34;
	width=&#34;680&#34;
	height=&#34;348&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682307471896_huf23cf1c3201c893b8b3f5c2bf75098c6_29363_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682307471896_huf23cf1c3201c893b8b3f5c2bf75098c6_29363_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;责任链模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;195&#34;
		data-flex-basis=&#34;468px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义一个处理请求的接口；&lt;/li&gt;
&lt;li&gt;（可选）实现后继链。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteHandler&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理它所负责的请求；&lt;/li&gt;
&lt;li&gt;可访问它的后继者；&lt;/li&gt;
&lt;li&gt;如果可处理该请求，就处理它，否则将该请求转发给后继者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;：向链上的具体处理者（&lt;code&gt;ConcreteHandler&lt;/code&gt;）对象提交请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chain of Responsibility模式适用于以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有&lt;u&gt;多个的对象可以处理一个请求&lt;/u&gt;，哪个对象处理该请求&lt;u&gt;运行时刻自动确定&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;想在&lt;u&gt;不明确指定接收者的情况下向多个对象中的一个提交一个请求&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;可处理一个请求的对象集合应被&lt;u&gt;动态指定&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有多个对象可以处理一个请求，在运行时刻自动确定由哪个对象处理。&lt;/li&gt;
&lt;li&gt;一个客户需要使用一组相关对象。&lt;/li&gt;
&lt;li&gt;想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键字：&lt;u&gt;多个对象、一个请求、一组相关对象&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;命令模式&#34;&gt;命令模式&lt;/h3&gt;
&lt;p&gt;命令（Command）模式将&lt;u&gt;一个请求封装为一个对象&lt;/u&gt;，从而使得可以&lt;u&gt;用不同的请求对客户进行参数化&lt;/u&gt;；对&lt;u&gt;请求排队&lt;/u&gt;或&lt;u&gt;记录请求日志&lt;/u&gt;，以及&lt;u&gt;支持可撤销的操作&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;命令模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311014909.png&#34;
	width=&#34;924&#34;
	height=&#34;305&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311014909_hu71620aca29416c3ad91bf9fc175e50fb_35195_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311014909_hu71620aca29416c3ad91bf9fc175e50fb_35195_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;命令模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;302&#34;
		data-flex-basis=&#34;727px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Command&lt;/code&gt;：声明执行操作的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;：将&lt;u&gt;一个接收者对象绑定于一个动作；调用接收者相应的操作&lt;/u&gt;，以实现&lt;code&gt;Execute&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;：创建一个具体命令对象并设定它的接收者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Invoker&lt;/code&gt;：要求该命令执行这个请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Receiver&lt;/code&gt;：知道如何实施与执行一个请求相关的操作。&lt;/p&gt;
&lt;p&gt;任何类都可能作为一个接收者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Command模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;u&gt;抽象出待执行的动作以参数化某对象。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;Command模式是过程语言中的&lt;u&gt;回调&lt;/u&gt;（Callback）&lt;u&gt;机制&lt;/u&gt;的一个面向对象的&lt;u&gt;替代品&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在不同的时刻指定、排列和执行请求。&lt;/p&gt;
&lt;p&gt;一个Command对象可以有一个与初始请求无关的生存期。&lt;/p&gt;
&lt;p&gt;如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程，并在那实现该请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持取消操作。&lt;/p&gt;
&lt;p&gt;Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。&lt;/p&gt;
&lt;p&gt;Command接口必须添加一个Unexecute操作，该操作取消上一次Execute 调用的效果。&lt;/p&gt;
&lt;p&gt;执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消和“重做”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持修改日志。&lt;/p&gt;
&lt;p&gt;这样当系统崩溃时，这些修改可以被重做一遍。&lt;/p&gt;
&lt;p&gt;在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。&lt;/p&gt;
&lt;p&gt;从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用构建在原语操作上的高层操作构造一个系统。&lt;/p&gt;
&lt;p&gt;这样一种结构在支持事务（Transaction）的信息系统中很常见。&lt;/p&gt;
&lt;p&gt;Command模式提供了对事务进行建模的方法。Command有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象出执行的动作以参数化某对象。&lt;/li&gt;
&lt;li&gt;将请求封装为对象从而可以使用不同的请求对客户进行参数化。&lt;/li&gt;
&lt;li&gt;在不同的时刻指定、排列和执行请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解释器模式&#34;&gt;解释器模式&lt;/h3&gt;
&lt;p&gt;解释器（Interpreter）模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。&lt;/p&gt;
&lt;p&gt;解释器模式结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311888750.png&#34;
	width=&#34;705&#34;
	height=&#34;369&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311888750_hu0fd3a707223ef37ad012b4e875690974_34918_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682311888750_hu0fd3a707223ef37ad012b4e875690974_34918_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;解释器模式结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;458px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AbstractExpression&lt;/code&gt;：声明一个&lt;u&gt;程序的解释操作&lt;/u&gt;，这个接口为抽象语法树中所有的结点所共享。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TerminalExpression&lt;/code&gt;：&lt;u&gt;实现与文法中的终结符相关联的解释操作&lt;/u&gt;；一个句子中的每个终结符需要该类的一个实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NonterminalExpression&lt;/code&gt;：对文法中的每一条规则都需要一个&lt;code&gt;NonterminalExpression&lt;/code&gt;类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每个符号都维护一个&lt;code&gt;AbstractExpression&lt;/code&gt;类型的实例变量；&lt;/li&gt;
&lt;li&gt;为文法中的非终结符实现解释（&lt;code&gt;Interpret&lt;/code&gt;）操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Context&lt;/code&gt;：包含解释器之外的一些&lt;u&gt;全局信息&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树，该抽象语法树由&lt;code&gt;NonterminalExpression&lt;/code&gt;和&lt;code&gt;TerminalExpression&lt;/code&gt;的实例装配而成；调用解释操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Interpreter模式适用于当&lt;u&gt;有一个语言需要解释执行&lt;/u&gt;，且&lt;u&gt;可将该语言中的句子表示为一个抽象语法树&lt;/u&gt;时，以下情况效果最好:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该&lt;u&gt;文法简单&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。&lt;/p&gt;
&lt;p&gt;即Interpreter模式需要构建抽象语法树，如果文法太复杂，需要构建复杂的语法树，不便于管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;u&gt;效率不是一个关键问题。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;p&gt;有一个语言需要&lt;u&gt;解释执行&lt;/u&gt;，并且可将句子表示为一个&lt;u&gt;抽象语法树&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;迭代器模式&#34;&gt;迭代器模式&lt;/h3&gt;
&lt;p&gt;迭代器（Iterator）模式提供一种方法&lt;u&gt;顺序访问&lt;/u&gt;一个&lt;u&gt;聚合对象中的各个元素&lt;/u&gt;，且&lt;u&gt;不需要暴露该对象的内部表示&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;迭代器模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682312615849.png&#34;
	width=&#34;845&#34;
	height=&#34;401&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682312615849_hub10e6946683a05bf6194a5483b6bc2bc_43952_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682312615849_hub10e6946683a05bf6194a5483b6bc2bc_43952_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;迭代器模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;210&#34;
		data-flex-basis=&#34;505px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt;（迭代器）：定义访问和遍历元素的接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteIterator&lt;/code&gt;（具体迭代器）：实现迭代器接口；对该聚合遍历时跟踪当前位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aggregate&lt;/code&gt;（聚合）：定义创建相应迭代器对象的接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteAggregate&lt;/code&gt;（具体聚合）：实现创建相应迭代器的接口，该操作返回&lt;code&gt;ConcreteIterator&lt;/code&gt;的一个适当的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Iterator模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;访问&lt;/u&gt;一个&lt;u&gt;聚合对象的内容&lt;/u&gt;而&lt;u&gt;无须暴露它的内部表示&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;支持&lt;u&gt;对聚合对象的多种遍历&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;为&lt;u&gt;遍历不同的聚合结构提供一个统一的接口&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;p&gt;访问一个聚合对象的内容而无须暴露它的内部表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;中介者模式&#34;&gt;中介者模式&lt;/h3&gt;
&lt;p&gt;中介者模式（Mediator）用一个&lt;u&gt;中介对象&lt;/u&gt;来&lt;u&gt;封装&lt;/u&gt;一系列的&lt;u&gt;对象交互&lt;/u&gt;。中介者&lt;u&gt;使各对象不需要显式地相互引用&lt;/u&gt;，从而使其&lt;u&gt;耦合松散&lt;/u&gt;，而且&lt;u&gt;可以独立地改变它们之间的交互&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;中介者模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682313139750.png&#34;
	width=&#34;855&#34;
	height=&#34;236&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682313139750_hue770aa3c8fde88302c9d09952e57e382_24131_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682313139750_hue770aa3c8fde88302c9d09952e57e382_24131_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;中介者模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;362&#34;
		data-flex-basis=&#34;869px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mediator&lt;/code&gt;（中介者）：定义一个接口用于各同事（&lt;code&gt;Colleague&lt;/code&gt;）对象通信。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteMediator&lt;/code&gt;（具体中介者）：通过协调各同事对象实现协作行为；了解并维护它的各个同事。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Colleague&lt;/code&gt;（同事类）：知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mediator模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一组对象以&lt;u&gt;定义良好但是复杂的方式进行通信&lt;/u&gt;，产生的&lt;u&gt;相互依赖关系结构混乱且难以理解&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;一个对象&lt;u&gt;引用其他很多对象&lt;/u&gt;并且&lt;u&gt;直接与这些对象通信&lt;/u&gt;，导致&lt;u&gt;难以复用该对象&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;想&lt;u&gt;定制一个分布在多个类中的行为&lt;/u&gt;，而又&lt;u&gt;不想生成太多的子类&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。&lt;/li&gt;
&lt;li&gt;一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。&lt;/li&gt;
&lt;li&gt;减少多个对象或类之间的通信复杂性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;备忘录模式&#34;&gt;备忘录模式&lt;/h3&gt;
&lt;p&gt;备忘录（Memento）模式在&lt;u&gt;不破坏封装性的前提下捕获一个对象的内部状态&lt;/u&gt;，并在对象之外保存这个状态。这样以后就可以&lt;u&gt;将对象恢复到原先保存的状态&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;Memento模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314218216.png&#34;
	width=&#34;847&#34;
	height=&#34;266&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314218216_hu96fb8022010cf254fe57392ea3f8173e_38752_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314218216_hu96fb8022010cf254fe57392ea3f8173e_38752_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Memento模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;318&#34;
		data-flex-basis=&#34;764px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Memento&lt;/code&gt;（备忘录）：存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Originator&lt;/code&gt;（原发器）：创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Caretaker&lt;/code&gt;（管理者）负责保存好备忘录；不能对备忘录的内容进行操作或检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Memento模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须&lt;u&gt;保存&lt;/u&gt;一个&lt;u&gt;对象在某一个时刻的（部分）状态&lt;/u&gt;，这样以后需要时它才能&lt;u&gt;恢复到先前的状态&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;如果一个用接口来让其他对象直接得到这些状态，将会&lt;u&gt;暴露对象的实现细节并破坏对象的封装性&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将对象的状态恢复到先前的状态。&lt;/li&gt;
&lt;li&gt;在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存。&lt;/li&gt;
&lt;li&gt;必须保存一个对象在某一个时刻的（部分）状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键词：&lt;u&gt;状态&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h3&gt;
&lt;p&gt;观察者（Observer）模式定义对象间的一种&lt;u&gt;一对多的依赖关系&lt;/u&gt;，当一个对象的&lt;u&gt;状态发生改变&lt;/u&gt;时，所有&lt;u&gt;依赖于它的对象都得到通知并被自动更新&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;观察者模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314647475.png&#34;
	width=&#34;814&#34;
	height=&#34;315&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314647475_hu9d1a28a63559700a0e73d11397468ba2_57129_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682314647475_hu9d1a28a63559700a0e73d11397468ba2_57129_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;观察者模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;258&#34;
		data-flex-basis=&#34;620px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Subject&lt;/code&gt;（目标）：提供注册和删除观察者对象的接口；知道它的观察者，可以有任意多个观察者观察同一个目标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Observer&lt;/code&gt;（观察者）：为那些在目标发生改变时需获得通知的对象&lt;u&gt;定义&lt;/u&gt;一个&lt;u&gt;更新接口&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteSubject&lt;/code&gt;（具体目标）：将&lt;u&gt;有关状态存入各&lt;code&gt;ConcreteObserver&lt;/code&gt;对象&lt;/u&gt;；当它的&lt;u&gt;状态发生改变&lt;/u&gt;时，向它的各个观察者&lt;u&gt;发出通知&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteObserver&lt;/code&gt;（具体观察者）：维护一个指向&lt;code&gt;ConcreteSubject&lt;/code&gt;对象的引用；&lt;u&gt;存储有关状态&lt;/u&gt;，这些状态应与目标的状态保持一致；实现&lt;code&gt;Observer&lt;/code&gt;的更新接口，以&lt;u&gt;使自身状态与目标的状态保持一致&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Observer模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个抽象模型有两个方面，其中&lt;u&gt;一个方面依赖于另一个方面&lt;/u&gt;，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。&lt;/li&gt;
&lt;li&gt;当对&lt;u&gt;一个对象的改变需要同时改变其他对象&lt;/u&gt;，而不知道具体有多少对象有待改变时。&lt;/li&gt;
&lt;li&gt;当&lt;u&gt;一个对象必须通知其他对象&lt;/u&gt;，而它又不能假定其他对象是谁，即&lt;u&gt;不希望这些对象是紧耦合的&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;状态模式&#34;&gt;状态模式&lt;/h3&gt;
&lt;p&gt;状态（State）模式允许一个对象在其&lt;u&gt;内部状态改变时改变它的行为&lt;/u&gt;。对象看起来似乎修改了它的类。&lt;/p&gt;
&lt;p&gt;状态模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682315217521.png&#34;
	width=&#34;644&#34;
	height=&#34;245&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682315217521_hu4dba732357bdf8362aa7b4938d2e11ca_27336_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682315217521_hu4dba732357bdf8362aa7b4938d2e11ca_27336_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;状态模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;262&#34;
		data-flex-basis=&#34;630px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Context&lt;/code&gt;（上下文）：定义客户感兴趣的接口；维护一个&lt;code&gt;ConcreteState&lt;/code&gt;子类的实例，这个实例定义当前状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State&lt;/code&gt;（状态）：定义一个接口以封装与&lt;code&gt;Context&lt;/code&gt;的一个特定状态相关的行为。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteState&lt;/code&gt;（具体状态子类）：每个子类实现与&lt;code&gt;Context&lt;/code&gt;的一个状态相关的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;State模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个对象的&lt;u&gt;行为决定于它的状态&lt;/u&gt;，并且它必须&lt;u&gt;在运行时刻根据状态改变它的行为&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个&lt;u&gt;操作中含有庞大的多分支的条件语句&lt;/u&gt;，且&lt;u&gt;这些分支依赖于该对象的状态&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;这个状态常用一个或多个&lt;u&gt;枚举常量&lt;/u&gt;表示。通常，有多个操作包含这一相同的条件结构。&lt;/p&gt;
&lt;p&gt;State模式&lt;u&gt;将每一个条件分支放入一个独立的类中&lt;/u&gt;。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个对象的行为决定于其状态且必须在运行时刻根据状态改变行为。&lt;/li&gt;
&lt;li&gt;一个对象在其内部状态改变时改变其行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;策略模式&#34;&gt;策略模式&lt;/h3&gt;
&lt;p&gt;策略（Strategy）模式&lt;u&gt;定义一系列的算法&lt;/u&gt;，把它们一个个封装起来，并且&lt;u&gt;使它们可以相互替换&lt;/u&gt;。此模式使得算法可以独立于使用它们的客户而变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Strategy&lt;/code&gt;（策略）：定义所有支持的算法的公共接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Context&lt;/code&gt;使用这个接口来调用某&lt;code&gt;ConcreteStrategy&lt;/code&gt;定义的算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteStrategy&lt;/code&gt;（具体策略）：以&lt;code&gt;Strategy&lt;/code&gt;接口实现某具体算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Context&lt;/code&gt;（上下文）：用一个&lt;code&gt;ConcreteStrategy&lt;/code&gt;对象来配置；维护一个对&lt;code&gt;Strategy&lt;/code&gt;对象的引用；可定义一个接口来让&lt;code&gt;Strategy&lt;/code&gt;访问它的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Strategy模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置-个类的方法。&lt;/li&gt;
&lt;li&gt;需要使用一个算法的不同变体例如,定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使厨策略模式。&lt;/li&gt;
&lt;li&gt;算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。&lt;/li&gt;
&lt;li&gt;一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要使用一个算法地不同变体。&lt;/li&gt;
&lt;li&gt;许多相关的类仅仅是行为有异。&lt;/li&gt;
&lt;li&gt;在设计某购物中心的收银软件系统时，要求能够支持在不同时期推出打折、返利、满减等不同促销活动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;模板方法模式&#34;&gt;模板方法模式&lt;/h3&gt;
&lt;p&gt;模板方法模式（Template Method）定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;模板方法模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316789017.png&#34;
	width=&#34;610&#34;
	height=&#34;352&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316789017_hu736eb87456a6272db6aa15cc311737f4_38587_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316789017_hu736eb87456a6272db6aa15cc311737f4_38587_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;模板方法模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;173&#34;
		data-flex-basis=&#34;415px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AbstractClass&lt;/code&gt;（抽象类）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；&lt;/li&gt;
&lt;li&gt;实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在&lt;code&gt;AbstractClass&lt;/code&gt;或其他对象中的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteClass&lt;/code&gt;（具体类）：实现原语操作以完成算法中与特定子类相关的步骤。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Template Method模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;u&gt;一次性实现&lt;/u&gt;一个&lt;u&gt;算法的不变的部分&lt;/u&gt;，并将&lt;u&gt;可变的行为留给子类来实现&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各&lt;u&gt;子类中公共的行为应被提取出来并集中到一个公共父类&lt;/u&gt;中，以&lt;u&gt;避免代码重复&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制子类扩展。&lt;/p&gt;
&lt;p&gt;模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展），这就只允许在这些点进行扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;访问者模式&#34;&gt;访问者模式&lt;/h3&gt;
&lt;p&gt;访问者（Visitor）模式表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/p&gt;
&lt;p&gt;访问者模式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316261510.png&#34;
	width=&#34;823&#34;
	height=&#34;653&#34;
	srcset=&#34;https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316261510_hu39725207e23c3afa845c404a5c71934c_93016_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1682316261510_hu39725207e23c3afa845c404a5c71934c_93016_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;访问者模式的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;302px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteVisitor&lt;/code&gt;（具体访问者）：实现每个有&lt;code&gt;Visitor&lt;/code&gt;声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcreteVisitor&lt;/code&gt;为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Element&lt;/code&gt;（元素）：定义以一个访问者为参数的&lt;code&gt;Accept&lt;/code&gt;操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ConcreteElement&lt;/code&gt;（具体元素）：实现以一个访问者为参数的&lt;code&gt;Accept&lt;/code&gt;操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ObjectStructure&lt;/code&gt;（对象结构）：能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Visitor模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个&lt;u&gt;对象结构包含很多类对象&lt;/u&gt;，它们有不同的接口，而用户想对这些对象&lt;u&gt;实施一些依赖于其具体类的操作&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要对一个&lt;u&gt;对象结构中的对象进行很多不同的并且不相关的操作&lt;/u&gt;，而又想要&lt;u&gt;避免&lt;/u&gt;这些操作&lt;u&gt;“污染”&lt;/u&gt;这些对象的类。&lt;/p&gt;
&lt;p&gt;Visitor使得用户&lt;u&gt;可以将相关的操作集中起来定义在一个类中&lt;/u&gt;。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;u&gt;定义对象结构的类很少改变&lt;/u&gt;，但经常需要在此结构上定义新的操作。&lt;/p&gt;
&lt;p&gt;改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;题目选项描述：&lt;/p&gt;
&lt;p&gt;需要对一个对象结构中的对象进行很多不同的并且不相关的操作。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>知识产权（软件设计师）</title>
        <link>https://blog.linner.asia/p/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <pubDate>Wed, 12 Apr 2023 12:29:35 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</guid>
        <description>&lt;h1 id=&#34;著作权&#34;&gt;著作权&lt;/h1&gt;
&lt;p&gt;著作权（也称为版权）：是指作者对其创作的作品享有的人身权和财产权。&lt;/p&gt;
&lt;p&gt;人身权包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发表权&lt;/li&gt;
&lt;li&gt;署名权&lt;/li&gt;
&lt;li&gt;修改权&lt;/li&gt;
&lt;li&gt;保护作品完整权&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;财产权包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作品的使用权&lt;/li&gt;
&lt;li&gt;获得报酬&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;著作权中，发表权有时限，时限是作者终身及其死亡后50年。署名权、修改权、保护作品完整权等不受时间限制，受到永久保护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;知识产权的特点&#34;&gt;知识产权的特点&lt;/h1&gt;
&lt;p&gt;知识产权的特点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无形性&lt;/li&gt;
&lt;li&gt;双重性&lt;/li&gt;
&lt;li&gt;确认性&lt;/li&gt;
&lt;li&gt;独占性&lt;/li&gt;
&lt;li&gt;地域性&lt;/li&gt;
&lt;li&gt;时间性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;地域性&#34;&gt;地域性&lt;/h2&gt;
&lt;p&gt;各国主管机关依照本国法律授予的知识产权，&lt;u&gt;只能在不国领域内受法律保护&lt;/u&gt;。著作权虽然自动产生，但它受地域限制。&lt;/p&gt;
&lt;h2 id=&#34;时间性&#34;&gt;时间性&lt;/h2&gt;
&lt;p&gt;知识产权具有法定的保护期限。&lt;/p&gt;
&lt;p&gt;例如，我国发明专利的保护期为20年，自专利申请日起计算。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我国公民的作品发表权的保护期为作者终生及其死亡后50年。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我国商标权的保护期限自核准注册之日起10年内有效。&lt;/p&gt;
&lt;p&gt;但可以根据其所有人的需要无限地延长权利期限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在期限届满前6个月内申请续展注册，&lt;/li&gt;
&lt;li&gt;每次续展注册的有效期为10年，&lt;/li&gt;
&lt;li&gt;续展注册的次数不限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;商业秘密受法律保护的期限是不确定的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;计算机软件著作权&#34;&gt;计算机软件著作权&lt;/h1&gt;
&lt;p&gt;计算机软件著作权有两个对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主体&lt;/strong&gt;：指享有著作权的人，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公民&lt;/li&gt;
&lt;li&gt;法人&lt;/li&gt;
&lt;li&gt;其他组织&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;客体&lt;/strong&gt;：指著作权法保护的计算机软件著作权的范围（受保护的对象）。&lt;/p&gt;
&lt;p&gt;著作权法保护的计算机软件是指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算机程序&lt;/strong&gt;，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源程序，&lt;/li&gt;
&lt;li&gt;目标程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算机程序&lt;strong&gt;有关文档&lt;/strong&gt;，文档一般以以下形式出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序设计说明书，&lt;/li&gt;
&lt;li&gt;流程图，&lt;/li&gt;
&lt;li&gt;用户手册。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算机软件著作权受到以下两个法律的保护：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《中华人民共和国著作权法》，简称著作权法；&lt;/li&gt;
&lt;li&gt;《计算机软件保护条例》。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时限：计算机软件著作权的权利自软件开发完成之日起产生。&lt;/p&gt;
&lt;h2 id=&#34;保护条件&#34;&gt;保护条件&lt;/h2&gt;
&lt;p&gt;《计算机软件保护条例》规定，依法受到保护的计算机软件作品必须符合下列条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;独立创作。&lt;/p&gt;
&lt;p&gt;不可抄袭。使用他人软件作品的逻辑步骤的组合方式，对他人构成侵权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可被感知。&lt;/p&gt;
&lt;p&gt;受保护的软件必须固定在某种有形物体上，例如固定在存储器、磁盘和磁带等设备上，也可以是其他的有形物，如纸张等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑合理。&lt;/p&gt;
&lt;p&gt;软件作品必须具备合理的逻辑思想，并以正确的逻辑步骤表现出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;权利&#34;&gt;权利&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算机软件的著作人身权&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发表权&lt;/li&gt;
&lt;li&gt;开发者身份权（也称为署名权）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算机软件的著作财产权&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用权&lt;/li&gt;
&lt;li&gt;复制权&lt;/li&gt;
&lt;li&gt;修改权&lt;/li&gt;
&lt;li&gt;发行权&lt;/li&gt;
&lt;li&gt;翻译权&lt;/li&gt;
&lt;li&gt;注释权&lt;/li&gt;
&lt;li&gt;信息网络传播权&lt;/li&gt;
&lt;li&gt;出租权&lt;/li&gt;
&lt;li&gt;使用许可权&lt;/li&gt;
&lt;li&gt;获得报酬权&lt;/li&gt;
&lt;li&gt;转让权&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件合法持有人的权利&lt;/p&gt;
&lt;p&gt;软件的合法复制品所有人享有下述权利：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据使用的需要把软件装入计算机等能存储信息的装置内。&lt;/li&gt;
&lt;li&gt;根据需要进行必要的复制。&lt;/li&gt;
&lt;li&gt;为了防止复制品损坏而制作备份复制品（不能给他人使用）。&lt;/li&gt;
&lt;li&gt;为了把该软件用于实际的计算机应用环境或者改进其功能性能而进行必要的修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;保护期&#34;&gt;保护期&lt;/h2&gt;
&lt;p&gt;计算机软件著作权的权利自软件开发完成之日起产生，保护期为50年。保护期满，除开发者身份权以外，其他权利终止。&lt;/p&gt;
&lt;p&gt;一旦计算机软件著作权超出保护期，软件就进入公有领域。计算机软件著作权人的单位终止和计算机软件著作权人的公民死亡均无合法继承人时，除开发者身份权以外，该软件的其他权利进入公有领域。软件进入公有领域后成为社会公共财富，公众可无偿使用。&lt;/p&gt;
&lt;h2 id=&#34;职务作品&#34;&gt;职务作品&lt;/h2&gt;
&lt;p&gt;职务软件作品是指公民在单位任职期间为热行本单位工作任务所开发的计算机软件作品。&lt;/p&gt;
&lt;p&gt;根据《计算机软件保护条例》可以判断软件作品的归属。&lt;/p&gt;
&lt;p&gt;构成职务软件作品的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公民在单位任职期间所开发的软件如果是执行本职工作的结果，即针对本职工作中明确指定的开发目标所开发的，则该软件的著作权属于该单位。&lt;/li&gt;
&lt;li&gt;当公民作为某单位的雇员时，如其开发的软件属于执行本职工作的结果，该软件著作权应当归单位享有。&lt;/li&gt;
&lt;li&gt;如果该雇员主要使用了单位的设备，著作权不能属于该雇员个人享有。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果软件作品属于职务软件作品，那开发者只有署名权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;构成非职务软件（个人）作品的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所开发的软件作品不是执行其本职工作的结果。&lt;/p&gt;
&lt;p&gt;若雇员开发创作的软件不是执行本职工作的结果，则构成非职务计算机软件著作权的条件之一。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发的软件作品与开发者在单位中从事的工作内容无直接联系。&lt;/p&gt;
&lt;p&gt;雇员所开发的软件作品与其本职工作没有直接的关系，则构成非职务计算机软件著作权的第二个条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发的软件作品未使用单位的物质技术条件。&lt;/p&gt;
&lt;p&gt;开发软件作品所必须的设备、数据、资金和其他软件开发环境，不属于雇员所在的单位所有。没有使用受雇单位的任何物质技术条件构成非职务软件著作权的第三个条件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;委托开发&#34;&gt;委托开发&lt;/h2&gt;
&lt;p&gt;委托开发的软件作品属于著作权法规定的委托软件作品。委托开发软件作品著作权关系的建立，&lt;u&gt;一般由委托方与受委托方订立合同而成立&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;委托开发软件作品关系中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;委托方：主要责任是提供资金、设备等物质条件，并不直接参与开发软件作品的创作开发活动。&lt;/li&gt;
&lt;li&gt;受托方：主要责任是根据委托合同规定的目标开发出符合条件的软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接受他人委托开发的软件，其著作权的归属由委托者与受委托者签订书面合同约定：无书面合同或者合同未作明确约定的，其著作权由受托人享
有。&lt;/p&gt;
&lt;p&gt;委托开发的软件著作权的归属按以下标准确定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件著作权的归属应当根据委托开发软件的合同来确定。&lt;/li&gt;
&lt;li&gt;若&lt;u&gt;没有签订书面协议&lt;/u&gt;，或者&lt;u&gt;在协议中未对软件著作权归属作出明确的约定&lt;/u&gt;，则&lt;u&gt;软件著作权属于受委托者&lt;/u&gt;，即&lt;u&gt;属于实际完成软件的开发者&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;侵权行为&#34;&gt;侵权行为&lt;/h2&gt;
&lt;p&gt;计算机软件著作权侵权行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;未经软件著作权人的同意而发表或者登记其软件作品。&lt;/p&gt;
&lt;p&gt;侵犯著作权人的发表权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将他人开发的软件当作自己的作品发表或者登记。&lt;/p&gt;
&lt;p&gt;侵犯开发者身份权和署名权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未经合作者的同意将与他人合作开发的软件当作自己独立完成的作品发表或者登记。&lt;/p&gt;
&lt;p&gt;合作开发的软件，软件作品的发表权也应由全体开发者共同行使。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在他人开发的软件上署名或者更改他人开发的软件上的署名。&lt;/p&gt;
&lt;p&gt;侵犯了软件著作人的开发者身份权及署名权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未经软件著作权人或者其合法受让者的许可，修改、翻译其软件作品。&lt;/p&gt;
&lt;p&gt;侵犯了著作权人或其合法受让者的使用权中的修改权、翻译权。&lt;/p&gt;
&lt;p&gt;如果征得软件作品著作人的同意，修改和改善新增加的部分，创作者应享有著作权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未经软件著作权人或其合法受让者的许可，复制或部分复制其软件作品。&lt;/p&gt;
&lt;p&gt;侵犯了著作权人或其合法受让者的使用权中的复制权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未经软件著作权人及其合法受让者同意，向公众发行、出租其软件的复制品。&lt;/p&gt;
&lt;p&gt;此种行为侵犯了著作权人或其合法受让者的发行权与出租权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未经软件著作权人或其合法受让者同意，向任何第三方办理软件权利许可或转让事宜。&lt;/p&gt;
&lt;p&gt;侵犯了软件著作权人或其合法受让者的使用许可权和转让权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未经软件著作权人及其合法受让者同意，通过信息网络传播著作权人的软件。&lt;/p&gt;
&lt;p&gt;侵犯了软件著作权人或其合法受让者的信息网络传播权。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;商业秘密权&#34;&gt;商业秘密权&lt;/h1&gt;
&lt;p&gt;商业秘密的定义：“指不为公众所知悉的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息”。&lt;/p&gt;
&lt;p&gt;商业秘密的基本内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经营秘密：未公开的经营信息，是指与生产经营销售活动有关的经营方法、
管理方法、产销策略、货源情报、客户名单、标底和标书内容等专有知识。&lt;/li&gt;
&lt;li&gt;技术秘密：未公开的技术信息，是指与产品生产和制造有关的技术诀窍、生产方案、工艺流程、设计图纸、化学配方和技术情报等专有知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;商业秘密的构成条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须具有未公开性，即不为公众所知悉；&lt;/li&gt;
&lt;li&gt;必须具有实用性，即能为权利人带来经济效益；&lt;/li&gt;
&lt;li&gt;必须具有保密性，即采取了保密措施。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;商业秘密的丧失：一项商业秘密受到法律保护的依据是必须具备上述构成商业秘密的3个条件，当缺少上述3个条件之一时就会造成商业秘密丧失保护。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;专利权&#34;&gt;专利权&lt;/h1&gt;
&lt;p&gt;专利申请的原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;专利申请人及其代理人&lt;/u&gt;在办理各种手续时都应当采用&lt;strong&gt;书面&lt;/strong&gt;形式。&lt;/li&gt;
&lt;li&gt;遵循&lt;u&gt;“一份申请一项发明”&lt;/u&gt;原则。&lt;/li&gt;
&lt;li&gt;多人就&lt;u&gt;同样&lt;/u&gt;的发明创造申请专利的，专利权&lt;u&gt;授给最先申请人&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;相同的发明，多人&lt;u&gt;同时&lt;/u&gt;申请，由所有申请人&lt;u&gt;协商确定&lt;/u&gt;专利权归属。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;专利的时限（均自申情日起计算）：&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;发明专利权&lt;/td&gt;
        &lt;td&gt;20年&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;实用新型专利权&lt;/td&gt;
        &lt;td&gt;10年&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;外观设计专利权&lt;/td&gt;
        &lt;td&gt;15年&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;h2 id=&#34;商标权&#34;&gt;商标权&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;商标权保护期限自核准注册之日起&lt;u&gt;10年内有效&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;商标权保护期限可以&lt;u&gt;根据其所有人的需要无限地延长权利期限&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;在期限届满&lt;u&gt;前6个月内&lt;/u&gt;申请续展注册，每次续展注册的&lt;u&gt;有效期为10年&lt;/u&gt;，&lt;u&gt;续展注册的次数不限&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;如果商标权人逾期不办理续展注册，其商标权也将终止。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;商标权注册先申请注册先得，同一天申请先使用商标先得，都没使用过则协商。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>数据结构（软件设计师）</title>
        <link>https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <pubDate>Tue, 04 Apr 2023 17:17:20 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</guid>
        <description>&lt;h1 id=&#34;复杂度&#34;&gt;复杂度&lt;/h1&gt;
&lt;h2 id=&#34;大o表示法&#34;&gt;大O表示法&lt;/h2&gt;
&lt;p&gt;算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1681099842666.png&#34;
	width=&#34;1014&#34;
	height=&#34;100&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1681099842666_hu8fb0d0a3c83abecf36c375990db2efe0_51379_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1681099842666_hu8fb0d0a3c83abecf36c375990db2efe0_51379_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1014&#34;
		data-flex-basis=&#34;2433px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加法规则：多项相加，保留最高阶项，并将系数化为1；&lt;/li&gt;
&lt;li&gt;乘法规则：多项相乘都保留，并将系数化为1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;递归式的时间（空间）复杂度：&lt;/p&gt;
&lt;p&gt;$$
递归的次数 \times 每次递归的时间（空间）复杂度
$$&lt;/p&gt;
&lt;h2 id=&#34;渐进符号&#34;&gt;渐进符号&lt;/h2&gt;
&lt;p&gt;可以用渐进符号来表示渐进复杂度。&lt;/p&gt;
&lt;p&gt;渐进符号包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$O$：算法运行时间的渐进上界。&lt;/p&gt;
&lt;p&gt;给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le f(n) \le cg(n) \}$。&lt;/p&gt;
&lt;p&gt;即，当$n \ge n_0$时，$f(n) \le c \cdot g(n)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Omega$：算法运行时间的渐进下界。&lt;/p&gt;
&lt;p&gt;给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le cg(n) \le f(n) \}$。&lt;/p&gt;
&lt;p&gt;即，当$n \ge n_0$时，$c \cdot g(n) \le f(n)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Theta$：算法运行时间的渐进上界和渐进下界，即渐进紧致界（又叫紧缺界）。&lt;/p&gt;
&lt;p&gt;给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c_1、c_2和n_0,使得\forall n \ge n_0, 有 0 \le c_1g(n) \le f(n) \le c_2g(n) \}$。&lt;/p&gt;
&lt;p&gt;即，当$n \ge n_0$时，$c_1g(n) \le f(n) \le c_2g(n)$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681110832416.png&#34;
	width=&#34;966&#34;
	height=&#34;1204&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681110832416_hud8e84328d379d2eda520e5c710188239_380512_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681110832416_hud8e84328d379d2eda520e5c710188239_380512_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;递归式主方法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;80&#34;
		data-flex-basis=&#34;192px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;逻辑结构分类&#34;&gt;逻辑结构分类&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;线性结构
&lt;ul&gt;
&lt;li&gt;线性表（一般线性表）&lt;/li&gt;
&lt;li&gt;特殊线性表
&lt;ul&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性表的推广
&lt;ul&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;广义表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非线性结构
&lt;ul&gt;
&lt;li&gt;树结构
&lt;ul&gt;
&lt;li&gt;二叉树&lt;/li&gt;
&lt;li&gt;多叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图结构
&lt;ul&gt;
&lt;li&gt;有向图&lt;/li&gt;
&lt;li&gt;无向图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集合结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;线性表&#34;&gt;线性表&lt;/h1&gt;
&lt;p&gt;&lt;u&gt;由 $n(n\geq 0)$ 个&lt;strong&gt;数据特性相同&lt;/strong&gt;的元素构成的&lt;strong&gt;有限序列&lt;/strong&gt;称为&lt;strong&gt;线性表&lt;/strong&gt;&lt;/u&gt;。$n=0$ 时，称为空表。非空表的特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在唯一一个“第一个”元素。&lt;/li&gt;
&lt;li&gt;存在唯一一个“最后一个”元素。&lt;/li&gt;
&lt;li&gt;相邻元素之间存在序偶关系：
&lt;ul&gt;
&lt;li&gt;除第一个之外，结构中的每个数据元素均只有一个&lt;strong&gt;前驱&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;除最后一个之外，结构中的每个数据元素均只有一个&lt;strong&gt;后继&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线性表的存储结构分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序存储；&lt;/li&gt;
&lt;li&gt;链式存储&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺序存储结构&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;线性表的&lt;strong&gt;顺序存储&lt;/strong&gt;是指用一组&lt;strong&gt;地址连续的存储单元&lt;/strong&gt;依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。在这种存储方式下，元素间的逻辑关系无须占用额外的空间来存储。&lt;/p&gt;
&lt;p&gt;其存储结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610120418.png&#34;
	width=&#34;130&#34;
	height=&#34;266&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610120418_hu2b33a584fc5a2d635ec65d6abeb2f0a4_3927_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610120418_hu2b33a584fc5a2d635ec65d6abeb2f0a4_3927_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;顺序表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;48&#34;
		data-flex-basis=&#34;117px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;假设线性表的每个元素占用的存储空间为$L$，$LOC(a_i)$为第$i$个元素的存储位置（$0 \le i \le n-1$，$n$为线性表的长度）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第$i+1$个元素和第$i$个元素的存储位置满足：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i+1})=LOC(a_i)+L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第$i$个元素的存储位置：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_i)=LOC(a_0) + i \times L
$$&lt;/p&gt;
&lt;p&gt;如果下标从1开始：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_i)=LOC(a_1) + (i-1) \times L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺序存储结构的线性表的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;strong&gt;可以随机存取表中的元素&lt;/strong&gt;，不需要额外的存储空间来表达元素之间的逻辑关系；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;插入和删除操作不方便、效率低、比较耗时&lt;/strong&gt;（&lt;strong&gt;插入和删除操作需要移动元素&lt;/strong&gt;），顺序表的长度是固定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在表厂为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在第$i$个插入位置插入，需要移动$n+1-i$个元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第1个位置插入（$a_1$）需要移动$n$个元素；&lt;/li&gt;
&lt;li&gt;在第$n+1$个位置插入（$a_n$后面）不需要移动元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设在第$i$个插入位置插入的概率为$p_i$，&lt;u&gt;等概率下&lt;/u&gt;（假如这$n+1$个插入位置插入的概率相同）&lt;u&gt;插入&lt;/u&gt;一个新元素需要移动的元素个数的&lt;u&gt;期望值$E_{insert}$&lt;/u&gt;为：&lt;/p&gt;
&lt;p&gt;$$
E_{insert} = \sum_{i=1}^{n+1}{ \Big( p_i \times (n-i+1) \Big) } = \cfrac{1}{n+1} \sum_{i=1}^{n+1}{(n-i+1)} = \cfrac{n+1}{2}
$$&lt;/p&gt;
&lt;p&gt;$$
p_i = \cfrac{1}{n+1}
$$&lt;/p&gt;
&lt;p&gt;即，$E_{insert} = \cfrac{插入位置数-1}{2} = \cfrac{n+1}{2}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;删除第$i$个元素$a_i$需要移动$n-i$个元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除元素$a_1$需要移动$n-1$个元素；&lt;/li&gt;
&lt;li&gt;删除元素$a_n$不需要移动元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设$a_i$被删除的概率为$q_i$，&lt;u&gt;等概率下删除元素&lt;/u&gt;时需要移动的元素个数的&lt;u&gt;期望值$E_{delete}$&lt;/u&gt;为：&lt;/p&gt;
&lt;p&gt;$$
E_{delete} = \sum_{i=1}^{n}{\Big( q_i \times (n-i) \Big)} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i)} = \cfrac{n-1}{2}
$$&lt;/p&gt;
&lt;p&gt;$$
q_i = \cfrac{1}{n}
$$&lt;/p&gt;
&lt;p&gt;即，$E_{delete} = \cfrac{删除位置数}{2} = \cfrac{n-1}{2}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;插入操作时间复杂度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好情况（在第$n+1$个位置插入）：$O(1)$；&lt;/li&gt;
&lt;li&gt;最坏情况（在第1个位置插入）：$O(n)$；&lt;/li&gt;
&lt;li&gt;平均复杂度：$O(n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查找元素时间复杂度&lt;/strong&gt;（根据下标查找）：$O(1)$。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;线性表的&lt;strong&gt;链式存储&lt;/strong&gt;是指&lt;strong&gt;通过指针链接起来&lt;/strong&gt;的结点来存储数据元素。&lt;/p&gt;
&lt;p&gt;其存储结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610469403.png&#34;
	width=&#34;403&#34;
	height=&#34;49&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610469403_hueeee19018a01756f2e48de06f8910c88_6757_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610469403_hueeee19018a01756f2e48de06f8910c88_6757_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;链式表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;822&#34;
		data-flex-basis=&#34;1973px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据域&lt;/strong&gt;：用于存储数据元素的&lt;strong&gt;值&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指针域&lt;/strong&gt;：用于存储当前元素的直接前驱或直接后继的&lt;strong&gt;位置信息&lt;/strong&gt;（直接前或后驱的&lt;strong&gt;指针&lt;/strong&gt;，称其为指针或链）。&lt;/p&gt;
&lt;p&gt;存储各数据元素的结点的&lt;u&gt;地址并不要求是连续的&lt;/u&gt;，因此存储数据元素的同时必须存储元素之间的逻辑关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链式表的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;结点空间只有在需要的时候才申请&lt;/u&gt;，无须事先分配；&lt;/li&gt;
&lt;li&gt;长度不固定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链式表结点之间通过指针域构成一个链表，&lt;u&gt;若结点中只有一个指针域，则称为线性链表&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610514354.png&#34;
	width=&#34;685&#34;
	height=&#34;64&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610514354_hu9c9f9d7fee45544c6864faab3f820061_7122_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680610514354_hu9c9f9d7fee45544c6864faab3f820061_7122_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;链式表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1070&#34;
		data-flex-basis=&#34;2568px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上图中的Head：一个指向链表第一个结点的针，称为头指针。使用它就可以顺序地访问到表中的任意一个元素。&lt;/p&gt;
&lt;p&gt;插入和删除操作时间复杂度（带不带头节点的复杂度都一样）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好情况（在$i=1$位置）：$O(1)$；&lt;/li&gt;
&lt;li&gt;最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$&lt;/li&gt;
&lt;li&gt;平均复杂度：$O(n)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链表操作的时间复杂度取决于指针遍历。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;栈&#34;&gt;栈&lt;/h1&gt;
&lt;p&gt;栈是一种&lt;strong&gt;后入先出&lt;/strong&gt;（Last In First Out，LIFO）的线性表。&lt;u&gt;栈只能通过访问它的一端来实现数据存储和检索。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;栈的基本操作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入栈&lt;/strong&gt;：将元素置入栈顶；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出栈&lt;/strong&gt;：将元素从栈顶中取出。&lt;/li&gt;
&lt;li&gt;读取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;栈的出栈顺序一定和入栈顺序&lt;strong&gt;相反&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;顺序存储结构-1&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;栈的顺序存储结构也称为&lt;strong&gt;顺序栈&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;顺序栈使用一个栈顶指针标记栈顶元素的索引位置。每次出栈时都需要重置栈顶指针，将栈顶指针向下移动，标记到新的栈顶元素。&lt;/p&gt;
&lt;p&gt;顺序栈的空间容量有限，所以每次入栈时都需要判断栈是否为满。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-1&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;栈的链式存储结构称为&lt;strong&gt;链栈&lt;/strong&gt;。链栈的头指针就是栈顶指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680676944766.png&#34;
	width=&#34;238&#34;
	height=&#34;265&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680676944766_hu1bea4090283c9929deed80a707d4d0a3_11895_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680676944766_hu1bea4090283c9929deed80a707d4d0a3_11895_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;链栈的存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;215px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;栈的应用&#34;&gt;栈的应用&lt;/h2&gt;
&lt;p&gt;栈的典型应用包括&lt;strong&gt;表达式求值、括号匹配&lt;/strong&gt;等，在计算机语言的实现以及将递归过程转变为非递归过程的处理中，栈有重要的作用。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;队列&#34;&gt;队列&lt;/h1&gt;
&lt;p&gt;队列是一种&lt;strong&gt;先入先出&lt;/strong&gt;（First In First Out，FIFO）的线性表。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;队列只允许在表的一端插入元素，在表的另一端删除元素。&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;队头&lt;/strong&gt;（Front）：允许&lt;strong&gt;删除&lt;/strong&gt;元素的一端；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队尾&lt;/strong&gt;（Rear）：允许&lt;strong&gt;插入&lt;/strong&gt;元素的一端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;队列的基本操作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入队&lt;/strong&gt;：将元素加入到队尾；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出队&lt;/strong&gt;：将元素加入到对头。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;队列的入队顺序一定&lt;strong&gt;等于&lt;/strong&gt;出队顺序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用两个栈可以来模拟一个队列（从一个栈出栈后的元素入另一个栈后再出栈）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;顺序存储结构-2&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;队列的顺序存储结构称为&lt;strong&gt;顺序队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;顺序队列设置两个指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队头指针：指向对头元素的下标；&lt;/li&gt;
&lt;li&gt;队尾指针：指向队尾元素的下标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果顺序队列只按照数组下标大小顺序来设置指针（对头指针的值永不大于队尾指针），那么在经过一段时间的操作后，对头指针有可能指向的并不是数组的第一个元素，此时队列的长度永远都到达不了数组的长度（空间无法被充分利用，实际使用的长度和逻辑长度不符）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680677900098.png&#34;
	width=&#34;959&#34;
	height=&#34;323&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680677900098_hua0e0c24049b10a1b1a22eff29a314663_53364_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680677900098_hua0e0c24049b10a1b1a22eff29a314663_53364_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;队列操作&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;296&#34;
		data-flex-basis=&#34;712px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以把数组想象为一个环型的结构（将最后一个元素和第一个元素连接起来，队头指针可以比队尾指针大）。如果此时队列的状态是上图中步骤$(e)$的状态，此时再插入元素，可以将元素放在数组索引0的位置，再让队尾指针始终保持在队列最后一个元素的索引之后即可。将这种队列称为&lt;strong&gt;循环队列&lt;/strong&gt;，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678225885.png&#34;
	width=&#34;907&#34;
	height=&#34;202&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678225885_hu78897751e6ca29164f26d83cde2f776e_48040_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678225885_hu78897751e6ca29164f26d83cde2f776e_48040_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;循环队列&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;449&#34;
		data-flex-basis=&#34;1077px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-2&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;队列的链式存储也称为&lt;strong&gt;链队列&lt;/strong&gt;（&lt;strong&gt;链队&lt;/strong&gt;）。这里为了便于操作，可以给链队列添加一个头结点，并令头指针指向头结点。因此，队列为空的判定条件是头指针和尾指针的值相同，且
均指向头结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678441791.png&#34;
	width=&#34;278&#34;
	height=&#34;340&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678441791_hud106655f2d3cb3393c4501ce0717f1de_16473_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680678441791_hud106655f2d3cb3393c4501ce0717f1de_16473_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;81&#34;
		data-flex-basis=&#34;196px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;队列的应用&#34;&gt;队列的应用&lt;/h2&gt;
&lt;p&gt;队列结构常用于处理需要排队的场合，例如操作系统中处理打印任务的打印队列、离散事件的计算机模拟等。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;串&#34;&gt;串&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;串&lt;/strong&gt;（&lt;strong&gt;字符串&lt;/strong&gt;）是一种&lt;strong&gt;特殊的线性表&lt;/strong&gt;，其&lt;strong&gt;数据元素为字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;串具有自身的特性，运算时常常把一个串作为一个整体来处理。&lt;/p&gt;
&lt;p&gt;串的基本概念和操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空串&lt;/strong&gt;：长度为0的串；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;子串&lt;/strong&gt;：由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。子串在主串中的位置是指子串首次出现时，该子串的第一个字符在主串中的位置。空串是任意串的子串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;串相等&lt;/strong&gt;：指两个串长度相等且对应序号的字符也相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;串比较&lt;/strong&gt;：两个串比较大小时以字符的ASCⅡ码值（或其他字符编码集合）作为依据。&lt;/p&gt;
&lt;p&gt;实质上，比较操作从两个串的第一个字符开始进行，字符的码值大者所在的串为大；若其中一个串先结束，则以串长较大者为大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;赋值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拷贝赋值：将一个串的值赋给另一个串；&lt;/li&gt;
&lt;li&gt;引用（地址）赋值：将一个串的引用（地址）赋给另一个串。那么这个串可以使用另一个串中的值，但是对这个串所做的操作，也会作用到另一个串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接串&lt;/strong&gt;：将一个串插入到另一个串尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插入串&lt;/strong&gt;：将一个串插入到另一个串的任意位置中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺序存储结构-3&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;串的顺序存储结构是一种定长的串（类似顺序表）。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-3&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;串的链式存储结构可以方便地对串进行插入删除操作（类似链表）。&lt;/p&gt;
&lt;h2 id=&#34;串的模式匹配&#34;&gt;串的模式匹配&lt;/h2&gt;
&lt;p&gt;子串的定位操作通常称为串的模式匹配。子串也称为模式串。&lt;/p&gt;
&lt;p&gt;有关串模式匹配算法的详细讲解可以查看：&lt;a class=&#34;link&#34; href=&#34;../%e7%bb%8f%e5%85%b8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d&#34; &gt;经典字符串匹配&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;朴素的模式匹配算法&#34;&gt;朴素的模式匹配算法&lt;/h3&gt;
&lt;p&gt;朴素的模式匹配算法也称为布鲁特一福斯算法（即暴力匹配算法），其基本思想是从主串的第一个字符起与模式串的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串第二个字符起与模式串的第一个字符重新比较，直到模式串中每个字符依次和主串中一个连续的字符序列相等时为止，此时称为匹配成功。如果不能在主串中找到与模式串相同的子串，则匹配失败。&lt;/p&gt;
&lt;p&gt;设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最好情况：$O(m)$，次数为$m$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最坏情况：$O(n \times m)$，次数为$\cfrac{1}{2} m(n-m+2)$：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=0}^{n-m}{p_i\big( (i+1) \times m \big)} = \cfrac{m}{n-m+1} \sum_{i=0}^{n-m}{(i+1)} = \cfrac{1}{2} m(n-m+2)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均：$O(n+m)$，次数为$\cfrac{1}{2} (n+m)$：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=0}^{n-m}{p_i(i+m)} = \cfrac{1}{n-m+1} \sum_{i=0}^{n-m}{i+m} = \cfrac{1}{2} (n+m)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kmp-算法&#34;&gt;KMP 算法&lt;/h3&gt;
&lt;p&gt;KMP算法又称为改进的模式匹配算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串的&lt;strong&gt;前缀&lt;/strong&gt;：包含第一个字符，且不包含最后一个字符的子串；&lt;/li&gt;
&lt;li&gt;串的&lt;strong&gt;后缀&lt;/strong&gt;：包含最后一个字符，且不包含第一个字符的子串。&lt;/li&gt;
&lt;li&gt;前缀集合：包含串的所有前缀的集合；&lt;/li&gt;
&lt;li&gt;后缀集合：包含串的所有后缀的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;KMP的重点是求模式串字符的next值（失配指针$Next[\ i\ ]$），假设$a_{i-1}$为当前要求next值的模式串字符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前缀集合：&lt;/p&gt;
&lt;p&gt;$$
Prefix=\{p_0,p_0p_1,\cdots,p_0&amp;hellip;p_{i-1}\}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀集合：&lt;/p&gt;
&lt;p&gt;$$
Postfix=\{p_{i-1},p_{i-2}p_{i-1},\cdots,p_1&amp;hellip;p_{i-1}\}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;失配指针：&lt;/p&gt;
&lt;p&gt;$$
Next[i] =
\begin{cases}
-1 &amp;amp; 当\ i=0 时 \\
max &amp;amp; \{ k|0&amp;lt;k&amp;lt;i 且 &amp;ldquo;p_0\cdots p_{k-1}&amp;rdquo; = &amp;ldquo;p_{i-k}\cdots p_{i-1}&amp;rdquo; \} \\
0 &amp;amp; 其他情况
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$Next[0] = -1$；&lt;/li&gt;
&lt;li&gt;$Next[i] = maxLen(Prefix \cap Postfix)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以解释为：&lt;/p&gt;
&lt;p&gt;$$
Next[\ i\ ] = 前i个子串的最长相同前后缀的长度
$$&lt;/p&gt;
&lt;p&gt;特殊情况：$Next[\ 1\ ] = 0$，因为其前缀集合和后缀集合都为空。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;失配表是用来指示匹配失败后指针该如何移动的。&lt;/p&gt;
&lt;p&gt;失配表的建立跟要匹配的串没有任何关系，仅跟模式串有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;多维数组&#34;&gt;多维数组&lt;/h1&gt;
&lt;p&gt;多维数组是定长线性表在维数上的扩展，即线性表中的元素又是一个线性表。多维数组是一种“同构”的数据结构，其每个数据元素类型相同、结构一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一维数组：即线性表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二维数组（仅讨论顺序存储结构）：&lt;/p&gt;
&lt;p&gt;二维数组的存储结构（如下图），可以分为以行为主序（下图左边）和以列为主序（下图右边）两种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680693946560.png&#34;
	width=&#34;451&#34;
	height=&#34;448&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680693946560_hu1932cb3790ae3468aeeee7cc636c93c8_34859_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680693946560_hu1932cb3790ae3468aeeee7cc636c93c8_34859_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二维数组为$A[n,m]$，$n$为行数，$m$为列数；&lt;/li&gt;
&lt;li&gt;数组元素$a_{i,j},\ 0 \le i \le n-1,\ 0 \le j \le m-1$；&lt;/li&gt;
&lt;li&gt;$LOC(a_{i,j})$为元素$a_{i,j}$的地址；&lt;/li&gt;
&lt;li&gt;$L$为单个元素的存储空间大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以行为主序优先存储：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i \times n + j) \times L
$$&lt;/p&gt;
&lt;p&gt;如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) \times n + (j-1) \big) \times L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以列为主序优先存储：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \times m) \times L
$$&lt;/p&gt;
&lt;p&gt;如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) + (j-1) \times m \big) \times L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;优先存储说法问题：&lt;/p&gt;
&lt;p&gt;以行为主序优先存储的意思应该是在内存中按行存储。以列为主序优先存储的意思应该是在内存中按列存储。&lt;/p&gt;
&lt;p&gt;假设一个二维数组为：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; a_{13} &amp;amp; a_{14} \\
a_{21} &amp;amp; a_{22} &amp;amp; a_{23} &amp;amp; a_{24} \\
a_{31} &amp;amp; a_{32} &amp;amp; a_{33} &amp;amp; a_{34} \\
a_{41} &amp;amp; a_{42} &amp;amp; a_{43} &amp;amp; a_{44} \\
a_{51} &amp;amp; a_{52} &amp;amp; a_{53} &amp;amp; a_{54}
\end{vmatrix}
$$&lt;/p&gt;
&lt;p&gt;按照以行为主序优先存储的公式，它在内存中应该是分为了5个地址连续的数组来存储。即内存中，$[a_{11},a_{12},a_{13},a_{14}]$为一个数组，其后再接一个数组$[a_{12},a_{22},a_{23},a_{24}]$，以此类推，在内存中按照列的元素作为一个连续的一维数组单位，再按照第1行后接第2行作为整个连续的二维数组。它们在内存中的地址顺序是：&lt;/p&gt;
&lt;p&gt;$$
a_{11},a_{12},&amp;hellip;,a_{14},\\
a_{21},&amp;hellip;,a_{24},\\
a_{31},&amp;hellip;,a_{34},\\
a_{41},&amp;hellip;,a_{44},\\
a_{51},&amp;hellip;,a_{54}
$$&lt;/p&gt;
&lt;p&gt;那么以列为主序优先存储的地址顺序就为：&lt;/p&gt;
&lt;p&gt;$$
a_{11},a_{21},&amp;hellip;,a_{51},\\
a_{12},&amp;hellip;,a_{52},\\
a_{13},&amp;hellip;,a_{53},\\
a_{14},&amp;hellip;,a_{54}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般矩阵都用二维数组来表示，但是对于一些特殊矩阵，如对称矩阵、三角矩阵和对角矩阵。它们的非0元素的分布存在一定规律，所以可以将其压缩存储在一维数组中，并且它们的多个值相同的元素（按照对应特殊矩阵定义上的值相同，并非简单的值相同）只分配一个存储单位。&lt;/p&gt;
&lt;h2 id=&#34;对称矩阵&#34;&gt;对称矩阵&lt;/h2&gt;
&lt;p&gt;若矩阵$A_{n \times n}$中的元素特点为$a_{ij}=a_{ji}\ (1 \le i,j \le n)$，则称之为$n$阶对称矩阵。&lt;/p&gt;
&lt;p&gt;对称矩阵$A_{n \times n}$：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1n} \\
a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2n} \\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
a_{n1} &amp;amp; a_{n2} &amp;amp; \cdots &amp;amp; a_{nn}
\end{vmatrix}
$$&lt;/p&gt;
&lt;p&gt;其中以对角线划分为三个区域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主对角线&lt;/strong&gt;：$a{11},a_{22},\cdots,a_{nn}$，共有$n$个元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上三角区&lt;/strong&gt;：对角线以上的所有元素，即：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
0 &amp;amp; a_{12} &amp;amp; a_{13} &amp;amp; \cdots &amp;amp; a_{1n} \\
0 &amp;amp; 0 &amp;amp; a_{23} &amp;amp; \cdots &amp;amp; a_{2n} \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; a_{(n-1)n} \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0
\end{vmatrix}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;下三角区&lt;/strong&gt;：对角线以下的所有元素，和上三角区的个数相等并且重复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以将对称矩阵中，$n^2$个元素压缩存储到$\cfrac{n(n+1)}{2}$个元素的存储空间中。一般是存储下三角区和对角线。&lt;/p&gt;
&lt;p&gt;假设将$n$阶对称矩阵$A_{n \times n}$压缩存储到一维数组$B\left[ \cfrac{n(n+1)}{2} \right]$，则$B[k]\ (1 \le k \le \cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$之间存在一一对应关系（以行为主序）：&lt;/p&gt;
&lt;p&gt;$$
k =
\begin{cases}
\cfrac{i(i-1)}{2} + j, &amp;amp; 当\ i \ge j \\
\cfrac{j(j-1)}{2} + i, &amp;amp; 当\ i &amp;lt; j
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;如果下标从0开始（第一个元素为$a_{00}$，$0 \le k \le \cfrac{n(n+1)}{2} - 1$，并且$0 \le i,j \le n-1$）：&lt;/p&gt;
&lt;p&gt;$$
k =
\begin{cases}
\cfrac{i(i+1)}{2} + j + 1, &amp;amp; 当\ i \ge j \\
\cfrac{j(j+1)}{2} + i + 1, &amp;amp; 当\ i &amp;lt; j
\end{cases}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么$length(B) = \cfrac{n(n+1)}{2}$（压缩存储的一维数组大小）：&lt;/p&gt;
&lt;p&gt;主对角线的元素的大小为$n$，下三角区的对角线大小分别为$n-1,n-2,&amp;hellip;,1$。即：
$$
length(B) = \sum_{i=1}^{n}{i} = \cfrac{n(n+1)}{2}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：《软件设计师教程（第五版）》中一维数组的下标$k$的取值范围错了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680698007514.png&#34;
	width=&#34;999&#34;
	height=&#34;344&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680698007514_hud68653e5fe46341035cf0f04b58f1fb8_157083_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680698007514_hud68653e5fe46341035cf0f04b58f1fb8_157083_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;对称矩阵&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;290&#34;
		data-flex-basis=&#34;696px&#34;
	
&gt;
很明显不是$\left[ 1, \cfrac{n(n+1)}{2} \right)$，而应该是$\left[ 1, \cfrac{n(n+1)}{2} \right]$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三对角矩阵&#34;&gt;三对角矩阵&lt;/h2&gt;
&lt;p&gt;对角矩阵是指矩阵中的&lt;u&gt;非0元素都集中在以主对角线为中心的带状区域中&lt;/u&gt;，即除了主对角线上和直接在对角线上、下方若干条对角线上的元素外，其余的矩阵元素都为0。三对角矩阵是对角矩阵中的一种，包括主对角线和在主对角线上、下方的各一条对角为非0元素：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; 0      &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
a_{21} &amp;amp; a_{22} &amp;amp; a_{23} &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
0      &amp;amp; a_{32} &amp;amp; a_{33} &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
0      &amp;amp; 0      &amp;amp; a_{43} &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots         &amp;amp; \vdots     \\
0      &amp;amp; 0      &amp;amp; 0      &amp;amp; \cdots &amp;amp; a_{(n-1)(n-1)} &amp;amp; a_{(n-1)n} \\
0      &amp;amp; 0      &amp;amp; 0      &amp;amp; \cdots &amp;amp; a_{n(n-1)}     &amp;amp; a_{nn}
\end{vmatrix}
$$&lt;/p&gt;
&lt;p&gt;设有$n$阶三对角矩阵$A_{n \times n}$，将其非0元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$存储在一维数组$B[k](1 \le k \le 3 \times n - 2)$中，则元素位置之间的对应关系为：&lt;/p&gt;
&lt;p&gt;$$
k = 3 \times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2
$$&lt;/p&gt;
&lt;p&gt;如果下标从0开始（$0 \le k \le 3(n-1)$，并且$0 \le i,j \le n-1$）：&lt;/p&gt;
&lt;p&gt;$$
k = 3 \times i - 1 + j - i + 1 + 1 = 2i + j + 1
$$&lt;/p&gt;
&lt;h2 id=&#34;稀疏矩阵&#34;&gt;稀疏矩阵&lt;/h2&gt;
&lt;p&gt;在一个矩阵中，若&lt;u&gt;非0元素的个数远远少于0元素的个数，且非0元素的分布&lt;strong&gt;没有规律&lt;/strong&gt;&lt;/u&gt;，则称之为稀疏矩阵。&lt;/p&gt;
&lt;p&gt;对于稀疏矩阵，存储非0元素时&lt;strong&gt;必须同时存储其位置&lt;/strong&gt;（即行号和列号），用&lt;u&gt;三元组$(i,j,a_{ij})$可唯一确定矩阵$A$中的一个元素&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;可以用三元组表来存储这些三元组。稀疏矩阵的三元组表的顺序存储结构称为&lt;strong&gt;三元组顺序表&lt;/strong&gt;，常用的三元组表的链式存储结构是&lt;strong&gt;十字链表&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;树&#34;&gt;树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;结构是一种&lt;strong&gt;非线性结构&lt;/strong&gt;，该结构中的一个数据元素可以有&lt;strong&gt;两个或两个以上的直接后继&lt;/strong&gt;元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;（Tree）是 $n(n\ge0)$ 个结点的有限集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空树&lt;/strong&gt;：$n=0$；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非空树&lt;/strong&gt;：$n&amp;gt;0$，
&lt;ul&gt;
&lt;li&gt;有且仅有一个&lt;strong&gt;根结点&lt;/strong&gt;，&lt;/li&gt;
&lt;li&gt;除根节点外的其余结点可分为 $m(m&amp;gt;0)$ 个互不相交的集合，即&lt;strong&gt;子树&lt;/strong&gt;（SubTree）$T_1,T_2,\cdots,T_m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树的定义是&lt;strong&gt;递归&lt;/strong&gt;的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一棵树由若干棵子树构成；&lt;/li&gt;
&lt;li&gt;子树又由更小的子树构成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;h3 id=&#34;术语&#34;&gt;术语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;度&lt;/strong&gt;：结点拥有的子树数。整个树的度是树内各结点度的最大值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶结点&lt;/strong&gt;：度为 0 的结点，也称&lt;strong&gt;终端结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非终端结点&lt;/strong&gt;：度不为 0 的结点，也称&lt;strong&gt;分支结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部结点&lt;/strong&gt;：除根节点外的非终端结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子节点&lt;/strong&gt;：结点&lt;u&gt;子树的根结点&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父结点&lt;/strong&gt;：与子结点相连的上一层的唯一一个结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟结点&lt;/strong&gt;：同一个父节点的子节点之间互为兄弟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;祖先结点&lt;/strong&gt;：从根结点到该结点所经分支上的所有结点（包括其父节点，但不包括其本身）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子孙结点&lt;/strong&gt;：以某结点为根的子树中的所有结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堂兄弟结点&lt;/strong&gt;：父节点在同一层（但不是同一个）的结点互为堂兄弟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;层次&lt;/strong&gt;：以根结点为第一层，根的子节点为第二层 …… 树中任意结点的层次等于其父节点的层次加 1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的高度&lt;/strong&gt;：树中结点的最大层次，也称&lt;strong&gt;树的深度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;森林&lt;/strong&gt;：是 $m(m\ge0)$ 棵互不相交的树的集合。树中每个结点的子树的集合即为森林。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;树的类型&#34;&gt;树的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有序树&lt;/strong&gt;：树中结点的各子树从左到右是有次序的，即不能互换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无序树&lt;/strong&gt;：树中结点的各子树相互之间可以互换，没有次序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;树的性质&#34;&gt;树的性质&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设$n$个结点的树，$d_i \ (1 \le i \le n)$为该树中结点的度：&lt;/p&gt;
&lt;p&gt;$$
n = (\sum_{i=1}^{n}{d_i})+1
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \ge 1$）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高度为$h$的$m$度树至多有$\cfrac{m^h-1}{m-1}$个结点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;树的逻辑结构&#34;&gt;树的逻辑结构&lt;/h2&gt;
&lt;p&gt;树可以用二元组 $Tree=(root,F)$ 表示。其中 $root$ 是根结点，$F$ 是 $m(m\ge0)$ 棵子树的森林，即 $F=(T_1,T_2,\cdots,T_m)$，其中 $T_i=(r_i,F_i)$ 为根 $root$ 的第 $i$ 棵子树。&lt;/p&gt;
&lt;p&gt;树根与其子树森林之间的关系：
$$
RF = \{ &amp;lt;root,r_i&amp;gt;|i=1,2,4,m,\quad m&amp;gt;0 \}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;二叉树&#34;&gt;二叉树&lt;/h1&gt;
&lt;p&gt;二叉树是（$n \ge 0$）个结点的有限集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空树：$n=0$；&lt;/li&gt;
&lt;li&gt;由一个根结点及两棵不相交的且分别称为左、右子树的二叉树所组成（两个子数顺序不可交换）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉树同样具有递归性质。&lt;/p&gt;
&lt;p&gt;二叉树的性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第$i$层（$i \ge 1$）上&lt;u&gt;最多&lt;/u&gt;有$2^{i-1}$个结点。&lt;/p&gt;
&lt;p&gt;因为二叉树每个结点至多有两个分支（结点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高度为$k$的二叉树最多有$2^k-1$个结点（$k \ge 1$）。&lt;/p&gt;
&lt;p&gt;每层结点都取最大值后累加：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=1}^{k}{2^{i-1}} = 2^k - 1
$$&lt;/p&gt;
&lt;p&gt;将深度为$k$且有$2^k-1$个结点的二叉树称为&lt;strong&gt;满二叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对满二叉树自上而下、从左至右进行编号（即层序遍历的顺序）。一个深度为$k$、有$n$个结点的二叉树，当且仅当其每一个结点都于深度为$k$的满二叉树中编号从1至$n$的结点一一对应时，称之为&lt;strong&gt;完全二叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完全二叉树有一个隐藏关系：$n &amp;gt; 2^{k-1}-1$。即深度为$k$的完全二叉树，其结点数$n$必须要比深度为$k-1$的满二叉树至少多1个结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;深度为$k$的满二叉树结点数$n$和其第$k$层结点数$m$的关系：&lt;/p&gt;
&lt;p&gt;$$
n = 2m-1
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何一棵二叉树，若其终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$
终端结点数（度0结点数）=度2结点数+1
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具有$n$个结点的完全二叉树的深度（高度）为：&lt;/p&gt;
&lt;p&gt;$$
\lfloor \log_2{n} \rfloor + 1;
$$&lt;/p&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;p&gt;$$
\lceil \log_2{(n+1)} \rceil
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉树形态总数（卡特兰数）：&lt;/p&gt;
&lt;p&gt;$$
\cfrac{C^{n}_{2n}}{n+1}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;排列组合公式：&lt;/p&gt;
&lt;p&gt;$$
A^n_m = m \times (m-1) \times \cdots \times (m-n+1)
$$&lt;/p&gt;
&lt;p&gt;$m$是起点，$n$是次数。&lt;/p&gt;
&lt;p&gt;$$
C^n_m = \cfrac{A^n_m}{A^n_n}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;顺序存储结构-4&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;用一组地址连续的存储单元存储二叉树中的结点。&lt;/p&gt;
&lt;p&gt;可以按照为完全二叉树编号的顺序（即层序遍历的顺序），将二叉树映射到顺序表中：&lt;/p&gt;
&lt;p&gt;若编号为$i$的结点（$i \ge 1$），则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$i=1$：根结点，没有双亲（父结点）；&lt;/li&gt;
&lt;li&gt;$i&amp;gt;1$：双亲为$\left\lfloor \cfrac{i}{2} \right\rfloor$；&lt;/li&gt;
&lt;li&gt;$i \le \cfrac{n}{2}$：左孩子编号为$2i$；&lt;/li&gt;
&lt;li&gt;$i \le \cfrac{n-1}{2}$：右孩子编号为$2i+1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完全二叉树适合采用顺序存储结构，而一般二叉树则不适合。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-4&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;可以用&lt;strong&gt;三叉链表或二叉链表&lt;/strong&gt;来存储二叉树（一个结点含有3个或2个指针，其中必须有两个指针来分别存储左子树和右子树的根结点）。链表的头指针指向二叉树根结点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680770614240.png&#34;
	width=&#34;980&#34;
	height=&#34;337&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680770614240_hu74a2d83457551f99334a785fee2a7f2b_53953_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680770614240_hu74a2d83457551f99334a785fee2a7f2b_53953_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;二叉树的链表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;290&#34;
		data-flex-basis=&#34;697px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三叉链表仅仅是多了一个指向父结点的链表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设有$n$个结点的二叉树，则其&lt;strong&gt;空指针域数量&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于二叉链表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总指针域个数：$2n$；&lt;/li&gt;
&lt;li&gt;分支数（子孙结点数，非空指针域个数）：$n-1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可得：&lt;/p&gt;
&lt;p&gt;$$
空指针域数=2n-(n-1)=n+1
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于三叉链表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总指针域个数：$3n$；&lt;/li&gt;
&lt;li&gt;分支数（子孙结点数）：$n-1$；&lt;/li&gt;
&lt;li&gt;指向父结点且非空的指针域个数：$n-1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，非空指针域个数为：$2(n-1)$。&lt;/p&gt;
&lt;p&gt;可得：&lt;/p&gt;
&lt;p&gt;$$
空指针域数=3n-2(n-1)=n+2
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;遍历&#34;&gt;遍历&lt;/h2&gt;
&lt;p&gt;二叉树有以下遍历方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先序遍历：根左右&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问根结点；&lt;/li&gt;
&lt;li&gt;先序遍历左子树；&lt;/li&gt;
&lt;li&gt;先序遍历右子树。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中序遍历：左根右&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中序遍历左子树；&lt;/li&gt;
&lt;li&gt;访问根结点；&lt;/li&gt;
&lt;li&gt;中序遍历右子树。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后序遍历：左右根&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;后序遍历左子树；&lt;/li&gt;
&lt;li&gt;后序遍历右子树；&lt;/li&gt;
&lt;li&gt;访问根结点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后序遍历可以使用栈：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根结点入栈；&lt;/li&gt;
&lt;li&gt;右子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；&lt;/li&gt;
&lt;li&gt;左子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；&lt;/li&gt;
&lt;li&gt;将栈中所有元素出栈，出栈顺序即为后序遍历的顺序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层序遍历：根据层序从上至下，从左到右遍历&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问根结点（第1层）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从左到右访问第2层所有结点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从左到右访问第3层所有结点；&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直至访问到最后一层的所有结点（从左到右）。&lt;/p&gt;
&lt;p&gt;层序遍历可以使用队列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将根结点入队；&lt;/li&gt;
&lt;li&gt;将对头元素出队，然后将其左右子结点（如果有的话）依序入队；&lt;/li&gt;
&lt;li&gt;重复步骤2直至所有元素出队，出队顺序即为层序遍历顺序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;二叉树的遍历实质上是对一个非线性结构进行线性化的过程，它使得每个结点（除第一个和最后一个）在这些线性序列中有且仅有一个直接前驱和直接后继。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h2&gt;
&lt;p&gt;二叉树可以用于快速查找。例如比根结点小的在左子树，比根结点大的在右子树（二叉排序树）。那么每次查找，根据根结点就可以剔除一半的范围。&lt;/p&gt;
&lt;p&gt;但是如果二叉树左右子树的结点数量差别很大，那么每次查找并不一定能剔除一半的范围，查询效率大打折扣。&lt;/p&gt;
&lt;p&gt;设一个二叉树的左右子树高度之差的绝对值为$d$，那么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不平衡的二叉树：$d &amp;gt; 1$；&lt;/li&gt;
&lt;li&gt;平衡的二叉树：$d \le 1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;完全二叉树一定是平衡二叉树，平衡二叉树不一定是完全二叉树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二叉排序树&#34;&gt;二叉排序树&lt;/h2&gt;
&lt;p&gt;二叉排序树的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;左子树&lt;/strong&gt;所有结点的关键字都&lt;strong&gt;小于&lt;/strong&gt;根结点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右子树&lt;/strong&gt;所有根结点的关键字都&lt;strong&gt;大于&lt;/strong&gt;根结点；&lt;/li&gt;
&lt;li&gt;左右子树也都是二叉排序树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉排序树的&lt;strong&gt;中序遍历&lt;/strong&gt;（左根右）得到的是该二叉树的&lt;strong&gt;有序序列&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;线索二叉树&#34;&gt;线索二叉树&lt;/h2&gt;
&lt;p&gt;线索二叉树是在二叉树结点中保存了结点的前驱和后继的信息。&lt;/p&gt;
&lt;p&gt;如果使用指针来指向其前驱和后继，增加指针信息会降低存储空间的利用率。&lt;/p&gt;
&lt;p&gt;可以采用增加两个标志（&lt;code&gt;leftTag&lt;/code&gt;和&lt;code&gt;rightTag&lt;/code&gt;）来区分指针域指向的是左或右子结点还是前驱或后继：&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;leftTag&lt;/td&gt;
        &lt;td&gt;leftChild&lt;/td&gt;
        &lt;td&gt;data&lt;/td&gt;
        &lt;td&gt;rightChild&lt;/td&gt;
        &lt;td&gt;rightTag&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;$$
leftTag =
\begin{cases}
True  &amp;amp; leftChild指向结点左孩子 \\
False &amp;amp; leftChild指向结点的直接前驱
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;$$
rightTag =
\begin{cases}
True  &amp;amp; rightChild指向结点右孩子 \\
False &amp;amp; rightChild指向结点的直接后继
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;若二叉树的二叉链表采用以上所示的结点结构，则相应的链表称为线索链表，其中指向结点前驱、后继的指针称为线索。&lt;/p&gt;
&lt;p&gt;对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化。&lt;/p&gt;
&lt;h2 id=&#34;哈夫曼树&#34;&gt;哈夫曼树&lt;/h2&gt;
&lt;p&gt;哈夫曼树即最优二叉树，是一类&lt;strong&gt;带权路径长度最短&lt;/strong&gt;的树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;：指从树中&lt;strong&gt;一个结点到另一个结点之间的通路&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路径长度&lt;/strong&gt;：路径上的&lt;strong&gt;分支数目&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;树的路径长度&lt;/strong&gt;：指从树根到每一个叶子之间的路径长度之和；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结点的带权路径长度&lt;/strong&gt;：从该结点到树根之间的&lt;strong&gt;路径长度&lt;/strong&gt;与该结点&lt;strong&gt;权值&lt;/strong&gt;的乘积；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;树的带权路径长度&lt;/strong&gt;：树中所有叶子结点的带权路径长度之和。&lt;/p&gt;
&lt;p&gt;设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带权叶子结点数：$n$；&lt;/li&gt;
&lt;li&gt;叶子结点的权值：$w_k$；&lt;/li&gt;
&lt;li&gt;叶子结点到根的路径长度：$l_k$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则树的带权路径长度为：&lt;/p&gt;
&lt;p&gt;$$
WPL = \sum_{k=1}^{n}{w_kl_k}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈夫曼树是指权值为$w_1,w_2,\cdots,w_n$的$n$个叶子结点的二叉树中，带权路径长度最小的二叉树。&lt;/p&gt;
&lt;p&gt;构造最优二叉树的哈夫曼算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据给定的$n$个权值$\{ w_1,w_2,\cdots,w_n \}$，构成$n$棵二叉树集合$F=\{T_1,T_2,\cdots,T_n\}$，每棵树$T_i$有且仅有一个带权为$w_i$的根结点。&lt;/li&gt;
&lt;li&gt;在$F$中选取2棵权值最小的树作为左、右子树，构造一棵新二叉树。新二叉树的根结点权值为其左右子树根结点权值之和。&lt;/li&gt;
&lt;li&gt;从$F$中删除这2棵树，并将新树加入到$F$中。&lt;/li&gt;
&lt;li&gt;重复步骤2、3直到$F$中仅含一棵树为止，这棵树便是哈夫曼树。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;哈夫曼算法并未规定哪棵树作为左或右子树，所以哈夫曼树并不唯一，但$WPL$值是唯一的。&lt;/p&gt;
&lt;p&gt;给定$n$个权值后，哈夫曼树的结点数$m$就确定了：&lt;/p&gt;
&lt;p&gt;$$
m = 2 \times n - 1
$$&lt;/p&gt;
&lt;p&gt;所以可用一维数组存储哈夫曼树。&lt;/p&gt;
&lt;h3 id=&#34;哈夫曼编码&#34;&gt;哈夫曼编码&lt;/h3&gt;
&lt;p&gt;哈夫曼编码是一种不等长的编码，它用哈夫曼算法来构造出最优前缀码：&lt;/p&gt;
&lt;p&gt;给定&lt;strong&gt;字符集&lt;/strong&gt;$D=\{ d_1,d_2,\cdots,d_n \}$及&lt;strong&gt;字符的使用频率&lt;/strong&gt;$W=\{w_1,w_2,\cdots,w_n\}$。&lt;/p&gt;
&lt;p&gt;构造&lt;strong&gt;最优前缀码&lt;/strong&gt;的方法为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以$d_1,d_2,\cdots,d_n$作为叶子结点，$w_1,w_2,\cdots,w_n$作为叶子结点的权值，构造出一棵最优二叉树。&lt;/li&gt;
&lt;li&gt;将树中每个结点的左分支标上0，右分支标上1（左0右1）。&lt;/li&gt;
&lt;li&gt;每个叶子结点代表字符的编码就是从根到叶子的路径上组成的0、1串。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680836524813.png&#34;
	width=&#34;347&#34;
	height=&#34;334&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680836524813_hu78baa79acc8330412526e447ee3074d0_24961_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680836524813_hu78baa79acc8330412526e447ee3074d0_24961_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;哈夫曼编码&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;103&#34;
		data-flex-basis=&#34;249px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其中，字符$a$字符$b$、$c$、$d$、$e$的编码分别为00、01、100、11、101。&lt;/p&gt;
&lt;h3 id=&#34;压缩比&#34;&gt;压缩比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680959771881.png&#34;
	width=&#34;784&#34;
	height=&#34;489&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;压缩比例题&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;384px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;按照&lt;u&gt;出现频率&lt;/u&gt;计算&lt;u&gt;加权平均长度&lt;/u&gt;：&lt;/p&gt;
&lt;p&gt;$$
加权平均长度 = \sum_{i=1}^{5}{字符i的位数 \times 字符i出现频率}
$$&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$
1 \times 40% + 3 \times (10% + 20% + 16% + 14%) = 2.2
$$&lt;/p&gt;
&lt;p&gt;压缩后平均长度为2.2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算压缩比：&lt;/p&gt;
&lt;p&gt;$$
压缩比 = \cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度}
$$&lt;/p&gt;
&lt;p&gt;即，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编码5个字符至少需要3位：$2^2 &amp;lt; 5 &amp;lt; 2^3$，所以压缩前编码长度为3；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;压缩比：&lt;/p&gt;
&lt;p&gt;$$
\cfrac{3-2.2}{3} \approx 0.27
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;哈夫曼编码方案是基于贪心策略的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;图&#34;&gt;图&lt;/h1&gt;
&lt;p&gt;在图中，任意两个结点之间都可能有直接的关系，所以图中&lt;u&gt;一个结点的前驱结点和后继结点的数目是没有限制的&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;图$G$是由集合$V$和$E$构成的二元组，记作$G=(V,E)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顶点&lt;/strong&gt;：表示数据元素。$V$是图中顶点的非空有限集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边&lt;/strong&gt;：表示数据元素之间的关系。$E$是图中边的有限集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图可分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;：有向图顶点之间的关系称为弧（或有向边），用$&amp;lt;v_i,v_j&amp;gt;$表示，$v_i$是&lt;strong&gt;弧尾&lt;/strong&gt;（始点或起点），$v_j$是&lt;strong&gt;弧头&lt;/strong&gt;（终点，箭头指向的顶点），即有向边是指&lt;u&gt;从弧尾指向弧头&lt;/u&gt;的一条边。$&amp;lt;v_i,v_j&amp;gt;$和$&amp;lt;v_j,v_i&amp;gt;$分别表示的是两条边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无向图&lt;/strong&gt;：无向图顶点之间的关系用$(v_i,v_j)$表示。$(v_i,v_j)$和$(v_j,v_i)$表示的是同一条边。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;术语-1&#34;&gt;术语&lt;/h2&gt;
&lt;h3 id=&#34;完全图&#34;&gt;完全图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;完全图&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无向完全图&lt;/strong&gt;：指一个有$n$个顶点的无向图，其每一个顶点与其他$n-1$个顶点之间都有边。&lt;/p&gt;
&lt;p&gt;$n$个顶点的无向完全图共有$\cfrac{n(n-1)}{2}$条边：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=1}^{n}{i} = \cfrac{n(n-1)}{2}
$$&lt;/p&gt;
&lt;p&gt;假设$n$个顶点的无向完全图，为他们编上1到$n$的编号，按照编号顺序计算边，第1个顶点跟其他$n-1$个顶点有$n$条边；第2个顶点跟其他$n-1$个顶点也有$n$条边，除去1条跟第1个顶点相连的边，有$n-1$条不一样的边；第3个顶点出去2条跟第1和第2个顶点相连的边，有$n-2$条不一样的边……以此类推，得出上方公式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有向完全图&lt;/strong&gt;：指一个有$n$个顶点的有向图，以其每一个顶点为始点与其他$n-1$个顶点之间都有弧。&lt;/p&gt;
&lt;p&gt;$n$个顶点的有向完全图共有$n(n-1)$条边：&lt;/p&gt;
&lt;p&gt;$$
\prod_{i=1}^{n}{n-1} = n(n-1)
$$&lt;/p&gt;
&lt;p&gt;有向完全图的$n$个顶点都有$n-1$条以其他顶点作为终点的弧（出度为$n-1$），并且这$n$个顶点的$n-1$条弧都是不同的弧，所以可推出上方公式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;度&#34;&gt;度&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;度&lt;/strong&gt;：顶点$v$的度是指关联于该顶点的边的数目，记作$D(v)$。&lt;/p&gt;
&lt;p&gt;若为有向图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入度&lt;/strong&gt;：以该顶点为终点的有向边的数目，记为$ID(v)$；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出度&lt;/strong&gt;：以该顶点为起点的有向边的数目，记为$OD(v)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有向图度与入度、出度的关系：&lt;/p&gt;
&lt;p&gt;$$
D(v) = ID(v) + OD(v)
$$&lt;/p&gt;
&lt;p&gt;对于所有的图，顶点数$n$、边数$e$与各顶点的度之间有：&lt;/p&gt;
&lt;p&gt;$$
e = \cfrac{1}{2} \sum_{i=1}^{n}{D(v_i)}
$$&lt;/p&gt;
&lt;p&gt;即，所有顶点的度数之和 $= 2e$。&lt;/p&gt;
&lt;h3 id=&#34;路径&#34;&gt;路径&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$(v_p,v_{i1}),(v_{i1},v_{i2}),\cdots,(v_{in},v_q) \in E(G)$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$&amp;lt;v_p,v_{i1}&amp;gt;,&amp;lt;v_{i1},v_{i2}&amp;gt;,\cdots,&amp;lt;v_{in},v_q&amp;gt; \in E(G)$。&lt;/p&gt;
&lt;p&gt;无向图中的路径也是有方向的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;子图&#34;&gt;子图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;子图&lt;/strong&gt;：若有两个图$G=(V,E)$和$G&#39;=(V&#39;,E&#39;)$，如果$V&#39; \sube V$且$E&#39; \sube E$，则称$G&#39;$为$G$的子图。&lt;/p&gt;
&lt;h3 id=&#34;连通图&#34;&gt;连通图&lt;/h3&gt;
&lt;p&gt;对于无向图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连通&lt;/strong&gt;：无向图中，若从顶点$v_i$到顶点$v_j$&lt;u&gt;有路径&lt;/u&gt;，则称顶点$v_i$和顶点$v_j$是联通的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连通图&lt;/strong&gt;：若无向图中&lt;u&gt;任意两个顶点都是联通的&lt;/u&gt;，称其为连通图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连通分量&lt;/strong&gt;：无向图$G$的&lt;strong&gt;极大连通子图&lt;/strong&gt;称为$G$的连通分量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$n$个结点的连通图，它的边的取值范围是$[n-1,\cfrac{n(n-1)}{2}]$。&lt;/p&gt;
&lt;p&gt;对于有向图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强连通图&lt;/strong&gt;：在有向图$G$中，如果对于每一对顶点，$v_i,v_j\in V$ 且 $v_i \neq v_j$，从顶点$v_i$到顶点$v_j$和从顶点$v_j$到顶点$v_i$都存在路径，则称图$G$为强连通图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强连通分量&lt;/strong&gt;：有向图中的&lt;strong&gt;极大连通子图&lt;/strong&gt;称为有向图的强连通分量。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;连通图是无向图中的一种，所以一般也称为无向连通图。&lt;/p&gt;
&lt;p&gt;强连通图是有向图的一种，一般也称为有向强连通图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;网&#34;&gt;网&lt;/h3&gt;
&lt;p&gt;边（或弧）带权值的图称为网。&lt;/p&gt;
&lt;h3 id=&#34;有向树&#34;&gt;有向树&lt;/h3&gt;
&lt;p&gt;如果一个有向图恰&lt;u&gt;有一个顶点的入度为0（作为root），其余顶点的入度均为1&lt;/u&gt;，则是一棵有向树。&lt;/p&gt;
&lt;h2 id=&#34;基本存储结构&#34;&gt;基本存储结构&lt;/h2&gt;
&lt;p&gt;图的基本存储结构有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵表示法：使用矩阵存储顶点关系，适合存储边比较多的图；&lt;/li&gt;
&lt;li&gt;邻接链表表示法：使用多个单链表存储顶点关系，适合存储边比较少的图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;邻接矩阵表示法&#34;&gt;邻接矩阵表示法&lt;/h3&gt;
&lt;p&gt;图的邻接矩阵表示法是指&lt;u&gt;用矩阵来表示图中顶点之间的关系&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;对于具有$n$个顶点的图$G=(V,E)$，其邻接矩阵是一个$n$阶方阵，且满足：&lt;/p&gt;
&lt;p&gt;$$
A[i][j] =
\begin{cases}
1 &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt;是E中的边 \\
0 &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt;不是E中的边
\end{cases}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即，横$i$竖$j$，横出竖入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无向图的邻接矩阵是对称矩阵，有向图的邻接矩阵则不一定对称。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无向图：顶点$v_i$的度是邻接矩阵第$i$行（或列）中值不为0的元素个数；&lt;/li&gt;
&lt;li&gt;有向图：第$i$行的非0元素个数是顶点$v_i$的出度$OD(v_i)$；第$i$列的非0元素个数是顶点$v_i$的入度$ID(v_j)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网（赋权图）的邻接矩阵定义（$W_{ij}$是边或弧上的权值）：&lt;/p&gt;
&lt;p&gt;$$
A[i][j] =
\begin{cases}
W_{ij} &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt; \in E \\
\infin &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt; \notin E
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;邻接矩阵适合用于存储边比较多的图。&lt;/p&gt;
&lt;h3 id=&#34;邻接链表表示法&#34;&gt;邻接链表表示法&lt;/h3&gt;
&lt;p&gt;邻接链表表示法指的是&lt;u&gt;为图的每个顶点建立一个单链表&lt;/u&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;边结点（表结点）：&lt;/p&gt;
  &lt;table&gt;
      &lt;tr&gt;
          &lt;td&gt;adjvex&lt;/td&gt;
          &lt;td&gt;nextarc&lt;/td&gt;
          &lt;td&gt;info&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;adjvex&lt;/code&gt;：指示与顶点$v_i$邻接的顶点的序号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextarc&lt;/code&gt;：指示下一条边或弧的结点；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info&lt;/code&gt;：存储与边或弧有关的信息，如权值等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表头结点（顶点结点）：&lt;/p&gt;
  &lt;table&gt;
      &lt;tr&gt;
          &lt;td&gt;data&lt;/td&gt;
          &lt;td&gt;firstarc&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：存储顶点$v_i$的名或其他有关信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;firstarc&lt;/code&gt;：指示链表中的第一个结点（邻接顶点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表头结点通常以顺序存储结构存储，以便随机访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于有向图，&lt;strong&gt;邻接链表&lt;/strong&gt;存储的是以当前结点作为&lt;strong&gt;起点&lt;/strong&gt;的弧；&lt;strong&gt;逆邻接链表&lt;/strong&gt;存储的是以当前结点作为&lt;strong&gt;终点&lt;/strong&gt;的弧。&lt;/p&gt;
&lt;p&gt;邻接链表适合用于存储边比较少的图。&lt;/p&gt;
&lt;h2 id=&#34;遍历-1&#34;&gt;遍历&lt;/h2&gt;
&lt;p&gt;图的遍历是指&lt;u&gt;从某个项点出发，沿着某条搜索路径对图中的所有项点进行访问且只访问一次的过程&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&#34;深度优先搜索&#34;&gt;深度优先搜索&lt;/h3&gt;
&lt;p&gt;深度优先搜索（Depth First Search，DFS）类似于树的先序遍历。从图$G$中任一结点$v$出发按深度优先搜索法进行遍历的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置搜索指针$p$，使$p$指向顶点$v$；&lt;/li&gt;
&lt;li&gt;访问$p$所指顶点，并使$p$指向与其&lt;u&gt;相邻接的且尚未被访问过&lt;/u&gt;的顶点。&lt;/li&gt;
&lt;li&gt;若$p$所指顶点存在，则重复步骤2，否则执行步骤4。&lt;/li&gt;
&lt;li&gt;沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间复杂度（$n$为顶点数，$e$为边数）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵：$O(n^2)$；&lt;/li&gt;
&lt;li&gt;邻接链表：$O(n+e)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;广度优先搜索&#34;&gt;广度优先搜索&lt;/h3&gt;
&lt;p&gt;图的广度优先搜索（Breadth First Search，BFS）步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从图中的某个顶点$v$出发；&lt;/li&gt;
&lt;li&gt;访问$v$后，依次访问$v$的各个未被访问过的邻接点；&lt;/li&gt;
&lt;li&gt;分别从$v$的邻接点出发，依次访问它们的邻接点；&lt;/li&gt;
&lt;li&gt;按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到；&lt;/li&gt;
&lt;li&gt;若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;广度优先搜索可以引入队列来保存已访问过的顶点序列。即，每当一个顶点被访问后，就将其放入队列中；当队头顶点出队时，就访问其未被访问的邻接点并令这些邻接顶点入队。每个顶点最多入队一次。&lt;/p&gt;
&lt;p&gt;广度和深度优先搜索遍历图的&lt;u&gt;时间复杂度相同&lt;/u&gt;（$n$为顶点数，$e$为边数）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵：$O(n^2)$；&lt;/li&gt;
&lt;li&gt;邻接链表：$O(n+e)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;广度和深度优先搜索遍历图的不同之处在于：&lt;u&gt;顶点访问的次序不同&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;生成树&#34;&gt;生成树&lt;/h2&gt;
&lt;p&gt;连通图的生成树是该图的极小连通子图（都是$n-1$条边）。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;非连通图&lt;/strong&gt;而言，每个连通分量中的顶点集和遍历时走过的边集一起构成若干棵生成树，把它们称为&lt;strong&gt;非连通图的生成树森林&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在图的生成树中任一加一条边，则必然形成回路。&lt;/p&gt;
&lt;p&gt;边数为$e$，$e \ge n$则必然形成回路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图的生成树不是唯一的。&lt;/p&gt;
&lt;p&gt;按深度和广度优先搜索进行遍历将得到不同的生成树，分别称为深度优先生成树和广度优先生成树。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h3&gt;
&lt;p&gt;连通网的生成树的边也带权，把生成树各边的权值总和称为生成树的权。&lt;u&gt;权值最小的生成树称为最小生成树&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&#34;aov-网&#34;&gt;AOV 网&lt;/h2&gt;
&lt;p&gt;一个大工程项目可以分为许多较小子工程（称为活动）。有向图中，用顶点表示活动，弧表示活动之间的优先级关系（活动进行时的制约关系），称这样的有向图为&lt;u&gt;以顶点表示活动的网&lt;/u&gt;（Activity On Vertex network，AOV网）。&lt;/p&gt;
&lt;p&gt;在AOV网中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从顶点$v_i$到$v_j$有一条有向路径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_i$是$v_j$的前驱，&lt;/li&gt;
&lt;li&gt;$v_j$是$v_i$的后继；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$&amp;lt;v_i,v_j&amp;gt;$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_i$是$v_j$的直接前驱，&lt;/li&gt;
&lt;li&gt;$v_j$是$v_i$的直接后继。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOV网中不应出现有向环。检测工程是否可行，首先应检查对应AOV网是否存在回路。不存在回路的有向图称为有向无环图（DAG，Directed Acycline Graph）。&lt;/p&gt;
&lt;h2 id=&#34;拓扑排序&#34;&gt;拓扑排序&lt;/h2&gt;
&lt;p&gt;检测AOV网是否是DAG的方法是对AOV网构造其&lt;u&gt;顶点的拓扑有序序列&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;拓扑排序是将AOV网中的所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点$v_i$到$v_j$有一条路径，则在该线性序列中，$v_i$必在$v_j$之前。对AOV网进行拓扑排序的方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。&lt;/li&gt;
&lt;li&gt;从网中删除该顶点及与该顶点有关的所有弧。&lt;/li&gt;
&lt;li&gt;重复上述两步，直到网中不存在入度为0的顶点为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有顶点已输出，说明网中不存在回路。&lt;/li&gt;
&lt;li&gt;尚有未输出的顶点，剩余顶点均有前驱顶点，表面网中存在回路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有向无环图的拓扑序列中，顶点$v_i$在$v_j$之前，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能存在弧$&amp;lt;v_i,v_j&amp;gt;$，一定不存在弧$&amp;lt;v_j,v_i&amp;gt;$；&lt;/li&gt;
&lt;li&gt;可能存在$v_i$到$v_j$的路径，一定不存在$v_j$到$v_i$的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681115534531.png&#34;
	width=&#34;133&#34;
	height=&#34;173&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681115534531_hu9a36ad2327d0139feeb1c8e76c812997_7356_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681115534531_hu9a36ad2327d0139feeb1c8e76c812997_7356_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;AOV网拓扑排序例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;184px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上图拓扑排序的结果为：6,1,4,3,2,5（结果并不唯一）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当有向图中无环时，也可以利用深度优先遍历进行逆拓扑排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;查找&#34;&gt;查找&lt;/h1&gt;
&lt;p&gt;查找是一种常用的基本运算。查找表是指由同一类型的数据元素（或记录）构成的集合。&lt;/p&gt;
&lt;p&gt;查找表经常要进行的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询某个特定的数据元素是否在查找表中。&lt;/li&gt;
&lt;li&gt;检索某个特定的数据元素的各种属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常将只进行这两种操作的查找表称为&lt;strong&gt;静态查找表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;查找表经常要进行的另外两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在查找表中插入一个数据元素。&lt;/li&gt;
&lt;li&gt;从查找表中删除一个数据元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要在查找表中插入或删除元素，称此类查找表为&lt;strong&gt;动态查找表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;是数据元素（或记录）的某个数据项的值，用它来识别（标识）这个数据元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主关键字&lt;/strong&gt;：能唯一标识一个数据元素的关键字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;次关键字&lt;/strong&gt;：能标识多个数据元素的关键字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;平均查找长度&#34;&gt;平均查找长度&lt;/h2&gt;
&lt;p&gt;查找算法基本操作是&lt;u&gt;“将记录的关键字与给定值进行比较”&lt;/u&gt;。因此，通常&lt;u&gt;以“其关键字和给定值进行过比较的记录个数的期望值”作为衡量查找算法好坏的依据&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;查找算法在查找成功时的&lt;u&gt;平均查找长度&lt;/u&gt;关键字和给定值比较次数的期望值：&lt;/p&gt;
&lt;p&gt;$$
ASL = \sum_{i=1}^{n}{P_iC_i}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P_i$为对表中第$i$个记录进行查找的概率，&lt;/p&gt;
&lt;p&gt;一般认为$P_i=\cfrac{1}{n}, 1 \le i \le n$，即$\sum_{i=1}^{n}{P_i}$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$C_i$为查找成功时，已经进行过比较的关键字个数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查找算法&#34;&gt;查找算法&lt;/h2&gt;
&lt;p&gt;静态查找表有以下查找方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序查找；&lt;/li&gt;
&lt;li&gt;折半查找；&lt;/li&gt;
&lt;li&gt;分块查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态查找表有以下查找方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉排序树；&lt;/li&gt;
&lt;li&gt;平衡排序树；&lt;/li&gt;
&lt;li&gt;B-树；&lt;/li&gt;
&lt;li&gt;哈希表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;顺序查找&#34;&gt;顺序查找&lt;/h3&gt;
&lt;p&gt;顺序查找是从表的一端开始，按照顺序（从左往右或从右往左）逐一进行查找。顺序查找的方法&lt;u&gt;对于&lt;strong&gt;顺序存储方式&lt;/strong&gt;和&lt;strong&gt;链式存储方式&lt;/strong&gt;的查找表都适用&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;顺序查找中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：&lt;/p&gt;
&lt;p&gt;$$
ASL_{ss} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i+1)} = \cfrac{n+1}{2}
$$&lt;/p&gt;
&lt;h3 id=&#34;二分查找&#34;&gt;二分查找&lt;/h3&gt;
&lt;p&gt;二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。步骤如下：&lt;/p&gt;
&lt;p&gt;以升序数列$L[0&amp;hellip;n-1]$为例，假设要查找的数为$x$：&lt;/p&gt;
&lt;p&gt;让$x$与数列中间位置的元素$L\left[ \left\lfloor \cfrac{n}{2} \right\rfloor \right]$进行比较，如果相等则返回该元素下标，否则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$x$比中间元素小，递归地对中间元素左边的数列（比$x$小的元素）进行二分查找；&lt;/li&gt;
&lt;li&gt;如果$x$比中间元素大，递归地对中间元素右边的数列（比$x$大的元素）进行二分查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;折半查找的过程可用二叉树描述。$n$个结点的二叉树深度为$\lfloor log_2{n} \rfloor + 1$，折半查找进行比较的关键字个数最多不超过树的深度。所以，折半查找在查找成功时和给定值&lt;u&gt;进行比较的关键字个数最多为$\lfloor log_2{n} \rfloor + 1$&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;折半查找的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：&lt;/p&gt;
&lt;p&gt;$$
ASL_{bs} = \cfrac{1}{n} \sum_{i=1}^{n}{i \times 2^{i-1}} = \cfrac{n+1}{n} log_2{(n+1)} - 1
$$&lt;/p&gt;
&lt;p&gt;当$n$值较大时，$ASL_{bs} \approx log_2{(n+1)} - 1$。&lt;/p&gt;
&lt;h1 id=&#34;哈希表&#34;&gt;哈希表&lt;/h1&gt;
&lt;p&gt;哈希表查找（又叫散列表查找）是通过散列技术，将存储位置和关键字构建一个确定的关系$H$，使得每个关键字$key$对应一个存储位置$H(key)$。其中，$H$称为哈希函数或者散列函数。&lt;/p&gt;
&lt;p&gt;根据设定的&lt;strong&gt;哈希函数&lt;/strong&gt;$H(key)$和&lt;strong&gt;处理冲突的方法&lt;/strong&gt;，将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这块连续的空间称为哈希表或散列表，这一映射过程称为&lt;strong&gt;哈希造表&lt;/strong&gt;或&lt;strong&gt;散列表&lt;/strong&gt;，所得的存储位置称为&lt;strong&gt;哈希地址&lt;/strong&gt;或&lt;strong&gt;散列地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于哈希表，主要考虑两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何构造哈希函数；&lt;/li&gt;
&lt;li&gt;如何解决冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;冲突&#34;&gt;冲突&lt;/h2&gt;
&lt;p&gt;对于某个哈希函数$H$和两个关键字$key_1$和$key_2$,如果$key_1 \neq key_2$，而$H(key_1)=H(key_2)$，则称为冲突。&lt;/p&gt;
&lt;p&gt;具有相同哈希函数值的关键字对该哈希函数来说称为同义词。&lt;/p&gt;
&lt;p&gt;一般情况下，冲突只能尽可能减少而不能完全避免。&lt;/p&gt;
&lt;h2 id=&#34;哈希函数的构造方法&#34;&gt;哈希函数的构造方法&lt;/h2&gt;
&lt;p&gt;常用的哈希函数构造方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接定址法；&lt;/li&gt;
&lt;li&gt;数字分析法；&lt;/li&gt;
&lt;li&gt;平方取中法；&lt;/li&gt;
&lt;li&gt;折叠法；&lt;/li&gt;
&lt;li&gt;随机数法；&lt;/li&gt;
&lt;li&gt;除留余数法……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈希函数的构造要考虑到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩性：节省存储空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;散列性：尽量减少冲突。&lt;/p&gt;
&lt;p&gt;要减少冲突，就要设法使哈希函数尽可能均匀地把关键字映射到存储区的各个存储单元。在构造哈希函数时，一般都要对关键字进行计算，且尽可能使关键字的所有组成部分都能起作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;除留取余数法&#34;&gt;除留取余数法&lt;/h3&gt;
&lt;p&gt;除留取余数法是最常用的构造散列函数方法。&lt;/p&gt;
&lt;p&gt;除留取余数法：&lt;/p&gt;
&lt;p&gt;$$
f(key)=key \enspace mod \enspace p\quad (p\le m),\ m为散列表长
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$mod$ 是取模运算。&lt;/p&gt;
&lt;p&gt;根据经验，若散列表表长为$m$，通常$p$为小于或等于表长（最好接近$m$）的最小质数，可以更好的减小冲突。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;冲突处理方法&#34;&gt;冲突处理方法&lt;/h2&gt;
&lt;p&gt;解决冲突就是为出现冲突的关键字找到另一个“空”的哈希地址。在处理冲突的过程中可能得到一个地址序列$H_i,(i=1,2,\dots,k)$。常见的处理冲突的方法有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放地址法；&lt;/li&gt;
&lt;li&gt;多重散列法（再哈希法）；&lt;/li&gt;
&lt;li&gt;链地址法；&lt;/li&gt;
&lt;li&gt;公共溢出区法……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;开放地址法&#34;&gt;开放地址法&lt;/h3&gt;
&lt;p&gt;开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。&lt;/p&gt;
&lt;p&gt;有三种寻找空散列地址的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线性探测法（线性探测再散列）：&lt;/p&gt;
&lt;p&gt;$$
H_i=(H(key)+d) mod m
$$&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$d$取$0,1,2,&amp;hellip;,m-1$；&lt;/li&gt;
&lt;li&gt;$m$为散列表的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二次探测法（二次探测再散列）：&lt;/p&gt;
&lt;p&gt;$$
H_i=(H(key)+q^2) mod m
$$&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$q$取$0,1,-1,2,-2,&amp;hellip;,\pm k$，$k \le \cfrac{m}{2}$&lt;/li&gt;
&lt;li&gt;$m$为散列表的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二次探测法其实是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线性探测法市能使第$i$个哈希地址的同义词存入第$i+1$个哈希地址，这样本应存入第$i+1$个哈希地址的元素变成了第$i+2$个哈希地址元素的同义词，……，因此，可能出现很多元素在相邻的哈希地址上“聚集”起来的现象，大大降低了查找效率。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;排序&#34;&gt;排序&lt;/h1&gt;
&lt;p&gt;排序算法有稳定排序和不稳定排序两种。假设待排序序列中，$R_i$和$R_j$关键字相同，即$k_i=k_j$，且$R_i$领先与$R_j$排序后&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定排序&lt;/strong&gt;：排序后$R_i$和$R_j$相对次序不变，$R_i$任领先于$R_j$；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不稳定排序&lt;/strong&gt;：排序后可能出现$R_j$领先于$R_i$的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据记录存储的位置可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内部排序&lt;/strong&gt;：待排序记录存储在内存中进行排序的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部排序&lt;/strong&gt;：排序记录的数量很大，内存无法容纳全部记录，在排序过程需要对外存进行访问的排序过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;排序过程需要进行的两种基本操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;比较两个关键字的大小。&lt;/p&gt;
&lt;p&gt;这种操作对于大多数排序方法来说是必需的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将记录从一个位置移动到另一个位置。&lt;/p&gt;
&lt;p&gt;这种操作可以通过改变记录的存储方式来避免。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;排序算法及其时间、空间复杂度：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;排序算法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;平均时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;最坏时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;最好时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;空间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;稳定性&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否归位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;直接插入排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;稳定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;希尔排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^{1.3})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不稳定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单选择排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不稳定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;堆排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不稳定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冒泡排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;稳定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;快速排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n^2)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(log_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不稳定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;归并排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(nlog_2{n})$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(n)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;稳定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;是否归位：在排序过程中，能否确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;
&lt;p&gt;选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去都是 $O(n²)$ 的时间复杂度。&lt;/p&gt;
&lt;p&gt;算法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。&lt;/li&gt;
&lt;li&gt;再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。&lt;/li&gt;
&lt;li&gt;重复步骤2，直到所有元素均排序完毕。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;归位：在排序过程中，能确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;selectionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; arr[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; ; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; ; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)     &lt;span style=&#34;color:#75715e&#34;&gt;// 走访未排序的元素
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 找到最小值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (arr[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; arr[min])
                min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; j;
        &lt;span style=&#34;color:#75715e&#34;&gt;// i 不是最小数时，将 i 和最小数进行交换
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; min)
        {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[i];
            arr[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[min];
            arr[min] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp; 
        }
    }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; arr[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { 
        &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;34&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;82&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;89&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;37&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;35&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;70&lt;/span&gt; };
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;arr);
    selectionSort(arr, len);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, arr[i]);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;
&lt;p&gt;冒泡排序（Bubble Sort）是一种简单直观的排序算法。&lt;/p&gt;
&lt;p&gt;这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/p&gt;
&lt;p&gt;算法步骤：&lt;/p&gt;
&lt;p&gt;假设一个序列长度为n，m（m≤n）是已排序完成的在末尾的数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。对比结束后，最后的元素会是最大的数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对接下来n-m个未排序的数重复步骤1和2，直到没有任何一对数字需要比较。&lt;/p&gt;
&lt;p&gt;第一趟对序列中所有n个数进行比对，第二趟对序列中n-1个未排序完成的数进行比对，以此类推。每次比对的数为n-m。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;归位：在排序过程中，能确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbleSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; arr[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (arr[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; arr[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
            {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[j];
                arr[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                arr[j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp;
            }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; arr[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { 
        &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;34&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;82&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;89&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;37&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;35&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;70&lt;/span&gt; };
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;arr);
    bubbleSort(arr, len);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, arr[i]);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;直接插入排序&#34;&gt;直接插入排序&lt;/h2&gt;
&lt;p&gt;直接插入排序的做法是：在插入第$i$个记录（$R_i$）时，序列中的前$i-1$个记录$R_1,R_2,\cdots,R_{i-1}$已排好序。将$R_i$与前面的有序序列做比较，找到应该插入的位置将$R_i$插入，并将插入位置后的记录依序向后移动。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。&lt;/p&gt;
&lt;p&gt;对于基本有序的序列用直接插入排序效率是最高的。&lt;/p&gt;
&lt;p&gt;不归位：在排序过程中，不能确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h2&gt;
&lt;p&gt;希尔排序又称为“缩小增量排序”，它是对直接插入排序方法的改进。&lt;/p&gt;
&lt;p&gt;希尔排序的基本思想是：先将整个待排记录序列分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择一个增量序列$t_1,t_2,&amp;hellip;,t_k$，其中$t_i &amp;lt; t_{i-1}(1 \le i \le k),t_k = 1$；&lt;/p&gt;
&lt;p&gt;一般来说，$t_1 \le \cfrac{n}{2}$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按增量序列个数$k$，对序列进行$k$趟排序；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为$t_i$的子序列，分别对各子表进行直接插入排序。仅增量因子为$1$时，整个序列作为一个表来处理，表长度即为整个序列的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681209778321.png&#34;
	width=&#34;649&#34;
	height=&#34;460&#34;
	srcset=&#34;https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681209778321_hu3445f2349c32f6de565415fce2b1b7c8_87538_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1681209778321_hu3445f2349c32f6de565415fce2b1b7c8_87538_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;338px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归位：在排序过程中，能确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;计数排序&#34;&gt;计数排序&lt;/h2&gt;
&lt;p&gt;计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。&lt;/p&gt;
&lt;p&gt;当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是$Θ(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。&lt;/p&gt;
&lt;p&gt;由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计数排序是用来排序0到100之间的数字的最好的算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出待排序的数组中最大和最小的元素。&lt;/li&gt;
&lt;li&gt;统计数组中每个值为 &lt;code&gt;i&lt;/code&gt;的元素出现的次数，存入数组 &lt;code&gt;C&lt;/code&gt;的第 &lt;code&gt;i&lt;/code&gt;项。&lt;/li&gt;
&lt;li&gt;对所有的计数累加（从 &lt;code&gt;C&lt;/code&gt;中的第一个元素开始，每一项和前一项相加）。&lt;/li&gt;
&lt;li&gt;反向填充目标数组：将每个元素 &lt;code&gt;i&lt;/code&gt;放在新数组的第 &lt;code&gt;C(i)&lt;/code&gt; 项，每放一个元素就将 &lt;code&gt;C(i)&lt;/code&gt; 减去 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;堆排序&#34;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。&lt;/p&gt;
&lt;p&gt;堆积是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;/p&gt;
&lt;p&gt;堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；&lt;/li&gt;
&lt;li&gt;小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算法步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将待排序的数组构造出一个堆 &lt;code&gt;H[0……n-1]&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把堆首（堆顶结点，即最大值）和堆尾（堆的最下层最右边的结点）互换；&lt;/p&gt;
&lt;p&gt;此时不再对原堆顶（最大值）进行操作，即原堆顶已经被“移出”，堆的长度缩小1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把新的数组顶端数据调整到相应位置；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复步骤 2 到 3，直到堆的尺寸为 1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;归位：在排序过程中，能确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。&lt;/p&gt;
&lt;p&gt;算法步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从序列中选择一个元素作为“基准”（pivot）。&lt;/li&gt;
&lt;li&gt;将所有比基准数小的放在基准左边，所有比基准数大的放在基准右边（相同的数可以在任一边）。这个称为分区（partition）操作。&lt;/li&gt;
&lt;li&gt;分区完成后，该基准就会归到序列中的相应位置，该位置是排序完成后的位置。&lt;/li&gt;
&lt;li&gt;分别递归地把小于基准数的子序列（左边）和大于基准数的子序列（右边）重复执行1到3操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;归位：在排序过程中，能确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;p&gt;归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。&lt;/p&gt;
&lt;p&gt;作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自上而下的递归；&lt;/li&gt;
&lt;li&gt;自下而上的迭代。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；&lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置；&lt;/li&gt;
&lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；&lt;/li&gt;
&lt;li&gt;重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;不归位：在排序过程中，不能确定某些元素的最终排序位置。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>程序设计语言（软件设计师）</title>
        <link>https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <pubDate>Thu, 30 Mar 2023 19:58:41 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</guid>
        <description>&lt;h1 id=&#34;低级和高级语言&#34;&gt;低级和高级语言&lt;/h1&gt;
&lt;p&gt;程序设计语言根据硬件是否能识别区分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低级语言&lt;/strong&gt;：二进制机器指令、汇编语言。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级语言&lt;/strong&gt;：面向各类应用的程序设计语言，更加接近自然语言。需要通过编译器或解释器（翻译）来让机器执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;编译和解释&#34;&gt;编译和解释&lt;/h1&gt;
&lt;p&gt;程序设计语言按照翻译的方式可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;：需要通过&lt;strong&gt;编译器&lt;/strong&gt;（&lt;strong&gt;编译程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;编译为包含二进制指令的&lt;u&gt;可执行文件（目标程序）&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;真正在机器上运行的是与源程序（逻辑）等价的目标程序。&lt;/p&gt;
&lt;p&gt;源程序和编译器都不再参与目标程序的运行过程。&lt;/p&gt;
&lt;p&gt;汇编程序也是属于编译执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：需要通过&lt;strong&gt;解释器&lt;/strong&gt;（&lt;strong&gt;解释程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;中的指令解释为二进制指令后给机器执行。&lt;/p&gt;
&lt;p&gt;该过程不会产生独立的目标程序。&lt;/p&gt;
&lt;p&gt;并且解释器和源程序都会参与到程序的运行过程（运行控制）中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与编译方式相比，解释方式程序执行的速度慢，因为解释方式执行的程序，需要解释器在其中充当一个原程序与机器之前实时的翻译。&lt;/p&gt;
&lt;p&gt;脚本语言属于动态语言，其程序结构可以在运行中改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译过程&#34;&gt;编译过程&lt;/h2&gt;
&lt;p&gt;编译程序的功能是把某高级语言书写的&lt;u&gt;源程序翻译成与之等价的目标程序&lt;/u&gt;（汇编语言或机
器语言)。&lt;/p&gt;
&lt;p&gt;编译程序的工作过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680232196718.png&#34;
	width=&#34;549&#34;
	height=&#34;466&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;282px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其中，以下几个阶段对于编译过程来说是必须的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下两个阶段对于编译过程来说不是必须的（可省略）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;li&gt;（中间或目标）代码优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;词法分析&#34;&gt;词法分析&lt;/h3&gt;
&lt;p&gt;源程序可以简单地被看成是一个&lt;u&gt;多行的字符串&lt;/u&gt;。&lt;strong&gt;词法分析&lt;/strong&gt;阶段的任务是&lt;u&gt;对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号&lt;/u&gt;。&lt;strong&gt;“单词”符号&lt;/strong&gt;是程序设计语言的&lt;strong&gt;基本语法单位&lt;/strong&gt;，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。&lt;/p&gt;
&lt;p&gt;词法分析程序输出的“单词”&lt;u&gt;常以&lt;strong&gt;二元组&lt;/strong&gt;的方式输出&lt;/u&gt;，即单词种别和单词自身的值。&lt;/p&gt;
&lt;p&gt;词法分析过程依据的是语言的&lt;u&gt;词法规则&lt;/u&gt;，即描述“单词”结构的规则。&lt;/p&gt;
&lt;h4 id=&#34;词法规则&#34;&gt;词法规则&lt;/h4&gt;
&lt;p&gt;词法分析根据词法规则将构成源程序的字符串转换成单词符号序列。词法规则可用3型文法（正规文法）或正规表达式描述。&lt;/p&gt;
&lt;h5 id=&#34;正规表达式&#34;&gt;正规表达式&lt;/h5&gt;
&lt;p&gt;正规表达式（正规式）有以下符号：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;闭包&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示其前面链接的符号或集合可以出现$[0, +\infty]$次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;·&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;连接&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可省略，将多个符号或集合连接起来。表示逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;或&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示逻辑或。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680248469003.png&#34;
	width=&#34;990&#34;
	height=&#34;277&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;357&#34;
		data-flex-basis=&#34;857px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;设$U$、$V$和$W$均为正规式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680249034196.png&#34;
	width=&#34;974&#34;
	height=&#34;185&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;526&#34;
		data-flex-basis=&#34;1263px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;有限自动机&#34;&gt;有限自动机&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;有限自动机&lt;/strong&gt;是词法分析的一个工具（一种识别装置的抽象概念），它能正确地&lt;strong&gt;识别正规集&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定的有限自动机&lt;/strong&gt;（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个DFA是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$S$：包含&lt;u&gt;状态的有限集&lt;/u&gt;（每个元素称为一个状态）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Sigma$：有穷&lt;u&gt;字母表&lt;/u&gt;，其每个元素称为一个&lt;u&gt;输入字符&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f$：$S \times \Sigma \to S$ 上的&lt;u&gt;单值部分映像&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$&lt;/p&gt;
&lt;p&gt;表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$s_0$：唯一的&lt;u&gt;开始状态&lt;/u&gt;，$s_0 \in S$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Z$：非空的&lt;u&gt;终止状态集合&lt;/u&gt;，$Z \subseteq S$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFA可以用两种直观的方式表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换图&lt;/strong&gt;：简称为转换图，是一个有向图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;状态&lt;/strong&gt;对应转换图中的一个&lt;strong&gt;结点&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;转换函数&lt;/strong&gt;对应图中的一条&lt;strong&gt;有向弧&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双圈表示的结点是终态结点。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;终态也可以是初态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换矩阵&lt;/strong&gt;：用一个二位数组$M$表示。&lt;/p&gt;
&lt;p&gt;矩阵元素$M[A,a]$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行下标&lt;/strong&gt;：表示状态。当前状态为$A$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列下标&lt;/strong&gt;：表示输入的字符。当前输入为$a$。&lt;/li&gt;
&lt;li&gt;$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680251834262.png&#34;
	width=&#34;983&#34;
	height=&#34;160&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;614&#34;
		data-flex-basis=&#34;1474px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680251962756.png&#34;
	width=&#34;982&#34;
	height=&#34;585&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不确定的有限自动机&lt;/strong&gt;（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是不唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;NFA也是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$f$是$S \times \Sigma \to 2^S$ 上的映像。&lt;/p&gt;
&lt;p&gt;对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DFA是NFA的特例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680252743732.png&#34;
	width=&#34;918&#34;
	height=&#34;407&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;541px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有向弧中出现如 $a,b$，代表该有向弧输入的值可以为$a$&lt;strong&gt;或&lt;/strong&gt;$b$。即&lt;code&gt;,&lt;/code&gt;代表或。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;语法分析&#34;&gt;语法分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语法分析&lt;/strong&gt;的任务是在词法分析的基础上，&lt;u&gt;根据语言的语法规则将单词符号序列分解成各类语法单位&lt;/u&gt;，如“表达式”“语句”和“程序”等。&lt;/p&gt;
&lt;p&gt;如果源程序中没有语法错误，语法分析后就能正确地&lt;u&gt;构造出其语法树&lt;/u&gt;；否则&lt;u&gt;指出语法错误&lt;/u&gt;，并&lt;u&gt;给出相应的诊断信息&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;例如对&lt;code&gt;id1 := id2 + id3 * 60&lt;/code&gt;进行语法分析后形成的语法树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680233200526.png&#34;
	width=&#34;888&#34;
	height=&#34;266&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;333&#34;
		data-flex-basis=&#34;801px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;词法分析和语法分析在本质上都是对源程序的结构进行分析。&lt;/p&gt;
&lt;p&gt;到达语法分析阶段可以发现程序中所有的语法错误。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量的值是否正确；&lt;/li&gt;
&lt;li&gt;语句的形式是否正确；&lt;/li&gt;
&lt;li&gt;语句的结构是否合法；&lt;/li&gt;
&lt;li&gt;检查括号是否匹配；&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法分析方法有多种，根据产生语法树的方向，可分为&lt;strong&gt;自底向上&lt;/strong&gt;和&lt;strong&gt;自顶向下&lt;/strong&gt;两类。&lt;/p&gt;
&lt;h4 id=&#34;上下文无关文法&#34;&gt;上下文无关文法&lt;/h4&gt;
&lt;p&gt;程序设计语言的&lt;u&gt;绝大多数&lt;strong&gt;语法规则&lt;/strong&gt;可以采用&lt;strong&gt;上下文无关文法&lt;/strong&gt;进行描述&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;上下文无关文法属于乔姆斯基定义的2型文法。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法，$G[S] = (V_N, V_T, P, S)$，其产生式的形式都是 $A \to \beta$，其中 $A \in V_n$，$\beta \in (V_N \cup V_T)^*$。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V_N$：非终结符号集合，&lt;/li&gt;
&lt;li&gt;$V_T$：终结符号集合，&lt;/li&gt;
&lt;li&gt;$P$：产生式集合，&lt;/li&gt;
&lt;li&gt;$S$：开始符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680255073014.png&#34;
	width=&#34;990&#34;
	height=&#34;393&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;251&#34;
		data-flex-basis=&#34;604px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上下文无关文法的推导过程可用树型结构描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680255429332.png&#34;
	width=&#34;210&#34;
	height=&#34;346&#34;
	srcset=&#34;https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;60&#34;
		data-flex-basis=&#34;145px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由上下文无关文法的推导过程也可以看出它是自顶向下推导。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法中的集合，有以下对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$S \to P$&lt;/li&gt;
&lt;li&gt;$P \to V_N$&lt;/li&gt;
&lt;li&gt;$V_N \to V_T$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语义分析&#34;&gt;语义分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语义分析&lt;/strong&gt;阶段分析各语法结构的含义，&lt;u&gt;检查源程序是否包含静态语义错误&lt;/u&gt;，并&lt;u&gt;收集类型信息&lt;/u&gt;供后面的代码生成阶段使用。&lt;u&gt;只有语法和语义都正确的源程序才能翻译成正确的目标代码。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;语义分析的一个主要工作是&lt;u&gt;进行类型分析和检查&lt;/u&gt;。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。&lt;/p&gt;
&lt;p&gt;语义分析阶段的输入是上一个阶段（语法分析）所构造的语法树。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析后语法树中可能会出现一些语义处理结点。例如&lt;code&gt;inttoreal&lt;/code&gt;，表示将一个整型数转换为浮点数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析不能发现程序中所有的语义错误。语义分析只能发现静态语义错误，动态语义错误需要在生成目标程序后运行时才能发现。&lt;/p&gt;
&lt;p&gt;有语义错误是可以编译成功的。例如&lt;code&gt;a/0&lt;/code&gt;，符合语法，也符合静态语义，编译器检验不出来这个是错的，只有运行才会报错，也就是动态语义，动态语义错误常见的还有死循环。&lt;/p&gt;
&lt;p&gt;PS：现在有些IDE会对一些常见的动态语义错误进行检查，在程序编译前提示给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;中间代码生成&#34;&gt;中间代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;中间代码生成&lt;/strong&gt;阶段的工作是&lt;u&gt;根据语义分析的输出生成中间代码&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。最常用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。四元式的形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(运算符, 运算对象1, 运算对象2, 运算结果)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;语义分析和中间代码生成所依据的是语言的语义规则。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;中间代码生成阶段&lt;/u&gt;对于编译过程来说是&lt;u&gt;可省略的&lt;/u&gt;。但是&lt;u&gt;前面的三个阶段词法分析、语法分析和语义分析还有最后的目标代码生成是不可省略的&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;编译器前后端&#34;&gt;编译器前后端&lt;/h4&gt;
&lt;p&gt;对于编译过程的各个阶段，在逻辑上可以把它们划分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;中间代码优化&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以中间代码为分水岭（中间代码作为前端的输出，然后再作为后端的输入来连接前后端），把编译器分成了与机器有关的部分（后端）和与机器无关的部分（前端）。如此一来，对于同一种程序设计语言的编译器，开发出一个前端之后，就可以针对不同的机器开发相应的后端，前、后端有机结合后就形成了该语言的一个编译器。当语言有改动时，只会涉及前端部分的维护。&lt;/p&gt;
&lt;p&gt;对于不同的程序设计语言，分别设计出相应的前端，然后将各个语言的前端与同一个后端相结合，就可以得到各个语言在某种机器上的编译器。&lt;/p&gt;
&lt;p&gt;使用中间代码，将编译器分为前后端的好处是，有利于编译程序的可移植性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译程序的可移植性提高了，那么相应的源程序（源代码）的可移植也会提高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;中缀和后缀表达式&#34;&gt;中缀和后缀表达式&lt;/h4&gt;
&lt;p&gt;中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。&lt;/p&gt;
&lt;p&gt;根据生成的语法树，按照不同的方式遍历即可生成形式不同的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中缀表达式：中序遍历（左-根-右）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀表达式：后序便利（左-右-根）。&lt;/p&gt;
&lt;p&gt;后缀转中缀用到了栈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;逆波兰式其实就是后缀式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;代码优化&#34;&gt;代码优化&lt;/h3&gt;
&lt;p&gt;由于编译器将源程序翻译成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间上和空间上有较大的浪费。&lt;u&gt;当需要生成高效的目标代码时，必须进行优化。&lt;/u&gt;优化过程&lt;u&gt;可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;由于中间代码不依赖于具体机器，此时&lt;u&gt;所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关&lt;/u&gt;。优化所依据的原则是&lt;strong&gt;程序的等价变换规则&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;目标代码生成&#34;&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标代码&lt;/strong&gt;生成阶段的任务是&lt;u&gt;把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码&lt;/u&gt;，这个阶段的工作&lt;strong&gt;与具体的机器密切相关&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;寄存器的分配：寄存器访问速度快，但数量有限，所以如何分配及使用寄存器是目标代码生成时需要着重考虑的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译过程中为变量分配的存储单元所用的地址是&lt;strong&gt;逻辑地址&lt;/strong&gt;，程序运行时再将逻辑地址映射为物理地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;符号表管理&#34;&gt;符号表管理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;符号表&lt;/strong&gt;的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录源程序中各个符号的必要信息；&lt;/li&gt;
&lt;li&gt;辅助语义的正确性检查和代码生成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;符号表在前三个阶段构建&lt;/u&gt;：可以始于词法分析阶段，也可以放到语法分析和语义分析阶段&lt;/li&gt;
&lt;li&gt;符号表的使用有时会&lt;u&gt;延续到目标代码的运行阶段&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编译过程中翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需的信息正确地填入符号表；对可执行语句，则是将其翻译成中间代码或目标代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;出错处理&#34;&gt;出错处理&lt;/h3&gt;
&lt;p&gt;编写的源程序中出现的错误分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态错误&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;编译阶段发现的程序错误，又可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法错误：有关语言结构上的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态语义错误：运算符与运算对象类型不合法等错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态错误&lt;/strong&gt;（动态语义错误）：发生在程序运行时。&lt;/p&gt;
&lt;p&gt;常见的动态错误例如除数为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译时发现程序中的错误后，编译程序应采用适当的策略修复它们，使得分析过程能够继续下去，以便在一次编译过程中尽可能多地找出程序中的错误。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;程序设计语言的基本成分&#34;&gt;程序设计语言的基本成分&lt;/h1&gt;
&lt;p&gt;程序设计语言的基本成分包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;运算&lt;/li&gt;
&lt;li&gt;控制&lt;/li&gt;
&lt;li&gt;传输&lt;/li&gt;
&lt;li&gt;（函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据成分&#34;&gt;数据成分&lt;/h2&gt;
&lt;p&gt;数据成分包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识符&lt;/strong&gt;：标识符通常是由字母、数字和下划线&lt;code&gt;_&lt;/code&gt;组成，并且不能由数字开头。&lt;/p&gt;
&lt;p&gt;一般有如下种类标识符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字。&lt;/li&gt;
&lt;li&gt;变量名。&lt;/li&gt;
&lt;li&gt;函数名。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;现在，某些高级语言已经支持中文等字符来当作变量名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量&lt;/strong&gt;：一般有&lt;u&gt;字面量&lt;/u&gt;（例如&lt;code&gt;123&lt;/code&gt;、&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;）和&lt;u&gt;不可变变量（在某些语言中也称其为常量）&lt;/u&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常量也具有类型；&lt;/li&gt;
&lt;li&gt;常量也有对应的存储单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt;：用来存储数据或对象。有存储类别、类型、名称（变量名）、作用域和生存周期等属性（这些也是数据的属性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为整个文件或程序&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;局部量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为定义它的函数或语句块中&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;：按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型（C和C++）及其他类型等。&lt;/p&gt;
&lt;p&gt;许多程序设计语言都规定，程序中的数据都必须具有类型，其作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分配存储单元&lt;/strong&gt;：便于为数据合理分配存储单元；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;检查数据对象&lt;/strong&gt;：便于对参与表达式计算的数据对象进行（合法性）检查；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取值范围&lt;/strong&gt;：便于规定数据对象的取值范围及能够进行的运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;动态数据结构，其数据的结构会在程序运行过程中改变，例如链表、二叉树等。&lt;/p&gt;
&lt;p&gt;动态数据结构的数据空间必须采用&lt;strong&gt;堆存储&lt;/strong&gt;分配策略，数据存放在&lt;strong&gt;堆区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在C/C++中，全局变量的存储空间在静态数据区分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;运算成分&#34;&gt;运算成分&lt;/h2&gt;
&lt;p&gt;大多数高级程序设计语言的基本运算可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算。&lt;/li&gt;
&lt;li&gt;关系运算。&lt;/li&gt;
&lt;li&gt;逻辑运算。&lt;/li&gt;
&lt;li&gt;位运算。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;
&lt;p&gt;有以下三种结构来构造程序中的控制逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序结构。&lt;/li&gt;
&lt;li&gt;选择结构。&lt;/li&gt;
&lt;li&gt;循环结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数高级语言都针对循环结构提供了&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;等控制流跳转语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;传输成分&#34;&gt;传输成分&lt;/h2&gt;
&lt;p&gt;程序设计语言的传输成分指明语言允许的数据传输方式，如赋值处理、数据的输入和输出等。&lt;/p&gt;
&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数首部：
&lt;ul&gt;
&lt;li&gt;返回值类型&lt;/li&gt;
&lt;li&gt;函数名&lt;/li&gt;
&lt;li&gt;形参表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数体：定义函数所实现的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;：在C（C++）中，函数需要先声明后引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数调用&lt;/strong&gt;：在调用函数中使用被调函数实现的功能。函数调用的一般形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数名(实参表)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用函数与被调函数之间参数的传递有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;值调用&lt;/strong&gt;（Call by Value）：形参是实参的一份拷贝。即实参将值传递给形参，对形参值的更改并不会作用到实参上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;引用调用&lt;/strong&gt;（Call by Reference）：形参是实参的一个别名。即函数中对形参的访问和修改实际上是对其相应实参所做的访问和修改。&lt;/p&gt;
&lt;p&gt;引用调用下，可以实现形参和实参之间数据的双向传递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在进行函数调用和返回时，由系统使用栈区来进行控制和管理。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>计算机系统（软件设计师）</title>
        <link>https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</guid>
        <description>&lt;h1 id=&#34;计算机的基本单位&#34;&gt;计算机的基本单位&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;位（比特）&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;bit、b&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;最小数据单位/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;字节&lt;/td&gt;
    &lt;td&gt;byte、B&lt;/td&gt;
    &lt;td&gt;1B = 8b&lt;/td&gt;
    &lt;td&gt;最小存储单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;千字节&lt;/td&gt;
    &lt;td&gt;KB&lt;/td&gt;
    &lt;td&gt;1KB = 1024B&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;兆字节&lt;/td&gt;
    &lt;td&gt;MB&lt;/td&gt;
    &lt;td&gt;1MB = 1024KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;吉字节&lt;/td&gt;
    &lt;td&gt;GB&lt;/td&gt;
    &lt;td&gt;1GB = 1024MB&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;太字节&lt;/td&gt;
    &lt;td&gt;TB&lt;/td&gt;
    &lt;td&gt;1TB = 1024GB&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;计算机系统&#34;&gt;计算机系统&lt;/h1&gt;
&lt;p&gt;计算机系统由&lt;u&gt;硬件&lt;/u&gt;和&lt;u&gt;软件&lt;/u&gt;组成。&lt;/p&gt;
&lt;p&gt;计算机基本硬件系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;中央处理单元&#34;&gt;中央处理单元&lt;/h1&gt;
&lt;p&gt;运算器、控制器等部件被集成在一起统称中央处理单元（CPU）。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。&lt;/p&gt;
&lt;p&gt;中央处理单元（CPU）负责获取程序指令、对指令进行译码并加以执行。&lt;/p&gt;
&lt;p&gt;CPU的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序控制：通过执行指令来控制程序的执行顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作控制：CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间控制：对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据处理：通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。&lt;/p&gt;
&lt;p&gt;对数据的加工处理也是CPU最根本的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对系统内部和外部的中断（异常）做出响应，进行相应的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;寄存器组&lt;/li&gt;
&lt;li&gt;内部总线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运算器&#34;&gt;运算器&lt;/h2&gt;
&lt;p&gt;运算器组成部件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;算术逻辑单元（ALU）：重要组成部件。负责处理数据，实现对数据的算术运算和逻辑运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;累加寄存器（AC，累加器）：是一个通用寄存器。存放操作数或者结果。&lt;/p&gt;
&lt;p&gt;其功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。例如，在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。
运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字，将不同时间段内读/写的数据隔离开来。&lt;/p&gt;
&lt;p&gt;DR的主要作用为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为CPU和内存、外部设备之间数据传送的中转站；&lt;/li&gt;
&lt;li&gt;作为CPU和内存、外围设备之间在操作速度上的缓冲；&lt;/li&gt;
&lt;li&gt;在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态（标志通常分别由1位触发器保存）。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制器&#34;&gt;控制器&lt;/h2&gt;
&lt;p&gt;控制器用于控制整个CPU的工作，它决定了计算机运行过程的
自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。&lt;/p&gt;
&lt;p&gt;指令控制逻辑要完&lt;u&gt;取指令&lt;/u&gt;、&lt;u&gt;分析指令&lt;/u&gt;和&lt;u&gt;执行指令&lt;/u&gt;的操作，其过程分为&lt;u&gt;取指令&lt;/u&gt;、&lt;u&gt;指令译码&lt;/u&gt;、&lt;u&gt;按指令操作码执行&lt;/u&gt;、&lt;u&gt;形成下一条指令地址&lt;/u&gt;等步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令寄存器（IR）：暂存要执行的指令，该指令从内存中获取（通过缓冲寄存器）。&lt;/p&gt;
&lt;p&gt;当CPU执行一条指令时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把指令从内存储器取到缓冲寄存器中。&lt;/li&gt;
&lt;li&gt;送入IR暂存。&lt;/li&gt;
&lt;li&gt;指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序计数器（PC，指令计数器）：具有寄存信息和计数两种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在程序开始执行前，将程序的起始地址送入PC。
该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。&lt;/li&gt;
&lt;li&gt;执行指令时，CPU自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。&lt;/p&gt;
&lt;p&gt;执行转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令译码器(ID)。指令包含操作码和地址码两部分，而指令译码器就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据表示&#34;&gt;数据表示&lt;/h1&gt;
&lt;h2 id=&#34;原码&#34;&gt;原码&lt;/h2&gt;
&lt;p&gt;原码表示法又叫符号加绝对值表示法。最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。&lt;/p&gt;
&lt;p&gt;原码特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0的表示不唯一（有正负0）；&lt;/li&gt;
&lt;li&gt;加、减运算方式不统一；&lt;/li&gt;
&lt;li&gt;需额外对符号位进行处理，不利于硬件设计；&lt;/li&gt;
&lt;li&gt;当 $a &amp;lt; b$ 时，实现 $a-b$ 比较困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反码&#34;&gt;反码&lt;/h2&gt;
&lt;p&gt;最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。正数的反码与原码相同，负数的反码则是除符号位以外其余各位按位取反。&lt;/p&gt;
&lt;h2 id=&#34;补码&#34;&gt;补码&lt;/h2&gt;
&lt;p&gt;计算机中的补码是模2补码&lt;/p&gt;
&lt;p&gt;概念：在一个模运算（Moduler Arithmetic）系统中，同余（Congruence Modulo）的数等价。&lt;/p&gt;
&lt;p&gt;补码的定义：有 $n$ 位时，$[X]_补=(2^n+X)\mod{2^n}\quad (-2^{n-1}\leq X&amp;lt;2^{n-1})$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 $X&amp;lt;0$ 时，补码有两种求法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各位取反，末位加 1。&lt;/li&gt;
&lt;li&gt;从第 2 个 1 开始往右各位取反。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 $X&amp;gt;0$ 时，补码与原码相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码的减法：$Y-X=Y+[-X]_补$。&lt;/p&gt;
&lt;p&gt;特殊的补码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$[-2^{n-1}]_补=(2^n-2^{n-1})\mod{2^n}=(10\ldots0)_2\ (n-1 个0)$。&lt;/p&gt;
&lt;p&gt;这个数的最高位（符号位）即表示符号，又表示数值。如，-128。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$[-1]_补=2^n-1=(11\ldots1)_2\ (n个1)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$[+0]_补=[-0]_补=(00\ldots0)\ (n个0)$。
补码的0表示唯一。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;移码&#34;&gt;移码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;移码就是将每个数值加上一个偏置常数（Excess/Bias）。&lt;/li&gt;
&lt;li&gt;通常，当编码位数为 $n$ 时，bias 取 $2^{n-1}$ 或 $2^{n-1}-1$。&lt;/li&gt;
&lt;li&gt;移码可以方便地进行大小的比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移码可以看成是在其补码的基础上对符号位取反。移码的0表示唯一。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实（个人认为）根据补码和移码的定义，可以将补码当作特殊的移码。其bias为$2^n$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;各种码制带符号数的范围&#34;&gt;各种码制带符号数的范围&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4.png&#34;
	width=&#34;1174&#34;
	height=&#34;273&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;430&#34;
		data-flex-basis=&#34;1032px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数&lt;/h2&gt;
&lt;p&gt;浮点数使用两个定点数来分别表示实数的尾数（F）和阶码（E）。其一般形式为：$N=2^E \times F$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个数的浮点表示不是唯一的。小数点位置改变，阶码也随着相应改变。&lt;/li&gt;
&lt;li&gt;浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规格化浮点数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尾数$M \ge 0$，其规格化尾数形式为$M=0.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[0.5,1]$。&lt;/li&gt;
&lt;li&gt;尾数$M \le 0$，其规格化尾数形式为$M=1.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[-1,-0.5]$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般浮点数阶码用R位的移码表示，尾数用M位的补码表示。这种表示的数值范围为：&lt;/p&gt;
&lt;p&gt;$$
-1 \times 2^{(2^{R-1}-1)} \sim +(1-2^{-M+1}) \times 2^{(2^{R-1}-1)}
$$&lt;/p&gt;
&lt;p&gt;现在所有通用计算机都采用 IEEE 754 来表示浮点数。IEEE 754 的尾数用原码表示，阶码还是用移码表示。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;寻址方式&#34;&gt;寻址方式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;立即寻址：操作数就包含在指令中。&lt;/li&gt;
&lt;li&gt;直接寻址：操作数在内存，指令给出操作数的地址。&lt;/li&gt;
&lt;li&gt;寄存器寻址：操作数在寄存器，指令给出操作数的寄存器名（地址）。&lt;/li&gt;
&lt;li&gt;寄存器间接寻址：操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。&lt;/li&gt;
&lt;li&gt;间接寻址：指令中给出操作数地址（操作数地址在内存中）的地址。&lt;/li&gt;
&lt;li&gt;相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。&lt;/li&gt;
&lt;li&gt;变址寻址：操作数地址等于变址寄存器的内容加偏移量。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;校验码&#34;&gt;校验码&lt;/h1&gt;
&lt;p&gt;码距，是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。码距为n的编码方案，在该编码方案中任意两个合法编码之间至少有n个二进制位不同。例如值1和2的编码分别为&lt;code&gt;0000 0001&lt;/code&gt;和&lt;code&gt;0000 0010&lt;/code&gt;他们最后两位不同，所以，码距为2。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个编码系统的码距$\ge 2$时，该编码系统具有&lt;u&gt;检错能力&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;一个编码系统的码距$\ge 3$时，该编码系统才&lt;u&gt;可能有纠错能力&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，一个校验码要想能够检错和纠错那么它的码距至少是3。&lt;/p&gt;
&lt;h2 id=&#34;奇偶校验码&#34;&gt;奇偶校验码&lt;/h2&gt;
&lt;p&gt;奇偶校验（Parity Codes）是通过在编码中增加一位校验位来&lt;u&gt;使编码中1的个数为奇数（奇校验）或者为偶数（偶校验）&lt;/u&gt;。但该编码只能检错，但不能纠错。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇偶校验码码距为2。&lt;/li&gt;
&lt;li&gt;奇校验：仅检测出代码中奇数位数（奇数个0或1发生错误），不能发现偶数位数出错。偶校验反之。&lt;/li&gt;
&lt;li&gt;常用的奇偶校验码有3种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;海明码&#34;&gt;海明码&lt;/h2&gt;
&lt;p&gt;海明码（Hamming Code）是一种利用奇偶性来&lt;u&gt;检错和纠错&lt;/u&gt;的校验方法。海明码是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：&lt;/p&gt;
&lt;p&gt;$$
2^k-1 \ge n+k
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该公式的字面意思为，$k$个校验位的最大值（$k$个校验位都为1），要比海明码的位数（$n+k$）要大。
海明码的码距为3。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;海明码的编码规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$k$个校验位：$P_k, P_{k-1}, \cdots, P_1$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n$个数据位：$D_{n-1}, D_{n-2}, \cdots, D_1, D_0$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的海明码：$H_{n+k}, H_{n+k-1}, \cdots, H_1$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$H_j = P_i, j=2^{i-1}$。&lt;/li&gt;
&lt;li&gt;数据位依序插入到海明码中剩下的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;海明码中任一位都是由若干个校验位来检验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;校验数据位时：被校验的海明位的下标等于所有参与校验该位的校验位的下标之和。&lt;/li&gt;
&lt;li&gt;校验位由自身校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679983905932.png&#34;
	width=&#34;1023&#34;
	height=&#34;1049&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679983905932_hu8233f94300cd2978c7262586b5e1abdc_350868_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679983905932_hu8233f94300cd2978c7262586b5e1abdc_350868_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;97&#34;
		data-flex-basis=&#34;234px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;偶校验：$G_4G_3G_2G_1={(0000)}_{2}$则表示数据无错误，否则表示接收到的数据有错误。&lt;/p&gt;
&lt;p&gt;若出错，$G_4G_3G_2G_1$的十进制值指出来出错位置。如$G_4G_3G_2G_1=1010$，说明$H_{10}(D_5)$出错，将其取反即可纠错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;奇校验：$G_4G_3G_2G_1=(1111)_2$则表示数据无错误，否则表示接收到的数据有错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环冗余码&#34;&gt;循环冗余码&lt;/h2&gt;
&lt;p&gt;循环冗余校验码（Cyclic Redundancy Check，CRC）广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生个校验位来进行编码，其编码长度为k+r。CRC的代码格式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679825785079.png&#34;
	width=&#34;613&#34;
	height=&#34;92&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679825785079_hue59488e391052e21a77b5920f121b7a3_12188_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679825785079_hue59488e391052e21a77b5920f121b7a3_12188_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;666&#34;
		data-flex-basis=&#34;1599px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;若CRC码的字长为n，又可称其为（n,k）码，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;左边为信息码（数据），占k位；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右边为校验码，占n-k位。&lt;/p&gt;
&lt;p&gt;校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。&lt;/p&gt;
&lt;p&gt;CRC码距为2，可以检错不能纠错。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;计算机指令集&#34;&gt;计算机指令集&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;RISC&lt;br&gt;精简指令集（计算机）&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CISC&lt;br&gt;复杂指令集（计算机）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令种类&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;少、精简&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多、复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令复杂度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低（简单）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高（复杂）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令长度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;寻址方式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;复杂多样&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实现（译码方式）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬布线控制逻辑（组合逻辑控制器）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;微程序控制技术&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通用寄存器数量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多、大量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流水线技术&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;流水线技术&#34;&gt;流水线技术&lt;/h1&gt;
&lt;p&gt;计算机中的流水线技术（Pipelining）是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。&lt;/p&gt;
&lt;p&gt;若要执行$n$条指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顺序执行总时间：&lt;/p&gt;
&lt;p&gt;$$
顺序执行总时间=单条指令执行的时间\times n
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线执行总时间：&lt;/p&gt;
&lt;p&gt;$$
流水线执行总时间=一条指令执行的时间+流水线周期 \times (n-1)
$$&lt;/p&gt;
&lt;p&gt;流水线（操作）周期为执行时间最长的一段操作的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连续输入$n$条指令的吞吐率：&lt;/p&gt;
&lt;p&gt;$$
吞吐率=\cfrac {n}{总执行时间}
$$&lt;/p&gt;
&lt;p&gt;如果是流水线的吞吐率，则总执行时间为流水线执行总时间。
流水线的吞吐率是最长流水段操作时间的倒数。即：&lt;/p&gt;
&lt;p&gt;$$
最长流水段操作时间=\cfrac {流水线执行总时间}{n}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加速比：&lt;/p&gt;
&lt;p&gt;$$
加速比 = \cfrac{顺序执行总时间}{流水线执行总时间}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;存储器&#34;&gt;存储器&lt;/h1&gt;
&lt;p&gt;按存储器所处位置可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。&lt;/li&gt;
&lt;li&gt;外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按存储器的构成材料分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁存储器&lt;/li&gt;
&lt;li&gt;半导体存储器&lt;/li&gt;
&lt;li&gt;光存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按存储器工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读/写存储器（RAM）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读存储器：ROM、PROM、EPROM、EEPROM等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。&lt;/li&gt;
&lt;li&gt;可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按访问方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按地址访问：&lt;/p&gt;
&lt;p&gt;可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机存储器&lt;/li&gt;
&lt;li&gt;顺序存储器&lt;/li&gt;
&lt;li&gt;直接存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按内容访问：例如相联存储器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟存储器由主存与辅存组成。&lt;/p&gt;
&lt;p&gt;DRAM（动态随机存储器）构成主存 DRAM需要周期性地刷新保持信息。&lt;/p&gt;
&lt;p&gt;SRAM（静态随机存储器）构成Cache（缓存）。&lt;/p&gt;
&lt;p&gt;闪存类似U盘，掉电后信息不会丢失。以块为单位进行删除。闪存是EPROM的一种类型，可以代替ROM存储器。闪存不可以代替主存。&lt;/p&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;p&gt;高速缓存用来存放当前最活跃的程序和数据，其特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于CPU与主存之间；容量一般在几千字节到几兆字节之间；&lt;/li&gt;
&lt;li&gt;速度一般比主存快5~10倍，由快速半导体存储器构成；&lt;/li&gt;
&lt;li&gt;其内容是主存局部域的副本，对程序员来说是透明的（看不到或可以忽略）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。&lt;/p&gt;
&lt;h2 id=&#34;缓存地址映射&#34;&gt;缓存地址映射&lt;/h2&gt;
&lt;p&gt;CPU工作时，送出的是主存单元的地址。为从Cache存储器中读/写信息，就需要将主存地址转成Cache存储器的地址，这种地址转换即为地址映像。&lt;/p&gt;
&lt;p&gt;高速缓存中的地址映像方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679884025087.png&#34;
	width=&#34;825&#34;
	height=&#34;526&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;376px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679884252415.png&#34;
	width=&#34;730&#34;
	height=&#34;538&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;325px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;发生块冲突从多到少的顺序：直接映像 &amp;gt; 组相联映像 &amp;gt; 全相联映像。
地址映像都是由硬件自动完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;中断&#34;&gt;中断&lt;/h1&gt;
&lt;p&gt;计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回源程序，这个过程称为中断。&lt;/p&gt;
&lt;p&gt;中断是一种非常重要的技术，&lt;u&gt;输入输出&lt;/u&gt;设备和&lt;u&gt;主机交换数据&lt;/u&gt;、&lt;u&gt;分时操作&lt;/u&gt;、&lt;u&gt;实时系统&lt;/u&gt;、&lt;u&gt;计算机网络&lt;/u&gt;和&lt;u&gt;分布式计算机系统&lt;/u&gt;中都要用到这种技术。为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。&lt;/p&gt;
&lt;h2 id=&#34;输入输出控制方式&#34;&gt;输入输出控制方式&lt;/h2&gt;
&lt;p&gt;程序查询方式（程序直接控制方式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888001780.png&#34;
	width=&#34;754&#34;
	height=&#34;1174&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;64&#34;
		data-flex-basis=&#34;154px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。&lt;/li&gt;
&lt;li&gt;一次只能读/写一个字。&lt;/li&gt;
&lt;li&gt;由CPU将数放入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断驱动方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888578058.png&#34;
	width=&#34;787&#34;
	height=&#34;1134&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;69&#34;
		data-flex-basis=&#34;166px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O设备通过中断信号主动向CPU报告I/O操作已完成。&lt;/li&gt;
&lt;li&gt;CPU和I/O可并行工作。&lt;/li&gt;
&lt;li&gt;CPU利用率得到提升。&lt;/li&gt;
&lt;li&gt;一次只能读/写一个字。&lt;/li&gt;
&lt;li&gt;由CPU将数据放入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA方式（直接存储器存储方式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888972074.png&#34;
	width=&#34;816&#34;
	height=&#34;723&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;112&#34;
		data-flex-basis=&#34;270px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU和I/O可并行工作。&lt;/li&gt;
&lt;li&gt;仅在传送数据块多开始和结束时才需要CPU的干预。&lt;/li&gt;
&lt;li&gt;由外设直接将数据放入内存。&lt;/li&gt;
&lt;li&gt;一次读写的单位为&amp;quot;块&amp;quot;而不是字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA传输数据比中断驱动方式传输数据要快一点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;总线&#34;&gt;总线&lt;/h1&gt;
&lt;p&gt;总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。&lt;/p&gt;
&lt;p&gt;采用总线结构主要有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化系统结构，便于系统设计制造；&lt;/li&gt;
&lt;li&gt;大大减少了连线数目，便于布线，减小体积，提高系统的可靠性；&lt;/li&gt;
&lt;li&gt;便于接口设计，所有与总线连接的设备均采用类似的接口；&lt;/li&gt;
&lt;li&gt;便于系统的扩充、更新与灵活配置，易于实现系统的模块化；&lt;/li&gt;
&lt;li&gt;便于设备的软件设计；&lt;/li&gt;
&lt;li&gt;便于故障诊断和维修，同时也降低了成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以减少信息传输线的数量。&lt;/p&gt;
&lt;p&gt;微机中的总线分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据总线&lt;/li&gt;
&lt;li&gt;地址总线&lt;/li&gt;
&lt;li&gt;控制总线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见总线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISA总线。&lt;/li&gt;
&lt;li&gt;EISA总线。&lt;/li&gt;
&lt;li&gt;PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。&lt;/li&gt;
&lt;li&gt;PCI Express 总线。&lt;/li&gt;
&lt;li&gt;前端总线。&lt;/li&gt;
&lt;li&gt;RS-232C。&lt;/li&gt;
&lt;li&gt;SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。&lt;/li&gt;
&lt;li&gt;SATA。&lt;/li&gt;
&lt;li&gt;USB。&lt;/li&gt;
&lt;li&gt;IEEE-1394。&lt;/li&gt;
&lt;li&gt;IEEE-488总线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址总线宽度：例如，内存容量4GB，$4GB=2^{2+10+10+10}B=2^32B$。所以内存单元的地址宽度为32位，即地址总线宽度为32位。&lt;/p&gt;
&lt;p&gt;数据总线宽度：例如字长为32的机器，那么其数据总线的宽度要为32。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;加密技术与认证技术&#34;&gt;加密技术与认证技术&lt;/h1&gt;
&lt;h2 id=&#34;加密技术&#34;&gt;加密技术&lt;/h2&gt;
&lt;p&gt;加密技术用于防止第三方窃听。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密：只有一把密钥。加密和解密用同一把密钥。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥分发有缺陷。&lt;/li&gt;
&lt;li&gt;加密解密速度很快。&lt;/li&gt;
&lt;li&gt;适合加量大量明文数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非对称加密：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密和解密不是同一把密钥。&lt;/li&gt;
&lt;li&gt;一共有两把密钥，分别是公钥和私钥。&lt;/li&gt;
&lt;li&gt;用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。&lt;/li&gt;
&lt;li&gt;不能通过一把密钥推出另一把密钥。&lt;/li&gt;
&lt;li&gt;用接收方的公钥加密明文可以实现防止窃听的效果。&lt;/li&gt;
&lt;li&gt;密钥分发没有缺陷。&lt;/li&gt;
&lt;li&gt;加密解密速度很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;认证技术&#34;&gt;认证技术&lt;/h2&gt;
&lt;p&gt;认证技术用于防止篡改、假冒和否认。&lt;/p&gt;
&lt;p&gt;摘要（防止篡改）：将发送的明文进行Hash算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比如果一致，侧没有篡改，否则有篡改。&lt;/p&gt;
&lt;p&gt;数字签名（防止假冒和否认）：&lt;/p&gt;
&lt;p&gt;发送方用自己的&lt;u&gt;私钥对摘要进行签名&lt;/u&gt;（加密）。得到数字签名放在密文后一起发送过去。&lt;/p&gt;
&lt;p&gt;接收方用发送方的&lt;u&gt;公钥对数字签名进行验证&lt;/u&gt;（解密）。如果验证成功则该消息没有被假冒且不能否认，否则该消息的真实性为假冒发送。&lt;/p&gt;
&lt;h2 id=&#34;数字证书&#34;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;数字证书是用第三方CA机构使用自己的私钥对用户的公钥签名（加密），来保证这个公钥不被篡改。然后接收方用CA的公钥验证（解密），从而得到用户的公钥。&lt;/p&gt;
&lt;h2 id=&#34;加密算法&#34;&gt;加密算法&lt;/h2&gt;
&lt;p&gt;对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DES&lt;/li&gt;
&lt;li&gt;3DES&lt;/li&gt;
&lt;li&gt;RC-5&lt;/li&gt;
&lt;li&gt;IDEA&lt;/li&gt;
&lt;li&gt;AES&lt;/li&gt;
&lt;li&gt;RC4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非对称密钥（公钥、公开密钥加密）算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSA&lt;/li&gt;
&lt;li&gt;ECC&lt;/li&gt;
&lt;li&gt;DSA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他加密算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hash函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SHA-1安全散列算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MD5摘要算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出结果为128位&lt;/li&gt;
&lt;li&gt;摘要算法防止发送的报文被篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加密可以阻止被动攻击，认证可以阻止主动攻击（不可以处理被动攻击）。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;系统可靠度&#34;&gt;系统可靠度&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F.png&#34;
	width=&#34;1157&#34;
	height=&#34;400&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F_huc533c9ebe7073a641e0c4f0ca26fe76d_129377_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F_huc533c9ebe7073a641e0c4f0ca26fe76d_129377_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;289&#34;
		data-flex-basis=&#34;694px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F.png&#34;
	width=&#34;1133&#34;
	height=&#34;376&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F_hu0151f1bd7a524d241456bee3273c718e_125234_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F_hu0151f1bd7a524d241456bee3273c718e_125234_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;301&#34;
		data-flex-basis=&#34;723px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
