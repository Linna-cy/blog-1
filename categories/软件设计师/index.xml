<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>软件设计师 on Linner&#39;s Blog</title>
        <link>https://blog.linner.asia/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/</link>
        <description>Recent content in 软件设计师 on Linner&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <lastBuildDate>Tue, 04 Apr 2023 17:17:20 +0800</lastBuildDate><atom:link href="https://blog.linner.asia/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>软件设计师——数据结构</title>
        <link>https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <pubDate>Tue, 04 Apr 2023 17:17:20 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h1 id=&#34;复杂度&#34;&gt;复杂度&lt;/h1&gt;
&lt;h2 id=&#34;大o表示法&#34;&gt;大O表示法&lt;/h2&gt;
&lt;p&gt;算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1681099842666.png&#34;
	width=&#34;1014&#34;
	height=&#34;100&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1681099842666_hu8fb0d0a3c83abecf36c375990db2efe0_51379_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1681099842666_hu8fb0d0a3c83abecf36c375990db2efe0_51379_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1014&#34;
		data-flex-basis=&#34;2433px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加法规则：多项相加，保留最高阶项，并将系数化为1；&lt;/li&gt;
&lt;li&gt;乘法规则：多项相乘都保留，并将系数化为1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;递归式的时间（空间）复杂度：&lt;/p&gt;
&lt;p&gt;$$
递归的次数 \times 每次递归的时间（空间）复杂度
$$&lt;/p&gt;
&lt;h2 id=&#34;渐进符号&#34;&gt;渐进符号&lt;/h2&gt;
&lt;p&gt;可以用渐进符号来表示渐进复杂度。&lt;/p&gt;
&lt;p&gt;渐进符号包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$O$：算法运行时间的渐进上界。&lt;/p&gt;
&lt;p&gt;给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le f(n) \le cg(n) \}$。&lt;/p&gt;
&lt;p&gt;即，当$n \ge n_0$时，$f(n) \le c \cdot g(n)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Omega$：算法运行时间的渐进下界。&lt;/p&gt;
&lt;p&gt;给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le cg(n) \le f(n) \}$。&lt;/p&gt;
&lt;p&gt;即，当$n \ge n_0$时，$c \cdot g(n) \le f(n)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Theta$：算法运行时间的渐进上界和渐进下界，即渐进紧致界（又叫紧缺界）。&lt;/p&gt;
&lt;p&gt;给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c_1、c_2和n_0,使得\forall n \ge n_0, 有 0 \le c_1g(n) \le f(n) \le c_2g(n) \}$。&lt;/p&gt;
&lt;p&gt;即，当$n \ge n_0$时，$c_1g(n) \le f(n) \le c_2g(n)$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1681110832416.png&#34;
	width=&#34;966&#34;
	height=&#34;1204&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1681110832416_hud8e84328d379d2eda520e5c710188239_380512_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1681110832416_hud8e84328d379d2eda520e5c710188239_380512_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;递归式主方法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;80&#34;
		data-flex-basis=&#34;192px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;逻辑结构分类&#34;&gt;逻辑结构分类&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;线性结构
&lt;ul&gt;
&lt;li&gt;线性表（一般线性表）&lt;/li&gt;
&lt;li&gt;特殊线性表
&lt;ul&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性表的推广
&lt;ul&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;广义表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非线性结构
&lt;ul&gt;
&lt;li&gt;树结构
&lt;ul&gt;
&lt;li&gt;二叉树&lt;/li&gt;
&lt;li&gt;多叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图结构
&lt;ul&gt;
&lt;li&gt;有向图&lt;/li&gt;
&lt;li&gt;无向图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集合结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;线性表&#34;&gt;线性表&lt;/h1&gt;
&lt;p&gt;&lt;u&gt;由 $n(n\geq 0)$ 个&lt;strong&gt;数据特性相同&lt;/strong&gt;的元素构成的&lt;strong&gt;有限序列&lt;/strong&gt;称为&lt;strong&gt;线性表&lt;/strong&gt;&lt;/u&gt;。$n=0$ 时，称为空表。非空表的特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在唯一一个“第一个”元素。&lt;/li&gt;
&lt;li&gt;存在唯一一个“最后一个”元素。&lt;/li&gt;
&lt;li&gt;相邻元素之间存在序偶关系：
&lt;ul&gt;
&lt;li&gt;除第一个之外，结构中的每个数据元素均只有一个&lt;strong&gt;前驱&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;除最后一个之外，结构中的每个数据元素均只有一个&lt;strong&gt;后继&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线性表的存储结构分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序存储；&lt;/li&gt;
&lt;li&gt;链式存储&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺序存储结构&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;线性表的&lt;strong&gt;顺序存储&lt;/strong&gt;是指用一组&lt;strong&gt;地址连续的存储单元&lt;/strong&gt;依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。在这种存储方式下，元素间的逻辑关系无须占用额外的空间来存储。&lt;/p&gt;
&lt;p&gt;其存储结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610120418.png&#34;
	width=&#34;130&#34;
	height=&#34;266&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610120418_hu2b33a584fc5a2d635ec65d6abeb2f0a4_3927_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610120418_hu2b33a584fc5a2d635ec65d6abeb2f0a4_3927_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;顺序表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;48&#34;
		data-flex-basis=&#34;117px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;假设线性表的每个元素占用的存储空间为$L$，$LOC(a_i)$为第$i$个元素的存储位置（$0 \le i \le n-1$，$n$为线性表的长度）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第$i+1$个元素和第$i$个元素的存储位置满足：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i+1})=LOC(a_i)+L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第$i$个元素的存储位置：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_i)=LOC(a_0) + i \times L
$$&lt;/p&gt;
&lt;p&gt;如果下标从1开始：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_i)=LOC(a_1) + (i-1) \times L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺序存储结构的线性表的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;strong&gt;可以随机存取表中的元素&lt;/strong&gt;，不需要额外的存储空间来表达元素之间的逻辑关系；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;插入和删除操作不方便、效率低、比较耗时&lt;/strong&gt;（&lt;strong&gt;插入和删除操作需要移动元素&lt;/strong&gt;），顺序表的长度是固定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在表厂为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在第$i$个插入位置插入，需要移动$n+1-i$个元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第1个位置插入（$a_1$）需要移动$n$个元素；&lt;/li&gt;
&lt;li&gt;在第$n+1$个位置插入（$a_n$后面）不需要移动元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设在第$i$个插入位置插入的概率为$P_i$，&lt;u&gt;等概率下&lt;/u&gt;（假如这$n+1$个插入位置插入的概率相同）&lt;u&gt;插入&lt;/u&gt;一个新元素需要移动的元素个数的&lt;u&gt;期望值$E_{insert}$&lt;/u&gt;为：&lt;/p&gt;
&lt;p&gt;$$
E_{insert} = \sum_{i=1}^{n+1}{ \Big( P_i \times (n-i+1) \Big) } = \cfrac{1}{n+1} \sum_{i=1}^{n+1}{(n+i+1)} = \cfrac{\colorbox{yellow}n}{\colorbox{yellow}2}
$$&lt;/p&gt;
&lt;p&gt;即，$E_{insert} = \cfrac{插入位置数}{2} = \cfrac{n+1}{2}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;删除第$i$个元素$a_i$需要移动$n-i$个元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除元素$a_1$需要移动$n-1$个元素；&lt;/li&gt;
&lt;li&gt;删除元素$a_n$不需要移动元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设$a_i$被删除的概率为$q_i$，&lt;u&gt;等概率下删除元素&lt;/u&gt;时需要移动的元素个数的&lt;u&gt;期望值$E_{delete}$&lt;/u&gt;为：&lt;/p&gt;
&lt;p&gt;$$
E_{delete} = \sum_{i=1}^{n}{\Big( q_i \times (n-i) \Big)} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i)} = \cfrac{n-1}{yellow}{2}
$$&lt;/p&gt;
&lt;p&gt;即，$E_{delete} = \cfrac{删除位置数}{2} = \cfrac{n}{2}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;插入操作时间复杂度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好情况（在第$n+1$个位置插入）：$O(1)$；&lt;/li&gt;
&lt;li&gt;最坏情况（在第1个位置插入）：$O(n)$；&lt;/li&gt;
&lt;li&gt;平均复杂度：$O(n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查找元素时间复杂度&lt;/strong&gt;（根据下标查找）：$O(1)$。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;线性表的&lt;strong&gt;链式存储&lt;/strong&gt;是指&lt;strong&gt;通过指针链接起来&lt;/strong&gt;的结点来存储数据元素。&lt;/p&gt;
&lt;p&gt;其存储结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610469403.png&#34;
	width=&#34;403&#34;
	height=&#34;49&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610469403_hueeee19018a01756f2e48de06f8910c88_6757_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610469403_hueeee19018a01756f2e48de06f8910c88_6757_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;链式表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;822&#34;
		data-flex-basis=&#34;1973px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据域&lt;/strong&gt;：用于存储数据元素的&lt;strong&gt;值&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指针域&lt;/strong&gt;：用于存储当前元素的直接前驱或直接后继的&lt;strong&gt;位置信息&lt;/strong&gt;（直接前或后驱的&lt;strong&gt;指针&lt;/strong&gt;，称其为指针或链）。&lt;/p&gt;
&lt;p&gt;存储各数据元素的结点的&lt;u&gt;地址并不要求是连续的&lt;/u&gt;，因此存储数据元素的同时必须存储元素之间的逻辑关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链式表的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;结点空间只有在需要的时候才申请&lt;/u&gt;，无须事先分配；&lt;/li&gt;
&lt;li&gt;长度不固定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链式表结点之间通过指针域构成一个链表，&lt;u&gt;若结点中只有一个指针域，则称为线性链表&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610514354.png&#34;
	width=&#34;685&#34;
	height=&#34;64&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610514354_hu9c9f9d7fee45544c6864faab3f820061_7122_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680610514354_hu9c9f9d7fee45544c6864faab3f820061_7122_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;链式表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1070&#34;
		data-flex-basis=&#34;2568px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上图中的Head：一个指向链表第一个结点的针，称为头指针。使用它就可以顺序地访问到表中的任意一个元素。&lt;/p&gt;
&lt;p&gt;插入和删除操作时间复杂度（带不带头节点的复杂度都一样）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好情况（在$i=1$位置）：$O(1)$；&lt;/li&gt;
&lt;li&gt;最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$&lt;/li&gt;
&lt;li&gt;平均复杂度：$O(n)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链表操作的时间复杂度取决于指针遍历。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;栈&#34;&gt;栈&lt;/h1&gt;
&lt;p&gt;栈是一种&lt;strong&gt;后入先出&lt;/strong&gt;（Last In First Out，LIFO）的线性表。&lt;u&gt;栈只能通过访问它的一端来实现数据存储和检索。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;栈的基本操作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入栈&lt;/strong&gt;：将元素置入栈顶；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出栈&lt;/strong&gt;：将元素从栈顶中取出。&lt;/li&gt;
&lt;li&gt;读取栈顶元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;栈的出栈顺序一定和入栈顺序&lt;strong&gt;相反&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;顺序存储结构-1&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;栈的顺序存储结构也称为&lt;strong&gt;顺序栈&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;顺序栈使用一个栈顶指针标记栈顶元素的索引位置。每次出栈时都需要重置栈顶指针，将栈顶指针向下移动，标记到新的栈顶元素。&lt;/p&gt;
&lt;p&gt;顺序栈的空间容量有限，所以每次入栈时都需要判断栈是否为满。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-1&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;栈的链式存储结构称为&lt;strong&gt;链栈&lt;/strong&gt;。链栈的头指针就是栈顶指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680676944766.png&#34;
	width=&#34;238&#34;
	height=&#34;265&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680676944766_hu1bea4090283c9929deed80a707d4d0a3_11895_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680676944766_hu1bea4090283c9929deed80a707d4d0a3_11895_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;链栈的存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;215px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;栈的应用&#34;&gt;栈的应用&lt;/h2&gt;
&lt;p&gt;栈的典型应用包括&lt;strong&gt;表达式求值、括号匹配&lt;/strong&gt;等，在计算机语言的实现以及将递归过程转变为非递归过程的处理中，栈有重要的作用。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;队列&#34;&gt;队列&lt;/h1&gt;
&lt;p&gt;队列是一种&lt;strong&gt;先入先出&lt;/strong&gt;（First In First Out，FIFO）的线性表。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;队列只允许在表的一端插入元素，在表的另一端删除元素。&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;队头&lt;/strong&gt;（Front）：允许&lt;strong&gt;删除&lt;/strong&gt;元素的一端；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队尾&lt;/strong&gt;（Rear）：允许&lt;strong&gt;插入&lt;/strong&gt;元素的一端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;队列的基本操作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入队&lt;/strong&gt;：将元素加入到队尾；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出队&lt;/strong&gt;：将元素加入到对头。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;队列的入队顺序一定&lt;strong&gt;等于&lt;/strong&gt;出队顺序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用两个栈可以来模拟一个队列（从一个栈出栈后的元素入另一个栈后再出栈）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;顺序存储结构-2&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;队列的顺序存储结构称为&lt;strong&gt;顺序队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;顺序队列设置两个指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队头指针：指向对头元素的下标；&lt;/li&gt;
&lt;li&gt;队尾指针：指向队尾元素的下标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果顺序队列只按照数组下标大小顺序来设置指针（对头指针的值永不大于队尾指针），那么在经过一段时间的操作后，对头指针有可能指向的并不是数组的第一个元素，此时队列的长度永远都到达不了数组的长度（空间无法被充分利用，实际使用的长度和逻辑长度不符）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680677900098.png&#34;
	width=&#34;959&#34;
	height=&#34;323&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680677900098_hua0e0c24049b10a1b1a22eff29a314663_53364_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680677900098_hua0e0c24049b10a1b1a22eff29a314663_53364_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;队列操作&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;296&#34;
		data-flex-basis=&#34;712px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以把数组想象为一个环型的结构（将最后一个元素和第一个元素连接起来，队头指针可以比队尾指针大）。如果此时队列的状态是上图中步骤$(e)$的状态，此时再插入元素，可以将元素放在数组索引0的位置，再让队尾指针始终保持在队列最后一个元素的索引之后即可。将这种队列称为&lt;strong&gt;循环队列&lt;/strong&gt;，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680678225885.png&#34;
	width=&#34;907&#34;
	height=&#34;202&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680678225885_hu78897751e6ca29164f26d83cde2f776e_48040_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680678225885_hu78897751e6ca29164f26d83cde2f776e_48040_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;循环队列&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;449&#34;
		data-flex-basis=&#34;1077px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-2&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;队列的链式存储也称为&lt;strong&gt;链队列&lt;/strong&gt;（&lt;strong&gt;链队&lt;/strong&gt;）。这里为了便于操作，可以给链队列添加一个头结点，并令头指针指向头结点。因此，队列为空的判定条件是头指针和尾指针的值相同，且
均指向头结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680678441791.png&#34;
	width=&#34;278&#34;
	height=&#34;340&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680678441791_hud106655f2d3cb3393c4501ce0717f1de_16473_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680678441791_hud106655f2d3cb3393c4501ce0717f1de_16473_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;81&#34;
		data-flex-basis=&#34;196px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;队列的应用&#34;&gt;队列的应用&lt;/h2&gt;
&lt;p&gt;队列结构常用于处理需要排队的场合，例如操作系统中处理打印任务的打印队列、离散事件的计算机模拟等。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;串&#34;&gt;串&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;串&lt;/strong&gt;（&lt;strong&gt;字符串&lt;/strong&gt;）是一种&lt;strong&gt;特殊的线性表&lt;/strong&gt;，其&lt;strong&gt;数据元素为字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;串具有自身的特性，运算时常常把一个串作为一个整体来处理。&lt;/p&gt;
&lt;p&gt;串的基本概念和操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空串&lt;/strong&gt;：长度为0的串；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;子串&lt;/strong&gt;：由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。子串在主串中的位置是指子串首次出现时，该子串的第一个字符在主串中的位置。空串是任意串的子串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;串相等&lt;/strong&gt;：指两个串长度相等且对应序号的字符也相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;串比较&lt;/strong&gt;：两个串比较大小时以字符的ASCⅡ码值（或其他字符编码集合）作为依据。&lt;/p&gt;
&lt;p&gt;实质上，比较操作从两个串的第一个字符开始进行，字符的码值大者所在的串为大；若其中一个串先结束，则以串长较大者为大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;赋值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拷贝赋值：将一个串的值赋给另一个串；&lt;/li&gt;
&lt;li&gt;引用（地址）赋值：将一个串的引用（地址）赋给另一个串。那么这个串可以使用另一个串中的值，但是对这个串所做的操作，也会作用到另一个串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接串&lt;/strong&gt;：将一个串插入到另一个串尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插入串&lt;/strong&gt;：将一个串插入到另一个串的任意位置中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺序存储结构-3&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;串的顺序存储结构是一种定长的串（类似顺序表）。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-3&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;串的链式存储结构可以方便地对串进行插入删除操作（类似链表）。&lt;/p&gt;
&lt;h2 id=&#34;串的模式匹配&#34;&gt;串的模式匹配&lt;/h2&gt;
&lt;p&gt;子串的定位操作通常称为串的模式匹配。子串也称为模式串。&lt;/p&gt;
&lt;p&gt;有关串模式匹配算法的详细讲解可以查看：&lt;a class=&#34;link&#34; href=&#34;../%e7%bb%8f%e5%85%b8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d&#34; &gt;经典字符串匹配&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;朴素的模式匹配算法&#34;&gt;朴素的模式匹配算法&lt;/h3&gt;
&lt;p&gt;朴素的模式匹配算法也称为布鲁特一福斯算法（即暴力匹配算法），其基本思想是从主串的第一个字符起与模式串的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串第二个字符起与模式串的第一个字符重新比较，直到模式串中每个字符依次和主串中一个连续的字符序列相等时为止，此时称为匹配成功。如果不能在主串中找到与模式串相同的子串，则匹配失败。&lt;/p&gt;
&lt;p&gt;设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最好情况：$O(m)$，次数为$m$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最坏情况：$O(n \times m)$，次数为$\cfrac{1}{2} m(n-m+2)$：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=0}^{n-m}{p_i\big( (i+1) \times m \big)} = \cfrac{m}{n-m+1} \sum_{i=0}^{n-m}{(i+1)} = \cfrac{1}{2} m(n-m+2)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均：$O(n+m)$，次数为$\cfrac{1}{2} (n+m)$：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=0}^{n-m}{p_i(i+m)} = \cfrac{1}{n-m+1} \sum_{i=0}^{n-m}{i+m} = \cfrac{1}{2} (n+m)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kmp-算法&#34;&gt;KMP 算法&lt;/h3&gt;
&lt;p&gt;KMP算法又称为改进的模式匹配算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串的&lt;strong&gt;前缀&lt;/strong&gt;：包含第一个字符，且不包含最后一个字符的子串；&lt;/li&gt;
&lt;li&gt;串的&lt;strong&gt;后缀&lt;/strong&gt;：包含最后一个字符，且不包含第一个字符的子串。&lt;/li&gt;
&lt;li&gt;前缀集合：包含串的所有前缀的集合；&lt;/li&gt;
&lt;li&gt;后缀集合：包含串的所有后缀的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;KMP的重点是求模式串字符的next值（失配指针$Next[\ i\ ]$），假设$a_{i-1}$为当前要求next值的模式串字符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前缀集合：$Prefix=\{p_0,p_0p_1,\cdots,p_0&amp;hellip;p_{i-1}\}$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀集合：$Postfix=\{p_{i-1},p_{i-2}p_{i-1},\cdots,p_1&amp;hellip;p_{i-1}\}$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;失配指针：&lt;/p&gt;
&lt;p&gt;$$
Next[i] =
\begin{cases}
-1 &amp;amp; 当\ i=0 时 \
max &amp;amp; \{ k|0&amp;lt;k&amp;lt;i 且 &amp;ldquo;p_0\cdots p_{k-1}&amp;rdquo; = &amp;ldquo;p_{i-k}\cdots p_{i-1}&amp;rdquo; \} \
0 &amp;amp; 其他情况
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$Next[0] = -1$；&lt;/li&gt;
&lt;li&gt;$Next[i] = maxLen(Prefix \cap Postfix)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以解释为：&lt;/p&gt;
&lt;p&gt;$$
Next[\ i\ ] = 前i个子串的最长相同前后缀的长度
$$&lt;/p&gt;
&lt;p&gt;特殊情况：$Next[\ 1\ ] = 0$，因为其前缀集合和后缀集合都为空。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;失配表是用来指示匹配失败后指针该如何移动的。&lt;/p&gt;
&lt;p&gt;失配表的建立跟要匹配的串没有任何关系，仅跟模式串有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;多维数组&#34;&gt;多维数组&lt;/h1&gt;
&lt;p&gt;多维数组是定长线性表在维数上的扩展，即线性表中的元素又是一个线性表。多维数组是一种“同构”的数据结构，其每个数据元素类型相同、结构一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一维数组：即线性表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二维数组（仅讨论顺序存储结构）：&lt;/p&gt;
&lt;p&gt;二维数组的存储结构（如下图），可以分为以行为主序（下图左边）和以列为主序（下图右边）两种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680693946560.png&#34;
	width=&#34;451&#34;
	height=&#34;448&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680693946560_hu1932cb3790ae3468aeeee7cc636c93c8_34859_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680693946560_hu1932cb3790ae3468aeeee7cc636c93c8_34859_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二维数组为$A[n,m]$，$n$为行数，$m$为列数；&lt;/li&gt;
&lt;li&gt;数组元素$a_{i,j},\ 0 \le i \le n-1,\ 0 \le j \le m-1$；&lt;/li&gt;
&lt;li&gt;$LOC(a_{i,j})$为元素$a_{i,j}$的地址；&lt;/li&gt;
&lt;li&gt;$L$为单个元素的存储空间大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以行为主序优先存储：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i \times n + j) \times L
$$&lt;/p&gt;
&lt;p&gt;如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) \times n + (j-1) \big) \times L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以列为主序优先存储：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \times m) \times L
$$&lt;/p&gt;
&lt;p&gt;如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：&lt;/p&gt;
&lt;p&gt;$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) + (j-1) \times m \big) \times L
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;优先存储说法问题：&lt;/p&gt;
&lt;p&gt;以行为主序优先存储的意思应该是在内存中按行存储。以列为主序优先存储的意思应该是在内存中按列存储。&lt;/p&gt;
&lt;p&gt;假设一个二维数组为：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; a_{13} &amp;amp; a_{14} \\
a_{21} &amp;amp; a_{22} &amp;amp; a_{23} &amp;amp; a_{24} \\
a_{31} &amp;amp; a_{32} &amp;amp; a_{33} &amp;amp; a_{34} \\
a_{41} &amp;amp; a_{42} &amp;amp; a_{43} &amp;amp; a_{44} \\
a_{51} &amp;amp; a_{52} &amp;amp; a_{53} &amp;amp; a_{54}
\end{vmatrix}
$$&lt;/p&gt;
&lt;p&gt;按照以行为主序优先存储的公式，它在内存中应该是分为了5个地址连续的数组来存储。即内存中，$[a_{11},a_{12},a_{13},a_{14}]$为一个数组，其后再接一个数组$[a_{12},a_{22},a_{23},a_{24}]$，以此类推，在内存中按照列的元素作为一个连续的一维数组单位，再按照第1行后接第2行作为整个连续的二维数组。它们在内存中的地址顺序是：&lt;/p&gt;
&lt;p&gt;$$
a_{11},a_{12},&amp;hellip;,a_{14},\\
a_{21},&amp;hellip;,a_{24},\\
a_{31},&amp;hellip;,a_{34},\\
a_{41},&amp;hellip;,a_{44},\\
a_{51},&amp;hellip;,a_{54}
$$&lt;/p&gt;
&lt;p&gt;那么以列为主序优先存储的地址顺序就为：&lt;/p&gt;
&lt;p&gt;$$
a_{11},a_{21},&amp;hellip;,a_{51},\\
a_{12},&amp;hellip;,a_{52},\\
a_{13},&amp;hellip;,a_{53},\\
a_{14},&amp;hellip;,a_{54}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般矩阵都用二维数组来表示，但是对于一些特殊矩阵，如对称矩阵、三角矩阵和对角矩阵。它们的非0元素的分布存在一定规律，所以可以将其压缩存储在一维数组中，并且它们的多个值相同的元素（按照对应特殊矩阵定义上的值相同，并非简单的值相同）只分配一个存储单位。&lt;/p&gt;
&lt;h2 id=&#34;对称矩阵&#34;&gt;对称矩阵&lt;/h2&gt;
&lt;p&gt;若矩阵$A_{n \times n}$中的元素特点为$a_{ij}=a_{ji}\ (1 \le i,j \le n)$，则称之为$n$阶对称矩阵。&lt;/p&gt;
&lt;p&gt;对称矩阵$A_{n \times n}$：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1n} \\
a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2n} \\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
a_{n1} &amp;amp; a_{n2} &amp;amp; \cdots &amp;amp; a_{nn}
\end{vmatrix}
$$&lt;/p&gt;
&lt;p&gt;其中以对角线划分为三个区域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主对角线&lt;/strong&gt;：$a{11},a_{22},\cdots,a_{nn}$，共有$n$个元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上三角区&lt;/strong&gt;：对角线以上的所有元素，即：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
0 &amp;amp; a_{12} &amp;amp; a_{13} &amp;amp; \cdots &amp;amp; a_{1n} \\
0 &amp;amp; 0 &amp;amp; a_{23} &amp;amp; \cdots &amp;amp; a_{2n} \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; a_{(n-1)n} \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0
\end{vmatrix}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;下三角区&lt;/strong&gt;：对角线以下的所有元素，和上三角区的个数相等并且重复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以将对称矩阵中，$n^2$个元素压缩存储到$\cfrac{n(n+1)}{2}$个元素的存储空间中。一般是存储下三角区和对角线。&lt;/p&gt;
&lt;p&gt;假设将$n$阶对称矩阵$A_{n \times n}$压缩存储到一维数组$B\left[ \cfrac{n(n+1)}{2} \right]$，则$B[k]\ (1 \le k \le \cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$之间存在一一对应关系（以行为主序）：&lt;/p&gt;
&lt;p&gt;$$
k =
\begin{cases}
\cfrac{i(i-1)}{2} + j, &amp;amp; 当\ i \ge j \\
\cfrac{j(j-1)}{2} + i, &amp;amp; 当\ i &amp;lt; j
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;如果下标从0开始（第一个元素为$a_{00}$，$0 \le k \le \cfrac{n(n+1)}{2} - 1$，并且$0 \le i,j \le n-1$）：&lt;/p&gt;
&lt;p&gt;$$
k =
\begin{cases}
\cfrac{i(i+1)}{2} + j + 1, &amp;amp; 当\ i \ge j \\
\cfrac{j(j+1)}{2} + i + 1, &amp;amp; 当\ i &amp;lt; j
\end{cases}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么$length(B) = \cfrac{n(n+1)}{2}$（压缩存储的一维数组大小）：&lt;/p&gt;
&lt;p&gt;主对角线的元素的大小为$n$，下三角区的对角线大小分别为$n-1,n-2,&amp;hellip;,1$。即：
$$
length(B) = \sum_{i=1}^{n}{i} = \cfrac{n(n+1)}{2}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：《软件设计师教程（第五版）》中一维数组的下标$k$的取值范围错了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1680698007514.png&#34;
	width=&#34;999&#34;
	height=&#34;344&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1680698007514_hud68653e5fe46341035cf0f04b58f1fb8_157083_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1680698007514_hud68653e5fe46341035cf0f04b58f1fb8_157083_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;对称矩阵&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;290&#34;
		data-flex-basis=&#34;696px&#34;
	
&gt;
很明显不是$\left[ 1, \cfrac{n(n+1)}{2} \right)$，而应该是$\left[ 1, \cfrac{n(n+1)}{2} \right]$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三对角矩阵&#34;&gt;三对角矩阵&lt;/h2&gt;
&lt;p&gt;对角矩阵是指矩阵中的&lt;u&gt;非0元素都集中在以主对角线为中心的带状区域中&lt;/u&gt;，即除了主对角线上和直接在对角线上、下方若干条对角线上的元素外，其余的矩阵元素都为0。三对角矩阵是对角矩阵中的一种，包括主对角线和在主对角线上、下方的各一条对角为非0元素：&lt;/p&gt;
&lt;p&gt;$$
\begin{vmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; 0      &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
a_{21} &amp;amp; a_{22} &amp;amp; a_{23} &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
0      &amp;amp; a_{32} &amp;amp; a_{33} &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
0      &amp;amp; 0      &amp;amp; a_{43} &amp;amp; \cdots &amp;amp; 0              &amp;amp; 0          \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots         &amp;amp; \vdots     \\
0      &amp;amp; 0      &amp;amp; 0      &amp;amp; \cdots &amp;amp; a_{(n-1)(n-1)} &amp;amp; a_{(n-1)n} \\
0      &amp;amp; 0      &amp;amp; 0      &amp;amp; \cdots &amp;amp; a_{n(n-1)}     &amp;amp; a_{nn}
\end{vmatrix}
$$&lt;/p&gt;
&lt;p&gt;设有$n$阶三对角矩阵$A_{n \times n}$，将其非0元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$存储在一维数组$B[k](1 \le k \le 3 \times n - 2)$中，则元素位置之间的对应关系为：&lt;/p&gt;
&lt;p&gt;$$
k = 3 \times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2
$$&lt;/p&gt;
&lt;p&gt;如果下标从0开始（$0 \le k \le 3(n-1)$，并且$0 \le i,j \le n-1$）：&lt;/p&gt;
&lt;p&gt;$$
k = 3 \times i - 1 + j - i + 1 + 1 = 2i + j + 1
$$&lt;/p&gt;
&lt;h2 id=&#34;稀疏矩阵&#34;&gt;稀疏矩阵&lt;/h2&gt;
&lt;p&gt;在一个矩阵中，若&lt;u&gt;非0元素的个数远远少于0元素的个数，且非0元素的分布&lt;strong&gt;没有规律&lt;/strong&gt;&lt;/u&gt;，则称之为稀疏矩阵。&lt;/p&gt;
&lt;p&gt;对于稀疏矩阵，存储非0元素时&lt;strong&gt;必须同时存储其位置&lt;/strong&gt;（即行号和列号），用&lt;u&gt;三元组$(i,j,a_{ij})$可唯一确定矩阵$A$中的一个元素&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;可以用三元组表来存储这些三元组。稀疏矩阵的三元组表的顺序存储结构称为&lt;strong&gt;三元组顺序表&lt;/strong&gt;，常用的三元组表的链式存储结构是&lt;strong&gt;十字链表&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;树&#34;&gt;树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;结构是一种&lt;strong&gt;非线性结构&lt;/strong&gt;，该结构中的一个数据元素可以有&lt;strong&gt;两个或两个以上的直接后继&lt;/strong&gt;元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;（Tree）是 $n(n\ge0)$ 个结点的有限集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空树&lt;/strong&gt;：$n=0$；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非空树&lt;/strong&gt;：$n&amp;gt;0$，
&lt;ul&gt;
&lt;li&gt;有且仅有一个&lt;strong&gt;根结点&lt;/strong&gt;，&lt;/li&gt;
&lt;li&gt;除根节点外的其余结点可分为 $m(m&amp;gt;0)$ 个互不相交的集合，即&lt;strong&gt;子树&lt;/strong&gt;（SubTree）$T_1,T_2,\cdots,T_m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树的定义是&lt;strong&gt;递归&lt;/strong&gt;的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一棵树由若干棵子树构成；&lt;/li&gt;
&lt;li&gt;子树又由更小的子树构成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;h3 id=&#34;术语&#34;&gt;术语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;度&lt;/strong&gt;：结点拥有的子树数。整个树的度是树内各结点度的最大值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶结点&lt;/strong&gt;：度为 0 的结点，也称&lt;strong&gt;终端结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非终端结点&lt;/strong&gt;：度不为 0 的结点，也称&lt;strong&gt;分支结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部结点&lt;/strong&gt;：除根节点外的非终端结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子节点&lt;/strong&gt;：结点&lt;u&gt;子树的根结点&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父结点&lt;/strong&gt;：与子结点相连的上一层的唯一一个结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟结点&lt;/strong&gt;：同一个父节点的子节点之间互为兄弟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;祖先结点&lt;/strong&gt;：从根结点到该结点所经分支上的所有结点（包括其父节点，但不包括其本身）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子孙结点&lt;/strong&gt;：以某结点为根的子树中的所有结点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堂兄弟结点&lt;/strong&gt;：父节点在同一层（但不是同一个）的结点互为堂兄弟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;层次&lt;/strong&gt;：以根结点为第一层，根的子节点为第二层 …… 树中任意结点的层次等于其父节点的层次加 1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的高度&lt;/strong&gt;：树中结点的最大层次，也称&lt;strong&gt;树的深度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;森林&lt;/strong&gt;：是 $m(m\ge0)$ 棵互不相交的树的集合。树中每个结点的子树的集合即为森林。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;树的类型&#34;&gt;树的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有序树&lt;/strong&gt;：树中结点的各子树从左到右是有次序的，即不能互换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无序树&lt;/strong&gt;：树中结点的各子树相互之间可以互换，没有次序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;树的性质&#34;&gt;树的性质&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;$$树中的结点总数=sum(树中所有结点的度数)+1$$。&lt;/li&gt;
&lt;li&gt;度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \ge 1$）。&lt;/li&gt;
&lt;li&gt;高度为$h$的$m$度树至多有$\cfrac{m^h-1}{m-1}个结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;树的逻辑结构&#34;&gt;树的逻辑结构&lt;/h2&gt;
&lt;p&gt;树可以用二元组 $Tree=(root,F)$ 表示。其中 $root$ 是根结点，$F$ 是 $m(m\ge0)$ 棵子树的森林，即 $F=(T_1,T_2,\cdots,T_m)$，其中 $T_i=(r_i,F_i)$ 为根 $root$ 的第 $i$ 棵子树。&lt;/p&gt;
&lt;p&gt;树根与其子树森林之间的关系：
$$
RF = \{ &amp;lt;root,r_i&amp;gt;|i=1,2,4,m,\quad m&amp;gt;0 \}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;二叉树&#34;&gt;二叉树&lt;/h1&gt;
&lt;p&gt;二叉树是（$n \ge 0$）个结点的有限集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空树：$n=0$；&lt;/li&gt;
&lt;li&gt;由一个根结点及两棵不相交的且分别称为左、右子树的二叉树所组成（两个子数顺序不可交换）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉树同样具有递归性质。&lt;/p&gt;
&lt;p&gt;二叉树的性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第$i$层（$i \ge 1$）上&lt;u&gt;最多&lt;/u&gt;有$2^{i-1}$个结点。&lt;/p&gt;
&lt;p&gt;因为二叉树每个结点至多有两个分支（结点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高度为$k$的二叉树最多有$2^k-1$个结点（$k \ge 1$）。&lt;/p&gt;
&lt;p&gt;每层结点都取最大值后累加：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=1}^{k}{2^{i-1}} = 2^k - 1
$$&lt;/p&gt;
&lt;p&gt;将深度为$k$且有$2^k-1$个结点的二叉树称为&lt;strong&gt;满二叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对满二叉树自上而下、从左至右进行编号（即层序遍历的顺序）。一个深度为$k$、有$n$个结点的二叉树，当且仅当其每一个结点都于深度为$k$的满二叉树中编号从1至$n$的结点一一对应时，称之为&lt;strong&gt;完全二叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完全二叉树有一个隐藏关系：$n &amp;gt; 2^{k-1}-1$。即深度为$k$的完全二叉树，其结点数$n$必须要比深度为$k-1$的满二叉树至少多1个结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;深度为$k$的满二叉树结点数$n$和其第$k$层结点数$m$的关系：&lt;/p&gt;
&lt;p&gt;$$
n = 2m-1
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何一棵二叉树，若其终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$
终端结点数（度0结点数）=度2结点数+1
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具有$n$个结点的完全二叉树的深度（高度）为：&lt;/p&gt;
&lt;p&gt;$$
\lfloor \log_2{n} \rfloor + 1;
$$&lt;/p&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;p&gt;$$
\lceil \log_2{n+1} \rceil
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉树形态总数（卡特兰数）：&lt;/p&gt;
&lt;p&gt;$$
\cfrac{C^{n}_{2n}}{n+1}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;排列组合公式：&lt;/p&gt;
&lt;p&gt;$$
A^n_m = m \times (m-1) \times \cdots \times (m-n+1)
$$&lt;/p&gt;
&lt;p&gt;$m$是起点，$n$是次数。&lt;/p&gt;
&lt;p&gt;$$
C^n_m = \cfrac{A^n_m}{A^n_n}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;顺序存储结构-4&#34;&gt;顺序存储结构&lt;/h2&gt;
&lt;p&gt;用一组地址连续的存储单元存储二叉树中的结点。&lt;/p&gt;
&lt;p&gt;可以按照为完全二叉树编号的顺序（即层序遍历的顺序），将二叉树映射到顺序表中：&lt;/p&gt;
&lt;p&gt;若编号为$i$的结点（$i \ge 1$），则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$i=1$：根结点，没有双亲（父结点）；&lt;/li&gt;
&lt;li&gt;$i&amp;gt;1$：双亲为$\left\lfloor \cfrac{i}{2} \right\rfloor$；&lt;/li&gt;
&lt;li&gt;$i \le \cfrac{n}{2}$：左孩子编号为$2i$；&lt;/li&gt;
&lt;li&gt;$i \le \cfrac{n-1}{2}：右孩子编号为$2i+1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完全二叉树适合采用顺序存储结构，而一般二叉树则不适合。&lt;/p&gt;
&lt;h2 id=&#34;链式存储结构-4&#34;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;可以用&lt;strong&gt;三叉链表或二叉链表&lt;/strong&gt;来存储二叉树（一个结点含有3个或2个指针，其中必须有两个指针来分别存储左子树和右子树的根结点）。链表的头指针指向二叉树根结点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680770614240.png&#34;
	width=&#34;980&#34;
	height=&#34;337&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680770614240_hu74a2d83457551f99334a785fee2a7f2b_53953_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680770614240_hu74a2d83457551f99334a785fee2a7f2b_53953_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;二叉树的链表存储结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;290&#34;
		data-flex-basis=&#34;697px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三叉链表仅仅是多了一个指向父结点的链表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设有$n$个结点的二叉树，则其&lt;strong&gt;空指针域数量&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于二叉链表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总指针域个数：$2n$；&lt;/li&gt;
&lt;li&gt;分支数（子孙结点数，非空指针域个数）：$n-1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可得：&lt;/p&gt;
&lt;p&gt;$$
空指针域数=2n-(n-1)=n+1
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于三叉链表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总指针域个数：$3n$；&lt;/li&gt;
&lt;li&gt;分支数（子孙结点数）：$n-1$；&lt;/li&gt;
&lt;li&gt;指向父结点且非空的指针域个数：$n-1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，非空指针域个数为：$2(n-1)$。&lt;/p&gt;
&lt;p&gt;可得：&lt;/p&gt;
&lt;p&gt;$$
空指针域数=3n-2(n-1)=n+2
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;遍历&#34;&gt;遍历&lt;/h2&gt;
&lt;p&gt;二叉树有以下遍历方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先序遍历：根左右&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问根结点；&lt;/li&gt;
&lt;li&gt;先序遍历左子树；&lt;/li&gt;
&lt;li&gt;先序遍历右子树。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中序遍历：左根右&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中序遍历左子树；&lt;/li&gt;
&lt;li&gt;访问根结点；&lt;/li&gt;
&lt;li&gt;中序遍历右子树。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后序遍历：左右根&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;后序遍历左子树；&lt;/li&gt;
&lt;li&gt;后序遍历右子树；&lt;/li&gt;
&lt;li&gt;访问根结点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后序遍历可以使用栈：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根结点入栈；&lt;/li&gt;
&lt;li&gt;右子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；&lt;/li&gt;
&lt;li&gt;左子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；&lt;/li&gt;
&lt;li&gt;将栈中所有元素出栈，出栈顺序即为后序遍历的顺序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层序遍历：根据层序从上至下，从左到右遍历&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问根结点（第1层）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从左到右访问第2层所有结点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从左到右访问第3层所有结点；&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直至访问到最后一层的所有结点（从左到右）。&lt;/p&gt;
&lt;p&gt;层序遍历可以使用队列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将根结点入队；&lt;/li&gt;
&lt;li&gt;将对头元素出队，然后将其左右子结点（如果有的话）依序入队；&lt;/li&gt;
&lt;li&gt;重复步骤2直至所有元素出队，出队顺序即为层序遍历顺序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;二叉树的遍历实质上是对一个非线性结构进行线性化的过程，它使得每个结点（除第一个和最后一个）在这些线性序列中有且仅有一个直接前驱和直接后继。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h2&gt;
&lt;p&gt;二叉树可以用于快速查找。例如比根结点小的在左子树，比根结点大的在右子树（二叉排序树）。那么每次查找，根据根结点就可以剔除一半的范围。&lt;/p&gt;
&lt;p&gt;但是如果二叉树左右子树的结点数量差别很大，那么每次查找并不一定能剔除一半的范围，查询效率大打折扣。&lt;/p&gt;
&lt;p&gt;设一个二叉树的左右子树高度之差的绝对值为$d$，那么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不平衡的二叉树：$d &amp;gt; 1$；&lt;/li&gt;
&lt;li&gt;平衡的二叉树：$d \le 1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;完全二叉树一定是平衡二叉树，平衡二叉树不一定是完全二叉树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二叉排序树&#34;&gt;二叉排序树&lt;/h2&gt;
&lt;p&gt;二叉排序树的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;左子树&lt;/strong&gt;所有结点的关键字都&lt;strong&gt;小于&lt;/strong&gt;根结点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右子树&lt;/strong&gt;所有根结点的关键字都&lt;strong&gt;大于&lt;/strong&gt;根结点；&lt;/li&gt;
&lt;li&gt;左右子树也都是二叉排序树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉排序树的&lt;strong&gt;中序遍历&lt;/strong&gt;（左根右）得到的是该二叉树的&lt;strong&gt;有序序列&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;线索二叉树&#34;&gt;线索二叉树&lt;/h2&gt;
&lt;p&gt;线索二叉树是在二叉树结点中保存了结点的前驱和后继的信息。&lt;/p&gt;
&lt;p&gt;如果使用指针来指向其前驱和后继，增加指针信息会降低存储空间的利用率。&lt;/p&gt;
&lt;p&gt;可以采用增加两个标志（&lt;code&gt;leftTag&lt;/code&gt;和&lt;code&gt;rightTag&lt;/code&gt;）来区分指针域指向的是左或右子结点还是前驱或后继：&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;leftTag&lt;/td&gt;
        &lt;td&gt;leftChild&lt;/td&gt;
        &lt;td&gt;data&lt;/td&gt;
        &lt;td&gt;rightChild&lt;/td&gt;
        &lt;td&gt;rightTag&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;$$
leftTag =
\begin{cases}
True  &amp;amp; leftChild指向结点左孩子 \\
False &amp;amp; leftChild指向结点的直接前驱
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;$$
rightTag =
\begin{cases}
True  &amp;amp; rightChild指向结点右孩子 \\
False &amp;amp; rightChild指向结点的直接后继
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;若二叉树的二叉链表采用以上所示的结点结构，则相应的链表称为线索链表，其中指向结点前驱、后继的指针称为线索。&lt;/p&gt;
&lt;p&gt;对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化。&lt;/p&gt;
&lt;h2 id=&#34;哈夫曼树&#34;&gt;哈夫曼树&lt;/h2&gt;
&lt;p&gt;哈夫曼树即最优二叉树，是一类&lt;strong&gt;带权路径长度最短&lt;/strong&gt;的树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;：指从树中&lt;strong&gt;一个结点到另一个结点之间的通路&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路径长度&lt;/strong&gt;：路径上的&lt;strong&gt;分支数目&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;树的路径长度&lt;/strong&gt;：指从树根到每一个叶子之间的路径长度之和；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结点的带权路径长度&lt;/strong&gt;：从该结点到树根之间的&lt;strong&gt;路径长度&lt;/strong&gt;与该结点&lt;strong&gt;权值&lt;/strong&gt;的乘积；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;树的带权路径长度&lt;/strong&gt;：树中所有叶子结点的带权路径长度之和。&lt;/p&gt;
&lt;p&gt;设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带权叶子结点数：$n$；&lt;/li&gt;
&lt;li&gt;叶子结点的权值：$w_k$；&lt;/li&gt;
&lt;li&gt;叶子结点到根的路径长度：$l_k$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则树的带权路径长度为：&lt;/p&gt;
&lt;p&gt;$$
WPL = \sum_{k=1}^{n}{w_kl_k}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈夫曼树是指权值为$w_1,w_2,\cdots,w_n$的$n$个叶子结点的二叉树中，带权路径长度最小的二叉树。&lt;/p&gt;
&lt;p&gt;构造最优二叉树的哈夫曼算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据给定的$n$个权值$\{ w_1,w_2,\cdots,w_n \}$，构成$n$棵二叉树集合$F=\{T_1,T_2,\cdots,T_n\}$，每棵树$T_i$有且仅有一个带权为$w_i$的根结点。&lt;/li&gt;
&lt;li&gt;在$F$中选取2棵权值最小的树作为左、右子树，构造一棵新二叉树。新二叉树的根结点权值为其左右子树根结点权值之和。&lt;/li&gt;
&lt;li&gt;从$F$中删除这2棵树，并将新树加入到$F$中。&lt;/li&gt;
&lt;li&gt;重复步骤2、3直到$F$中仅含一棵树为止，这棵树便是哈夫曼树。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;哈夫曼算法并未规定哪棵树作为左或右子树，所以哈夫曼树并不唯一，但$WPL$值是唯一的。&lt;/p&gt;
&lt;p&gt;给定$n$个权值后，哈夫曼树的结点数$m$就确定了：&lt;/p&gt;
&lt;p&gt;$$
m = 2 \times n - 1
$$&lt;/p&gt;
&lt;p&gt;所以可用一维数组存储哈夫曼树。&lt;/p&gt;
&lt;h3 id=&#34;哈夫曼编码&#34;&gt;哈夫曼编码&lt;/h3&gt;
&lt;p&gt;哈夫曼编码是一种不等长的编码，它用哈夫曼算法来构造出最优前缀码：&lt;/p&gt;
&lt;p&gt;给定&lt;strong&gt;字符集&lt;/strong&gt;$D=\{ d_1,d_2,\cdots,d_n \}$及&lt;strong&gt;字符的使用频率&lt;/strong&gt;$W=\{w_1,w_2,\cdots,w_n\}$。&lt;/p&gt;
&lt;p&gt;构造&lt;strong&gt;最优前缀码&lt;/strong&gt;的方法为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以$d_1,d_2,\cdots,d_n$作为叶子结点，$w_1,w_2,\cdots,w_n$作为叶子结点的权值，构造出一棵最优二叉树。&lt;/li&gt;
&lt;li&gt;将树中每个结点的左分支标上0，右分支标上1（左0右1）。&lt;/li&gt;
&lt;li&gt;每个叶子结点代表字符的编码就是从根到叶子的路径上组成的0、1串。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680836524813.png&#34;
	width=&#34;347&#34;
	height=&#34;334&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680836524813_hu78baa79acc8330412526e447ee3074d0_24961_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680836524813_hu78baa79acc8330412526e447ee3074d0_24961_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;哈夫曼编码&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;103&#34;
		data-flex-basis=&#34;249px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其中，字符$a$字符$b$、$c$、$d$、$e$的编码分别为00、01、100、11、101。&lt;/p&gt;
&lt;h3 id=&#34;压缩比&#34;&gt;压缩比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680959771881.png&#34;
	width=&#34;784&#34;
	height=&#34;489&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1680959771881_hu4f7b4b1585cf7b1f2369bc9d93906f07_66292_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;压缩比例题&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;384px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;按照&lt;u&gt;出现频率&lt;/u&gt;计算&lt;u&gt;加权平均长度&lt;/u&gt;：&lt;/p&gt;
&lt;p&gt;$$
加权平均长度 = \sum_{i=1}^{5}{字符i的位数 \times 字符i出现频率}
$$&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$
1 \times 40% + 3 \times (10% + 20% + 16% + 14%) = 2.2
$$&lt;/p&gt;
&lt;p&gt;压缩后平均长度为2.2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算压缩比：&lt;/p&gt;
&lt;p&gt;$$
压缩比 = \cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度}
$$&lt;/p&gt;
&lt;p&gt;即，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编码5个字符至少需要3位：$2^2 &amp;lt; 5 &amp;lt; 2^3$，所以压缩前编码长度为3；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;压缩比：&lt;/p&gt;
&lt;p&gt;$$
\cfrac{3-2.2}{3} \approx 0.27
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;哈夫曼编码方案是基于贪心策略的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;图&#34;&gt;图&lt;/h1&gt;
&lt;p&gt;在图中，任意两个结点之间都可能有直接的关系，所以图中&lt;u&gt;一个结点的前驱结点和后继结点的数目是没有限制的&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;图$G$是由集合$V$和$E$构成的二元组，记作$G=(V,E)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顶点&lt;/strong&gt;：表示数据元素。$V$是图中顶点的非空有限集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边&lt;/strong&gt;：表示数据元素之间的关系。$E$是图中边的有限集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图可分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;：有向图顶点之间的关系称为弧（或有向边），用$&amp;lt;v_i,v_j&amp;gt;$表示，$v_i$是&lt;strong&gt;弧尾&lt;/strong&gt;（始点或起点），$v_j$是&lt;strong&gt;弧头&lt;/strong&gt;（终点，箭头指向的顶点），即有向边是指&lt;u&gt;从弧尾指向弧头&lt;/u&gt;的一条边。$&amp;lt;v_i,v_j&amp;gt;$和$&amp;lt;v_j,v_i&amp;gt;$分别表示的是两条边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无向图&lt;/strong&gt;：无向图顶点之间的关系用$(v_i,v_j)$表示。$(v_i,v_j)$和$(v_j,v_i)$表示的是同一条边。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;术语-1&#34;&gt;术语&lt;/h2&gt;
&lt;h3 id=&#34;完全图&#34;&gt;完全图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;完全图&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无向完全图&lt;/strong&gt;：指一个有$n$个顶点的无向图，其每一个顶点与其他$n-1$个顶点之间都有边。&lt;/p&gt;
&lt;p&gt;$n$个顶点的无向完全图共有$\cfrac{n(n-1)}{2}$条边：&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=1}^{n}{i} = \cfrac{n(n-1)}{2}
$$&lt;/p&gt;
&lt;p&gt;假设$n$个顶点的无向完全图，为他们编上1到$n$的编号，按照编号顺序计算边，第1个顶点跟其他$n-1$个顶点有$n$条边；第2个顶点跟其他$n-1$个顶点也有$n$条边，除去1条跟第1个顶点相连的边，有$n-1$条不一样的边；第3个顶点出去2条跟第1和第2个顶点相连的边，有$n-2$条不一样的边……以此类推，得出上方公式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有向完全图&lt;/strong&gt;：指一个有$n$个顶点的有向图，以其每一个顶点为始点与其他$n-1$个顶点之间都有弧。&lt;/p&gt;
&lt;p&gt;$n$个顶点的有向完全图共有$n(n-1)$条边：&lt;/p&gt;
&lt;p&gt;$$
\prod_{i=1}^{n}{n-1} = n(n-1)
$$&lt;/p&gt;
&lt;p&gt;有向完全图的$n$个顶点都有$n-1$条以其他顶点作为终点的弧（出度为$n-1$），并且这$n$个顶点的$n-1$条弧都是不同的弧，所以可推出上方公式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;度&#34;&gt;度&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;度&lt;/strong&gt;：顶点$v$的度是指关联于该顶点的边的数目，记作$D(v)$。&lt;/p&gt;
&lt;p&gt;若为有向图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入度&lt;/strong&gt;：以该顶点为终点的有向边的数目，记为$ID(v)$；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出度&lt;/strong&gt;：以该顶点为起点的有向边的数目，记为$OD(v)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有向图度与入度、出度的关系：&lt;/p&gt;
&lt;p&gt;$$
D(v) = ID(v) + OD(v)
$$&lt;/p&gt;
&lt;p&gt;对于所有的图，顶点数$n$、边数$e$与各顶点的度之间有：&lt;/p&gt;
&lt;p&gt;$$
e = \cfrac{1}{2} \sum_{i=1}^{n}{D(v_i)}
$$&lt;/p&gt;
&lt;p&gt;即，所有顶点的度数之和 $= 2e$。&lt;/p&gt;
&lt;h3 id=&#34;路径&#34;&gt;路径&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$(v_p,v_{i1}),(v_{i1},v_{i2}),\cdots,(v_{in},v_q) \in E(G)$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$&amp;lt;v_p,v_{i1}&amp;gt;,&amp;lt;v_{i1},v_{i2}&amp;gt;,\cdots,&amp;lt;v_{in},v_q&amp;gt; \in E(G)$。&lt;/p&gt;
&lt;p&gt;无向图中的路径也是有方向的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;子图&#34;&gt;子图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;子图&lt;/strong&gt;：若有两个图$G=(V,E)$和$G&#39;=(V&#39;,E&#39;)$，如果$V&#39; \sube V$且$E&#39; \sube E$，则称$G&#39;$为$G$的子图。&lt;/p&gt;
&lt;h3 id=&#34;连通图&#34;&gt;连通图&lt;/h3&gt;
&lt;p&gt;对于无向图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连通&lt;/strong&gt;：无向图中，若从顶点$v_i$到顶点$v_j$&lt;u&gt;有路径&lt;/u&gt;，则称顶点$v_i$和顶点$v_j$是联通的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连通图&lt;/strong&gt;：若无向图中&lt;u&gt;任意两个顶点都是联通的&lt;/u&gt;，称其为连通图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连通分量&lt;/strong&gt;：无向图$G$的&lt;strong&gt;极大连通子图&lt;/strong&gt;称为$G$的连通分量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$n$个结点的连通图，它的边的取值范围是$[n-1,\cfrac{n(n-1)}{2}]$。&lt;/p&gt;
&lt;p&gt;对于有向图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强连通图&lt;/strong&gt;：在有向图$G$中，如果对于每一对顶点，$v_i,v_j\in V$ 且 $v_i \neq v_j$，从顶点$v_i$到顶点$v_j$和从顶点$v_j$到顶点$v_i$都存在路径，则称图$G$为强连通图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强连通分量&lt;/strong&gt;：有向图中的&lt;strong&gt;极大连通子图&lt;/strong&gt;称为有向图的强连通分量。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;连通图是无向图中的一种，所以一般也称为无向连通图。&lt;/p&gt;
&lt;p&gt;强连通图是有向图的一种，一般也称为有向强连通图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;网&#34;&gt;网&lt;/h3&gt;
&lt;p&gt;边（或弧）带权值的图称为网。&lt;/p&gt;
&lt;h3 id=&#34;有向树&#34;&gt;有向树&lt;/h3&gt;
&lt;p&gt;如果一个有向图恰&lt;u&gt;有一个顶点的入度为0（作为root），其余顶点的入度均为1&lt;/u&gt;，则是一棵有向树。&lt;/p&gt;
&lt;h2 id=&#34;基本存储结构&#34;&gt;基本存储结构&lt;/h2&gt;
&lt;p&gt;图的基本存储结构有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵表示法：使用矩阵存储顶点关系，适合存储边比较多的图；&lt;/li&gt;
&lt;li&gt;邻接链表表示法：使用多个单链表存储顶点关系，适合存储边比较少的图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;邻接矩阵表示法&#34;&gt;邻接矩阵表示法&lt;/h3&gt;
&lt;p&gt;图的邻接矩阵表示法是指&lt;u&gt;用矩阵来表示图中顶点之间的关系&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;对于具有$n$个顶点的图$G=(V,E)$，其邻接矩阵是一个$n$阶方阵，且满足：&lt;/p&gt;
&lt;p&gt;$$
A[i][j] =
\begin{cases}
1 &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt;是E中的边 \\
0 &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt;不是E中的边
\end{cases}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即，横$i$竖$j$，横出竖入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无向图的邻接矩阵是对称矩阵，有向图的邻接矩阵则不一定对称。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无向图：顶点$v_i$的度是邻接矩阵第$i$行（或列）中值不为0的元素个数；&lt;/li&gt;
&lt;li&gt;有向图：第$i$行的非0元素个数是顶点$v_i$的出度$OD(v_i)$；第$i$列的非0元素个数是顶点$v_i$的入度$ID(v_j)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网（赋权图）的邻接矩阵定义（$W_{ij}$是边或弧上的权值）：&lt;/p&gt;
&lt;p&gt;$$
A[i][j] =
\begin{cases}
W_{ij} &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt; \in E \\
\infin &amp;amp; 若(v_i,v_j)或&amp;lt;v_i,v_j&amp;gt; \notin E
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;邻接矩阵适合用于存储边比较多的图。&lt;/p&gt;
&lt;h3 id=&#34;邻接链表表示法&#34;&gt;邻接链表表示法&lt;/h3&gt;
&lt;p&gt;邻接链表表示法指的是&lt;u&gt;为图的每个顶点建立一个单链表&lt;/u&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;边结点（表结点）：&lt;/p&gt;
  &lt;table&gt;
      &lt;tr&gt;
          &lt;td&gt;adjvex&lt;/td&gt;
          &lt;td&gt;nextarc&lt;/td&gt;
          &lt;td&gt;info&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;adjvex&lt;/code&gt;：指示与顶点$v_i$邻接的顶点的序号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextarc&lt;/code&gt;：指示下一条边或弧的结点；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info&lt;/code&gt;：存储与边或弧有关的信息，如权值等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表头结点（顶点结点）：&lt;/p&gt;
  &lt;table&gt;
      &lt;tr&gt;
          &lt;td&gt;data&lt;/td&gt;
          &lt;td&gt;firstarc&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：存储顶点$v_i$的名或其他有关信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;firstarc&lt;/code&gt;：指示链表中的第一个结点（邻接顶点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表头结点通常以顺序存储结构存储，以便随机访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于有向图，&lt;strong&gt;邻接链表&lt;/strong&gt;存储的是以当前结点作为&lt;strong&gt;起点&lt;/strong&gt;的弧；&lt;strong&gt;逆邻接链表&lt;/strong&gt;存储的是以当前结点作为&lt;strong&gt;终点&lt;/strong&gt;的弧。&lt;/p&gt;
&lt;p&gt;邻接链表适合用于存储边比较少的图。&lt;/p&gt;
&lt;h2 id=&#34;遍历-1&#34;&gt;遍历&lt;/h2&gt;
&lt;p&gt;图的遍历是指&lt;u&gt;从某个项点出发，沿着某条搜索路径对图中的所有项点进行访问且只访问一次的过程&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&#34;深度优先搜索&#34;&gt;深度优先搜索&lt;/h3&gt;
&lt;p&gt;深度优先搜索（Depth First Search，DFS）类似于树的先序遍历。从图$G$中任一结点$v$出发按深度优先搜索法进行遍历的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置搜索指针$p$，使$p$指向顶点$v$；&lt;/li&gt;
&lt;li&gt;访问$p$所指顶点，并使$p$指向与其&lt;u&gt;相邻接的且尚未被访问过&lt;/u&gt;的顶点。&lt;/li&gt;
&lt;li&gt;若$p$所指顶点存在，则重复步骤2，否则执行步骤4。&lt;/li&gt;
&lt;li&gt;沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间复杂度（$n$为顶点数，$e$为边数）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵：$O(n^2)$；&lt;/li&gt;
&lt;li&gt;邻接链表：$O(n+e)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;广度优先搜索&#34;&gt;广度优先搜索&lt;/h3&gt;
&lt;p&gt;图的广度优先搜索（Breadth First Search，BFS）步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从图中的某个顶点$v$出发；&lt;/li&gt;
&lt;li&gt;访问$v$后，依次访问$v$的各个未被访问过的邻接点；&lt;/li&gt;
&lt;li&gt;分别从$v$的邻接点出发，依次访问它们的邻接点；&lt;/li&gt;
&lt;li&gt;按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到；&lt;/li&gt;
&lt;li&gt;若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;广度优先搜索可以引入队列来保存已访问过的顶点序列。即，每当一个顶点被访问后，就将其放入队列中；当队头顶点出队时，就访问其未被访问的邻接点并令这些邻接顶点入队。每个顶点最多入队一次。&lt;/p&gt;
&lt;p&gt;广度和深度优先搜索遍历图的&lt;u&gt;时间复杂度相同&lt;/u&gt;（$n$为顶点数，$e$为边数）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵：$O(n^2)$；&lt;/li&gt;
&lt;li&gt;邻接链表：$O(n+e)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;广度和深度优先搜索遍历图的不同之处在于：&lt;u&gt;顶点访问的次序不同&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;生成树&#34;&gt;生成树&lt;/h2&gt;
&lt;p&gt;连通图的生成树是该图的极小连通子图（都是$n-1$条边）。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;非连通图&lt;/strong&gt;而言，每个连通分量中的顶点集和遍历时走过的边集一起构成若干棵生成树，把它们称为&lt;strong&gt;非连通图的生成树森林&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在图的生成树中任一加一条边，则必然形成回路。&lt;/p&gt;
&lt;p&gt;边数为$e$，$e \ge n$则必然形成回路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图的生成树不是唯一的。&lt;/p&gt;
&lt;p&gt;按深度和广度优先搜索进行遍历将得到不同的生成树，分别称为深度优先生成树和广度优先生成树。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h3&gt;
&lt;p&gt;连通网的生成树的边也带权，把生成树各边的权值总和称为生成树的权。&lt;u&gt;权值最小的生成树称为最小生成树&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&#34;aov-网&#34;&gt;AOV 网&lt;/h2&gt;
&lt;p&gt;一个大工程项目可以分为许多较小子工程（称为活动）。有向图中，用顶点表示活动，弧表示活动之间的优先级关系（活动进行时的制约关系），称这样的有向图为&lt;u&gt;以顶点表示活动的网&lt;/u&gt;（Activity On Vertex network，AOV网）。&lt;/p&gt;
&lt;p&gt;在AOV网中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从顶点$v_i$到$v_j$有一条有向路径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_i$是$v_j$的前驱，&lt;/li&gt;
&lt;li&gt;$v_j$是$v_i$的后继；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$&amp;lt;v_i,v_j&amp;gt;$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_i$是$v_j$的直接前驱，&lt;/li&gt;
&lt;li&gt;$v_j$是$v_i$的直接后继。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOV网中不应出现有向环。检测工程是否可行，首先应检查对应AOV网是否存在回路。不存在回路的有向图称为有向无环图（DAG，Directed Acycline Graph）。&lt;/p&gt;
&lt;h2 id=&#34;拓扑排序&#34;&gt;拓扑排序&lt;/h2&gt;
&lt;p&gt;检测AOV网是否是DAG的方法是对AOV网构造其&lt;u&gt;顶点的拓扑有序序列&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;拓扑排序是将AOV网中的所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点$v_i$到$v_j$有一条路径，则在该线性序列中，$v_i$必在$v_j$之前。对AOV网进行拓扑排序的方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。&lt;/li&gt;
&lt;li&gt;从网中删除该顶点及与该顶点有关的所有弧。&lt;/li&gt;
&lt;li&gt;重复上述两步，直到网中不存在入度为0的顶点为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有顶点已输出，说明网中不存在回路。&lt;/li&gt;
&lt;li&gt;尚有未输出的顶点，剩余顶点均有前驱顶点，表面网中存在回路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有向无环图的拓扑序列中，顶点$v_i$在$v_j$之前，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能存在弧$&amp;lt;v_i,v_j&amp;gt;$，一定不存在弧$&amp;lt;v_j,v_i&amp;gt;$；&lt;/li&gt;
&lt;li&gt;可能存在$v_i$到$v_j$的路径，一定不存在$v_j$到$v_i$的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1681115534531.png&#34;
	width=&#34;133&#34;
	height=&#34;173&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1681115534531_hu9a36ad2327d0139feeb1c8e76c812997_7356_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/uTools_1681115534531_hu9a36ad2327d0139feeb1c8e76c812997_7356_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;AOV网拓扑排序例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;184px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上图拓扑排序的结果为：6,1,4,3,2,5（结果并不唯一）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当有向图中无环时，也可以利用深度优先遍历进行逆拓扑排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;查找&#34;&gt;查找&lt;/h1&gt;
&lt;p&gt;查找是一种常用的基本运算。查找表是指由同一类型的数据元素（或记录）构成的集合。&lt;/p&gt;
&lt;p&gt;查找表经常要进行的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询某个特定的数据元素是否在查找表中。&lt;/li&gt;
&lt;li&gt;检索某个特定的数据元素的各种属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常将只进行这两种操作的查找表称为&lt;strong&gt;静态查找表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;查找表经常要进行的另外两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在查找表中插入一个数据元素。&lt;/li&gt;
&lt;li&gt;从查找表中删除一个数据元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要在查找表中插入或删除元素，称此类查找表为&lt;strong&gt;动态查找表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;是数据元素（或记录）的某个数据项的值，用它来识别（标识）这个数据元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主关键字&lt;/strong&gt;：能唯一标识一个数据元素的关键字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;次关键字&lt;/strong&gt;：能标识多个数据元素的关键字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;平均查找长度&#34;&gt;平均查找长度&lt;/h2&gt;
&lt;p&gt;查找算法基本操作是&lt;u&gt;“将记录的关键字与给定值进行比较”&lt;/u&gt;。因此，通常&lt;u&gt;以“其关键字和给定值进行过比较的记录个数的期望值”作为衡量查找算法好坏的依据&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;查找算法在查找成功时的&lt;u&gt;平均查找长度&lt;/u&gt;关键字和给定值比较次数的期望值：&lt;/p&gt;
&lt;p&gt;$$
ASL = \sum_{i=1}^{n}{P_iC_i}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$P_i$为对表中第$i$个记录进行查找的概率，&lt;/p&gt;
&lt;p&gt;一般认为$P_i=\cfrac{1}{n}, 1 \le i \le n$，即$\sum_{i=1}^{n}{P_i}$；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$C_i$为查找成功时，已经进行过比较的关键字个数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查找算法&#34;&gt;查找算法&lt;/h2&gt;
&lt;p&gt;静态查找表有以下查找方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序查找；&lt;/li&gt;
&lt;li&gt;折半查找；&lt;/li&gt;
&lt;li&gt;分块查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态查找表有以下查找方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉排序树；&lt;/li&gt;
&lt;li&gt;平衡排序树；&lt;/li&gt;
&lt;li&gt;B-树；&lt;/li&gt;
&lt;li&gt;哈希表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;顺序查找&#34;&gt;顺序查找&lt;/h3&gt;
&lt;p&gt;顺序查找是从表的一端开始，按照顺序（从左往右或从右往左）逐一进行查找。顺序查找的方法&lt;u&gt;对于&lt;strong&gt;顺序存储方式&lt;/strong&gt;和&lt;strong&gt;链式存储方式&lt;/strong&gt;的查找表都适用&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;顺序查找中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：&lt;/p&gt;
&lt;p&gt;$$
ASL_{ss} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i+1)} = \cfrac{n+1}{2}
$$&lt;/p&gt;
&lt;h3 id=&#34;二分查找&#34;&gt;二分查找&lt;/h3&gt;
&lt;p&gt;二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。步骤如下：&lt;/p&gt;
&lt;p&gt;以升序数列$L[0&amp;hellip;n-1]$为例，假设要查找的数为$x$：&lt;/p&gt;
&lt;p&gt;让$x$与数列中间位置的元素$L\left[ \left\lfloor \cfrac{n}{2} \right\rfloor \right]$进行比较，如果相等则返回该元素下标，否则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$x$比中间元素小，递归地对中间元素左边的数列（比$x$小的元素）进行二分查找；&lt;/li&gt;
&lt;li&gt;如果$x$比中间元素大，递归地对中间元素右边的数列（比$x$大的元素）进行二分查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;折半查找的过程可用二叉树描述。$n$个结点的二叉树深度为$\lfloor log_2{n} \rfloor + 1$，折半查找进行比较的关键字个数最多不超过树的深度。所以，折半查找在查找成功时和给定值&lt;u&gt;进行比较的关键字个数最多为$\lfloor log_2{n} \rfloor + 1$&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;折半查找的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：&lt;/p&gt;
&lt;p&gt;$$
ASL_{bs} = \cfrac{1}{n} \sum_{i=1}^{n}{i \times 2^{i-1}} = \cfrac{n+1}{n} log_2{(n+1)} - 1
$$&lt;/p&gt;
&lt;p&gt;当$n$值较大时，$ASL_{bs} \approx log_2{(n+1)} - 1$。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>软件设计师——程序设计语言</title>
        <link>https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</link>
        <pubDate>Thu, 30 Mar 2023 19:58:41 +0800</pubDate>
        
        <guid>https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</guid>
        <description>&lt;h1 id=&#34;低级和高级语言&#34;&gt;低级和高级语言&lt;/h1&gt;
&lt;p&gt;程序设计语言根据硬件是否能识别区分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低级语言&lt;/strong&gt;：二进制机器指令、汇编语言。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级语言&lt;/strong&gt;：面向各类应用的程序设计语言，更加接近自然语言。需要通过编译器或解释器（翻译）来让机器执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;编译和解释&#34;&gt;编译和解释&lt;/h1&gt;
&lt;p&gt;程序设计语言按照翻译的方式可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;：需要通过&lt;strong&gt;编译器&lt;/strong&gt;（&lt;strong&gt;编译程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;编译为包含二进制指令的&lt;u&gt;可执行文件（目标程序）&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;真正在机器上运行的是与源程序（逻辑）等价的目标程序。&lt;/p&gt;
&lt;p&gt;源程序和编译器都不再参与目标程序的运行过程。&lt;/p&gt;
&lt;p&gt;汇编程序也是属于编译执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：需要通过&lt;strong&gt;解释器&lt;/strong&gt;（&lt;strong&gt;解释程序&lt;/strong&gt;）将&lt;u&gt;源程序（源代码）&lt;/u&gt;中的指令解释为二进制指令后给机器执行。&lt;/p&gt;
&lt;p&gt;该过程不会产生独立的目标程序。&lt;/p&gt;
&lt;p&gt;并且解释器和源程序都会参与到程序的运行过程（运行控制）中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与编译方式相比，解释方式程序执行的速度慢，因为解释方式执行的程序，需要解释器在其中充当一个原程序与机器之前实时的翻译。&lt;/p&gt;
&lt;p&gt;脚本语言属于动态语言，其程序结构可以在运行中改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译过程&#34;&gt;编译过程&lt;/h2&gt;
&lt;p&gt;编译程序的功能是把某高级语言书写的&lt;u&gt;源程序翻译成与之等价的目标程序&lt;/u&gt;（汇编语言或机
器语言)。&lt;/p&gt;
&lt;p&gt;编译程序的工作过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680232196718.png&#34;
	width=&#34;549&#34;
	height=&#34;466&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680232196718_hu22cb7da26b44a72475eca6b4da41107c_39469_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;282px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其中，以下几个阶段对于编译过程来说是必须的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下两个阶段对于编译过程来说不是必须的（可省略）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;li&gt;（中间或目标）代码优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;词法分析&#34;&gt;词法分析&lt;/h3&gt;
&lt;p&gt;源程序可以简单地被看成是一个&lt;u&gt;多行的字符串&lt;/u&gt;。&lt;strong&gt;词法分析&lt;/strong&gt;阶段的任务是&lt;u&gt;对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号&lt;/u&gt;。&lt;strong&gt;“单词”符号&lt;/strong&gt;是程序设计语言的&lt;strong&gt;基本语法单位&lt;/strong&gt;，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。&lt;/p&gt;
&lt;p&gt;词法分析程序输出的“单词”&lt;u&gt;常以&lt;strong&gt;二元组&lt;/strong&gt;的方式输出&lt;/u&gt;，即单词种别和单词自身的值。&lt;/p&gt;
&lt;p&gt;词法分析过程依据的是语言的&lt;u&gt;词法规则&lt;/u&gt;，即描述“单词”结构的规则。&lt;/p&gt;
&lt;h4 id=&#34;词法规则&#34;&gt;词法规则&lt;/h4&gt;
&lt;p&gt;词法分析根据词法规则将构成源程序的字符串转换成单词符号序列。词法规则可用3型文法（正规文法）或正规表达式描述。&lt;/p&gt;
&lt;h5 id=&#34;正规表达式&#34;&gt;正规表达式&lt;/h5&gt;
&lt;p&gt;正规表达式（正规式）有以下符号：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;闭包&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示其前面链接的符号或集合可以出现$[0, +\infty]$次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;·&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;连接&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可省略，将多个符号或集合连接起来。表示逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;或&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示逻辑或。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/1680248469003.png&#34;
	width=&#34;990&#34;
	height=&#34;277&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/1680248469003_huaaba3cb8f1b33a18fcb91ebc2f451286_91806_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;357&#34;
		data-flex-basis=&#34;857px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;设$U$、$V$和$W$均为正规式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680249034196.png&#34;
	width=&#34;974&#34;
	height=&#34;185&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680249034196_hu7097887f00dc6fb602c5be85b92d295e_40054_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;526&#34;
		data-flex-basis=&#34;1263px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;有限自动机&#34;&gt;有限自动机&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;有限自动机&lt;/strong&gt;是词法分析的一个工具（一种识别装置的抽象概念），它能正确地&lt;strong&gt;识别正规集&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定的有限自动机&lt;/strong&gt;（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个DFA是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$S$：包含&lt;u&gt;状态的有限集&lt;/u&gt;（每个元素称为一个状态）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Sigma$：有穷&lt;u&gt;字母表&lt;/u&gt;，其每个元素称为一个&lt;u&gt;输入字符&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f$：$S \times \Sigma \to S$ 上的&lt;u&gt;单值部分映像&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$&lt;/p&gt;
&lt;p&gt;表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$s_0$：唯一的&lt;u&gt;开始状态&lt;/u&gt;，$s_0 \in S$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Z$：非空的&lt;u&gt;终止状态集合&lt;/u&gt;，$Z \subseteq S$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFA可以用两种直观的方式表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换图&lt;/strong&gt;：简称为转换图，是一个有向图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;状态&lt;/strong&gt;对应转换图中的一个&lt;strong&gt;结点&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DFA中的每个&lt;strong&gt;转换函数&lt;/strong&gt;对应图中的一条&lt;strong&gt;有向弧&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双圈表示的结点是终态结点。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;终态也可以是初态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态转换矩阵&lt;/strong&gt;：用一个二位数组$M$表示。&lt;/p&gt;
&lt;p&gt;矩阵元素$M[A,a]$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行下标&lt;/strong&gt;：表示状态。当前状态为$A$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列下标&lt;/strong&gt;：表示输入的字符。当前输入为$a$。&lt;/li&gt;
&lt;li&gt;$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251834262.png&#34;
	width=&#34;983&#34;
	height=&#34;160&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251834262_hudda18d0f6413fec2c6bfff005f78095a_126189_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;614&#34;
		data-flex-basis=&#34;1474px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251962756.png&#34;
	width=&#34;982&#34;
	height=&#34;585&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680251962756_hub668c80da120ede04799d85ae8f0770b_237616_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不确定的有限自动机&lt;/strong&gt;（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的&lt;strong&gt;状态是不唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;NFA也是一个&lt;strong&gt;五元组&lt;/strong&gt;$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$f$是$S \times \Sigma \to 2^S$ 上的映像。&lt;/p&gt;
&lt;p&gt;对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;DFA是NFA的特例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680252743732.png&#34;
	width=&#34;918&#34;
	height=&#34;407&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680252743732_hu52e92fdc66cb95fd2f0c67685207a651_114412_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;541px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有向弧中出现如 $a,b$，代表该有向弧输入的值可以为$a$&lt;strong&gt;或&lt;/strong&gt;$b$。即&lt;code&gt;,&lt;/code&gt;代表或。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;语法分析&#34;&gt;语法分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语法分析&lt;/strong&gt;的任务是在词法分析的基础上，&lt;u&gt;根据语言的语法规则将单词符号序列分解成各类语法单位&lt;/u&gt;，如“表达式”“语句”和“程序”等。&lt;/p&gt;
&lt;p&gt;如果源程序中没有语法错误，语法分析后就能正确地&lt;u&gt;构造出其语法树&lt;/u&gt;；否则&lt;u&gt;指出语法错误&lt;/u&gt;，并&lt;u&gt;给出相应的诊断信息&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;例如对&lt;code&gt;id1 := id2 + id3 * 60&lt;/code&gt;进行语法分析后形成的语法树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680233200526.png&#34;
	width=&#34;888&#34;
	height=&#34;266&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680233200526_hub39a12f42925ee3f44c562351b5287d6_25864_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;333&#34;
		data-flex-basis=&#34;801px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;词法分析和语法分析在本质上都是对源程序的结构进行分析。&lt;/p&gt;
&lt;p&gt;到达语法分析阶段可以发现程序中所有的语法错误。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量的值是否正确；&lt;/li&gt;
&lt;li&gt;语句的形式是否正确；&lt;/li&gt;
&lt;li&gt;语句的结构是否合法；&lt;/li&gt;
&lt;li&gt;检查括号是否匹配；&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法分析方法有多种，根据产生语法树的方向，可分为&lt;strong&gt;自底向上&lt;/strong&gt;和&lt;strong&gt;自顶向下&lt;/strong&gt;两类。&lt;/p&gt;
&lt;h4 id=&#34;上下文无关文法&#34;&gt;上下文无关文法&lt;/h4&gt;
&lt;p&gt;程序设计语言的&lt;u&gt;绝大多数&lt;strong&gt;语法规则&lt;/strong&gt;可以采用&lt;strong&gt;上下文无关文法&lt;/strong&gt;进行描述&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;上下文无关文法属于乔姆斯基定义的2型文法。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法，$G[S] = (V_N, V_T, P, S)$，其产生式的形式都是 $A \to \beta$，其中 $A \in V_n$，$\beta \in (V_N \cup V_T)^*$。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V_N$：非终结符号集合，&lt;/li&gt;
&lt;li&gt;$V_T$：终结符号集合，&lt;/li&gt;
&lt;li&gt;$P$：产生式集合，&lt;/li&gt;
&lt;li&gt;$S$：开始符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255073014.png&#34;
	width=&#34;990&#34;
	height=&#34;393&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255073014_hub03b05e46f3a2c7483ad3eeddb5269a8_262819_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;251&#34;
		data-flex-basis=&#34;604px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上下文无关文法的推导过程可用树型结构描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255429332.png&#34;
	width=&#34;210&#34;
	height=&#34;346&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/uTools_1680255429332_hu3ef184a27e7b53ced5b1ffcd5bd7d8dd_10720_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;60&#34;
		data-flex-basis=&#34;145px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由上下文无关文法的推导过程也可以看出它是自顶向下推导。&lt;/p&gt;
&lt;p&gt;对于上下文无关文法中的集合，有以下对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$S \to P$&lt;/li&gt;
&lt;li&gt;$P \to V_N$&lt;/li&gt;
&lt;li&gt;$V_N \to V_T$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语义分析&#34;&gt;语义分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语义分析&lt;/strong&gt;阶段分析各语法结构的含义，&lt;u&gt;检查源程序是否包含静态语义错误&lt;/u&gt;，并&lt;u&gt;收集类型信息&lt;/u&gt;供后面的代码生成阶段使用。&lt;u&gt;只有语法和语义都正确的源程序才能翻译成正确的目标代码。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;语义分析的一个主要工作是&lt;u&gt;进行类型分析和检查&lt;/u&gt;。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。&lt;/p&gt;
&lt;p&gt;语义分析阶段的输入是上一个阶段（语法分析）所构造的语法树。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析后语法树中可能会出现一些语义处理结点。例如&lt;code&gt;inttoreal&lt;/code&gt;，表示将一个整型数转换为浮点数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;语义分析不能发现程序中所有的语义错误。语义分析只能发现静态语义错误，动态语义错误需要在生成目标程序后运行时才能发现。&lt;/p&gt;
&lt;p&gt;有语义错误是可以编译成功的。例如&lt;code&gt;a/0&lt;/code&gt;，符合语法，也符合静态语义，编译器检验不出来这个是错的，只有运行才会报错，也就是动态语义，动态语义错误常见的还有死循环。&lt;/p&gt;
&lt;p&gt;PS：现在有些IDE会对一些常见的动态语义错误进行检查，在程序编译前提示给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;中间代码生成&#34;&gt;中间代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;中间代码生成&lt;/strong&gt;阶段的工作是&lt;u&gt;根据语义分析的输出生成中间代码&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。最常用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。四元式的形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(运算符, 运算对象1, 运算对象2, 运算结果)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;语义分析和中间代码生成所依据的是语言的语义规则。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;中间代码生成阶段&lt;/u&gt;对于编译过程来说是&lt;u&gt;可省略的&lt;/u&gt;。但是&lt;u&gt;前面的三个阶段词法分析、语法分析和语义分析还有最后的目标代码生成是不可省略的&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;编译器前后端&#34;&gt;编译器前后端&lt;/h4&gt;
&lt;p&gt;对于编译过程的各个阶段，在逻辑上可以把它们划分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后端&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;中间代码优化&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以中间代码为分水岭（中间代码作为前端的输出，然后再作为后端的输入来连接前后端），把编译器分成了与机器有关的部分（后端）和与机器无关的部分（前端）。如此一来，对于同一种程序设计语言的编译器，开发出一个前端之后，就可以针对不同的机器开发相应的后端，前、后端有机结合后就形成了该语言的一个编译器。当语言有改动时，只会涉及前端部分的维护。&lt;/p&gt;
&lt;p&gt;对于不同的程序设计语言，分别设计出相应的前端，然后将各个语言的前端与同一个后端相结合，就可以得到各个语言在某种机器上的编译器。&lt;/p&gt;
&lt;p&gt;使用中间代码，将编译器分为前后端的好处是，有利于编译程序的可移植性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译程序的可移植性提高了，那么相应的源程序（源代码）的可移植也会提高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;中缀和后缀表达式&#34;&gt;中缀和后缀表达式&lt;/h4&gt;
&lt;p&gt;中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。&lt;/p&gt;
&lt;p&gt;根据生成的语法树，按照不同的方式遍历即可生成形式不同的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中缀表达式：中序遍历（左-根-右）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀表达式：后序便利（左-右-根）。&lt;/p&gt;
&lt;p&gt;后缀转中缀用到了栈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;逆波兰式其实就是后缀式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;代码优化&#34;&gt;代码优化&lt;/h3&gt;
&lt;p&gt;由于编译器将源程序翻译成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间上和空间上有较大的浪费。&lt;u&gt;当需要生成高效的目标代码时，必须进行优化。&lt;/u&gt;优化过程&lt;u&gt;可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;由于中间代码不依赖于具体机器，此时&lt;u&gt;所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关&lt;/u&gt;。优化所依据的原则是&lt;strong&gt;程序的等价变换规则&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;目标代码生成&#34;&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目标代码&lt;/strong&gt;生成阶段的任务是&lt;u&gt;把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码&lt;/u&gt;，这个阶段的工作&lt;strong&gt;与具体的机器密切相关&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;寄存器的分配：寄存器访问速度快，但数量有限，所以如何分配及使用寄存器是目标代码生成时需要着重考虑的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译过程中为变量分配的存储单元所用的地址是&lt;strong&gt;逻辑地址&lt;/strong&gt;，程序运行时再将逻辑地址映射为物理地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;符号表管理&#34;&gt;符号表管理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;符号表&lt;/strong&gt;的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录源程序中各个符号的必要信息；&lt;/li&gt;
&lt;li&gt;辅助语义的正确性检查和代码生成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;符号表在前三个阶段构建&lt;/u&gt;：可以始于词法分析阶段，也可以放到语法分析和语义分析阶段&lt;/li&gt;
&lt;li&gt;符号表的使用有时会&lt;u&gt;延续到目标代码的运行阶段&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编译过程中翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需的信息正确地填入符号表；对可执行语句，则是将其翻译成中间代码或目标代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;出错处理&#34;&gt;出错处理&lt;/h3&gt;
&lt;p&gt;编写的源程序中出现的错误分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态错误&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;编译阶段发现的程序错误，又可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法错误：有关语言结构上的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态语义错误：运算符与运算对象类型不合法等错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态错误&lt;/strong&gt;（动态语义错误）：发生在程序运行时。&lt;/p&gt;
&lt;p&gt;常见的动态错误例如除数为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译时发现程序中的错误后，编译程序应采用适当的策略修复它们，使得分析过程能够继续下去，以便在一次编译过程中尽可能多地找出程序中的错误。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;程序设计语言的基本成分&#34;&gt;程序设计语言的基本成分&lt;/h1&gt;
&lt;p&gt;程序设计语言的基本成分包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;运算&lt;/li&gt;
&lt;li&gt;控制&lt;/li&gt;
&lt;li&gt;传输&lt;/li&gt;
&lt;li&gt;（函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据成分&#34;&gt;数据成分&lt;/h2&gt;
&lt;p&gt;数据成分包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识符&lt;/strong&gt;：标识符通常是由字母、数字和下划线&lt;code&gt;_&lt;/code&gt;组成，并且不能由数字开头。&lt;/p&gt;
&lt;p&gt;一般有如下种类标识符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字。&lt;/li&gt;
&lt;li&gt;变量名。&lt;/li&gt;
&lt;li&gt;函数名。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;现在，某些高级语言已经支持中文等字符来当作变量名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量&lt;/strong&gt;：一般有&lt;u&gt;字面量&lt;/u&gt;（例如&lt;code&gt;123&lt;/code&gt;、&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;）和&lt;u&gt;不可变变量（在某些语言中也称其为常量）&lt;/u&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常量也具有类型；&lt;/li&gt;
&lt;li&gt;常量也有对应的存储单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt;：用来存储数据或对象。有存储类别、类型、名称（变量名）、作用域和生存周期等属性（这些也是数据的属性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为整个文件或程序&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;局部量&lt;/strong&gt;：在程序代码中的&lt;u&gt;作用域（作用范围）为定义它的函数或语句块中&lt;/u&gt;的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;：按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型（C和C++）及其他类型等。&lt;/p&gt;
&lt;p&gt;许多程序设计语言都规定，程序中的数据都必须具有类型，其作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分配存储单元&lt;/strong&gt;：便于为数据合理分配存储单元；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;检查数据对象&lt;/strong&gt;：便于对参与表达式计算的数据对象进行（合法性）检查；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取值范围&lt;/strong&gt;：便于规定数据对象的取值范围及能够进行的运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;动态数据结构，其数据的结构会在程序运行过程中改变，例如链表、二叉树等。&lt;/p&gt;
&lt;p&gt;动态数据结构的数据空间必须采用&lt;strong&gt;堆存储&lt;/strong&gt;分配策略，数据存放在&lt;strong&gt;堆区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在C/C++中，全局变量的存储空间在静态数据区分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;运算成分&#34;&gt;运算成分&lt;/h2&gt;
&lt;p&gt;大多数高级程序设计语言的基本运算可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算。&lt;/li&gt;
&lt;li&gt;关系运算。&lt;/li&gt;
&lt;li&gt;逻辑运算。&lt;/li&gt;
&lt;li&gt;位运算。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;
&lt;p&gt;有以下三种结构来构造程序中的控制逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序结构。&lt;/li&gt;
&lt;li&gt;选择结构。&lt;/li&gt;
&lt;li&gt;循环结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数高级语言都针对循环结构提供了&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;等控制流跳转语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;传输成分&#34;&gt;传输成分&lt;/h2&gt;
&lt;p&gt;程序设计语言的传输成分指明语言允许的数据传输方式，如赋值处理、数据的输入和输出等。&lt;/p&gt;
&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数首部：
&lt;ul&gt;
&lt;li&gt;返回值类型&lt;/li&gt;
&lt;li&gt;函数名&lt;/li&gt;
&lt;li&gt;形参表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数体：定义函数所实现的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;：在C（C++）中，函数需要先声明后引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数调用&lt;/strong&gt;：在调用函数中使用被调函数实现的功能。函数调用的一般形式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数名(实参表)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用函数与被调函数之间参数的传递有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;值调用&lt;/strong&gt;（Call by Value）：形参是实参的一份拷贝。即实参将值传递给形参，对形参值的更改并不会作用到实参上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;引用调用&lt;/strong&gt;（Call by Reference）：形参是实参的一个别名。即函数中对形参的访问和修改实际上是对其相应实参所做的访问和修改。&lt;/p&gt;
&lt;p&gt;引用调用下，可以实现形参和实参之间数据的双向传递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在进行函数调用和返回时，由系统使用栈区来进行控制和管理。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>软件设计师——计算机系统</title>
        <link>https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h1 id=&#34;计算机的基本单位&#34;&gt;计算机的基本单位&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;位（比特）&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;bit、b&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;最小数据单位/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;字节&lt;/td&gt;
    &lt;td&gt;byte、B&lt;/td&gt;
    &lt;td&gt;1B = 8b&lt;/td&gt;
    &lt;td&gt;最小存储单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;千字节&lt;/td&gt;
    &lt;td&gt;KB&lt;/td&gt;
    &lt;td&gt;1KB = 1024B&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;兆字节&lt;/td&gt;
    &lt;td&gt;MB&lt;/td&gt;
    &lt;td&gt;1MB = 1024KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;吉字节&lt;/td&gt;
    &lt;td&gt;GB&lt;/td&gt;
    &lt;td&gt;1GB = 1024MB&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;太字节&lt;/td&gt;
    &lt;td&gt;TB&lt;/td&gt;
    &lt;td&gt;1TB = 1024GB&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;计算机系统&#34;&gt;计算机系统&lt;/h1&gt;
&lt;p&gt;计算机系统由&lt;u&gt;硬件&lt;/u&gt;和&lt;u&gt;软件&lt;/u&gt;组成。&lt;/p&gt;
&lt;p&gt;计算机基本硬件系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;中央处理单元&#34;&gt;中央处理单元&lt;/h1&gt;
&lt;p&gt;运算器、控制器等部件被集成在一起统称中央处理单元（CPU）。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。&lt;/p&gt;
&lt;p&gt;中央处理单元（CPU）负责获取程序指令、对指令进行译码并加以执行。&lt;/p&gt;
&lt;p&gt;CPU的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序控制：通过执行指令来控制程序的执行顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作控制：CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间控制：对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据处理：通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。&lt;/p&gt;
&lt;p&gt;对数据的加工处理也是CPU最根本的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对系统内部和外部的中断（异常）做出响应，进行相应的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;寄存器组&lt;/li&gt;
&lt;li&gt;内部总线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运算器&#34;&gt;运算器&lt;/h2&gt;
&lt;p&gt;运算器组成部件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;算术逻辑单元（ALU）：重要组成部件。负责处理数据，实现对数据的算术运算和逻辑运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;累加寄存器（AC，累加器）：是一个通用寄存器。存放操作数或者结果。&lt;/p&gt;
&lt;p&gt;其功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。例如，在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。
运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字，将不同时间段内读/写的数据隔离开来。&lt;/p&gt;
&lt;p&gt;DR的主要作用为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为CPU和内存、外部设备之间数据传送的中转站；&lt;/li&gt;
&lt;li&gt;作为CPU和内存、外围设备之间在操作速度上的缓冲；&lt;/li&gt;
&lt;li&gt;在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态（标志通常分别由1位触发器保存）。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制器&#34;&gt;控制器&lt;/h2&gt;
&lt;p&gt;控制器用于控制整个CPU的工作，它决定了计算机运行过程的
自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。&lt;/p&gt;
&lt;p&gt;指令控制逻辑要完&lt;u&gt;取指令&lt;/u&gt;、&lt;u&gt;分析指令&lt;/u&gt;和&lt;u&gt;执行指令&lt;/u&gt;的操作，其过程分为&lt;u&gt;取指令&lt;/u&gt;、&lt;u&gt;指令译码&lt;/u&gt;、&lt;u&gt;按指令操作码执行&lt;/u&gt;、&lt;u&gt;形成下一条指令地址&lt;/u&gt;等步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令寄存器（IR）：暂存要执行的指令，该指令从内存中获取（通过缓冲寄存器）。&lt;/p&gt;
&lt;p&gt;当CPU执行一条指令时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把指令从内存储器取到缓冲寄存器中。&lt;/li&gt;
&lt;li&gt;送入IR暂存。&lt;/li&gt;
&lt;li&gt;指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序计数器（PC，指令计数器）：具有寄存信息和计数两种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在程序开始执行前，将程序的起始地址送入PC。
该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。&lt;/li&gt;
&lt;li&gt;执行指令时，CPU自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。&lt;/p&gt;
&lt;p&gt;执行转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令译码器(ID)。指令包含操作码和地址码两部分，而指令译码器就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据表示&#34;&gt;数据表示&lt;/h1&gt;
&lt;h2 id=&#34;原码&#34;&gt;原码&lt;/h2&gt;
&lt;p&gt;原码表示法又叫符号加绝对值表示法。最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。&lt;/p&gt;
&lt;p&gt;原码特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0的表示不唯一（有正负0）；&lt;/li&gt;
&lt;li&gt;加、减运算方式不统一；&lt;/li&gt;
&lt;li&gt;需额外对符号位进行处理，不利于硬件设计；&lt;/li&gt;
&lt;li&gt;当 $a &amp;lt; b$ 时，实现 $a-b$ 比较困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反码&#34;&gt;反码&lt;/h2&gt;
&lt;p&gt;最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。正数的反码与原码相同，负数的反码则是除符号位以外其余各位按位取反。&lt;/p&gt;
&lt;h2 id=&#34;补码&#34;&gt;补码&lt;/h2&gt;
&lt;p&gt;计算机中的补码是模2补码&lt;/p&gt;
&lt;p&gt;概念：在一个模运算（Moduler Arithmetic）系统中，同余（Congruence Modulo）的数等价。&lt;/p&gt;
&lt;p&gt;补码的定义：有 $n$ 位时，$[X]_补=(2^n+X)\mod{2^n}\quad (-2^{n-1}\leq X&amp;lt;2^{n-1})$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 $X&amp;lt;0$ 时，补码有两种求法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各位取反，末位加 1。&lt;/li&gt;
&lt;li&gt;从第 2 个 1 开始往右各位取反。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 $X&amp;gt;0$ 时，补码与原码相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码的减法：$Y-X=Y+[-X]_补$。&lt;/p&gt;
&lt;p&gt;特殊的补码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$[-2^{n-1}]_补=(2^n-2^{n-1})\mod{2^n}=(10\ldots0)_2\ (n-1 个0)$。&lt;/p&gt;
&lt;p&gt;这个数的最高位（符号位）即表示符号，又表示数值。如，-128。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$[-1]_补=2^n-1=(11\ldots1)_2\ (n个1)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$[+0]_补=[-0]_补=(00\ldots0)\ (n个0)$。
补码的0表示唯一。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;移码&#34;&gt;移码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;移码就是将每个数值加上一个偏置常数（Excess/Bias）。&lt;/li&gt;
&lt;li&gt;通常，当编码位数为 $n$ 时，bias 取 $2^{n-1}$ 或 $2^{n-1}-1$。&lt;/li&gt;
&lt;li&gt;移码可以方便地进行大小的比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移码可以看成是在其补码的基础上对符号位取反。移码的0表示唯一。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实（个人认为）根据补码和移码的定义，可以将补码当作特殊的移码。其bias为$2^n$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;各种码制带符号数的范围&#34;&gt;各种码制带符号数的范围&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4.png&#34;
	width=&#34;1174&#34;
	height=&#34;273&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4_huf86084d3b2fa3b4510a57d1d605f45ba_75716_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;430&#34;
		data-flex-basis=&#34;1032px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数&lt;/h2&gt;
&lt;p&gt;浮点数使用两个定点数来分别表示实数的尾数（F）和阶码（E）。其一般形式为：$N=2^E \times F$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个数的浮点表示不是唯一的。小数点位置改变，阶码也随着相应改变。&lt;/li&gt;
&lt;li&gt;浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规格化浮点数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尾数$M \ge 0$，其规格化尾数形式为$M=0.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[0.5,1]$。&lt;/li&gt;
&lt;li&gt;尾数$M \le 0$，其规格化尾数形式为$M=1.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[-1,-0.5]$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般浮点数阶码用R位的移码表示，尾数用M位的补码表示。这种表示的数值范围为：&lt;/p&gt;
&lt;p&gt;$$
-1 \times 2^{(2^{R-1}-1)} \sim +(1-2^{-M+1}) \times 2^{(2^{R-1}-1)}
$$&lt;/p&gt;
&lt;p&gt;现在所有通用计算机都采用 IEEE 754 来表示浮点数。IEEE 754 的尾数用原码表示，阶码还是用移码表示。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;寻址方式&#34;&gt;寻址方式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;立即寻址：操作数就包含在指令中。&lt;/li&gt;
&lt;li&gt;直接寻址：操作数在内存，指令给出操作数的地址。&lt;/li&gt;
&lt;li&gt;寄存器寻址：操作数在寄存器，指令给出操作数的寄存器名（地址）。&lt;/li&gt;
&lt;li&gt;寄存器间接寻址：操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。&lt;/li&gt;
&lt;li&gt;间接寻址：指令中给出操作数地址（操作数地址在内存中）的地址。&lt;/li&gt;
&lt;li&gt;相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。&lt;/li&gt;
&lt;li&gt;变址寻址：操作数地址等于变址寄存器的内容加偏移量。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;校验码&#34;&gt;校验码&lt;/h1&gt;
&lt;p&gt;码距，是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。码距为n的编码方案，在该编码方案中任意两个合法编码之间至少有n个二进制位不同。例如值1和2的编码分别为&lt;code&gt;0000 0001&lt;/code&gt;和&lt;code&gt;0000 0010&lt;/code&gt;他们最后两位不同，所以，码距为2。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个编码系统的码距$\ge 2$时，该编码系统具有&lt;u&gt;检错能力&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;一个编码系统的码距$\ge 3$时，该编码系统才&lt;u&gt;可能有纠错能力&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，一个校验码要想能够检错和纠错那么它的码距至少是3。&lt;/p&gt;
&lt;h2 id=&#34;奇偶校验码&#34;&gt;奇偶校验码&lt;/h2&gt;
&lt;p&gt;奇偶校验（Parity Codes）是通过在编码中增加一位校验位来&lt;u&gt;使编码中1的个数为奇数（奇校验）或者为偶数（偶校验）&lt;/u&gt;。但该编码只能检错，但不能纠错。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇偶校验码码距为2。&lt;/li&gt;
&lt;li&gt;奇校验：仅检测出代码中奇数位数（奇数个0或1发生错误），不能发现偶数位数出错。偶校验反之。&lt;/li&gt;
&lt;li&gt;常用的奇偶校验码有3种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;海明码&#34;&gt;海明码&lt;/h2&gt;
&lt;p&gt;海明码（Hamming Code）是一种利用奇偶性来&lt;u&gt;检错和纠错&lt;/u&gt;的校验方法。海明码是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：&lt;/p&gt;
&lt;p&gt;$$
2^k-1 \ge n+k
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该公式的字面意思为，$k$个校验位的最大值（$k$个校验位都为1），要比海明码的位数（$n+k$）要大。
海明码的码距为3。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;海明码的编码规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$k$个校验位：$P_k, P_{k-1}, \cdots, P_1$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n$个数据位：$D_{n-1}, D_{n-2}, \cdots, D_1, D_0$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的海明码：$H_{n+k}, H_{n+k-1}, \cdots, H_1$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$H_j = P_i, j=2^{i-1}$。&lt;/li&gt;
&lt;li&gt;数据位依序插入到海明码中剩下的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;海明码中任一位都是由若干个校验位来检验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;校验数据位时：被校验的海明位的下标等于所有参与校验该位的校验位的下标之和。&lt;/li&gt;
&lt;li&gt;校验位由自身校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679983905932.png&#34;
	width=&#34;1023&#34;
	height=&#34;1049&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679983905932_hu8233f94300cd2978c7262586b5e1abdc_350868_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679983905932_hu8233f94300cd2978c7262586b5e1abdc_350868_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;97&#34;
		data-flex-basis=&#34;234px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;偶校验：$G_4G_3G_2G_1={(0000)}_{2}$则表示数据无错误，否则表示接收到的数据有错误。&lt;/p&gt;
&lt;p&gt;若出错，$G_4G_3G_2G_1$的十进制值指出来出错位置。如$G_4G_3G_2G_1=1010$，说明$H_{10}(D_5)$出错，将其取反即可纠错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;奇校验：$G_4G_3G_2G_1=(1111)_2$则表示数据无错误，否则表示接收到的数据有错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环冗余码&#34;&gt;循环冗余码&lt;/h2&gt;
&lt;p&gt;循环冗余校验码（Cyclic Redundancy Check，CRC）广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生个校验位来进行编码，其编码长度为k+r。CRC的代码格式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679825785079.png&#34;
	width=&#34;613&#34;
	height=&#34;92&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679825785079_hue59488e391052e21a77b5920f121b7a3_12188_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679825785079_hue59488e391052e21a77b5920f121b7a3_12188_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;666&#34;
		data-flex-basis=&#34;1599px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;若CRC码的字长为n，又可称其为（n,k）码，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;左边为信息码（数据），占k位；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右边为校验码，占n-k位。&lt;/p&gt;
&lt;p&gt;校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。&lt;/p&gt;
&lt;p&gt;CRC码距为2，可以检错不能纠错。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;计算机指令集&#34;&gt;计算机指令集&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;RISC&lt;br&gt;精简指令集（计算机）&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CISC&lt;br&gt;复杂指令集（计算机）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令种类&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;少、精简&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多、复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令复杂度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;低（简单）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高（复杂）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指令长度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;寻址方式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;复杂多样&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实现（译码方式）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬布线控制逻辑（组合逻辑控制器）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;微程序控制技术&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通用寄存器数量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多、大量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流水线技术&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;流水线技术&#34;&gt;流水线技术&lt;/h1&gt;
&lt;p&gt;计算机中的流水线技术（Pipelining）是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。&lt;/p&gt;
&lt;p&gt;若要执行$n$条指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顺序执行总时间：&lt;/p&gt;
&lt;p&gt;$$
顺序执行总时间=单条指令执行的时间\times n
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流水线执行总时间：&lt;/p&gt;
&lt;p&gt;$$
流水线执行总时间=一条指令执行的时间+流水线周期 \times (n-1)
$$&lt;/p&gt;
&lt;p&gt;流水线（操作）周期为执行时间最长的一段操作的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连续输入$n$条指令的吞吐率：&lt;/p&gt;
&lt;p&gt;$$
吞吐率=\cfrac {n}{总执行时间}
$$&lt;/p&gt;
&lt;p&gt;如果是流水线的吞吐率，则总执行时间为流水线执行总时间。
流水线的吞吐率是最长流水段操作时间的倒数。即：&lt;/p&gt;
&lt;p&gt;$$
最长流水段操作时间=\cfrac {流水线执行总时间}{n}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加速比：&lt;/p&gt;
&lt;p&gt;$$
加速比 = \cfrac{顺序执行总时间}{流水线执行总时间}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;存储器&#34;&gt;存储器&lt;/h1&gt;
&lt;p&gt;按存储器所处位置可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。&lt;/li&gt;
&lt;li&gt;外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按存储器的构成材料分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁存储器&lt;/li&gt;
&lt;li&gt;半导体存储器&lt;/li&gt;
&lt;li&gt;光存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按存储器工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读/写存储器（RAM）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读存储器：ROM、PROM、EPROM、EEPROM等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。&lt;/li&gt;
&lt;li&gt;可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按访问方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按地址访问：&lt;/p&gt;
&lt;p&gt;可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机存储器&lt;/li&gt;
&lt;li&gt;顺序存储器&lt;/li&gt;
&lt;li&gt;直接存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按内容访问：例如相联存储器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟存储器由主存与辅存组成。&lt;/p&gt;
&lt;p&gt;DRAM（动态随机存储器）构成主存 DRAM需要周期性地刷新保持信息。&lt;/p&gt;
&lt;p&gt;SRAM（静态随机存储器）构成Cache（缓存）。&lt;/p&gt;
&lt;p&gt;闪存类似U盘，掉电后信息不会丢失。以块为单位进行删除。闪存是EPROM的一种类型，可以代替ROM存储器。闪存不可以代替主存。&lt;/p&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;p&gt;高速缓存用来存放当前最活跃的程序和数据，其特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于CPU与主存之间；容量一般在几千字节到几兆字节之间；&lt;/li&gt;
&lt;li&gt;速度一般比主存快5~10倍，由快速半导体存储器构成；&lt;/li&gt;
&lt;li&gt;其内容是主存局部域的副本，对程序员来说是透明的（看不到或可以忽略）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。&lt;/p&gt;
&lt;h2 id=&#34;缓存地址映射&#34;&gt;缓存地址映射&lt;/h2&gt;
&lt;p&gt;CPU工作时，送出的是主存单元的地址。为从Cache存储器中读/写信息，就需要将主存地址转成Cache存储器的地址，这种地址转换即为地址映像。&lt;/p&gt;
&lt;p&gt;高速缓存中的地址映像方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884025087.png&#34;
	width=&#34;825&#34;
	height=&#34;526&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884025087_hu5b011bac95c34a4b59523b3fc3e9bdf5_66159_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;376px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884252415.png&#34;
	width=&#34;730&#34;
	height=&#34;538&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679884252415_hu0e33dbcf5fa3fed2f738b321711ef11e_91734_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;325px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;发生块冲突从多到少的顺序：直接映像 &amp;gt; 组相联映像 &amp;gt; 全相联映像。
地址映像都是由硬件自动完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;中断&#34;&gt;中断&lt;/h1&gt;
&lt;p&gt;计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回源程序，这个过程称为中断。&lt;/p&gt;
&lt;p&gt;中断是一种非常重要的技术，&lt;u&gt;输入输出&lt;/u&gt;设备和&lt;u&gt;主机交换数据&lt;/u&gt;、&lt;u&gt;分时操作&lt;/u&gt;、&lt;u&gt;实时系统&lt;/u&gt;、&lt;u&gt;计算机网络&lt;/u&gt;和&lt;u&gt;分布式计算机系统&lt;/u&gt;中都要用到这种技术。为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。&lt;/p&gt;
&lt;h2 id=&#34;输入输出控制方式&#34;&gt;输入输出控制方式&lt;/h2&gt;
&lt;p&gt;程序查询方式（程序直接控制方式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888001780.png&#34;
	width=&#34;754&#34;
	height=&#34;1174&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888001780_hud6ebe6012cde16108d1ee611e4248e31_240258_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;64&#34;
		data-flex-basis=&#34;154px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。&lt;/li&gt;
&lt;li&gt;一次只能读/写一个字。&lt;/li&gt;
&lt;li&gt;由CPU将数放入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断驱动方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888578058.png&#34;
	width=&#34;787&#34;
	height=&#34;1134&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888578058_huafad4d8f462045fe6ed8d3f6574e2433_264777_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;69&#34;
		data-flex-basis=&#34;166px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O设备通过中断信号主动向CPU报告I/O操作已完成。&lt;/li&gt;
&lt;li&gt;CPU和I/O可并行工作。&lt;/li&gt;
&lt;li&gt;CPU利用率得到提升。&lt;/li&gt;
&lt;li&gt;一次只能读/写一个字。&lt;/li&gt;
&lt;li&gt;由CPU将数据放入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA方式（直接存储器存储方式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888972074.png&#34;
	width=&#34;816&#34;
	height=&#34;723&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/uTools_1679888972074_hu524534b10c6d25022b5676913927ee92_146843_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;112&#34;
		data-flex-basis=&#34;270px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU和I/O可并行工作。&lt;/li&gt;
&lt;li&gt;仅在传送数据块多开始和结束时才需要CPU的干预。&lt;/li&gt;
&lt;li&gt;由外设直接将数据放入内存。&lt;/li&gt;
&lt;li&gt;一次读写的单位为&amp;quot;块&amp;quot;而不是字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA传输数据比中断驱动方式传输数据要快一点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;总线&#34;&gt;总线&lt;/h1&gt;
&lt;p&gt;总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。&lt;/p&gt;
&lt;p&gt;采用总线结构主要有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化系统结构，便于系统设计制造；&lt;/li&gt;
&lt;li&gt;大大减少了连线数目，便于布线，减小体积，提高系统的可靠性；&lt;/li&gt;
&lt;li&gt;便于接口设计，所有与总线连接的设备均采用类似的接口；&lt;/li&gt;
&lt;li&gt;便于系统的扩充、更新与灵活配置，易于实现系统的模块化；&lt;/li&gt;
&lt;li&gt;便于设备的软件设计；&lt;/li&gt;
&lt;li&gt;便于故障诊断和维修，同时也降低了成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以减少信息传输线的数量。&lt;/p&gt;
&lt;p&gt;微机中的总线分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据总线&lt;/li&gt;
&lt;li&gt;地址总线&lt;/li&gt;
&lt;li&gt;控制总线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见总线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISA总线。&lt;/li&gt;
&lt;li&gt;EISA总线。&lt;/li&gt;
&lt;li&gt;PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。&lt;/li&gt;
&lt;li&gt;PCI Express 总线。&lt;/li&gt;
&lt;li&gt;前端总线。&lt;/li&gt;
&lt;li&gt;RS-232C。&lt;/li&gt;
&lt;li&gt;SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。&lt;/li&gt;
&lt;li&gt;SATA。&lt;/li&gt;
&lt;li&gt;USB。&lt;/li&gt;
&lt;li&gt;IEEE-1394。&lt;/li&gt;
&lt;li&gt;IEEE-488总线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址总线宽度：例如，内存容量4GB，$4GB=2^{2+10+10+10}B=2^32B$。所以内存单元的地址宽度为32位，即地址总线宽度为32位。&lt;/p&gt;
&lt;p&gt;数据总线宽度：例如字长为32的机器，那么其数据总线的宽度要为32。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;加密技术与认证技术&#34;&gt;加密技术与认证技术&lt;/h1&gt;
&lt;h2 id=&#34;加密技术&#34;&gt;加密技术&lt;/h2&gt;
&lt;p&gt;加密技术用于防止第三方窃听。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密：只有一把密钥。加密和解密用同一把密钥。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥分发有缺陷。&lt;/li&gt;
&lt;li&gt;加密解密速度很快。&lt;/li&gt;
&lt;li&gt;适合加量大量明文数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非对称加密：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密和解密不是同一把密钥。&lt;/li&gt;
&lt;li&gt;一共有两把密钥，分别是公钥和私钥。&lt;/li&gt;
&lt;li&gt;用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。&lt;/li&gt;
&lt;li&gt;不能通过一把密钥推出另一把密钥。&lt;/li&gt;
&lt;li&gt;用接收方的公钥加密明文可以实现防止窃听的效果。&lt;/li&gt;
&lt;li&gt;密钥分发没有缺陷。&lt;/li&gt;
&lt;li&gt;加密解密速度很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;认证技术&#34;&gt;认证技术&lt;/h2&gt;
&lt;p&gt;认证技术用于防止篡改、假冒和否认。&lt;/p&gt;
&lt;p&gt;摘要（防止篡改）：将发送的明文进行Hash算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比如果一致，侧没有篡改，否则有篡改。&lt;/p&gt;
&lt;p&gt;数字签名（防止假冒和否认）：&lt;/p&gt;
&lt;p&gt;发送方用自己的&lt;u&gt;私钥对摘要进行签名&lt;/u&gt;（加密）。得到数字签名放在密文后一起发送过去。&lt;/p&gt;
&lt;p&gt;接收方用发送方的&lt;u&gt;公钥对数字签名进行验证&lt;/u&gt;（解密）。如果验证成功则该消息没有被假冒且不能否认，否则该消息的真实性为假冒发送。&lt;/p&gt;
&lt;h2 id=&#34;数字证书&#34;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;数字证书是用第三方CA机构使用自己的私钥对用户的公钥签名（加密），来保证这个公钥不被篡改。然后接收方用CA的公钥验证（解密），从而得到用户的公钥。&lt;/p&gt;
&lt;h2 id=&#34;加密算法&#34;&gt;加密算法&lt;/h2&gt;
&lt;p&gt;对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DES&lt;/li&gt;
&lt;li&gt;3DES&lt;/li&gt;
&lt;li&gt;RC-5&lt;/li&gt;
&lt;li&gt;IDEA&lt;/li&gt;
&lt;li&gt;AES&lt;/li&gt;
&lt;li&gt;RC4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非对称密钥（公钥、公开密钥加密）算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSA&lt;/li&gt;
&lt;li&gt;ECC&lt;/li&gt;
&lt;li&gt;DSA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他加密算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hash函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SHA-1安全散列算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MD5摘要算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出结果为128位&lt;/li&gt;
&lt;li&gt;摘要算法防止发送的报文被篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加密可以阻止被动攻击，认证可以阻止主动攻击（不可以处理被动攻击）。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;系统可靠度&#34;&gt;系统可靠度&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F.png&#34;
	width=&#34;1157&#34;
	height=&#34;400&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F_huc533c9ebe7073a641e0c4f0ca26fe76d_129377_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F_huc533c9ebe7073a641e0c4f0ca26fe76d_129377_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;289&#34;
		data-flex-basis=&#34;694px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F.png&#34;
	width=&#34;1133&#34;
	height=&#34;376&#34;
	srcset=&#34;https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F_hu0151f1bd7a524d241456bee3273c718e_125234_480x0_resize_box_3.png 480w, https://blog.linner.asia/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F_hu0151f1bd7a524d241456bee3273c718e_125234_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;301&#34;
		data-flex-basis=&#34;723px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
